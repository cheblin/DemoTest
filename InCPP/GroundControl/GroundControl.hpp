
#include "Utils_.hpp"


namespace com { namespace company { namespace demo {
	enum class PID_TUNING_AXIS {
		PID_TUNING_ROLL    = 1,
		PID_TUNING_PITCH   = 2,
		PID_TUNING_YAW     = 3,
		PID_TUNING_ACCZ    = 4,
		PID_TUNING_STEER   = 5,
		PID_TUNING_LANDING = 6
	};
	/**
*Flags in EKF_STATUS message */
	enum class ESTIMATOR_STATUS_FLAGS {
		ESTIMATOR_ATTITUDE           = 1,//True if the attitude estimate is good
		ESTIMATOR_VELOCITY_HORIZ     = 2,//True if the horizontal velocity estimate is good
		ESTIMATOR_VELOCITY_VERT      = 4,//True if the  vertical velocity estimate is good
		ESTIMATOR_POS_HORIZ_REL      = 8,//True if the horizontal position (relative) estimate is good
		ESTIMATOR_POS_HORIZ_ABS      = 16,//True if the horizontal position (absolute) estimate is good
		ESTIMATOR_POS_VERT_ABS       = 32,//True if the vertical position (absolute) estimate is good
		ESTIMATOR_POS_VERT_AGL       = 64,//True if the vertical position (above ground) estimate is good
		/**
*True if the EKF is in a constant position mode and is not using external measurements (eg GPS or optical
*			 flow */
		ESTIMATOR_CONST_POS_MODE     = 128,
		ESTIMATOR_PRED_POS_HORIZ_REL = 256,//True if the EKF has sufficient data to enter a mode that will provide a (relative) position estimat
		ESTIMATOR_PRED_POS_HORIZ_ABS = 512,//True if the EKF has sufficient data to enter a mode that will provide a (absolute) position estimat
		ESTIMATOR_GPS_GLITCH         = 1024//True if the EKF has detected a GPS glitch
	};
	
	inline static ESTIMATOR_STATUS_FLAGS ESTIMATOR_STATUS_FLAGS_from(UMAX id) {
		switch (id) {
			default :return ESTIMATOR_STATUS_FLAGS::ESTIMATOR_ATTITUDE;
			case 1:return ESTIMATOR_STATUS_FLAGS::ESTIMATOR_VELOCITY_HORIZ;
			case 2:return ESTIMATOR_STATUS_FLAGS::ESTIMATOR_VELOCITY_VERT;
			case 3:return ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_HORIZ_REL;
			case 4:return ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_HORIZ_ABS;
			case 5:return ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_VERT_ABS;
			case 6:return ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_VERT_AGL;
			case 7:return ESTIMATOR_STATUS_FLAGS::ESTIMATOR_CONST_POS_MODE;
			case 8:return ESTIMATOR_STATUS_FLAGS::ESTIMATOR_PRED_POS_HORIZ_REL;
			case 9:return ESTIMATOR_STATUS_FLAGS::ESTIMATOR_PRED_POS_HORIZ_ABS;
			case 10:return ESTIMATOR_STATUS_FLAGS::ESTIMATOR_GPS_GLITCH;
			
		}
	}
	
	inline static UMAX ESTIMATOR_STATUS_FLAGS_into(ESTIMATOR_STATUS_FLAGS en) {
		switch (en) {
			case ESTIMATOR_STATUS_FLAGS::ESTIMATOR_ATTITUDE:return 0;
			case ESTIMATOR_STATUS_FLAGS::ESTIMATOR_VELOCITY_HORIZ:return 1;
			case ESTIMATOR_STATUS_FLAGS::ESTIMATOR_VELOCITY_VERT:return 2;
			case ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_HORIZ_REL:return 3;
			case ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_HORIZ_ABS:return 4;
			case ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_VERT_ABS:return 5;
			case ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_VERT_AGL:return 6;
			case ESTIMATOR_STATUS_FLAGS::ESTIMATOR_CONST_POS_MODE:return 7;
			case ESTIMATOR_STATUS_FLAGS::ESTIMATOR_PRED_POS_HORIZ_REL:return 8;
			case ESTIMATOR_STATUS_FLAGS::ESTIMATOR_PRED_POS_HORIZ_ABS:return 9;
			case ESTIMATOR_STATUS_FLAGS::ESTIMATOR_GPS_GLITCH:return 10;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	enum class MAV_TYPE {
		GENERIC            = 0,//Generic micro air vehicle.
		FIXED_WING         = 1,//Fixed wing aircraft.
		QUADROTOR          = 2,//Quadrotor
		COAXIAL            = 3,//Coaxial helicopter
		HELICOPTER         = 4,//Normal helicopter with tail rotor.
		ANTENNA_TRACKER    = 5,//Ground installation
		GCS                = 6,//Operator control unit / ground control station
		AIRSHIP            = 7,//Airship, controlled
		FREE_BALLOON       = 8,//Free balloon, uncontrolled
		ROCKET             = 9,//Rocket
		GROUND_ROVER       = 10,//Ground rover
		SURFACE_BOAT       = 11,//Surface vessel, boat, ship
		SUBMARINE          = 12,//Submarine
		HEXAROTOR          = 13,//Hexarotor
		OCTOROTOR          = 14,//Octorotor
		TRICOPTER          = 15,//Tricopter
		FLAPPING_WING      = 16,//Flapping wing
		KITE               = 17,//Kite
		ONBOARD_CONTROLLER = 18,//Onboard companion controller
		VTOL_DUOROTOR      = 19,//Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter.
		VTOL_QUADROTOR     = 20,//Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter.
		VTOL_TILTROTOR     = 21,//Tiltrotor VTOL
		VTOL_RESERVED2     = 22,//VTOL reserved 2
		VTOL_RESERVED3     = 23,//VTOL reserved 3
		VTOL_RESERVED4     = 24,//VTOL reserved 4
		VTOL_RESERVED5     = 25,//VTOL reserved 5
		GIMBAL             = 26,//Onboard gimbal
		ADSB               = 27,//Onboard ADSB peripheral
		PARAFOIL           = 28//Steerable, nonrigid airfoil
	};
	enum class GOPRO_CAPTURE_MODE {
		GOPRO_CAPTURE_MODE_VIDEO      = 0,//Video mode
		GOPRO_CAPTURE_MODE_PHOTO      = 1,//Photo mode
		GOPRO_CAPTURE_MODE_BURST      = 2,//Burst mode, hero 3+ only
		GOPRO_CAPTURE_MODE_TIME_LAPSE = 3,//Time lapse mode, hero 3+ only
		GOPRO_CAPTURE_MODE_MULTI_SHOT = 4,//Multi shot mode, hero 4 only
		GOPRO_CAPTURE_MODE_PLAYBACK   = 5,//Playback mode, hero 4 only, silver only except when LCD or HDMI is connected to black
		GOPRO_CAPTURE_MODE_SETUP      = 6,//Playback mode, hero 4 only
		GOPRO_CAPTURE_MODE_UNKNOWN    = 255//Mode not yet known
	};
	
	inline static GOPRO_CAPTURE_MODE GOPRO_CAPTURE_MODE_from(UMAX id) {
		switch (id) {
			default :return GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_VIDEO;
			case 1:return GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_PHOTO;
			case 2:return GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_BURST;
			case 3:return GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_TIME_LAPSE;
			case 4:return GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_MULTI_SHOT;
			case 5:return GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_PLAYBACK;
			case 6:return GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_SETUP;
			case 7:return GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_UNKNOWN;
			
		}
	}
	
	inline static UMAX GOPRO_CAPTURE_MODE_into(GOPRO_CAPTURE_MODE en) {
		switch (en) {
			case GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_VIDEO:return 0;
			case GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_PHOTO:return 1;
			case GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_BURST:return 2;
			case GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_TIME_LAPSE:return 3;
			case GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_MULTI_SHOT:return 4;
			case GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_PLAYBACK:return 5;
			case GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_SETUP:return 6;
			case GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_UNKNOWN:return 7;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*Micro air vehicle / autopilot classes. This identifies the individual model. */
	enum class MAV_AUTOPILOT {
		GENERIC                                      = 0,//Generic autopilot, full support for everything
		RESERVED                                     = 1,//Reserved for future use.
		SLUGS                                        = 2,//SLUGS autopilot, http:slugsuav.soe.ucsc.edu
		ARDUPILOTMEGA                                = 3,//ArduPilotMega / ArduCopter, http:diydrones.com
		OPENPILOT                                    = 4,//OpenPilot, http:openpilot.org
		GENERIC_WAYPOINTS_ONLY                       = 5,//Generic autopilot only supporting simple waypoints
		GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY = 6,//Generic autopilot supporting waypoints and other simple navigation commands
		GENERIC_MISSION_FULL                         = 7,//Generic autopilot supporting the full mission command set
		INVALID                                      = 8,//No valid autopilot, e.g. a GCS or other MAVLink component
		PPZ                                          = 9,//PPZ UAV - http:nongnu.org/paparazzi
		UDB                                          = 10,//UAV Dev Board
		FP                                           = 11,//FlexiPilot
		PX4                                          = 12,//PX4 Autopilot - http:pixhawk.ethz.ch/px4/
		SMACCMPILOT                                  = 13,//SMACCMPilot - http:smaccmpilot.org
		AUTOQUAD                                     = 14,//AutoQuad -- http:autoquad.org
		ARMAZILA                                     = 15,//Armazila -- http:armazila.com
		AEROB                                        = 16,//Aerob -- http:aerob.ru
		ASLUAV                                       = 17,//ASLUAV autopilot -- http:www.asl.ethz.ch
		SMARTAP                                      = 18//SmartAP Autopilot - http:sky-drones.com
	};
	/**
*Enumeration of battery functions */
	enum class MAV_BATTERY_FUNCTION {
		MAV_BATTERY_FUNCTION_UNKNOWN    = 0,//Battery function is unknown
		MAV_BATTERY_FUNCTION_ALL        = 1,//Battery supports all flight systems
		MAV_BATTERY_FUNCTION_PROPULSION = 2,//Battery for the propulsion system
		MAV_BATTERY_FUNCTION_AVIONICS   = 3,//Avionics battery
		MAV_BATTERY_TYPE_PAYLOAD        = 4//Payload battery
	};
	/**
*Type of landing target */
	enum class LANDING_TARGET_TYPE {
		LANDING_TARGET_TYPE_LIGHT_BEACON    = 0,//Landing target signaled by light beacon (ex: IR-LOCK)
		LANDING_TARGET_TYPE_RADIO_BEACON    = 1,//Landing target signaled by radio beacon (ex: ILS, NDB)
		LANDING_TARGET_TYPE_VISION_FIDUCIAL = 2,//Landing target represented by a fiducial marker (ex: ARTag)
		LANDING_TARGET_TYPE_VISION_OTHER    = 3//Landing target represented by a pre-defined visual shape/feature (ex: X-marker, H-marker, square)
	};
	enum class LIMIT_MODULE {
		LIMIT_GPSLOCK  = 1,//pre-initialization
		LIMIT_GEOFENCE = 2,//disabled
		LIMIT_ALTITUDE = 4//checking limits
	};
	
	inline static LIMIT_MODULE LIMIT_MODULE_from(UMAX id) {
		switch (id) {
			default :return LIMIT_MODULE::LIMIT_GPSLOCK;
			case 1:return LIMIT_MODULE::LIMIT_GEOFENCE;
			case 2:return LIMIT_MODULE::LIMIT_ALTITUDE;
			
		}
	}
	
	inline static UMAX LIMIT_MODULE_into(LIMIT_MODULE en) {
		switch (en) {
			case LIMIT_MODULE::LIMIT_GPSLOCK:return 0;
			case LIMIT_MODULE::LIMIT_GEOFENCE:return 1;
			case LIMIT_MODULE::LIMIT_ALTITUDE:return 2;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*Enumeration of landed detector states */
	enum class MAV_LANDED_STATE {
		MAV_LANDED_STATE_UNDEFINED = 0,//MAV landed state is unknown
		MAV_LANDED_STATE_ON_GROUND = 1,//MAV is landed (on ground)
		MAV_LANDED_STATE_IN_AIR    = 2,//MAV is in air
		MAV_LANDED_STATE_TAKEOFF   = 3,//MAV currently taking off
		MAV_LANDED_STATE_LANDING   = 4//MAV currently landing
	};
	/**
*Specifies the datatype of a MAVLink parameter. */
	enum class MAV_PARAM_TYPE {
		MAV_PARAM_TYPE_UINT8  = 1,//8-bit unsigned integer
		MAV_PARAM_TYPE_INT8   = 2,//8-bit signed integer
		MAV_PARAM_TYPE_UINT16 = 3,//16-bit unsigned integer
		MAV_PARAM_TYPE_INT16  = 4,//16-bit signed integer
		MAV_PARAM_TYPE_UINT32 = 5,//32-bit unsigned integer
		MAV_PARAM_TYPE_INT32  = 6,//32-bit signed integer
		MAV_PARAM_TYPE_UINT64 = 7,//64-bit unsigned integer
		MAV_PARAM_TYPE_INT64  = 8,//64-bit signed integer
		MAV_PARAM_TYPE_REAL32 = 9,//32-bit floating-point
		MAV_PARAM_TYPE_REAL64 = 10//64-bit floating-point
	};
	/**
*Emergency status encoding */
	enum class UAVIONIX_ADSB_EMERGENCY_STATUS {
		UAVIONIX_ADSB_OUT_NO_EMERGENCY                    = 0,
		UAVIONIX_ADSB_OUT_GENERAL_EMERGENCY               = 1,
		UAVIONIX_ADSB_OUT_LIFEGUARD_EMERGENCY             = 2,
		UAVIONIX_ADSB_OUT_MINIMUM_FUEL_EMERGENCY          = 3,
		UAVIONIX_ADSB_OUT_NO_COMM_EMERGENCY               = 4,
		UAVIONIX_ADSB_OUT_UNLAWFUL_INTERFERANCE_EMERGENCY = 5,
		UAVIONIX_ADSB_OUT_DOWNED_AIRCRAFT_EMERGENCY       = 6,
		UAVIONIX_ADSB_OUT_RESERVED                        = 7
	};
	/**
*Indicates the severity level, generally used for status messages to indicate their relative urgency. Based
*		 on RFC-5424 using expanded definitions at: http:www.kiwisyslog.com/kb/info:-syslog-message-levels/ */
	enum class MAV_SEVERITY {
		MAV_SEVERITY_EMERGENCY = 0,//System is unusable. This is a "panic" condition.
		MAV_SEVERITY_ALERT     = 1,//Action should be taken immediately. Indicates error in non-critical systems.
		MAV_SEVERITY_CRITICAL  = 2,//Action must be taken immediately. Indicates failure in a primary system.
		MAV_SEVERITY_ERROR     = 3,//Indicates an error in secondary/redundant systems.
		/**
*Indicates about a possible future error if this is not resolved within a given timeframe. Example would
*			 be a low battery warning */
		MAV_SEVERITY_WARNING   = 4,
		/**
*An unusual event has occured, though not an error condition. This should be investigated for the root
*			 cause */
		MAV_SEVERITY_NOTICE    = 5,
		MAV_SEVERITY_INFO      = 6,//Normal operational messages. Useful for logging. No action is required for these messages.
		MAV_SEVERITY_DEBUG     = 7//Useful non-operational messages that can assist in debugging. These should not occur during normal operation
	};
	/**
*These defines are predefined OR-combined mode flags. There is no need to use values from this enum, but it
*		 simplifies the use of the mode flags. Note that manual input is enabled in all modes as a safety override. */
	enum class MAV_MODE {
		PREFLIGHT              = 0,//System is not ready to fly, booting, calibrating, etc. No flag is set.
		MANUAL_DISARMED        = 64,//System is allowed to be active, under manual (RC) control, no stabilization
		MAV_MODE_TEST_DISARMED = 66,//UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only
		STABILIZE_DISARMED     = 80,//System is allowed to be active, under assisted RC control.
		GUIDED_DISARMED        = 88,//System is allowed to be active, under autonomous control, manual setpoint
		/**
*System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard
*			 and not pre-programmed by waypoints */
		MAV_MODE_AUTO_DISARMED = 92,
		MANUAL_ARMED           = 192,//System is allowed to be active, under manual (RC) control, no stabilization
		MAV_MODE_TEST_ARMED    = 194,//UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only
		STABILIZE_ARMED        = 208,//System is allowed to be active, under assisted RC control.
		GUIDED_ARMED           = 216,//System is allowed to be active, under autonomous control, manual setpoint
		/**
*System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard
*			 and not pre-programmed by waypoints */
		MAV_MODE_AUTO_ARMED    = 220
	};
	
	inline static MAV_MODE MAV_MODE_from(UMAX id) {
		switch (id) {
			default :return MAV_MODE::PREFLIGHT;
			case 1:return MAV_MODE::MANUAL_DISARMED;
			case 2:return MAV_MODE::MAV_MODE_TEST_DISARMED;
			case 3:return MAV_MODE::STABILIZE_DISARMED;
			case 4:return MAV_MODE::GUIDED_DISARMED;
			case 5:return MAV_MODE::MAV_MODE_AUTO_DISARMED;
			case 6:return MAV_MODE::MANUAL_ARMED;
			case 7:return MAV_MODE::MAV_MODE_TEST_ARMED;
			case 8:return MAV_MODE::STABILIZE_ARMED;
			case 9:return MAV_MODE::GUIDED_ARMED;
			case 10:return MAV_MODE::MAV_MODE_AUTO_ARMED;
			
		}
	}
	
	inline static UMAX MAV_MODE_into(MAV_MODE en) {
		switch (en) {
			case MAV_MODE::PREFLIGHT:return 0;
			case MAV_MODE::MANUAL_DISARMED:return 1;
			case MAV_MODE::MAV_MODE_TEST_DISARMED:return 2;
			case MAV_MODE::STABILIZE_DISARMED:return 3;
			case MAV_MODE::GUIDED_DISARMED:return 4;
			case MAV_MODE::MAV_MODE_AUTO_DISARMED:return 5;
			case MAV_MODE::MANUAL_ARMED:return 6;
			case MAV_MODE::MAV_MODE_TEST_ARMED:return 7;
			case MAV_MODE::STABILIZE_ARMED:return 8;
			case MAV_MODE::GUIDED_ARMED:return 9;
			case MAV_MODE::MAV_MODE_AUTO_ARMED:return 10;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*Enumeration of the ADSB altimeter types */
	enum class ADSB_ALTITUDE_TYPE {
		ADSB_ALTITUDE_TYPE_PRESSURE_QNH = 0,//Altitude reported from a Baro source using QNH reference
		ADSB_ALTITUDE_TYPE_GEOMETRIC    = 1//Altitude reported from a GNSS source
	};
	/**
*Type of mission items being requested/sent in mission protocol. */
	enum class MAV_MISSION_TYPE {
		MAV_MISSION_TYPE_MISSION = 0,//Items are mission commands for main mission.
		MAV_MISSION_TYPE_FENCE   = 1,//Specifies GeoFence area(s). Items are MAV_CMD_FENCE_ GeoFence items.
		/**
*Specifies the rally points for the vehicle. Rally points are alternative RTL points. Items are MAV_CMD_RALLY_POINT
*			 rally point items */
		MAV_MISSION_TYPE_RALLY   = 2,
		MAV_MISSION_TYPE_ALL     = 255//Only used in MISSION_CLEAR_ALL to clear all mission types.
	};
	
	inline static MAV_MISSION_TYPE MAV_MISSION_TYPE_from(UMAX id) {
		switch (id) {
			default :return MAV_MISSION_TYPE::MAV_MISSION_TYPE_MISSION;
			case 1:return MAV_MISSION_TYPE::MAV_MISSION_TYPE_FENCE;
			case 2:return MAV_MISSION_TYPE::MAV_MISSION_TYPE_RALLY;
			case 3:return MAV_MISSION_TYPE::MAV_MISSION_TYPE_ALL;
			
		}
	}
	
	inline static UMAX MAV_MISSION_TYPE_into(MAV_MISSION_TYPE en) {
		switch (en) {
			case MAV_MISSION_TYPE::MAV_MISSION_TYPE_MISSION:return 0;
			case MAV_MISSION_TYPE::MAV_MISSION_TYPE_FENCE:return 1;
			case MAV_MISSION_TYPE::MAV_MISSION_TYPE_RALLY:return 2;
			case MAV_MISSION_TYPE::MAV_MISSION_TYPE_ALL:return 3;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*Enumeration of distance sensor types */
	enum class MAV_DISTANCE_SENSOR {
		MAV_DISTANCE_SENSOR_LASER      = 0,//Laser rangefinder, e.g. LightWare SF02/F or PulsedLight units
		MAV_DISTANCE_SENSOR_ULTRASOUND = 1,//Ultrasound rangefinder, e.g. MaxBotix units
		MAV_DISTANCE_SENSOR_INFRARED   = 2,//Infrared rangefinder, e.g. Sharp units
		MAV_DISTANCE_SENSOR_RADAR      = 3,//Radar type, e.g. uLanding units
		MAV_DISTANCE_SENSOR_UNKNOWN    = 4//Broken or unknown type, e.g. analog units
	};
	/**
*Enumeration of VTOL states */
	enum class MAV_VTOL_STATE {
		MAV_VTOL_STATE_UNDEFINED        = 0,//MAV is not configured as VTOL
		MAV_VTOL_STATE_TRANSITION_TO_FW = 1,//VTOL is in transition from multicopter to fixed-wing
		MAV_VTOL_STATE_TRANSITION_TO_MC = 2,//VTOL is in transition from fixed-wing to multicopter
		MAV_VTOL_STATE_MC               = 3,//VTOL is in multicopter state
		MAV_VTOL_STATE_FW               = 4//VTOL is in fixed-wing state
	};
	/**
*Type of GPS fix */
	enum class GPS_FIX_TYPE {
		GPS_FIX_TYPE_NO_GPS    = 0,//No GPS connected
		GPS_FIX_TYPE_NO_FIX    = 1,//No position information, GPS is connected
		GPS_FIX_TYPE_2D_FIX    = 2,//2D position
		GPS_FIX_TYPE_3D_FIX    = 3,//3D position
		GPS_FIX_TYPE_DGPS      = 4,//DGPS/SBAS aided 3D position
		GPS_FIX_TYPE_RTK_FLOAT = 5,//RTK float, 3D position
		GPS_FIX_TYPE_RTK_FIXED = 6,//RTK Fixed, 3D position
		GPS_FIX_TYPE_STATIC    = 7,//Static fixed, typically used for base stations
		GPS_FIX_TYPE_PPP       = 8//PPP, 3D position.
	};
	/**
*Specifies the datatype of a MAVLink extended parameter. */
	enum class MAV_PARAM_EXT_TYPE {
		MAV_PARAM_EXT_TYPE_UINT8  = 1,//8-bit unsigned integer
		MAV_PARAM_EXT_TYPE_INT8   = 2,//8-bit signed integer
		MAV_PARAM_EXT_TYPE_UINT16 = 3,//16-bit unsigned integer
		MAV_PARAM_EXT_TYPE_INT16  = 4,//16-bit signed integer
		MAV_PARAM_EXT_TYPE_UINT32 = 5,//32-bit unsigned integer
		MAV_PARAM_EXT_TYPE_INT32  = 6,//32-bit signed integer
		MAV_PARAM_EXT_TYPE_UINT64 = 7,//64-bit unsigned integer
		MAV_PARAM_EXT_TYPE_INT64  = 8,//64-bit signed integer
		MAV_PARAM_EXT_TYPE_REAL32 = 9,//32-bit floating-point
		MAV_PARAM_EXT_TYPE_REAL64 = 10,//64-bit floating-point
		MAV_PARAM_EXT_TYPE_CUSTOM = 11//Custom Type
	};
	/**
*Enumeration of estimator types */
	enum class MAV_ESTIMATOR_TYPE {
		MAV_ESTIMATOR_TYPE_NAIVE   = 1,//This is a naive estimator without any real covariance feedback.
		MAV_ESTIMATOR_TYPE_VISION  = 2,//Computer vision based estimate. Might be up to scale.
		MAV_ESTIMATOR_TYPE_VIO     = 3,//Visual-inertial estimate.
		MAV_ESTIMATOR_TYPE_GPS     = 4,//Plain GPS estimate.
		MAV_ESTIMATOR_TYPE_GPS_INS = 5//Estimator integrating GPS and inertial sensing.
	};
	enum class CAMERA_FEEDBACK_FLAGS {
		CAMERA_FEEDBACK_PHOTO       = 0,//Shooting photos, not video
		CAMERA_FEEDBACK_VIDEO       = 1,//Shooting video, not stills
		CAMERA_FEEDBACK_BADEXPOSURE = 2,//Unable to achieve requested exposure (e.g. shutter speed too low)
		CAMERA_FEEDBACK_CLOSEDLOOP  = 3,//Closed loop feedback from camera, we know for sure it has successfully taken a picture
		/**
*Open loop camera, an image trigger has been requested but we can't know for sure it has successfully taken
*			 a pictur */
		CAMERA_FEEDBACK_OPENLOOP    = 4
	};
	/**
*Generalized UAVCAN node health */
	enum class UAVCAN_NODE_HEALTH {
		UAVCAN_NODE_HEALTH_OK       = 0,//The node is functioning properly.
		UAVCAN_NODE_HEALTH_WARNING  = 1,//A critical parameter went out of range or the node has encountered a minor failure.
		UAVCAN_NODE_HEALTH_ERROR    = 2,//The node has encountered a major failure.
		UAVCAN_NODE_HEALTH_CRITICAL = 3//The node has suffered a fatal malfunction.
	};
	/**
*Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script.
*		 If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows:
*		 Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what
*		 ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data */
	enum class MAV_CMD {
		/**
*Navigate to waypoint.
*					 1	Hold time in decimal seconds. (ignored by fixed wing, time to stay at waypoint for rotary wing)
*					 2	Acceptance radius in meters (if the sphere with this radius is hit, the waypoint counts as reached)
*					 3	0 to pass through the WP, if 	>	0 radius in meters to pass by WP. Positive value for clockwise orbit, negative value for counter-clockwise orbit. Allows trajectory control.
*					 4	Desired yaw angle at waypoint (rotary wing). NaN for unchanged.
*					 5	Latitude
*					 6	Longitude
*					 7	Altitude */
		MAV_CMD_NAV_WAYPOINT                       = 16,
		/**
*Loiter around this waypoint an unlimited amount of time
*			 1	Empty
*			 2	Empty
*			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
*			 4	Desired yaw angle.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
		MAV_CMD_NAV_LOITER_UNLIM                   = 17,
		/**
*Loiter around this waypoint for X turns
*			 1	Turns
*			 2	Empty
*			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
*			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
		MAV_CMD_NAV_LOITER_TURNS                   = 18,
		/**
*Loiter around this waypoint for X seconds
*			 1	Seconds (decimal)
*			 2	Empty
*			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
*			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
		MAV_CMD_NAV_LOITER_TIME                    = 19,
		/**
*Return to launch location
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_NAV_RETURN_TO_LAUNCH               = 20,
		/**
*Land at location
*			 1	Abort Alt
*			 2	Empty
*			 3	Empty
*			 4	Desired yaw angle. NaN for unchanged.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude (ground level) */
		MAV_CMD_NAV_LAND                           = 21,
		/**
*Takeoff from ground / hand
*			 1	Minimum pitch (if airspeed sensor present), desired pitch without sensor
*			 2	Empty
*			 3	Empty
*			 4	Yaw angle (if magnetometer present), ignored without magnetometer. NaN for unchanged.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
		MAV_CMD_NAV_TAKEOFF                        = 22,
		/**
*Land at local position (local frame only)
*			 1	Landing target number (if available)
*			 2	Maximum accepted offset from desired landing position [m] - computed magnitude from spherical coordinates: d = sqrt(x^2 + y^2 + z^2), which gives the maximum accepted distance between the desired landing position and the position where the vehicle is about to land
*			 3	Landing descend rate [ms^-1]
*			 4	Desired yaw angle [rad]
*			 5	Y-axis position [m]
*			 6	X-axis position [m]
*			 7	Z-axis / ground level position [m] */
		MAV_CMD_NAV_LAND_LOCAL                     = 23,
		/**
*Takeoff from local position (local frame only)
*			 1	Minimum pitch (if airspeed sensor present), desired pitch without sensor [rad]
*			 2	Empty
*			 3	Takeoff ascend rate [ms^-1]
*			 4	Yaw angle [rad] (if magnetometer or another yaw estimation source present), ignored without one of these
*			 5	Y-axis position [m]
*			 6	X-axis position [m]
*			 7	Z-axis position [m] */
		MAV_CMD_NAV_TAKEOFF_LOCAL                  = 24,
		/**
*Vehicle following, i.e. this waypoint represents the position of a moving vehicle
*			 1	Following logic to use (e.g. loitering or sinusoidal following) - depends on specific autopilot implementation
*			 2	Ground speed of vehicle to be followed
*			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
*			 4	Desired yaw angle.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
		MAV_CMD_NAV_FOLLOW                         = 25,
		/**
*Continue on the current course and climb/descend to specified altitude.  When the altitude is reached
*			 continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached
*			 1	Climb or Descend (0 = Neutral, command completes when within 5m of this command's altitude, 1 = Climbing, command completes when at or above this command's altitude, 2 = Descending, command completes when at or below this command's altitude.
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Desired altitude in meters */
		MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT        = 30,
		/**
*Begin loiter at the specified Latitude and Longitude.  If Lat=Lon=0, then loiter at the current position.
*			 Don't consider the navigation command complete (don't leave loiter) until the altitude has been reached.
*			 Additionally, if the Heading Required parameter is non-zero the  aircraft will not leave the loiter
*			 until heading toward the next waypoint.
*			 1	Heading Required (0 = False)
*			 2	Radius in meters. If positive loiter clockwise, negative counter-clockwise, 0 means no change to standard loiter.
*			 3	Empty
*			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
		MAV_CMD_NAV_LOITER_TO_ALT                  = 31,
		/**
*Being following a target
*			 1	System ID (the system ID of the FOLLOW_TARGET beacon). Send 0 to disable follow-me and return to the default position hold mode
*			 2	RESERVED
*			 3	RESERVED
*			 4	altitude flag: 0: Keep current altitude, 1: keep altitude difference to target, 2: go to a fixed altitude above home
*			 5	altitude
*			 6	RESERVED
*			 7	TTL in seconds in which the MAV should go to the default position hold mode after a message rx timeout */
		MAV_CMD_DO_FOLLOW                          = 32,
		/**
*Reposition the MAV after a follow target command has been sent
*			 1	Camera q1 (where 0 is on the ray from the camera to the tracking device)
*			 2	Camera q2
*			 3	Camera q3
*			 4	Camera q4
*			 5	altitude offset from target (m)
*			 6	X offset from target (m)
*			 7	Y offset from target (m) */
		MAV_CMD_DO_FOLLOW_REPOSITION               = 33,
		/**
*Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the
*			 vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras
*			 1	Region of intereset mode. (see MAV_ROI enum)
*			 2	Waypoint index/ target ID. (see MAV_ROI enum)
*			 3	ROI index (allows a vehicle to manage multiple ROI's)
*			 4	Empty
*			 5	x the location of the fixed ROI (see MAV_FRAME)
*			 6	y
*			 7	z */
		MAV_CMD_NAV_ROI                            = 80,
		/**
*Control autonomous path planning on the MAV.
*			 1	0: Disable local obstacle avoidance / local path planning (without resetting map), 1: Enable local path planning, 2: Enable and reset local path planning
*			 2	0: Disable full path planning (without resetting map), 1: Enable, 2: Enable and reset map/occupancy grid, 3: Enable and reset planned route, but not occupancy grid
*			 3	Empty
*			 4	Yaw angle at goal, in compass degrees, [0..360]
*			 5	Latitude/X of goal
*			 6	Longitude/Y of goal
*			 7	Altitude/Z of goal */
		MAV_CMD_NAV_PATHPLANNING                   = 81,
		/**
*Navigate to waypoint using a spline path.
*			 1	Hold time in decimal seconds. (ignored by fixed wing, time to stay at waypoint for rotary wing)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Latitude/X of goal
*			 6	Longitude/Y of goal
*			 7	Altitude/Z of goal */
		MAV_CMD_NAV_SPLINE_WAYPOINT                = 82,
		/**
*Mission command to wait for an altitude or downwards vertical speed. This is meant for high altitude balloon
*			 launches, allowing the aircraft to be idle until either an altitude is reached or a negative vertical
*			 speed is reached (indicating early balloon burst). The wiggle time is how often to wiggle the control
*			 surfaces to prevent them seizing up
*			 1	altitude (m)
*			 2	descent speed (m/s)
*			 3	Wiggle Time (s)
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_NAV_ALTITUDE_WAIT                  = 83,
		/**
*Takeoff from ground using VTOL mode
*			 1	Empty
*			 2	Front transition heading, see VTOL_TRANSITION_HEADING enum.
*			 3	Empty
*			 4	Yaw angle in degrees. NaN for unchanged.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
		MAV_CMD_NAV_VTOL_TAKEOFF                   = 84,
		/**
*Land using VTOL mode
*			 1	Empty
*			 2	Empty
*			 3	Approach altitude (with the same reference as the Altitude field). NaN if unspecified.
*			 4	Yaw angle in degrees. NaN for unchanged.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude (ground level) */
		MAV_CMD_NAV_VTOL_LAND                      = 85,
		/**
*hand control over to an external controller
*			 1	On / Off (	>	0.5f on)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_NAV_GUIDED_ENABLE                  = 92,
		/**
*Delay the next navigation command a number of seconds or until a specified time
*			 1	Delay in seconds (decimal, -1 to enable time-of-day fields)
*			 2	hour (24h format, UTC, -1 to ignore)
*			 3	minute (24h format, UTC, -1 to ignore)
*			 4	second (24h format, UTC)
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_NAV_DELAY                          = 93,
		/**
*Descend and place payload.  Vehicle descends until it detects a hanging payload has reached the ground,
*			 the gripper is opened to release the payloa
*			 1	Maximum distance to descend (meters)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Latitude (deg * 1E7)
*			 6	Longitude (deg * 1E7)
*			 7	Altitude (meters) */
		MAV_CMD_NAV_PAYLOAD_PLACE                  = 94,
		/**
*NOP - This command is only used to mark the upper limit of the NAV/ACTION commands in the enumeratio
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_NAV_LAST                           = 95,
		/**
*Delay mission state machine.
*			 1	Delay in seconds (decimal)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_CONDITION_DELAY                    = 112,
		/**
*Ascend/descend at rate.  Delay mission state machine until desired altitude reached.
*			 1	Descent / Ascend rate (m/s)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Finish Altitude */
		MAV_CMD_CONDITION_CHANGE_ALT               = 113,
		/**
*Delay mission state machine until within desired distance of next NAV point.
*			 1	Distance (meters)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_CONDITION_DISTANCE                 = 114,
		/**
*Reach a certain target angle.
*			 1	target angle: [0-360], 0 is north
*			 2	speed during yaw change:[deg per second]
*			 3	direction: negative: counter clockwise, positive: clockwise [-1,1]
*			 4	relative offset or absolute angle: [ 1,0]
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_CONDITION_YAW                      = 115,
		/**
*NOP - This command is only used to mark the upper limit of the CONDITION commands in the enumeratio
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_CONDITION_LAST                     = 159,
		/**
*Set system mode.
*			 1	Mode, as defined by ENUM MAV_MODE
*			 2	Custom mode - this is system specific, please refer to the individual autopilot specifications for details.
*			 3	Custom sub mode - this is system specific, please refer to the individual autopilot specifications for details.
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_SET_MODE                        = 176,
		/**
*Jump to the desired command in the mission list.  Repeat this action only the specified number of time
*			 1	Sequence number
*			 2	Repeat count
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_JUMP                            = 177,
		/**
*Change speed and/or throttle set points.
*			 1	Speed type (0=Airspeed, 1=Ground Speed)
*			 2	Speed  (m/s, -1 indicates no change)
*			 3	Throttle  ( Percent, -1 indicates no change)
*			 4	absolute or relative [0,1]
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_CHANGE_SPEED                    = 178,
		/**
*Changes the home location either to the current location or a specified location.
*			 1	Use current (1=use current location, 0=use specified location)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
		MAV_CMD_DO_SET_HOME                        = 179,
		/**
*Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value
*			 of the parameter
*			 1	Parameter number
*			 2	Parameter value
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_SET_PARAMETER                   = 180,
		/**
*Set a relay to a condition.
*			 1	Relay number
*			 2	Setting (1=on, 0=off, others possible depending on system hardware)
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_SET_RELAY                       = 181,
		/**
*Cycle a relay on and off for a desired number of cyles with a desired period.
*			 1	Relay number
*			 2	Cycle count
*			 3	Cycle time (seconds, decimal)
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_REPEAT_RELAY                    = 182,
		/**
*Set a servo to a desired PWM value.
*			 1	Servo number
*			 2	PWM (microseconds, 1000 to 2000 typical)
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_SET_SERVO                       = 183,
		/**
*Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period
*			 1	Servo number
*			 2	PWM (microseconds, 1000 to 2000 typical)
*			 3	Cycle count
*			 4	Cycle time (seconds)
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_REPEAT_SERVO                    = 184,
		/**
*Terminate flight immediately
*			 1	Flight termination activated if 	>	0.5
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_FLIGHTTERMINATION               = 185,
		/**
*Change altitude set point.
*			 1	Altitude in meters
*			 2	Mav frame of new altitude (see MAV_FRAME)
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_CHANGE_ALTITUDE                 = 186,
		/**
*Mission command to perform a landing. This is used as a marker in a mission to tell the autopilot where
*			 a sequence of mission items that represents a landing starts. It may also be sent via a COMMAND_LONG
*			 to trigger a landing, in which case the nearest (geographically) landing sequence in the mission will
*			 be used. The Latitude/Longitude is optional, and may be set to 0 if not needed. If specified then it
*			 will be used to help find the closest landing sequence
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Latitude
*			 6	Longitude
*			 7	Empty */
		MAV_CMD_DO_LAND_START                      = 189,
		/**
*Mission command to perform a landing from a rally point.
*			 1	Break altitude (meters)
*			 2	Landing speed (m/s)
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_RALLY_LAND                      = 190,
		/**
*Mission command to safely abort an autonmous landing.
*			 1	Altitude (meters)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_GO_AROUND                       = 191,
		/**
*Reposition the vehicle to a specific WGS84 global position.
*			 1	Ground speed, less than 0 (-1) for default
*			 2	Bitmask of option flags, see the MAV_DO_REPOSITION_FLAGS enum.
*			 3	Reserved
*			 4	Yaw heading, NaN for unchanged. For planes indicates loiter direction (0: clockwise, 1: counter clockwise)
*			 5	Latitude (deg * 1E7)
*			 6	Longitude (deg * 1E7)
*			 7	Altitude (meters) */
		MAV_CMD_DO_REPOSITION                      = 192,
		/**
*If in a GPS controlled position mode, hold the current position or continue.
*			 1	0: Pause current mission or reposition command, hold current position. 1: Continue mission. A VTOL capable vehicle should enter hover mode (multicopter and VTOL planes). A plane should loiter with the default loiter radius.
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Reserved
*			 6	Reserved
*			 7	Reserved */
		MAV_CMD_DO_PAUSE_CONTINUE                  = 193,
		/**
*Set moving direction to forward or reverse.
*			 1	Direction (0=Forward, 1=Reverse)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_SET_REVERSE                     = 194,
		/**
*Control onboard camera system.
*			 1	Camera ID (-1 for all)
*			 2	Transmission: 0: disabled, 1: enabled compressed, 2: enabled raw
*			 3	Transmission mode: 0: video stream, 	>	0: single images every n seconds (decimal)
*			 4	Recording: 0: disabled, 1: enabled compressed, 2: enabled raw
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_CONTROL_VIDEO                   = 200,
		/**
*Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the
*			 vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras
*			 1	Region of intereset mode. (see MAV_ROI enum)
*			 2	Waypoint index/ target ID. (see MAV_ROI enum)
*			 3	ROI index (allows a vehicle to manage multiple ROI's)
*			 4	Empty
*			 5	MAV_ROI_WPNEXT: pitch offset from next waypoint, MAV_ROI_LOCATION: latitude
*			 6	MAV_ROI_WPNEXT: roll offset from next waypoint, MAV_ROI_LOCATION: longitude
*			 7	MAV_ROI_WPNEXT: yaw offset from next waypoint, MAV_ROI_LOCATION: altitude */
		MAV_CMD_DO_SET_ROI                         = 201,
		/**
*Mission command to configure an on-board camera controller system.
*			 1	Modes: P, TV, AV, M, Etc
*			 2	Shutter speed: Divisor number for one second
*			 3	Aperture: F stop number
*			 4	ISO number e.g. 80, 100, 200, Etc
*			 5	Exposure type enumerator
*			 6	Command Identity
*			 7	Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off) */
		MAV_CMD_DO_DIGICAM_CONFIGURE               = 202,
		/**
*Mission command to control an on-board camera controller system.
*			 1	Session control e.g. show/hide lens
*			 2	Zoom's absolute position
*			 3	Zooming step value to offset zoom from the current position
*			 4	Focus Locking, Unlocking or Re-locking
*			 5	Shooting Command
*			 6	Command Identity
*			 7	Test shot identifier. If set to 1, image will only be captured, but not counted towards internal frame count. */
		MAV_CMD_DO_DIGICAM_CONTROL                 = 203,
		/**
*Mission command to configure a camera or antenna mount
*			 1	Mount operation mode (see MAV_MOUNT_MODE enum)
*			 2	stabilize roll? (1 = yes, 0 = no)
*			 3	stabilize pitch? (1 = yes, 0 = no)
*			 4	stabilize yaw? (1 = yes, 0 = no)
*			 5	roll input (0 = angle, 1 = angular rate)
*			 6	pitch input (0 = angle, 1 = angular rate)
*			 7	yaw input (0 = angle, 1 = angular rate) */
		MAV_CMD_DO_MOUNT_CONFIGURE                 = 204,
		/**
*Mission command to control a camera or antenna mount
*			 1	pitch depending on mount mode (degrees or degrees/second depending on pitch input).
*			 2	roll depending on mount mode (degrees or degrees/second depending on roll input).
*			 3	yaw depending on mount mode (degrees or degrees/second depending on yaw input).
*			 4	alt in meters depending on mount mode.
*			 5	latitude in degrees * 1E7, set if appropriate mount mode.
*			 6	longitude in degrees * 1E7, set if appropriate mount mode.
*			 7	MAV_MOUNT_MODE enum value */
		MAV_CMD_DO_MOUNT_CONTROL                   = 205,
		/**
*Mission command to set camera trigger distance for this flight. The camera is trigerred each time this
*			 distance is exceeded. This command can also be used to set the shutter integration time for the camera
*			 1	Camera trigger distance (meters). 0 to stop triggering.
*			 2	Camera shutter integration time (milliseconds). -1 or 0 to ignore
*			 3	Trigger camera once immediately. (0 = no trigger, 1 = trigger)
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_SET_CAM_TRIGG_DIST              = 206,
		/**
*Mission command to enable the geofence
*			 1	enable? (0=disable, 1=enable, 2=disable_floor_only)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_FENCE_ENABLE                    = 207,
		/**
*Mission command to trigger a parachute
*			 1	action (0=disable, 1=enable, 2=release, for some systems see PARACHUTE_ACTION enum, not in general message set.)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_PARACHUTE                       = 208,
		/**
*Mission command to perform motor test
*			 1	motor sequence number (a number from 1 to max number of motors on the vehicle)
*			 2	throttle type (0=throttle percentage, 1=PWM, 2=pilot throttle channel pass-through. See MOTOR_TEST_THROTTLE_TYPE enum)
*			 3	throttle
*			 4	timeout (in seconds)
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_MOTOR_TEST                      = 209,
		/**
*Change to/from inverted flight
*			 1	inverted (0=normal, 1=inverted)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_INVERTED_FLIGHT                 = 210,
		/**
*Mission command to operate EPM gripper
*			 1	gripper number (a number from 1 to max number of grippers on the vehicle)
*			 2	gripper action (0=release, 1=grab. See GRIPPER_ACTIONS enum)
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_GRIPPER                         = 211,
		/**
*Enable/disable autotune
*			 1	enable (1: enable, 0:disable)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_AUTOTUNE_ENABLE                 = 212,
		/**
*Sets a desired vehicle turn angle and speed change
*			 1	yaw angle to adjust steering by in centidegress
*			 2	speed - normalized to 0 .. 1
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_NAV_SET_YAW_SPEED                  = 213,
		/**
*Mission command to set camera trigger interval for this flight. If triggering is enabled, the camera is
*			 triggered each time this interval expires. This command can also be used to set the shutter integration
*			 time for the camera
*			 1	Camera trigger cycle time (milliseconds). -1 or 0 to ignore.
*			 2	Camera shutter integration time (milliseconds). Should be less than trigger cycle time. -1 or 0 to ignore.
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL          = 214,
		/**
*Mission command to control a camera or antenna mount, using a quaternion as reference.
*			 1	q1 - quaternion param #1, w (1 in null-rotation)
*			 2	q2 - quaternion param #2, x (0 in null-rotation)
*			 3	q3 - quaternion param #3, y (0 in null-rotation)
*			 4	q4 - quaternion param #4, z (0 in null-rotation)
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_MOUNT_CONTROL_QUAT              = 220,
		/**
*set id of master controller
*			 1	System ID
*			 2	Component ID
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_GUIDED_MASTER                   = 221,
		/**
*set limits for external control
*			 1	timeout - maximum time (in seconds) that external controller will be allowed to control vehicle. 0 means no timeout
*			 2	absolute altitude min (in meters, AMSL) - if vehicle moves below this alt, the command will be aborted and the mission will continue.  0 means no lower altitude limit
*			 3	absolute altitude max (in meters)- if vehicle moves above this alt, the command will be aborted and the mission will continue.  0 means no upper altitude limit
*			 4	horizontal move limit (in meters, AMSL) - if vehicle moves more than this distance from it's location at the moment the command was executed, the command will be aborted and the mission will continue. 0 means no horizontal altitude limit
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_GUIDED_LIMITS                   = 222,
		/**
*Control vehicle engine. This is interpreted by the vehicles engine controller to change the target engine
*			 state. It is intended for vehicles with internal combustion engine
*			 1	0: Stop engine, 1:Start Engine
*			 2	0: Warm start, 1:Cold start. Controls use of choke where applicable
*			 3	Height delay (meters). This is for commanding engine start only after the vehicle has gained the specified height. Used in VTOL vehicles during takeoff to start engine after the aircraft is off the ground. Zero for no delay.
*			 4	Empty
*			 5	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_ENGINE_CONTROL                  = 223,
		/**
*NOP - This command is only used to mark the upper limit of the DO commands in the enumeration
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_LAST                            = 240,
		/**
*Trigger calibration. This command will be only accepted if in pre-flight mode. Except for Temperature
*			 Calibration, only one sensor should be set in a single message and all others should be zero
*			 1	1: gyro calibration, 3: gyro temperature calibration
*			 2	1: magnetometer calibration
*			 3	1: ground pressure calibration
*			 4	1: radio RC calibration, 2: RC trim calibration
*			 5	1: accelerometer calibration, 2: board level calibration, 3: accelerometer temperature calibration
*			 6	1: APM: compass/motor interference calibration (PX4: airspeed calibration, deprecated), 2: airspeed calibration
*			 7	1: ESC calibration, 3: barometer temperature calibration */
		MAV_CMD_PREFLIGHT_CALIBRATION              = 241,
		/**
*Set sensor offsets. This command will be only accepted if in pre-flight mode.
*			 1	Sensor to adjust the offsets for: 0: gyros, 1: accelerometer, 2: magnetometer, 3: barometer, 4: optical flow, 5: second magnetometer, 6: third magnetometer
*			 2	X axis offset (or generic dimension 1), in the sensor's raw units
*			 3	Y axis offset (or generic dimension 2), in the sensor's raw units
*			 4	Z axis offset (or generic dimension 3), in the sensor's raw units
*			 5	Generic dimension 4, in the sensor's raw units
*			 6	Generic dimension 5, in the sensor's raw units
*			 7	Generic dimension 6, in the sensor's raw units */
		MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS       = 242,
		/**
*Trigger UAVCAN config. This command will be only accepted if in pre-flight mode.
*			 1	1: Trigger actuator ID assignment and direction mapping.
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Reserved
*			 6	Reserved
*			 7	Reserved */
		MAV_CMD_PREFLIGHT_UAVCAN                   = 243,
		/**
*Request storage of different parameter values and logs. This command will be only accepted if in pre-flight
*			 mode
*			 1	Parameter storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults
*			 2	Mission storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults
*			 3	Onboard logging: 0: Ignore, 1: Start default rate logging, -1: Stop logging, 	>	1: start logging with rate of param 3 in Hz (e.g. set to 1000 for 1000 Hz logging)
*			 4	Reserved
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_PREFLIGHT_STORAGE                  = 245,
		/**
*Request the reboot or shutdown of system components.
*			 1	0: Do nothing for autopilot, 1: Reboot autopilot, 2: Shutdown autopilot, 3: Reboot autopilot and keep it in the bootloader until upgraded.
*			 2	0: Do nothing for onboard computer, 1: Reboot onboard computer, 2: Shutdown onboard computer, 3: Reboot onboard computer and keep it in the bootloader until upgraded.
*			 3	WIP: 0: Do nothing for camera, 1: Reboot onboard camera, 2: Shutdown onboard camera, 3: Reboot onboard camera and keep it in the bootloader until upgraded
*			 4	WIP: 0: Do nothing for mount (e.g. gimbal), 1: Reboot mount, 2: Shutdown mount, 3: Reboot mount and keep it in the bootloader until upgraded
*			 5	Reserved, send 0
*			 6	Reserved, send 0
*			 7	WIP: ID (e.g. camera ID -1 for all IDs) */
		MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN          = 246,
		/**
*Hold / continue the current action
*			 1	MAV_GOTO_DO_HOLD: hold MAV_GOTO_DO_CONTINUE: continue with next item in mission plan
*			 2	MAV_GOTO_HOLD_AT_CURRENT_POSITION: Hold at current position MAV_GOTO_HOLD_AT_SPECIFIED_POSITION: hold at specified position
*			 3	MAV_FRAME coordinate frame of hold point
*			 4	Desired yaw angle in degrees
*			 5	Latitude / X position
*			 6	Longitude / Y position
*			 7	Altitude / Z position */
		MAV_CMD_OVERRIDE_GOTO                      = 252,
		/**
*start running a mission
*			 1	first_item: the first mission item to run
*			 2	last_item:  the last mission item to run (after this item is run, the mission ends) */
		MAV_CMD_MISSION_START                      = 300,
		/**
*Arms / Disarms a component
*			 1	1 to arm, 0 to disarm */
		MAV_CMD_COMPONENT_ARM_DISARM               = 400,
		/**
*Request the home position from the vehicle.
*			 1	Reserved
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Reserved
*			 6	Reserved
*			 7	Reserved */
		MAV_CMD_GET_HOME_POSITION                  = 410,
		/**
*Starts receiver pairing
*			 1	0:Spektrum
*			 2	0:Spektrum DSM2, 1:Spektrum DSMX */
		MAV_CMD_START_RX_PAIR                      = 500,
		/**
*Request the interval between messages for a particular MAVLink message ID
*			 1	The MAVLink message ID */
		MAV_CMD_GET_MESSAGE_INTERVAL               = 510,
		/**
*Request the interval between messages for a particular MAVLink message ID. This interface replaces REQUEST_DATA_STREA
*			 1	The MAVLink message ID
*			 2	The interval between two messages, in microseconds. Set to -1 to disable and 0 to request default rate. */
		MAV_CMD_SET_MESSAGE_INTERVAL               = 511,
		/**
*Request MAVLink protocol version compatibility
*			 1	1: Request supported protocol versions by all nodes on the network
*			 2	Reserved (all remaining params) */
		MAV_CMD_REQUEST_PROTOCOL_VERSION           = 519,
		/**
*Request autopilot capabilities
*			 1	1: Request autopilot version
*			 2	Reserved (all remaining params) */
		MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES     = 520,
		/**
*WIP: Request camera information (CAMERA_INFORMATION).
*			 1	0: No action 1: Request camera capabilities
*			 2	Reserved (all remaining params) */
		MAV_CMD_REQUEST_CAMERA_INFORMATION         = 521,
		/**
*WIP: Request camera settings (CAMERA_SETTINGS).
*			 1	0: No Action 1: Request camera settings
*			 2	Reserved (all remaining params) */
		MAV_CMD_REQUEST_CAMERA_SETTINGS            = 522,
		/**
*WIP: Request storage information (STORAGE_INFORMATION). Use the command's target_component to target a
*			 specific component's storage
*			 1	Storage ID (0 for all, 1 for first, 2 for second, etc.)
*			 2	0: No Action 1: Request storage information
*			 3	Reserved (all remaining params) */
		MAV_CMD_REQUEST_STORAGE_INFORMATION        = 525,
		/**
*WIP: Format a storage medium. Once format is complete, a STORAGE_INFORMATION message is sent. Use the
*			 command's target_component to target a specific component's storage
*			 1	Storage ID (1 for first, 2 for second, etc.)
*			 2	0: No action 1: Format storage
*			 3	Reserved (all remaining params) */
		MAV_CMD_STORAGE_FORMAT                     = 526,
		/**
*WIP: Request camera capture status (CAMERA_CAPTURE_STATUS)
*			 1	0: No Action 1: Request camera capture status
*			 2	Reserved (all remaining params) */
		MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS      = 527,
		/**
*WIP: Request flight information (FLIGHT_INFORMATION)
*			 1	1: Request flight information
*			 2	Reserved (all remaining params) */
		MAV_CMD_REQUEST_FLIGHT_INFORMATION         = 528,
		/**
*WIP: Reset all camera settings to Factory Default
*			 1	0: No Action 1: Reset all settings
*			 2	Reserved (all remaining params) */
		MAV_CMD_RESET_CAMERA_SETTINGS              = 529,
		/**
*Set camera running mode. Use NAN for reserved values.
*			 1	Reserved (Set to 0)
*			 2	Camera mode (see CAMERA_MODE enum)
*			 3	Reserved (all remaining params) */
		MAV_CMD_SET_CAMERA_MODE                    = 530,
		/**
*Start image capture sequence. Sends CAMERA_IMAGE_CAPTURED after each capture. Use NAN for reserved values
*			 1	Reserved (Set to 0)
*			 2	Duration between two consecutive pictures (in seconds)
*			 3	Number of images to capture total - 0 for unlimited capture
*			 4	Reserved (all remaining params) */
		MAV_CMD_IMAGE_START_CAPTURE                = 2000,
		/**
*Stop image capture sequence Use NAN for reserved values.
*			 1	Reserved (Set to 0)
*			 2	Reserved (all remaining params) */
		MAV_CMD_IMAGE_STOP_CAPTURE                 = 2001,
		/**
*WIP: Re-request a CAMERA_IMAGE_CAPTURE packet. Use NAN for reserved values.
*			 1	Sequence number for missing CAMERA_IMAGE_CAPTURE packet
*			 2	Reserved (all remaining params) */
		MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE       = 2002,
		/**
*Enable or disable on-board camera triggering system.
*			 1	Trigger enable/disable (0 for disable, 1 for start), -1 to ignore
*			 2	1 to reset the trigger sequence, -1 or 0 to ignore
*			 3	1 to pause triggering, but without switching the camera off or retracting it. -1 to ignore */
		MAV_CMD_DO_TRIGGER_CONTROL                 = 2003,
		/**
*Starts video capture (recording). Use NAN for reserved values.
*			 1	Reserved (Set to 0)
*			 2	Frequency CAMERA_CAPTURE_STATUS messages should be sent while recording (0 for no messages, otherwise frequency in Hz)
*			 3	Reserved (all remaining params) */
		MAV_CMD_VIDEO_START_CAPTURE                = 2500,
		/**
*Stop the current video capture (recording). Use NAN for reserved values.
*			 1	Reserved (Set to 0)
*			 2	Reserved (all remaining params) */
		MAV_CMD_VIDEO_STOP_CAPTURE                 = 2501,
		/**
*WIP: Start video streaming
*			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
*			 2	Reserved */
		MAV_CMD_VIDEO_START_STREAMING              = 2502,
		/**
*WIP: Stop the current video streaming
*			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
*			 2	Reserved */
		MAV_CMD_VIDEO_STOP_STREAMING               = 2503,
		/**
*WIP: Request video stream information (VIDEO_STREAM_INFORMATION)
*			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
*			 2	0: No Action 1: Request video stream information
*			 3	Reserved (all remaining params) */
		MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION   = 2504,
		/**
*Request to start streaming logging data over MAVLink (see also LOGGING_DATA message)
*			 1	Format: 0: ULog
*			 2	Reserved (set to 0)
*			 3	Reserved (set to 0)
*			 4	Reserved (set to 0)
*			 5	Reserved (set to 0)
*			 6	Reserved (set to 0)
*			 7	Reserved (set to 0) */
		MAV_CMD_LOGGING_START                      = 2510,
		/**
*Request to stop streaming log data over MAVLink
*			 1	Reserved (set to 0)
*			 2	Reserved (set to 0)
*			 3	Reserved (set to 0)
*			 4	Reserved (set to 0)
*			 5	Reserved (set to 0)
*			 6	Reserved (set to 0)
*			 7	Reserved (set to 0) */
		MAV_CMD_LOGGING_STOP                       = 2511,
		/**
*1	Landing gear ID (default: 0, -1 for all)
*			 2	Landing gear position (Down: 0, Up: 1, NAN for no change)
*			 3	Reserved, set to NAN
*			 4	Reserved, set to NAN
*			 5	Reserved, set to NAN
*			 6	Reserved, set to NAN
*			 7	Reserved, set to NAN */
		MAV_CMD_AIRFRAME_CONFIGURATION             = 2520,
		/**
*Create a panorama at the current position
*			 1	Viewing angle horizontal of the panorama (in degrees, +- 0.5 the total angle)
*			 2	Viewing angle vertical of panorama (in degrees)
*			 3	Speed of the horizontal rotation (in degrees per second)
*			 4	Speed of the vertical rotation (in degrees per second) */
		MAV_CMD_PANORAMA_CREATE                    = 2800,
		/**
*Request VTOL transition
*			 1	The target VTOL state, as defined by ENUM MAV_VTOL_STATE. Only MAV_VTOL_STATE_MC and MAV_VTOL_STATE_FW can be used. */
		MAV_CMD_DO_VTOL_TRANSITION                 = 3000,
		/**
*Request authorization to arm the vehicle to a external entity, the arm authorizer is resposible to request all data that is needs from the vehicle before authorize or deny the request. If approved the progress of command_ack message should be set with period of time that this authorization is valid in seconds or in case it was denied it should be set with one of the reasons in ARM_AUTH_DENIED_REASON.
*			 <p>
*			 1	Vehicle system id, this way ground station can request arm authorization on behalf of any vehicle */
		MAV_CMD_ARM_AUTHORIZATION_REQUEST          = 3001,
		/**
*This command sets the submode to standard guided when vehicle is in guided mode. The vehicle holds position and altitude and the user can input the desired velocites along all three axes. */
		MAV_CMD_SET_GUIDED_SUBMODE_STANDARD        = 4000,
		/**
*This command sets submode circle when vehicle is in guided mode. Vehicle flies along a circle facing the center of the circle. The user can input the velocity along the circle and change the radius. If no input is given the vehicle will hold position.
*			 <p>
*			 1	Radius of desired circle in CIRCLE_MODE
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Unscaled target latitude of center of circle in CIRCLE_MODE
*			 6	Unscaled target longitude of center of circle in CIRCLE_MODE */
		MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE          = 4001,
		/**
*WIP: Delay mission state machine until gate has been reached.
*			 1	Geometry: 0: orthogonal to path between previous and next waypoint.
*			 2	Altitude: 0: ignore altitude
*			 3	Empty
*			 4	Empty
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
		MAV_CMD_CONDITION_GATE                     = 4501,
		/**
*Fence return point. There can only be one fence return point.
*			 <p>
*			 1	Reserved
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
		MAV_CMD_NAV_FENCE_RETURN_POINT             = 5000,
		/**
*Fence vertex for an inclusion polygon (the polygon must not be self-intersecting). The vehicle must stay within this area. Minimum of 3 vertices required.
*			 <p>
*			 1	Polygon vertex count
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Reserved */
		MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION = 5001,
		/**
*Fence vertex for an exclusion polygon (the polygon must not be self-intersecting). The vehicle must stay outside this area. Minimum of 3 vertices required.
*			 <p>
*			 1	Polygon vertex count
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Reserved */
		MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION = 5002,
		/**
*Circular fence area. The vehicle must stay inside this area.
*			 <p>
*			 1	radius in meters
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Reserved */
		MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION         = 5003,
		/**
*Circular fence area. The vehicle must stay outside this area.
*			 <p>
*			 1	radius in meters
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Reserved */
		MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION         = 5004,
		/**
*Rally point. You can have multiple rally points defined.
*			 <p>
*			 1	Reserved
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
		MAV_CMD_NAV_RALLY_POINT                    = 5100,
		/**
*Commands the vehicle to respond with a sequence of messages UAVCAN_NODE_INFO, one message per every UAVCAN
*			 node that is online. Note that some of the response messages can be lost, which the receiver can detect
*			 easily by checking whether every received UAVCAN_NODE_STATUS has a matching message UAVCAN_NODE_INFO
*			 received earlier; if not, this command should be sent again in order to request re-transmission of the
*			 node information messages
*			 1	Reserved (set to 0)
*			 2	Reserved (set to 0)
*			 3	Reserved (set to 0)
*			 4	Reserved (set to 0)
*			 5	Reserved (set to 0)
*			 6	Reserved (set to 0)
*			 7	Reserved (set to 0) */
		MAV_CMD_UAVCAN_GET_NODE_INFO               = 5200,
		/**
*Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release
*			 position and velocity
*			 1	Operation mode. 0: prepare single payload deploy (overwriting previous requests), but do not execute it. 1: execute payload deploy immediately (rejecting further deploy commands during execution, but allowing abort). 2: add payload deploy to existing deployment list.
*			 2	Desired approach vector in degrees compass heading (0..360). A negative value indicates the system can define the approach vector at will.
*			 3	Desired ground speed at release time. This can be overriden by the airframe in case it needs to meet minimum airspeed. A negative value indicates the system can define the ground speed at will.
*			 4	Minimum altitude clearance to the release position in meters. A negative value indicates the system can define the clearance at will.
*			 5	Latitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT
*			 6	Longitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT
*			 7	Altitude, in meters AMSL */
		MAV_CMD_PAYLOAD_PREPARE_DEPLOY             = 30001,
		/**
*Control the payload deployment.
*			 1	Operation mode. 0: Abort deployment, continue normal mission. 1: switch to payload deploment mode. 100: delete first payload deployment request. 101: delete all payload deployment requests.
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Reserved
*			 6	Reserved
*			 7	Reserved */
		MAV_CMD_PAYLOAD_CONTROL_DEPLOY             = 30002,
		/**
*User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
		MAV_CMD_WAYPOINT_USER_1                    = 31000,
		/**
*User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
		MAV_CMD_WAYPOINT_USER_2                    = 31001,
		/**
*User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
		MAV_CMD_WAYPOINT_USER_3                    = 31002,
		/**
*User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
		MAV_CMD_WAYPOINT_USER_4                    = 31003,
		/**
*User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
		MAV_CMD_WAYPOINT_USER_5                    = 31004,
		/**
*User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
*			 ROI item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
		MAV_CMD_SPATIAL_USER_1                     = 31005,
		/**
*User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
*			 ROI item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
		MAV_CMD_SPATIAL_USER_2                     = 31006,
		/**
*User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
*			 ROI item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
		MAV_CMD_SPATIAL_USER_3                     = 31007,
		/**
*User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
*			 ROI item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
		MAV_CMD_SPATIAL_USER_4                     = 31008,
		/**
*User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
*			 ROI item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
		MAV_CMD_SPATIAL_USER_5                     = 31009,
		/**
*User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
*			 item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	User defined
*			 6	User defined
*			 7	User defined */
		MAV_CMD_USER_1                             = 31010,
		/**
*User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
*			 item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	User defined
*			 6	User defined
*			 7	User defined */
		MAV_CMD_USER_2                             = 31011,
		/**
*User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
*			 item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	User defined
*			 6	User defined
*			 7	User defined */
		MAV_CMD_USER_3                             = 31012,
		/**
*User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
*			 item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	User defined
*			 6	User defined
*			 7	User defined */
		MAV_CMD_USER_4                             = 31013,
		/**
*User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
*			 item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	User defined
*			 6	User defined
*			 7	User defined */
		MAV_CMD_USER_5                             = 31014,
		/**
*A system wide power-off event has been initiated.
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_POWER_OFF_INITIATED                = 42000,
		/**
*FLY button has been clicked.
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_SOLO_BTN_FLY_CLICK                 = 42001,
		/**
*FLY button has been held for 1.5 seconds.
*			 1	Takeoff altitude
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_SOLO_BTN_FLY_HOLD                  = 42002,
		/**
*PAUSE button has been clicked.
*			 1	1 if Solo is in a shot mode, 0 otherwise
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_SOLO_BTN_PAUSE_CLICK               = 42003,
		/**
*Initiate a magnetometer calibration
*			 1	uint8_t bitmask of magnetometers (0 means all)
*			 2	Automatically retry on failure (0=no retry, 1=retry).
*			 3	Save without user input (0=require input, 1=autosave).
*			 4	Delay (seconds)
*			 5	Autoreboot (0=user reboot, 1=autoreboot)
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_START_MAG_CAL                   = 42424,
		/**
*Initiate a magnetometer calibration
*			 1	uint8_t bitmask of magnetometers (0 means all)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_ACCEPT_MAG_CAL                  = 42425,
		/**
*Cancel a running magnetometer calibration
*			 1	uint8_t bitmask of magnetometers (0 means all)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_CANCEL_MAG_CAL                  = 42426,
		/**
*Command autopilot to get into factory test/diagnostic mode
*			 1	0 means get out of test mode, 1 means get into test mode
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_SET_FACTORY_TEST_MODE              = 42427,
		/**
*Reply with the version banner
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_DO_SEND_BANNER                     = 42428,
		/**
*Used when doing accelerometer calibration. When sent to the GCS tells it what position to put the vehicle
*			 in. When sent to the vehicle says what position the vehicle is in
*			 1	Position, one of the ACCELCAL_VEHICLE_POS enum values
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_ACCELCAL_VEHICLE_POS               = 42429,
		/**
*Causes the gimbal to reset and boot as if it was just powered on
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_GIMBAL_RESET                       = 42501,
		/**
*Reports progress and success or failure of gimbal axis calibration procedure
*			 1	Gimbal axis we're reporting calibration progress for
*			 2	Current calibration progress for this axis, 0x64=100%
*			 3	Status of the calibration
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS     = 42502,
		/**
*Starts commutation calibration on the gimbal
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
		MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION    = 42503,
		/**
*Erases gimbal application and parameters
*			 1	Magic number
*			 2	Magic number
*			 3	Magic number
*			 4	Magic number
*			 5	Magic number
*			 6	Magic number
*			 7	Magic number */
		MAV_CMD_GIMBAL_FULL_RESET                  = 42505
	};
	
	inline static MAV_CMD MAV_CMD_from(UMAX id) {
		switch (id) {
			default :return MAV_CMD::MAV_CMD_NAV_WAYPOINT;
			case 1:return MAV_CMD::MAV_CMD_NAV_LOITER_UNLIM;
			case 2:return MAV_CMD::MAV_CMD_NAV_LOITER_TURNS;
			case 3:return MAV_CMD::MAV_CMD_NAV_LOITER_TIME;
			case 4:return MAV_CMD::MAV_CMD_NAV_RETURN_TO_LAUNCH;
			case 5:return MAV_CMD::MAV_CMD_NAV_LAND;
			case 6:return MAV_CMD::MAV_CMD_NAV_TAKEOFF;
			case 7:return MAV_CMD::MAV_CMD_NAV_LAND_LOCAL;
			case 8:return MAV_CMD::MAV_CMD_NAV_TAKEOFF_LOCAL;
			case 9:return MAV_CMD::MAV_CMD_NAV_FOLLOW;
			case 10:return MAV_CMD::MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT;
			case 11:return MAV_CMD::MAV_CMD_NAV_LOITER_TO_ALT;
			case 12:return MAV_CMD::MAV_CMD_DO_FOLLOW;
			case 13:return MAV_CMD::MAV_CMD_DO_FOLLOW_REPOSITION;
			case 14:return MAV_CMD::MAV_CMD_NAV_ROI;
			case 15:return MAV_CMD::MAV_CMD_NAV_PATHPLANNING;
			case 16:return MAV_CMD::MAV_CMD_NAV_SPLINE_WAYPOINT;
			case 17:return MAV_CMD::MAV_CMD_NAV_ALTITUDE_WAIT;
			case 18:return MAV_CMD::MAV_CMD_NAV_VTOL_TAKEOFF;
			case 19:return MAV_CMD::MAV_CMD_NAV_VTOL_LAND;
			case 20:return MAV_CMD::MAV_CMD_NAV_GUIDED_ENABLE;
			case 21:return MAV_CMD::MAV_CMD_NAV_DELAY;
			case 22:return MAV_CMD::MAV_CMD_NAV_PAYLOAD_PLACE;
			case 23:return MAV_CMD::MAV_CMD_NAV_LAST;
			case 24:return MAV_CMD::MAV_CMD_CONDITION_DELAY;
			case 25:return MAV_CMD::MAV_CMD_CONDITION_CHANGE_ALT;
			case 26:return MAV_CMD::MAV_CMD_CONDITION_DISTANCE;
			case 27:return MAV_CMD::MAV_CMD_CONDITION_YAW;
			case 28:return MAV_CMD::MAV_CMD_CONDITION_LAST;
			case 29:return MAV_CMD::MAV_CMD_DO_SET_MODE;
			case 30:return MAV_CMD::MAV_CMD_DO_JUMP;
			case 31:return MAV_CMD::MAV_CMD_DO_CHANGE_SPEED;
			case 32:return MAV_CMD::MAV_CMD_DO_SET_HOME;
			case 33:return MAV_CMD::MAV_CMD_DO_SET_PARAMETER;
			case 34:return MAV_CMD::MAV_CMD_DO_SET_RELAY;
			case 35:return MAV_CMD::MAV_CMD_DO_REPEAT_RELAY;
			case 36:return MAV_CMD::MAV_CMD_DO_SET_SERVO;
			case 37:return MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
			case 38:return MAV_CMD::MAV_CMD_DO_FLIGHTTERMINATION;
			case 39:return MAV_CMD::MAV_CMD_DO_CHANGE_ALTITUDE;
			case 40:return MAV_CMD::MAV_CMD_DO_LAND_START;
			case 41:return MAV_CMD::MAV_CMD_DO_RALLY_LAND;
			case 42:return MAV_CMD::MAV_CMD_DO_GO_AROUND;
			case 43:return MAV_CMD::MAV_CMD_DO_REPOSITION;
			case 44:return MAV_CMD::MAV_CMD_DO_PAUSE_CONTINUE;
			case 45:return MAV_CMD::MAV_CMD_DO_SET_REVERSE;
			case 46:return MAV_CMD::MAV_CMD_DO_CONTROL_VIDEO;
			case 47:return MAV_CMD::MAV_CMD_DO_SET_ROI;
			case 48:return MAV_CMD::MAV_CMD_DO_DIGICAM_CONFIGURE;
			case 49:return MAV_CMD::MAV_CMD_DO_DIGICAM_CONTROL;
			case 50:return MAV_CMD::MAV_CMD_DO_MOUNT_CONFIGURE;
			case 51:return MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL;
			case 52:return MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_DIST;
			case 53:return MAV_CMD::MAV_CMD_DO_FENCE_ENABLE;
			case 54:return MAV_CMD::MAV_CMD_DO_PARACHUTE;
			case 55:return MAV_CMD::MAV_CMD_DO_MOTOR_TEST;
			case 56:return MAV_CMD::MAV_CMD_DO_INVERTED_FLIGHT;
			case 57:return MAV_CMD::MAV_CMD_DO_GRIPPER;
			case 58:return MAV_CMD::MAV_CMD_DO_AUTOTUNE_ENABLE;
			case 59:return MAV_CMD::MAV_CMD_NAV_SET_YAW_SPEED;
			case 60:return MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL;
			case 61:return MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL_QUAT;
			case 62:return MAV_CMD::MAV_CMD_DO_GUIDED_MASTER;
			case 63:return MAV_CMD::MAV_CMD_DO_GUIDED_LIMITS;
			case 64:return MAV_CMD::MAV_CMD_DO_ENGINE_CONTROL;
			case 65:return MAV_CMD::MAV_CMD_DO_LAST;
			case 66:return MAV_CMD::MAV_CMD_PREFLIGHT_CALIBRATION;
			case 67:return MAV_CMD::MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS;
			case 68:return MAV_CMD::MAV_CMD_PREFLIGHT_UAVCAN;
			case 69:return MAV_CMD::MAV_CMD_PREFLIGHT_STORAGE;
			case 70:return MAV_CMD::MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN;
			case 71:return MAV_CMD::MAV_CMD_OVERRIDE_GOTO;
			case 72:return MAV_CMD::MAV_CMD_MISSION_START;
			case 73:return MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM;
			case 74:return MAV_CMD::MAV_CMD_GET_HOME_POSITION;
			case 75:return MAV_CMD::MAV_CMD_START_RX_PAIR;
			case 76:return MAV_CMD::MAV_CMD_GET_MESSAGE_INTERVAL;
			case 77:return MAV_CMD::MAV_CMD_SET_MESSAGE_INTERVAL;
			case 78:return MAV_CMD::MAV_CMD_REQUEST_PROTOCOL_VERSION;
			case 79:return MAV_CMD::MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES;
			case 80:return MAV_CMD::MAV_CMD_REQUEST_CAMERA_INFORMATION;
			case 81:return MAV_CMD::MAV_CMD_REQUEST_CAMERA_SETTINGS;
			case 82:return MAV_CMD::MAV_CMD_REQUEST_STORAGE_INFORMATION;
			case 83:return MAV_CMD::MAV_CMD_STORAGE_FORMAT;
			case 84:return MAV_CMD::MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS;
			case 85:return MAV_CMD::MAV_CMD_REQUEST_FLIGHT_INFORMATION;
			case 86:return MAV_CMD::MAV_CMD_RESET_CAMERA_SETTINGS;
			case 87:return MAV_CMD::MAV_CMD_SET_CAMERA_MODE;
			case 88:return MAV_CMD::MAV_CMD_IMAGE_START_CAPTURE;
			case 89:return MAV_CMD::MAV_CMD_IMAGE_STOP_CAPTURE;
			case 90:return MAV_CMD::MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE;
			case 91:return MAV_CMD::MAV_CMD_DO_TRIGGER_CONTROL;
			case 92:return MAV_CMD::MAV_CMD_VIDEO_START_CAPTURE;
			case 93:return MAV_CMD::MAV_CMD_VIDEO_STOP_CAPTURE;
			case 94:return MAV_CMD::MAV_CMD_VIDEO_START_STREAMING;
			case 95:return MAV_CMD::MAV_CMD_VIDEO_STOP_STREAMING;
			case 96:return MAV_CMD::MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION;
			case 97:return MAV_CMD::MAV_CMD_LOGGING_START;
			case 98:return MAV_CMD::MAV_CMD_LOGGING_STOP;
			case 99:return MAV_CMD::MAV_CMD_AIRFRAME_CONFIGURATION;
			case 100:return MAV_CMD::MAV_CMD_PANORAMA_CREATE;
			case 101:return MAV_CMD::MAV_CMD_DO_VTOL_TRANSITION;
			case 102:return MAV_CMD::MAV_CMD_ARM_AUTHORIZATION_REQUEST;
			case 103:return MAV_CMD::MAV_CMD_SET_GUIDED_SUBMODE_STANDARD;
			case 104:return MAV_CMD::MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE;
			case 105:return MAV_CMD::MAV_CMD_CONDITION_GATE;
			case 106:return MAV_CMD::MAV_CMD_NAV_FENCE_RETURN_POINT;
			case 107:return MAV_CMD::MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION;
			case 108:return MAV_CMD::MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION;
			case 109:return MAV_CMD::MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION;
			case 110:return MAV_CMD::MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION;
			case 111:return MAV_CMD::MAV_CMD_NAV_RALLY_POINT;
			case 112:return MAV_CMD::MAV_CMD_UAVCAN_GET_NODE_INFO;
			case 113:return MAV_CMD::MAV_CMD_PAYLOAD_PREPARE_DEPLOY;
			case 114:return MAV_CMD::MAV_CMD_PAYLOAD_CONTROL_DEPLOY;
			case 115:return MAV_CMD::MAV_CMD_WAYPOINT_USER_1;
			case 116:return MAV_CMD::MAV_CMD_WAYPOINT_USER_2;
			case 117:return MAV_CMD::MAV_CMD_WAYPOINT_USER_3;
			case 118:return MAV_CMD::MAV_CMD_WAYPOINT_USER_4;
			case 119:return MAV_CMD::MAV_CMD_WAYPOINT_USER_5;
			case 120:return MAV_CMD::MAV_CMD_SPATIAL_USER_1;
			case 121:return MAV_CMD::MAV_CMD_SPATIAL_USER_2;
			case 122:return MAV_CMD::MAV_CMD_SPATIAL_USER_3;
			case 123:return MAV_CMD::MAV_CMD_SPATIAL_USER_4;
			case 124:return MAV_CMD::MAV_CMD_SPATIAL_USER_5;
			case 125:return MAV_CMD::MAV_CMD_USER_1;
			case 126:return MAV_CMD::MAV_CMD_USER_2;
			case 127:return MAV_CMD::MAV_CMD_USER_3;
			case 128:return MAV_CMD::MAV_CMD_USER_4;
			case 129:return MAV_CMD::MAV_CMD_USER_5;
			case 130:return MAV_CMD::MAV_CMD_POWER_OFF_INITIATED;
			case 131:return MAV_CMD::MAV_CMD_SOLO_BTN_FLY_CLICK;
			case 132:return MAV_CMD::MAV_CMD_SOLO_BTN_FLY_HOLD;
			case 133:return MAV_CMD::MAV_CMD_SOLO_BTN_PAUSE_CLICK;
			case 134:return MAV_CMD::MAV_CMD_DO_START_MAG_CAL;
			case 135:return MAV_CMD::MAV_CMD_DO_ACCEPT_MAG_CAL;
			case 136:return MAV_CMD::MAV_CMD_DO_CANCEL_MAG_CAL;
			case 137:return MAV_CMD::MAV_CMD_SET_FACTORY_TEST_MODE;
			case 138:return MAV_CMD::MAV_CMD_DO_SEND_BANNER;
			case 139:return MAV_CMD::MAV_CMD_ACCELCAL_VEHICLE_POS;
			case 140:return MAV_CMD::MAV_CMD_GIMBAL_RESET;
			case 141:return MAV_CMD::MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS;
			case 142:return MAV_CMD::MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION;
			case 143:return MAV_CMD::MAV_CMD_GIMBAL_FULL_RESET;
			
		}
	}
	
	inline static UMAX MAV_CMD_into(MAV_CMD en) {
		switch (en) {
			case MAV_CMD::MAV_CMD_NAV_WAYPOINT:return 0;
			case MAV_CMD::MAV_CMD_NAV_LOITER_UNLIM:return 1;
			case MAV_CMD::MAV_CMD_NAV_LOITER_TURNS:return 2;
			case MAV_CMD::MAV_CMD_NAV_LOITER_TIME:return 3;
			case MAV_CMD::MAV_CMD_NAV_RETURN_TO_LAUNCH:return 4;
			case MAV_CMD::MAV_CMD_NAV_LAND:return 5;
			case MAV_CMD::MAV_CMD_NAV_TAKEOFF:return 6;
			case MAV_CMD::MAV_CMD_NAV_LAND_LOCAL:return 7;
			case MAV_CMD::MAV_CMD_NAV_TAKEOFF_LOCAL:return 8;
			case MAV_CMD::MAV_CMD_NAV_FOLLOW:return 9;
			case MAV_CMD::MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT:return 10;
			case MAV_CMD::MAV_CMD_NAV_LOITER_TO_ALT:return 11;
			case MAV_CMD::MAV_CMD_DO_FOLLOW:return 12;
			case MAV_CMD::MAV_CMD_DO_FOLLOW_REPOSITION:return 13;
			case MAV_CMD::MAV_CMD_NAV_ROI:return 14;
			case MAV_CMD::MAV_CMD_NAV_PATHPLANNING:return 15;
			case MAV_CMD::MAV_CMD_NAV_SPLINE_WAYPOINT:return 16;
			case MAV_CMD::MAV_CMD_NAV_ALTITUDE_WAIT:return 17;
			case MAV_CMD::MAV_CMD_NAV_VTOL_TAKEOFF:return 18;
			case MAV_CMD::MAV_CMD_NAV_VTOL_LAND:return 19;
			case MAV_CMD::MAV_CMD_NAV_GUIDED_ENABLE:return 20;
			case MAV_CMD::MAV_CMD_NAV_DELAY:return 21;
			case MAV_CMD::MAV_CMD_NAV_PAYLOAD_PLACE:return 22;
			case MAV_CMD::MAV_CMD_NAV_LAST:return 23;
			case MAV_CMD::MAV_CMD_CONDITION_DELAY:return 24;
			case MAV_CMD::MAV_CMD_CONDITION_CHANGE_ALT:return 25;
			case MAV_CMD::MAV_CMD_CONDITION_DISTANCE:return 26;
			case MAV_CMD::MAV_CMD_CONDITION_YAW:return 27;
			case MAV_CMD::MAV_CMD_CONDITION_LAST:return 28;
			case MAV_CMD::MAV_CMD_DO_SET_MODE:return 29;
			case MAV_CMD::MAV_CMD_DO_JUMP:return 30;
			case MAV_CMD::MAV_CMD_DO_CHANGE_SPEED:return 31;
			case MAV_CMD::MAV_CMD_DO_SET_HOME:return 32;
			case MAV_CMD::MAV_CMD_DO_SET_PARAMETER:return 33;
			case MAV_CMD::MAV_CMD_DO_SET_RELAY:return 34;
			case MAV_CMD::MAV_CMD_DO_REPEAT_RELAY:return 35;
			case MAV_CMD::MAV_CMD_DO_SET_SERVO:return 36;
			case MAV_CMD::MAV_CMD_DO_REPEAT_SERVO:return 37;
			case MAV_CMD::MAV_CMD_DO_FLIGHTTERMINATION:return 38;
			case MAV_CMD::MAV_CMD_DO_CHANGE_ALTITUDE:return 39;
			case MAV_CMD::MAV_CMD_DO_LAND_START:return 40;
			case MAV_CMD::MAV_CMD_DO_RALLY_LAND:return 41;
			case MAV_CMD::MAV_CMD_DO_GO_AROUND:return 42;
			case MAV_CMD::MAV_CMD_DO_REPOSITION:return 43;
			case MAV_CMD::MAV_CMD_DO_PAUSE_CONTINUE:return 44;
			case MAV_CMD::MAV_CMD_DO_SET_REVERSE:return 45;
			case MAV_CMD::MAV_CMD_DO_CONTROL_VIDEO:return 46;
			case MAV_CMD::MAV_CMD_DO_SET_ROI:return 47;
			case MAV_CMD::MAV_CMD_DO_DIGICAM_CONFIGURE:return 48;
			case MAV_CMD::MAV_CMD_DO_DIGICAM_CONTROL:return 49;
			case MAV_CMD::MAV_CMD_DO_MOUNT_CONFIGURE:return 50;
			case MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL:return 51;
			case MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_DIST:return 52;
			case MAV_CMD::MAV_CMD_DO_FENCE_ENABLE:return 53;
			case MAV_CMD::MAV_CMD_DO_PARACHUTE:return 54;
			case MAV_CMD::MAV_CMD_DO_MOTOR_TEST:return 55;
			case MAV_CMD::MAV_CMD_DO_INVERTED_FLIGHT:return 56;
			case MAV_CMD::MAV_CMD_DO_GRIPPER:return 57;
			case MAV_CMD::MAV_CMD_DO_AUTOTUNE_ENABLE:return 58;
			case MAV_CMD::MAV_CMD_NAV_SET_YAW_SPEED:return 59;
			case MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL:return 60;
			case MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL_QUAT:return 61;
			case MAV_CMD::MAV_CMD_DO_GUIDED_MASTER:return 62;
			case MAV_CMD::MAV_CMD_DO_GUIDED_LIMITS:return 63;
			case MAV_CMD::MAV_CMD_DO_ENGINE_CONTROL:return 64;
			case MAV_CMD::MAV_CMD_DO_LAST:return 65;
			case MAV_CMD::MAV_CMD_PREFLIGHT_CALIBRATION:return 66;
			case MAV_CMD::MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS:return 67;
			case MAV_CMD::MAV_CMD_PREFLIGHT_UAVCAN:return 68;
			case MAV_CMD::MAV_CMD_PREFLIGHT_STORAGE:return 69;
			case MAV_CMD::MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN:return 70;
			case MAV_CMD::MAV_CMD_OVERRIDE_GOTO:return 71;
			case MAV_CMD::MAV_CMD_MISSION_START:return 72;
			case MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM:return 73;
			case MAV_CMD::MAV_CMD_GET_HOME_POSITION:return 74;
			case MAV_CMD::MAV_CMD_START_RX_PAIR:return 75;
			case MAV_CMD::MAV_CMD_GET_MESSAGE_INTERVAL:return 76;
			case MAV_CMD::MAV_CMD_SET_MESSAGE_INTERVAL:return 77;
			case MAV_CMD::MAV_CMD_REQUEST_PROTOCOL_VERSION:return 78;
			case MAV_CMD::MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES:return 79;
			case MAV_CMD::MAV_CMD_REQUEST_CAMERA_INFORMATION:return 80;
			case MAV_CMD::MAV_CMD_REQUEST_CAMERA_SETTINGS:return 81;
			case MAV_CMD::MAV_CMD_REQUEST_STORAGE_INFORMATION:return 82;
			case MAV_CMD::MAV_CMD_STORAGE_FORMAT:return 83;
			case MAV_CMD::MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS:return 84;
			case MAV_CMD::MAV_CMD_REQUEST_FLIGHT_INFORMATION:return 85;
			case MAV_CMD::MAV_CMD_RESET_CAMERA_SETTINGS:return 86;
			case MAV_CMD::MAV_CMD_SET_CAMERA_MODE:return 87;
			case MAV_CMD::MAV_CMD_IMAGE_START_CAPTURE:return 88;
			case MAV_CMD::MAV_CMD_IMAGE_STOP_CAPTURE:return 89;
			case MAV_CMD::MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE:return 90;
			case MAV_CMD::MAV_CMD_DO_TRIGGER_CONTROL:return 91;
			case MAV_CMD::MAV_CMD_VIDEO_START_CAPTURE:return 92;
			case MAV_CMD::MAV_CMD_VIDEO_STOP_CAPTURE:return 93;
			case MAV_CMD::MAV_CMD_VIDEO_START_STREAMING:return 94;
			case MAV_CMD::MAV_CMD_VIDEO_STOP_STREAMING:return 95;
			case MAV_CMD::MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION:return 96;
			case MAV_CMD::MAV_CMD_LOGGING_START:return 97;
			case MAV_CMD::MAV_CMD_LOGGING_STOP:return 98;
			case MAV_CMD::MAV_CMD_AIRFRAME_CONFIGURATION:return 99;
			case MAV_CMD::MAV_CMD_PANORAMA_CREATE:return 100;
			case MAV_CMD::MAV_CMD_DO_VTOL_TRANSITION:return 101;
			case MAV_CMD::MAV_CMD_ARM_AUTHORIZATION_REQUEST:return 102;
			case MAV_CMD::MAV_CMD_SET_GUIDED_SUBMODE_STANDARD:return 103;
			case MAV_CMD::MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE:return 104;
			case MAV_CMD::MAV_CMD_CONDITION_GATE:return 105;
			case MAV_CMD::MAV_CMD_NAV_FENCE_RETURN_POINT:return 106;
			case MAV_CMD::MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION:return 107;
			case MAV_CMD::MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION:return 108;
			case MAV_CMD::MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION:return 109;
			case MAV_CMD::MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION:return 110;
			case MAV_CMD::MAV_CMD_NAV_RALLY_POINT:return 111;
			case MAV_CMD::MAV_CMD_UAVCAN_GET_NODE_INFO:return 112;
			case MAV_CMD::MAV_CMD_PAYLOAD_PREPARE_DEPLOY:return 113;
			case MAV_CMD::MAV_CMD_PAYLOAD_CONTROL_DEPLOY:return 114;
			case MAV_CMD::MAV_CMD_WAYPOINT_USER_1:return 115;
			case MAV_CMD::MAV_CMD_WAYPOINT_USER_2:return 116;
			case MAV_CMD::MAV_CMD_WAYPOINT_USER_3:return 117;
			case MAV_CMD::MAV_CMD_WAYPOINT_USER_4:return 118;
			case MAV_CMD::MAV_CMD_WAYPOINT_USER_5:return 119;
			case MAV_CMD::MAV_CMD_SPATIAL_USER_1:return 120;
			case MAV_CMD::MAV_CMD_SPATIAL_USER_2:return 121;
			case MAV_CMD::MAV_CMD_SPATIAL_USER_3:return 122;
			case MAV_CMD::MAV_CMD_SPATIAL_USER_4:return 123;
			case MAV_CMD::MAV_CMD_SPATIAL_USER_5:return 124;
			case MAV_CMD::MAV_CMD_USER_1:return 125;
			case MAV_CMD::MAV_CMD_USER_2:return 126;
			case MAV_CMD::MAV_CMD_USER_3:return 127;
			case MAV_CMD::MAV_CMD_USER_4:return 128;
			case MAV_CMD::MAV_CMD_USER_5:return 129;
			case MAV_CMD::MAV_CMD_POWER_OFF_INITIATED:return 130;
			case MAV_CMD::MAV_CMD_SOLO_BTN_FLY_CLICK:return 131;
			case MAV_CMD::MAV_CMD_SOLO_BTN_FLY_HOLD:return 132;
			case MAV_CMD::MAV_CMD_SOLO_BTN_PAUSE_CLICK:return 133;
			case MAV_CMD::MAV_CMD_DO_START_MAG_CAL:return 134;
			case MAV_CMD::MAV_CMD_DO_ACCEPT_MAG_CAL:return 135;
			case MAV_CMD::MAV_CMD_DO_CANCEL_MAG_CAL:return 136;
			case MAV_CMD::MAV_CMD_SET_FACTORY_TEST_MODE:return 137;
			case MAV_CMD::MAV_CMD_DO_SEND_BANNER:return 138;
			case MAV_CMD::MAV_CMD_ACCELCAL_VEHICLE_POS:return 139;
			case MAV_CMD::MAV_CMD_GIMBAL_RESET:return 140;
			case MAV_CMD::MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS:return 141;
			case MAV_CMD::MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION:return 142;
			case MAV_CMD::MAV_CMD_GIMBAL_FULL_RESET:return 143;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*Camera Modes. */
	enum class CAMERA_MODE {
		CAMERA_MODE_IMAGE        = 0,//Camera is in image/photo capture mode.
		CAMERA_MODE_VIDEO        = 1,//Camera is in video capture mode.
		CAMERA_MODE_IMAGE_SURVEY = 2//Camera is in image survey capture mode. It allows for camera controller to do specific settings for surveys
	};
	/**
*Source of information about this collision. */
	enum class MAV_COLLISION_SRC {
		MAV_COLLISION_SRC_ADSB                   = 0,//ID field references ADSB_VEHICLE packets
		MAV_COLLISION_SRC_MAVLINK_GPS_GLOBAL_INT = 1//ID field references MAVLink SRC ID
	};
	/**
*Possible remote log data block statuses */
	enum class MAV_REMOTE_LOG_DATA_BLOCK_STATUSES {
		MAV_REMOTE_LOG_DATA_BLOCK_NACK = 0,//This block has NOT been received
		MAV_REMOTE_LOG_DATA_BLOCK_ACK  = 1//This block has been received
	};
	/**
*Status flags for ADS-B transponder dynamic output */
	enum class UAVIONIX_ADSB_RF_HEALTH {
		UAVIONIX_ADSB_RF_HEALTH_INITIALIZING = 0,
		UAVIONIX_ADSB_RF_HEALTH_OK           = 1,
		UAVIONIX_ADSB_RF_HEALTH_FAIL_TX      = 2,
		UAVIONIX_ADSB_RF_HEALTH_FAIL_RX      = 16
	};
	
	inline static UAVIONIX_ADSB_RF_HEALTH UAVIONIX_ADSB_RF_HEALTH_from(UMAX id) {
		switch (id) {
			default :return UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_INITIALIZING;
			case 1:return UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_OK;
			case 2:return UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_FAIL_TX;
			case 3:return UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_FAIL_RX;
			
		}
	}
	
	inline static UMAX UAVIONIX_ADSB_RF_HEALTH_into(UAVIONIX_ADSB_RF_HEALTH en) {
		switch (en) {
			case UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_INITIALIZING:return 0;
			case UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_OK:return 1;
			case UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_FAIL_TX:return 2;
			case UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_FAIL_RX:return 3;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*result from a mavlink command */
	enum class MAV_RESULT {
		MAV_RESULT_ACCEPTED             = 0,//Command ACCEPTED and EXECUTED
		MAV_RESULT_TEMPORARILY_REJECTED = 1,//Command TEMPORARY REJECTED/DENIED
		MAV_RESULT_DENIED               = 2,//Command PERMANENTLY DENIED
		MAV_RESULT_UNSUPPORTED          = 3,//Command UNKNOWN/UNSUPPORTED
		MAV_RESULT_FAILED               = 4,//Command executed, but failed
		MAV_RESULT_IN_PROGRESS          = 5//WIP: Command being executed
	};
	/**
*Special ACK block numbers control activation of dataflash log streaming */
	enum class MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS {
		MAV_REMOTE_LOG_DATA_BLOCK_STOP  = 2147483645UL,//UAV to stop sending DataFlash blocks
		MAV_REMOTE_LOG_DATA_BLOCK_START = 2147483646UL//UAV to start sending DataFlash blocks
	};
	/**
*Status for ADS-B transponder dynamic input */
	enum class UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX {
		UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_0 = 0,
		UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_1 = 1,
		UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_2D     = 2,
		UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_3D     = 3,
		UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_DGPS   = 4,
		UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_RTK    = 5
	};
	enum class GOPRO_COMMAND {
		GOPRO_COMMAND_POWER                 = 0,//(Get/Set)
		GOPRO_COMMAND_CAPTURE_MODE          = 1,//(Get/Set)
		GOPRO_COMMAND_SHUTTER               = 2,//(___/Set)
		GOPRO_COMMAND_BATTERY               = 3,//(Get/___)
		GOPRO_COMMAND_MODEL                 = 4,//(Get/___)
		GOPRO_COMMAND_VIDEO_SETTINGS        = 5,//(Get/Set)
		GOPRO_COMMAND_LOW_LIGHT             = 6,//(Get/Set)
		GOPRO_COMMAND_PHOTO_RESOLUTION      = 7,//(Get/Set)
		GOPRO_COMMAND_PHOTO_BURST_RATE      = 8,//(Get/Set)
		GOPRO_COMMAND_PROTUNE               = 9,//(Get/Set)
		GOPRO_COMMAND_PROTUNE_WHITE_BALANCE = 10,//(Get/Set) Hero 3+ Only
		GOPRO_COMMAND_PROTUNE_COLOUR        = 11,//(Get/Set) Hero 3+ Only
		GOPRO_COMMAND_PROTUNE_GAIN          = 12,//(Get/Set) Hero 3+ Only
		GOPRO_COMMAND_PROTUNE_SHARPNESS     = 13,//(Get/Set) Hero 3+ Only
		GOPRO_COMMAND_PROTUNE_EXPOSURE      = 14,//(Get/Set) Hero 3+ Only
		GOPRO_COMMAND_TIME                  = 15,//(Get/Set)
		GOPRO_COMMAND_CHARGING              = 16//(Get/Set)
	};
	enum class GOPRO_REQUEST_STATUS {
		GOPRO_REQUEST_SUCCESS = 0,//The write message with ID indicated succeeded
		GOPRO_REQUEST_FAILED  = 1//The write message with ID indicated failed
	};
	/**
*Definitions for aircraft size */
	enum class UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE {
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_NO_DATA     = 0,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L15M_W23M   = 1,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25M_W28P5M = 2,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25_34M     = 3,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_33M     = 4,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_38M     = 5,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_39P5M   = 6,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_45M     = 7,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_45M     = 8,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_52M     = 9,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_59P5M   = 10,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_67M     = 11,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W72P5M  = 12,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W80M    = 13,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W80M    = 14,
		UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W90M    = 15
	};
	enum class MAV_STATE {
		UNINIT             = 0,//Uninitialized system, state is unknown.
		ACTIVE             = 1,//System is active and might be already airborne. Motors are engaged.
		BOOT               = 2,//System is booting up.
		CALIBRATING        = 3,//System is calibrating and not flight-ready.
		CRITICAL           = 4,//System is in a non-normal flight mode. It can however still navigate.
		/**
*System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in
*			 mayday and going down */
		EMERGENCY          = 5,
		FLIGHT_TERMINATION = 6,//System is terminating itself.
		POWEROFF           = 7,//System just initialized its power-down sequence, will shut down now.
		STANDBY            = 8//System is grounded and on standby. It can be launched any time.
	};
	/**
*SERIAL_CONTROL flags (bitmask) */
	enum class SERIAL_CONTROL_FLAG {
		SERIAL_CONTROL_FLAG_REPLY     = 1,//Set if this is a reply
		SERIAL_CONTROL_FLAG_RESPOND   = 2,//Set if the sender wants the receiver to send a response as another SERIAL_CONTROL message
		/**
*Set if access to the serial port should be removed from whatever driver is currently using it, giving
*			 exclusive access to the SERIAL_CONTROL protocol. The port can be handed back by sending a request without
*			 this flag se */
		SERIAL_CONTROL_FLAG_EXCLUSIVE = 4,
		SERIAL_CONTROL_FLAG_BLOCKING  = 8,//Block on writes to the serial port
		SERIAL_CONTROL_FLAG_MULTI     = 16//Send multiple replies until port is drained
	};
	
	inline static SERIAL_CONTROL_FLAG SERIAL_CONTROL_FLAG_from(UMAX id) {
		switch (id) {
			default :return SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_REPLY;
			case 1:return SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_RESPOND;
			case 2:return SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_EXCLUSIVE;
			case 3:return SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_BLOCKING;
			case 4:return SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_MULTI;
			
		}
	}
	
	inline static UMAX SERIAL_CONTROL_FLAG_into(SERIAL_CONTROL_FLAG en) {
		switch (en) {
			case SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_REPLY:return 0;
			case SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_RESPOND:return 1;
			case SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_EXCLUSIVE:return 2;
			case SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_BLOCKING:return 3;
			case SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_MULTI:return 4;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*Camera capability flags (Bitmap). */
	enum class CAMERA_CAP_FLAGS {
		CAMERA_CAP_FLAGS_CAPTURE_VIDEO                   = 1,//Camera is able to record video.
		CAMERA_CAP_FLAGS_CAPTURE_IMAGE                   = 2,//Camera is able to capture images.
		CAMERA_CAP_FLAGS_HAS_MODES                       = 4,//Camera has separate Video and Image/Photo modes (MAV_CMD_SET_CAMERA_MODE)
		CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE = 8,//Camera can capture images while in video mode
		CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE = 16,//Camera can capture videos while in Photo/Image mode
		CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE           = 32//Camera has image survey mode (MAV_CMD_SET_CAMERA_MODE)
	};
	
	inline static CAMERA_CAP_FLAGS CAMERA_CAP_FLAGS_from(UMAX id) {
		switch (id) {
			default :return CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAPTURE_VIDEO;
			case 1:return CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAPTURE_IMAGE;
			case 2:return CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_HAS_MODES;
			case 3:return CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE;
			case 4:return CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE;
			case 5:return CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE;
			
		}
	}
	
	inline static UMAX CAMERA_CAP_FLAGS_into(CAMERA_CAP_FLAGS en) {
		switch (en) {
			case CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAPTURE_VIDEO:return 0;
			case CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAPTURE_IMAGE:return 1;
			case CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_HAS_MODES:return 2;
			case CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE:return 3;
			case CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE:return 4;
			case CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE:return 5;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	enum class GOPRO_HEARTBEAT_FLAGS {
		GOPRO_FLAG_RECORDING = 1//GoPro is currently recording
	};
	/**
*Bitmask of (optional) autopilot capabilities (64 bit). If a bit is set, the autopilot supports this capability */
	enum class MAV_PROTOCOL_CAPABILITY {
		MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT                  = 1,//Autopilot supports MISSION float message type.
		MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT                    = 2,//Autopilot supports the new param float message type.
		MAV_PROTOCOL_CAPABILITY_MISSION_INT                    = 4,//Autopilot supports MISSION_INT scaled integer message type.
		MAV_PROTOCOL_CAPABILITY_COMMAND_INT                    = 8,//Autopilot supports COMMAND_INT scaled integer message type.
		MAV_PROTOCOL_CAPABILITY_PARAM_UNION                    = 16,//Autopilot supports the new param union message type.
		MAV_PROTOCOL_CAPABILITY_FTP                            = 32,//Autopilot supports the new FILE_TRANSFER_PROTOCOL message type.
		MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET            = 64,//Autopilot supports commanding attitude offboard.
		MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED  = 128,//Autopilot supports commanding position and velocity targets in local NED frame.
		MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT = 256,//Autopilot supports commanding position and velocity targets in global scaled integers.
		MAV_PROTOCOL_CAPABILITY_TERRAIN                        = 512,//Autopilot supports terrain protocol / data handling.
		MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET            = 1024,//Autopilot supports direct actuator control.
		MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION             = 2048,//Autopilot supports the flight termination command.
		MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION            = 4096,//Autopilot supports onboard compass calibration.
		MAV_PROTOCOL_CAPABILITY_MAVLINK2                       = 8192,//Autopilot supports mavlink version 2.
		MAV_PROTOCOL_CAPABILITY_MISSION_FENCE                  = 16384,//Autopilot supports mission fence protocol.
		MAV_PROTOCOL_CAPABILITY_MISSION_RALLY                  = 32768,//Autopilot supports mission rally point protocol.
		MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION             = 65536//Autopilot supports the flight information protocol.
	};
	
	inline static MAV_PROTOCOL_CAPABILITY MAV_PROTOCOL_CAPABILITY_from(UMAX id) {
		switch (id) {
			default :return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT;
			case 1:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT;
			case 2:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_INT;
			case 3:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_COMMAND_INT;
			case 4:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_PARAM_UNION;
			case 5:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FTP;
			case 6:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET;
			case 7:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED;
			case 8:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT;
			case 9:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_TERRAIN;
			case 10:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET;
			case 11:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION;
			case 12:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION;
			case 13:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MAVLINK2;
			case 14:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_FENCE;
			case 15:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_RALLY;
			case 16:return MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION;
			
		}
	}
	
	inline static UMAX MAV_PROTOCOL_CAPABILITY_into(MAV_PROTOCOL_CAPABILITY en) {
		switch (en) {
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT:return 0;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT:return 1;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_INT:return 2;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_COMMAND_INT:return 3;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_PARAM_UNION:return 4;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FTP:return 5;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET:return 6;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED:return 7;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT:return 8;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_TERRAIN:return 9;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET:return 10;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION:return 11;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION:return 12;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MAVLINK2:return 13;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_FENCE:return 14;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_RALLY:return 15;
			case MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION:return 16;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	enum class GOPRO_HEARTBEAT_STATUS {
		GOPRO_HEARTBEAT_STATUS_DISCONNECTED = 0,//No GoPro connected
		GOPRO_HEARTBEAT_STATUS_INCOMPATIBLE = 1,//The detected GoPro is not HeroBus compatible
		GOPRO_HEARTBEAT_STATUS_CONNECTED    = 2,//A HeroBus compatible GoPro is connected
		GOPRO_HEARTBEAT_STATUS_ERROR        = 3//An unrecoverable error was encountered with the connected GoPro, it may require a power cycle
	};
	enum class MAG_CAL_STATUS {
		MAG_CAL_NOT_STARTED      = 0,
		MAG_CAL_WAITING_TO_START = 1,
		MAG_CAL_RUNNING_STEP_ONE = 2,
		MAG_CAL_RUNNING_STEP_TWO = 3,
		MAG_CAL_SUCCESS          = 4,
		MAG_CAL_FAILED           = 5
	};
	enum class CAMERA_STATUS_TYPES {
		CAMERA_STATUS_TYPE_HEARTBEAT  = 0,//Camera heartbeat, announce camera component ID at 1hz
		CAMERA_STATUS_TYPE_TRIGGER    = 1,//Camera image triggered
		CAMERA_STATUS_TYPE_DISCONNECT = 2,//Camera connection lost
		CAMERA_STATUS_TYPE_ERROR      = 3,//Camera unknown error
		CAMERA_STATUS_TYPE_LOWBATT    = 4,//Camera battery low. Parameter p1 shows reported voltage
		CAMERA_STATUS_TYPE_LOWSTORE   = 5,//Camera storage low. Parameter p1 shows reported shots remaining
		CAMERA_STATUS_TYPE_LOWSTOREV  = 6//Camera storage low. Parameter p1 shows reported video minutes remaining
	};
	/**
*SERIAL_CONTROL device types */
	enum class SERIAL_CONTROL_DEV {
		SERIAL_CONTROL_DEV_TELEM1 = 0,//First telemetry port
		SERIAL_CONTROL_DEV_TELEM2 = 1,//Second telemetry port
		SERIAL_CONTROL_DEV_GPS1   = 2,//First GPS port
		SERIAL_CONTROL_DEV_GPS2   = 3,//Second GPS port
		SERIAL_CONTROL_DEV_SHELL  = 10//system shell
	};
	
	inline static SERIAL_CONTROL_DEV SERIAL_CONTROL_DEV_from(UMAX id) {
		switch (id) {
			default :return SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_TELEM1;
			case 1:return SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_TELEM2;
			case 2:return SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_GPS1;
			case 3:return SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_GPS2;
			case 4:return SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_SHELL;
			
		}
	}
	
	inline static UMAX SERIAL_CONTROL_DEV_into(SERIAL_CONTROL_DEV en) {
		switch (en) {
			case SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_TELEM1:return 0;
			case SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_TELEM2:return 1;
			case SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_GPS1:return 2;
			case SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_GPS2:return 3;
			case SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_SHELL:return 4;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*result in a mavlink mission ack */
	enum class MAV_MISSION_RESULT {
		MAV_MISSION_ACCEPTED          = 0,//mission accepted OK
		MAV_MISSION_ERROR             = 1,//generic error / not accepting mission commands at all right now
		MAV_MISSION_UNSUPPORTED_FRAME = 2,//coordinate frame is not supported
		MAV_MISSION_UNSUPPORTED       = 3,//command is not supported
		MAV_MISSION_NO_SPACE          = 4,//mission item exceeds storage space
		MAV_MISSION_INVALID           = 5,//one of the parameters has an invalid value
		MAV_MISSION_INVALID_PARAM1    = 6,//param1 has an invalid value
		MAV_MISSION_INVALID_PARAM2    = 7,//param2 has an invalid value
		MAV_MISSION_INVALID_PARAM3    = 8,//param3 has an invalid value
		MAV_MISSION_INVALID_PARAM4    = 9,//param4 has an invalid value
		MAV_MISSION_INVALID_PARAM5_X  = 10,//x/param5 has an invalid value
		MAV_MISSION_INVALID_PARAM6_Y  = 11,//y/param6 has an invalid value
		MAV_MISSION_INVALID_PARAM7    = 12,//param7 has an invalid value
		MAV_MISSION_INVALID_SEQUENCE  = 13,//received waypoint out of sequence
		MAV_MISSION_DENIED            = 14//not accepting any mission commands from this communication partner
	};
	/**
*Power supply status flags (bitmask) */
	enum class MAV_POWER_STATUS {
		MAV_POWER_STATUS_BRICK_VALID                = 1,//main brick power supply valid
		MAV_POWER_STATUS_SERVO_VALID                = 2,//main servo power supply valid for FMU
		MAV_POWER_STATUS_USB_CONNECTED              = 4,//USB power is connected
		MAV_POWER_STATUS_PERIPH_OVERCURRENT         = 8,//peripheral supply is in over-current state
		MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT = 16,//hi-power peripheral supply is in over-current state
		MAV_POWER_STATUS_CHANGED                    = 32//Power status has changed since boot
	};
	
	inline static MAV_POWER_STATUS MAV_POWER_STATUS_from(UMAX id) {
		switch (id) {
			default :return MAV_POWER_STATUS::MAV_POWER_STATUS_BRICK_VALID;
			case 1:return MAV_POWER_STATUS::MAV_POWER_STATUS_SERVO_VALID;
			case 2:return MAV_POWER_STATUS::MAV_POWER_STATUS_USB_CONNECTED;
			case 3:return MAV_POWER_STATUS::MAV_POWER_STATUS_PERIPH_OVERCURRENT;
			case 4:return MAV_POWER_STATUS::MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT;
			case 5:return MAV_POWER_STATUS::MAV_POWER_STATUS_CHANGED;
			
		}
	}
	
	inline static UMAX MAV_POWER_STATUS_into(MAV_POWER_STATUS en) {
		switch (en) {
			case MAV_POWER_STATUS::MAV_POWER_STATUS_BRICK_VALID:return 0;
			case MAV_POWER_STATUS::MAV_POWER_STATUS_SERVO_VALID:return 1;
			case MAV_POWER_STATUS::MAV_POWER_STATUS_USB_CONNECTED:return 2;
			case MAV_POWER_STATUS::MAV_POWER_STATUS_PERIPH_OVERCURRENT:return 3;
			case MAV_POWER_STATUS::MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT:return 4;
			case MAV_POWER_STATUS::MAV_POWER_STATUS_CHANGED:return 5;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*Generalized UAVCAN node mode */
	enum class UAVCAN_NODE_MODE {
		UAVCAN_NODE_MODE_OPERATIONAL     = 0,//The node is performing its primary functions.
		UAVCAN_NODE_MODE_INITIALIZATION  = 1,//The node is initializing; this mode is entered immediately after startup.
		UAVCAN_NODE_MODE_MAINTENANCE     = 2,//The node is under maintenance.
		UAVCAN_NODE_MODE_SOFTWARE_UPDATE = 3,//The node is in the process of updating its software.
		UAVCAN_NODE_MODE_OFFLINE         = 7//The node is no longer available online.
	};
	
	inline static UAVCAN_NODE_MODE UAVCAN_NODE_MODE_from(UMAX id) {
		switch (id) {
			default :return UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_OPERATIONAL;
			case 1:return UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_INITIALIZATION;
			case 2:return UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_MAINTENANCE;
			case 3:return UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_SOFTWARE_UPDATE;
			case 4:return UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_OFFLINE;
			
		}
	}
	
	inline static UMAX UAVCAN_NODE_MODE_into(UAVCAN_NODE_MODE en) {
		switch (en) {
			case UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_OPERATIONAL:return 0;
			case UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_INITIALIZATION:return 1;
			case UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_MAINTENANCE:return 2;
			case UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_SOFTWARE_UPDATE:return 3;
			case UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_OFFLINE:return 4;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*These flags indicate status such as data validity of each data source. Set = data valid */
	enum class ADSB_FLAGS {
		ADSB_FLAGS_VALID_COORDS   = 1,
		ADSB_FLAGS_VALID_ALTITUDE = 2,
		ADSB_FLAGS_VALID_HEADING  = 4,
		ADSB_FLAGS_VALID_VELOCITY = 8,
		ADSB_FLAGS_VALID_CALLSIGN = 16,
		ADSB_FLAGS_VALID_SQUAWK   = 32,
		ADSB_FLAGS_SIMULATED      = 64
	};
	
	inline static ADSB_FLAGS ADSB_FLAGS_from(UMAX id) {
		switch (id) {
			default :return ADSB_FLAGS::ADSB_FLAGS_VALID_COORDS;
			case 1:return ADSB_FLAGS::ADSB_FLAGS_VALID_ALTITUDE;
			case 2:return ADSB_FLAGS::ADSB_FLAGS_VALID_HEADING;
			case 3:return ADSB_FLAGS::ADSB_FLAGS_VALID_VELOCITY;
			case 4:return ADSB_FLAGS::ADSB_FLAGS_VALID_CALLSIGN;
			case 5:return ADSB_FLAGS::ADSB_FLAGS_VALID_SQUAWK;
			case 6:return ADSB_FLAGS::ADSB_FLAGS_SIMULATED;
			
		}
	}
	
	inline static UMAX ADSB_FLAGS_into(ADSB_FLAGS en) {
		switch (en) {
			case ADSB_FLAGS::ADSB_FLAGS_VALID_COORDS:return 0;
			case ADSB_FLAGS::ADSB_FLAGS_VALID_ALTITUDE:return 1;
			case ADSB_FLAGS::ADSB_FLAGS_VALID_HEADING:return 2;
			case ADSB_FLAGS::ADSB_FLAGS_VALID_VELOCITY:return 3;
			case ADSB_FLAGS::ADSB_FLAGS_VALID_CALLSIGN:return 4;
			case ADSB_FLAGS::ADSB_FLAGS_VALID_SQUAWK:return 5;
			case ADSB_FLAGS::ADSB_FLAGS_SIMULATED:return 6;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*Result from a PARAM_EXT_SET message. */
	enum class PARAM_ACK {
		PARAM_ACK_ACCEPTED          = 0,//Parameter value ACCEPTED and SET
		PARAM_ACK_VALUE_UNSUPPORTED = 1,//Parameter value UNKNOWN/UNSUPPORTED
		PARAM_ACK_FAILED            = 2,//Parameter failed to set
		/**
*Parameter value received but not yet validated or set. A subsequent PARAM_EXT_ACK will follow once operation
*			 is completed with the actual result. These are for parameters that may take longer to set. Instead of
*			 waiting for an ACK and potentially timing out, you will immediately receive this response to let you
*			 know it was received */
		PARAM_ACK_IN_PROGRESS       = 3
	};
	/**
*Enumeration of possible mount operation modes */
	enum class MAV_MOUNT_MODE {
		MAV_MOUNT_MODE_RETRACT           = 0,//Load and keep safe position (Roll,Pitch,Yaw) from permant memory and stop stabilization
		MAV_MOUNT_MODE_NEUTRAL           = 1,//Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory.
		MAV_MOUNT_MODE_MAVLINK_TARGETING = 2,//Load neutral position and start MAVLink Roll,Pitch,Yaw control with stabilization
		MAV_MOUNT_MODE_RC_TARGETING      = 3,//Load neutral position and start RC Roll,Pitch,Yaw control with stabilization
		MAV_MOUNT_MODE_GPS_POINT         = 4//Load neutral position and start to point to Lat,Lon,Alt
	};
	/**
*Enumeration of sensor orientation, according to its rotations */
	enum class MAV_SENSOR_ORIENTATION {
		NONE                       = 0,//Roll: 0, Pitch: 0, Yaw: 0
		YAW_45                     = 1,//Roll: 0, Pitch: 0, Yaw: 45
		YAW_90                     = 2,//Roll: 0, Pitch: 0, Yaw: 90
		YAW_135                    = 3,//Roll: 0, Pitch: 0, Yaw: 135
		YAW_180                    = 4,//Roll: 0, Pitch: 0, Yaw: 180
		YAW_225                    = 5,//Roll: 0, Pitch: 0, Yaw: 225
		YAW_270                    = 6,//Roll: 0, Pitch: 0, Yaw: 270
		YAW_315                    = 7,//Roll: 0, Pitch: 0, Yaw: 315
		ROLL_180                   = 8,//Roll: 180, Pitch: 0, Yaw: 0
		ROLL_180_YAW_45            = 9,//Roll: 180, Pitch: 0, Yaw: 45
		ROLL_180_YAW_90            = 10,//Roll: 180, Pitch: 0, Yaw: 90
		ROLL_180_YAW_135           = 11,//Roll: 180, Pitch: 0, Yaw: 135
		PITCH_180                  = 12,//Roll: 0, Pitch: 180, Yaw: 0
		ROLL_180_YAW_225           = 13,//Roll: 180, Pitch: 0, Yaw: 225
		ROLL_180_YAW_270           = 14,//Roll: 180, Pitch: 0, Yaw: 270
		ROLL_180_YAW_315           = 15,//Roll: 180, Pitch: 0, Yaw: 315
		ROLL_90                    = 16,//Roll: 90, Pitch: 0, Yaw: 0
		ROLL_90_YAW_45             = 17,//Roll: 90, Pitch: 0, Yaw: 45
		ROLL_90_YAW_90             = 18,//Roll: 90, Pitch: 0, Yaw: 90
		ROLL_90_YAW_135            = 19,//Roll: 90, Pitch: 0, Yaw: 135
		ROLL_270                   = 20,//Roll: 270, Pitch: 0, Yaw: 0
		ROLL_270_YAW_45            = 21,//Roll: 270, Pitch: 0, Yaw: 45
		ROLL_270_YAW_90            = 22,//Roll: 270, Pitch: 0, Yaw: 90
		ROLL_270_YAW_135           = 23,//Roll: 270, Pitch: 0, Yaw: 135
		PITCH_90                   = 24,//Roll: 0, Pitch: 90, Yaw: 0
		PITCH_270                  = 25,//Roll: 0, Pitch: 270, Yaw: 0
		PITCH_180_YAW_90           = 26,//Roll: 0, Pitch: 180, Yaw: 90
		PITCH_180_YAW_270          = 27,//Roll: 0, Pitch: 180, Yaw: 270
		ROLL_90_PITCH_90           = 28,//Roll: 90, Pitch: 90, Yaw: 0
		ROLL_180_PITCH_90          = 29,//Roll: 180, Pitch: 90, Yaw: 0
		ROLL_270_PITCH_90          = 30,//Roll: 270, Pitch: 90, Yaw: 0
		ROLL_90_PITCH_180          = 31,//Roll: 90, Pitch: 180, Yaw: 0
		ROLL_270_PITCH_180         = 32,//Roll: 270, Pitch: 180, Yaw: 0
		ROLL_90_PITCH_270          = 33,//Roll: 90, Pitch: 270, Yaw: 0
		ROLL_180_PITCH_270         = 34,//Roll: 180, Pitch: 270, Yaw: 0
		ROLL_270_PITCH_270         = 35,//Roll: 270, Pitch: 270, Yaw: 0
		ROLL_90_PITCH_180_YAW_90   = 36,//Roll: 90, Pitch: 180, Yaw: 90
		ROLL_90_YAW_270            = 37,//Roll: 90, Pitch: 0, Yaw: 270
		ROLL_315_PITCH_315_YAW_315 = 38//Roll: 315, Pitch: 315, Yaw: 315
	};
	/**
*State flags for ADS-B transponder dynamic report */
	enum class UAVIONIX_ADSB_OUT_DYNAMIC_STATE {
		UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE        = 1,
		UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED    = 2,
		UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED = 4,
		UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND            = 8,
		UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT                = 16
	};
	
	inline static UAVIONIX_ADSB_OUT_DYNAMIC_STATE UAVIONIX_ADSB_OUT_DYNAMIC_STATE_from(UMAX id) {
		switch (id) {
			default :return UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE;
			case 1:return UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED;
			case 2:return UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED;
			case 3:return UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND;
			case 4:return UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT;
			
		}
	}
	
	inline static UMAX UAVIONIX_ADSB_OUT_DYNAMIC_STATE_into(UAVIONIX_ADSB_OUT_DYNAMIC_STATE en) {
		switch (en) {
			case UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE:return 0;
			case UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED:return 1;
			case UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED:return 2;
			case UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND:return 3;
			case UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT:return 4;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*Possible actions an aircraft can take to avoid a collision. */
	enum class MAV_COLLISION_ACTION {
		MAV_COLLISION_ACTION_NONE               = 0,//Ignore any potential collisions
		MAV_COLLISION_ACTION_REPORT             = 1,//Report potential collision
		MAV_COLLISION_ACTION_ASCEND_OR_DESCEND  = 2,//Ascend or Descend to avoid threat
		MAV_COLLISION_ACTION_MOVE_HORIZONTALLY  = 3,//Move horizontally to avoid threat
		MAV_COLLISION_ACTION_MOVE_PERPENDICULAR = 4,//Aircraft to move perpendicular to the collision's velocity vector
		MAV_COLLISION_ACTION_RTL                = 5,//Aircraft to fly directly back to its launch point
		MAV_COLLISION_ACTION_HOVER              = 6//Aircraft to stop in place
	};
	/**
*Aircraft-rated danger from this threat. */
	enum class MAV_COLLISION_THREAT_LEVEL {
		MAV_COLLISION_THREAT_LEVEL_NONE = 0,//Not a threat
		MAV_COLLISION_THREAT_LEVEL_LOW  = 1,//Craft is mildly concerned about this threat
		MAV_COLLISION_THREAT_LEVEL_HIGH = 2//Craft is panicing, and may take actions to avoid threat
	};
	enum class LIMITS_STATE {
		LIMITS_INIT       = 0,//pre-initialization
		LIMITS_DISABLED   = 1,//disabled
		LIMITS_ENABLED    = 2,//checking limits
		LIMITS_TRIGGERED  = 3,//a limit has been breached
		LIMITS_RECOVERING = 4,//taking action eg. RTL
		LIMITS_RECOVERED  = 5//we're no longer in breach of a limit
	};
	/**
*Transceiver RF control flags for ADS-B transponder dynamic reports */
	enum class UAVIONIX_ADSB_OUT_RF_SELECT {
		UAVIONIX_ADSB_OUT_RF_SELECT_STANDBY    = 0,
		UAVIONIX_ADSB_OUT_RF_SELECT_RX_ENABLED = 1,
		UAVIONIX_ADSB_OUT_RF_SELECT_TX_ENABLED = 2
	};
	/**
*Enumeration of battery types */
	enum class MAV_BATTERY_TYPE {
		UNKNOWN = 0,//Not specified.
		LIPO    = 1,//Lithium polymer battery
		LIFE    = 2,//Lithium-iron-phosphate battery
		LION    = 3,//Lithium-ION battery
		NIMH    = 4//Nickel metal hydride battery
	};
	/**
*Flags in EKF_STATUS message */
	enum class EKF_STATUS_FLAGS {
		EKF_ATTITUDE           = 1,//set if EKF's attitude estimate is good
		EKF_VELOCITY_HORIZ     = 2,//set if EKF's horizontal velocity estimate is good
		EKF_VELOCITY_VERT      = 4,//set if EKF's vertical velocity estimate is good
		EKF_POS_HORIZ_REL      = 8,//set if EKF's horizontal position (relative) estimate is good
		EKF_POS_HORIZ_ABS      = 16,//set if EKF's horizontal position (absolute) estimate is good
		EKF_POS_VERT_ABS       = 32,//set if EKF's vertical position (absolute) estimate is good
		EKF_POS_VERT_AGL       = 64,//set if EKF's vertical position (above ground) estimate is good
		EKF_CONST_POS_MODE     = 128,//EKF is in constant position mode and does not know it's absolute or relative position
		EKF_PRED_POS_HORIZ_REL = 256,//set if EKF's predicted horizontal position (relative) estimate is good
		EKF_PRED_POS_HORIZ_ABS = 512//set if EKF's predicted horizontal position (absolute) estimate is good
	};
	
	inline static EKF_STATUS_FLAGS EKF_STATUS_FLAGS_from(UMAX id) {
		switch (id) {
			default :return EKF_STATUS_FLAGS::EKF_ATTITUDE;
			case 1:return EKF_STATUS_FLAGS::EKF_VELOCITY_HORIZ;
			case 2:return EKF_STATUS_FLAGS::EKF_VELOCITY_VERT;
			case 3:return EKF_STATUS_FLAGS::EKF_POS_HORIZ_REL;
			case 4:return EKF_STATUS_FLAGS::EKF_POS_HORIZ_ABS;
			case 5:return EKF_STATUS_FLAGS::EKF_POS_VERT_ABS;
			case 6:return EKF_STATUS_FLAGS::EKF_POS_VERT_AGL;
			case 7:return EKF_STATUS_FLAGS::EKF_CONST_POS_MODE;
			case 8:return EKF_STATUS_FLAGS::EKF_PRED_POS_HORIZ_REL;
			case 9:return EKF_STATUS_FLAGS::EKF_PRED_POS_HORIZ_ABS;
			
		}
	}
	
	inline static UMAX EKF_STATUS_FLAGS_into(EKF_STATUS_FLAGS en) {
		switch (en) {
			case EKF_STATUS_FLAGS::EKF_ATTITUDE:return 0;
			case EKF_STATUS_FLAGS::EKF_VELOCITY_HORIZ:return 1;
			case EKF_STATUS_FLAGS::EKF_VELOCITY_VERT:return 2;
			case EKF_STATUS_FLAGS::EKF_POS_HORIZ_REL:return 3;
			case EKF_STATUS_FLAGS::EKF_POS_HORIZ_ABS:return 4;
			case EKF_STATUS_FLAGS::EKF_POS_VERT_ABS:return 5;
			case EKF_STATUS_FLAGS::EKF_POS_VERT_AGL:return 6;
			case EKF_STATUS_FLAGS::EKF_CONST_POS_MODE:return 7;
			case EKF_STATUS_FLAGS::EKF_PRED_POS_HORIZ_REL:return 8;
			case EKF_STATUS_FLAGS::EKF_PRED_POS_HORIZ_ABS:return 9;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*These encode the sensors whose status is sent as part of the SYS_STATUS message. */
	enum class MAV_SYS_STATUS_SENSOR {
		MAV_SYS_STATUS_SENSOR_3D_GYRO                = 1,//0x01 3D gyro
		MAV_SYS_STATUS_SENSOR_3D_ACCEL               = 2,//0x02 3D accelerometer
		MAV_SYS_STATUS_SENSOR_3D_MAG                 = 4,//0x04 3D magnetometer
		MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE      = 8,//0x08 absolute pressure
		MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE  = 16,//0x10 differential pressure
		MAV_SYS_STATUS_SENSOR_GPS                    = 32,//0x20 GPS
		MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW           = 64,//0x40 optical flow
		MAV_SYS_STATUS_SENSOR_VISION_POSITION        = 128,//0x80 computer vision position
		MAV_SYS_STATUS_SENSOR_LASER_POSITION         = 256,//0x100 laser based position
		MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH  = 512,//0x200 external ground truth (Vicon or Leica)
		MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL   = 1024,//0x400 3D angular rate control
		MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION = 2048,//0x800 attitude stabilization
		MAV_SYS_STATUS_SENSOR_YAW_POSITION           = 4096,//0x1000 yaw position
		MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL     = 8192,//0x2000 z/altitude control
		MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL    = 16384,//0x4000 x/y position control
		MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS          = 32768,//0x8000 motor outputs / control
		MAV_SYS_STATUS_SENSOR_RC_RECEIVER            = 65536,//0x10000 rc receiver
		MAV_SYS_STATUS_SENSOR_3D_GYRO2               = 131072,//0x20000 2nd 3D gyro
		MAV_SYS_STATUS_SENSOR_3D_ACCEL2              = 262144,//0x40000 2nd 3D accelerometer
		MAV_SYS_STATUS_SENSOR_3D_MAG2                = 524288,//0x80000 2nd 3D magnetometer
		MAV_SYS_STATUS_GEOFENCE                      = 1048576,//0x100000 geofence
		MAV_SYS_STATUS_AHRS                          = 2097152,//0x200000 AHRS subsystem health
		MAV_SYS_STATUS_TERRAIN                       = 4194304,//0x400000 Terrain subsystem health
		MAV_SYS_STATUS_REVERSE_MOTOR                 = 8388608,//0x800000 Motors are reversed
		MAV_SYS_STATUS_LOGGING                       = 16777216,//0x1000000 Logging
		MAV_SYS_STATUS_SENSOR_BATTERY                = 33554432//0x2000000 Battery
	};
	
	inline static MAV_SYS_STATUS_SENSOR MAV_SYS_STATUS_SENSOR_from(UMAX id) {
		switch (id) {
			default :return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_GYRO;
			case 1:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_ACCEL;
			case 2:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_MAG;
			case 3:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE;
			case 4:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE;
			case 5:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_GPS;
			case 6:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW;
			case 7:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_VISION_POSITION;
			case 8:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_LASER_POSITION;
			case 9:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH;
			case 10:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL;
			case 11:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION;
			case 12:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_YAW_POSITION;
			case 13:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL;
			case 14:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL;
			case 15:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS;
			case 16:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_RC_RECEIVER;
			case 17:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_GYRO2;
			case 18:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_ACCEL2;
			case 19:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_MAG2;
			case 20:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_GEOFENCE;
			case 21:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_AHRS;
			case 22:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_TERRAIN;
			case 23:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_REVERSE_MOTOR;
			case 24:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_LOGGING;
			case 25:return MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_BATTERY;
			
		}
	}
	
	inline static UMAX MAV_SYS_STATUS_SENSOR_into(MAV_SYS_STATUS_SENSOR en) {
		switch (en) {
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_GYRO:return 0;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_ACCEL:return 1;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_MAG:return 2;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE:return 3;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE:return 4;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_GPS:return 5;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW:return 6;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_VISION_POSITION:return 7;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_LASER_POSITION:return 8;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH:return 9;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL:return 10;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION:return 11;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_YAW_POSITION:return 12;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL:return 13;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL:return 14;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS:return 15;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_RC_RECEIVER:return 16;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_GYRO2:return 17;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_ACCEL2:return 18;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_MAG2:return 19;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_GEOFENCE:return 20;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_AHRS:return 21;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_TERRAIN:return 22;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_REVERSE_MOTOR:return 23;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_LOGGING:return 24;
			case MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_BATTERY:return 25;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	enum class MAV_FRAME {
		/**
*Global coordinate frame, WGS84 coordinate system. First value / x: latitude, second value / y: longitude,
*					 third value / z: positive altitude over mean sea level (MSL */
		MAV_FRAME_GLOBAL                  = 0,
		MAV_FRAME_LOCAL_NED               = 1,//Local coordinate frame, Z-up (x: north, y: east, z: down).
		MAV_FRAME_MISSION                 = 2,//NOT a coordinate frame, indicates a mission command.
		/**
*Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home
*			 position. First value / x: latitude, second value / y: longitude, third value / z: positive altitude
*			 with 0 being at the altitude of the home location */
		MAV_FRAME_GLOBAL_RELATIVE_ALT     = 3,
		MAV_FRAME_LOCAL_ENU               = 4,//Local coordinate frame, Z-down (x: east, y: north, z: up)
		/**
*Global coordinate frame, WGS84 coordinate system. First value / x: latitude in degrees*1.0e-7, second
*			 value / y: longitude in degrees*1.0e-7, third value / z: positive altitude over mean sea level (MSL */
		MAV_FRAME_GLOBAL_INT              = 5,
		/**
*Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home
*			 position. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third
*			 value / z: positive altitude with 0 being at the altitude of the home location */
		MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6,
		/**
*Offset to the current local frame. Anything expressed in this frame should be added to the current local
*			 frame position */
		MAV_FRAME_LOCAL_OFFSET_NED        = 7,
		/**
*Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to
*			 command 2 m/s^2 acceleration to the right */
		MAV_FRAME_BODY_NED                = 8,
		/**
*Offset in body NED frame. This makes sense if adding setpoints to the current flight path, to avoid an
*			 obstacle - e.g. useful to command 2 m/s^2 acceleration to the east */
		MAV_FRAME_BODY_OFFSET_NED         = 9,
		/**
*Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude
*			 over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees, second value
*			 / y: longitude in degrees, third value / z: positive altitude in meters with 0 being at ground level
*			 in terrain model */
		MAV_FRAME_GLOBAL_TERRAIN_ALT      = 10,
		/**
*Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude
*			 over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees*10e-7, second
*			 value / y: longitude in degrees*10e-7, third value / z: positive altitude in meters with 0 being at ground
*			 level in terrain model */
		MAV_FRAME_GLOBAL_TERRAIN_ALT_INT  = 11
	};
	/**
*ADSB classification for the type of vehicle emitting the transponder signal */
	enum class ADSB_EMITTER_TYPE {
		ADSB_EMITTER_TYPE_NO_INFO           = 0,
		ADSB_EMITTER_TYPE_LIGHT             = 1,
		ADSB_EMITTER_TYPE_SMALL             = 2,
		ADSB_EMITTER_TYPE_LARGE             = 3,
		ADSB_EMITTER_TYPE_HIGH_VORTEX_LARGE = 4,
		ADSB_EMITTER_TYPE_HEAVY             = 5,
		ADSB_EMITTER_TYPE_HIGHLY_MANUV      = 6,
		ADSB_EMITTER_TYPE_ROTOCRAFT         = 7,
		ADSB_EMITTER_TYPE_UNASSIGNED        = 8,
		ADSB_EMITTER_TYPE_GLIDER            = 9,
		ADSB_EMITTER_TYPE_LIGHTER_AIR       = 10,
		ADSB_EMITTER_TYPE_PARACHUTE         = 11,
		ADSB_EMITTER_TYPE_ULTRA_LIGHT       = 12,
		ADSB_EMITTER_TYPE_UNASSIGNED2       = 13,
		ADSB_EMITTER_TYPE_UAV               = 14,
		ADSB_EMITTER_TYPE_SPACE             = 15,
		ADSB_EMITTER_TYPE_UNASSGINED3       = 16,
		ADSB_EMITTER_TYPE_EMERGENCY_SURFACE = 17,
		ADSB_EMITTER_TYPE_SERVICE_SURFACE   = 18,
		ADSB_EMITTER_TYPE_POINT_OBSTACLE    = 19
	};
	/**
*GPS lataral offset encoding */
	enum class UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT {
		NO_DATA  = 0,
		LEFT_2M  = 1,
		LEFT_4M  = 2,
		LEFT_6M  = 3,
		RIGHT_0M = 4,
		RIGHT_2M = 5,
		RIGHT_4M = 6,
		RIGHT_6M = 7
	};
	/**
*GPS longitudinal offset encoding */
	enum class UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON {
		UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_NO_DATA           = 0,
		UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_APPLIED_BY_SENSOR = 1
	};
	enum class GPS_INPUT_IGNORE_FLAGS {
		GPS_INPUT_IGNORE_FLAG_ALT                 = 1,//ignore altitude field
		GPS_INPUT_IGNORE_FLAG_HDOP                = 2,//ignore hdop field
		GPS_INPUT_IGNORE_FLAG_VDOP                = 4,//ignore vdop field
		GPS_INPUT_IGNORE_FLAG_VEL_HORIZ           = 8,//ignore horizontal velocity field (vn and ve)
		GPS_INPUT_IGNORE_FLAG_VEL_VERT            = 16,//ignore vertical velocity field (vd)
		GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY      = 32,//ignore speed accuracy field
		GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY = 64,//ignore horizontal accuracy field
		GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY   = 128//ignore vertical accuracy field
	};
	
	inline static GPS_INPUT_IGNORE_FLAGS GPS_INPUT_IGNORE_FLAGS_from(UMAX id) {
		switch (id) {
			default :return GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_ALT;
			case 1:return GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_HDOP;
			case 2:return GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VDOP;
			case 3:return GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VEL_HORIZ;
			case 4:return GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VEL_VERT;
			case 5:return GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY;
			case 6:return GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY;
			case 7:return GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY;
			
		}
	}
	
	inline static UMAX GPS_INPUT_IGNORE_FLAGS_into(GPS_INPUT_IGNORE_FLAGS en) {
		switch (en) {
			case GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_ALT:return 0;
			case GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_HDOP:return 1;
			case GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VDOP:return 2;
			case GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VEL_HORIZ:return 3;
			case GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VEL_VERT:return 4;
			case GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY:return 5;
			case GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY:return 6;
			case GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY:return 7;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*Flags in RALLY_POINT message */
	enum class RALLY_FLAGS {
		FAVORABLE_WIND   = 1,//Flag set when requiring favorable winds for landing.
		/**
*Flag set when plane is to immediately descend to break altitude and land without GCS intervention. Flag
*			 not set when plane is to loiter at Rally point until commanded to land */
		LAND_IMMEDIATELY = 2
	};
	enum class FENCE_BREACH {
		FENCE_BREACH_NONE     = 0,//No last fence breach
		FENCE_BREACH_MINALT   = 1,//Breached minimum altitude
		FENCE_BREACH_MAXALT   = 2,//Breached maximum altitude
		FENCE_BREACH_BOUNDARY = 3//Breached fence boundary
	};
	/**
*These flags encode the MAV mode. */
	enum class MAV_MODE_FLAG {
		MAV_MODE_FLAG_CUSTOM_MODE_ENABLED  = 1,//0b00000001 Reserved for future use.
		/**
*0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should
*			 not be used for stable implementations */
		MAV_MODE_FLAG_TEST_ENABLED         = 2,
		/**
*0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not,
*			 depends on the actual implementation */
		MAV_MODE_FLAG_AUTO_ENABLED         = 4,
		MAV_MODE_FLAG_GUIDED_ENABLED       = 8,//0b00001000 guided mode enabled, system flies waypoints / mission items.
		/**
*0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further
*			 control inputs to move around */
		MAV_MODE_FLAG_STABILIZE_ENABLED    = 16,
		/**
*0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software
*			 is full operational */
		MAV_MODE_FLAG_HIL_ENABLED          = 32,
		MAV_MODE_FLAG_MANUAL_INPUT_ENABLED = 64,//0b01000000 remote control input is enabled.
		/**
*0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. Additional
*					 note: this flag is to be ignore when sent in the command MAV_CMD_DO_SET_MODE and MAV_CMD_COMPONENT_ARM_DISARM
*					 shall be used instead. The flag can still be used to report the armed state */
		MAV_MODE_FLAG_SAFETY_ARMED         = 128
	};
	
	inline static MAV_MODE_FLAG MAV_MODE_FLAG_from(UMAX id) {
		switch (id) {
			default :return MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
			case 1:return MAV_MODE_FLAG::MAV_MODE_FLAG_TEST_ENABLED;
			case 2:return MAV_MODE_FLAG::MAV_MODE_FLAG_AUTO_ENABLED;
			case 3:return MAV_MODE_FLAG::MAV_MODE_FLAG_GUIDED_ENABLED;
			case 4:return MAV_MODE_FLAG::MAV_MODE_FLAG_STABILIZE_ENABLED;
			case 5:return MAV_MODE_FLAG::MAV_MODE_FLAG_HIL_ENABLED;
			case 6:return MAV_MODE_FLAG::MAV_MODE_FLAG_MANUAL_INPUT_ENABLED;
			case 7:return MAV_MODE_FLAG::MAV_MODE_FLAG_SAFETY_ARMED;
			
		}
	}
	
	inline static UMAX MAV_MODE_FLAG_into(MAV_MODE_FLAG en) {
		switch (en) {
			case MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED:return 0;
			case MAV_MODE_FLAG::MAV_MODE_FLAG_TEST_ENABLED:return 1;
			case MAV_MODE_FLAG::MAV_MODE_FLAG_AUTO_ENABLED:return 2;
			case MAV_MODE_FLAG::MAV_MODE_FLAG_GUIDED_ENABLED:return 3;
			case MAV_MODE_FLAG::MAV_MODE_FLAG_STABILIZE_ENABLED:return 4;
			case MAV_MODE_FLAG::MAV_MODE_FLAG_HIL_ENABLED:return 5;
			case MAV_MODE_FLAG::MAV_MODE_FLAG_MANUAL_INPUT_ENABLED:return 6;
			case MAV_MODE_FLAG::MAV_MODE_FLAG_SAFETY_ARMED:return 7;
			
			default:;//assert(false);//("Unknown enum ID " + id);
		}
		return -1;
	}
	
	/**
*Bus types for device operations */
	enum class DEVICE_OP_BUSTYPE {
		DEVICE_OP_BUSTYPE_I2C = 0,//I2C Device operation
		DEVICE_OP_BUSTYPE_SPI = 1//SPI Device operation
	};
	
	struct ATTITUDE_TARGET {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		ATTITUDE_TARGET(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const ATTITUDE_TARGET &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 37) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		int8_t type_mask() const { return static_cast< int8_t >((&data_)[4] ); }
		
		
		struct q_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, q_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, q_> end() const { return {*this, 4}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			static constexpr size_t len = 4;
			
		};
		
		struct q_ q() const {
			struct q_ ret{&data_ + 5};
			return ret;
		}
		
		float body_roll_rate() const { return (intBitsToFloat(get_bytes(&data_, 21, 4))); }
		
		float body_pitch_rate() const { return (intBitsToFloat(get_bytes(&data_, 25, 4))); }
		
		float body_yaw_rate() const { return (intBitsToFloat(get_bytes(&data_, 29, 4))); }
		
		float thrust() const { return (intBitsToFloat(get_bytes(&data_, 33, 4))); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void type_mask( int8_t src  ) {}
	void q( const struct com::company::demo::ATTITUDE_TARGET :: q_  & src  ) const {}
	void body_roll_rate( float src  ) {}
	void body_pitch_rate( float src  ) {}
	void body_yaw_rate( float src  ) {}
	void thrust( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct MISSION_COUNT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MISSION_COUNT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t count() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[3] ); }
		
		
		struct mission_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MISSION_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mission_type_ mission_type() const {
			if (data_.base.field_bit != 32 && !set_field(&data_, 32, -1)) return {0, 0};
			mission_type_ ret{true, static_cast< enum MAV_MISSION_TYPE > ( MAV_MISSION_TYPE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void count( int16_t src  ) {}
	void mission_type( enum com::company::demo:: MAV_MISSION_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct ADSB_VEHICLE {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const ADSB_VEHICLE &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t heading() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void heading(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t hor_velocity() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void hor_velocity(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		int16_t squawk() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		void squawk(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 4); }
		
		int32_t ICAO_address() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 6, 4))); }
		
		void ICAO_address(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 6); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 10, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 10); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 14, 4))); }
		
		void lon(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 14); }
		
		int32_t altitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 18, 4))); }
		
		void altitude(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 18); }
		
		int16_t ver_velocity() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 22, 2))); }
		
		void ver_velocity(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 22); }
		
		int8_t tslc() const { return static_cast< int8_t >((data_.base.bytes)[24] ); }
		
		void tslc(int8_t src) const { (data_.base.bytes)[24] = (uint8_t) (src); }
		
		struct altitude_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum ADSB_ALTITUDE_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		altitude_type_ altitude_type() const {
			if (data_.base.field_bit != 202 && !set_field(&data_, 202, -1)) return {0, 0};
			altitude_type_ ret{true, static_cast< enum ADSB_ALTITUDE_TYPE > (    static_cast< enum ADSB_ALTITUDE_TYPE >(   get_bits(data_.base.bytes, data_.BIT, 1)))};
			return ret;
		}
		
		
		void altitude_type(enum ADSB_ALTITUDE_TYPE src) const {
			
			if (data_.base.field_bit != 202) set_field(&data_, 202, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 1, data_.base.bytes, data_.BIT);
		}
		
		
		struct callsign_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		callsign_ callsign() const {
			if (data_.base.field_bit != 203 && !set_field(&data_, 203, -1)) return {0, 0, 0};
			
			callsign_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			callsign_ callsign(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 203) set_field(&data_, 203, len);
				const callsign_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		callsign_ callsign(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 203) set_field(&data_, 203, len);
			const callsign_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		struct emitter_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum ADSB_EMITTER_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		emitter_type_ emitter_type() const {
			if (data_.base.field_bit != 204 && !set_field(&data_, 204, -1)) return {0, 0};
			emitter_type_ ret{true, static_cast< enum ADSB_EMITTER_TYPE > (    static_cast< enum ADSB_EMITTER_TYPE >(   get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		void emitter_type(enum ADSB_EMITTER_TYPE src) const {
			
			if (data_.base.field_bit != 204) set_field(&data_, 204, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 5, data_.base.bytes, data_.BIT);
		}
		
		
		struct flags_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum ADSB_FLAGS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		flags_ flags() const {
			if (data_.base.field_bit != 205 && !set_field(&data_, 205, -1)) return {0, 0};
			flags_ ret{true, static_cast< enum ADSB_FLAGS > ( ADSB_FLAGS_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void flags(enum ADSB_FLAGS src) const {
			
			if (data_.base.field_bit != 205) set_field(&data_, 205, 0);
			
			set_bits(ADSB_FLAGS_into(src), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void ICAO_address( int32_t src  ) {}
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void altitude_type( enum com::company::demo:: ADSB_ALTITUDE_TYPE src  ) {}
	void altitude( int32_t src  ) {}
	void heading( int16_t src  ) {}
	void hor_velocity( int16_t src  ) {}
	void ver_velocity( int16_t src  ) {}
	void callsign( const struct com::company::demo::ADSB_VEHICLE :: callsign_::CASE::EXISTS  & src  ) const {}
	void emitter_type( enum com::company::demo:: ADSB_EMITTER_TYPE src  ) {}
	void tslc( int8_t src  ) {}
	void flags( enum com::company::demo:: ADSB_FLAGS src  ) {}
	void squawk( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t ICAO_address(  ) {}
	int32_t ICAO_address(  ) {}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lon(  ) {}
	int32_t lon(  ) {}
	enum com::company::demo:: ADSB_ALTITUDE_TYPE altitude_type(  ) {}
	bool altitude_type_exists(){}
	int32_t altitude(  ) {}
	int32_t altitude(  ) {}
	int16_t heading(  ) {}
	int16_t heading(  ) {}
	int16_t hor_velocity(  ) {}
	int16_t hor_velocity(  ) {}
	int16_t ver_velocity(  ) {}
	int16_t ver_velocity(  ) {}
	std container of chars  callsign(  ) {}
	bool callsign_exists(){}
	enum com::company::demo:: ADSB_EMITTER_TYPE emitter_type(  ) {}
	bool emitter_type_exists(){}
	int8_t tslc(  ) {}
	int8_t tslc(  ) {}
	enum com::company::demo:: ADSB_FLAGS flags(  ) {}
	bool flags_exists(){}
	int16_t squawk(  ) {}
	int16_t squawk(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MESSAGE_INTERVAL {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		MESSAGE_INTERVAL(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const MESSAGE_INTERVAL &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 6) == 0);
		}
		
		int16_t message_id() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void message_id(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int32_t interval_us() const { return (static_cast< int32_t > (get_bytes(&data_, 2, 4))); }
		
		void interval_us(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 2); }
		
		
		/*
struct <DST> {
	void message_id( int16_t src  ) {}
	void interval_us( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t message_id(  ) {}
	int16_t message_id(  ) {}
	int32_t interval_us(  ) {}
	int32_t interval_us(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct EKF_STATUS_REPORT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const EKF_STATUS_REPORT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		float velocity_variance() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 0, 4))); }
		
		void velocity_variance(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 0); }
		
		float pos_horiz_variance() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 4, 4))); }
		
		void pos_horiz_variance(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 4); }
		
		float pos_vert_variance() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 8, 4))); }
		
		void pos_vert_variance(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 8); }
		
		float compass_variance() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		void compass_variance(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 12); }
		
		float terrain_alt_variance() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		void terrain_alt_variance(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 16); }
		
		struct flags_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum EKF_STATUS_FLAGS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		flags_ flags() const {
			if (data_.base.field_bit != 160 && !set_field(&data_, 160, -1)) return {0, 0};
			flags_ ret{true, static_cast< enum EKF_STATUS_FLAGS > ( EKF_STATUS_FLAGS_from(get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void flags(enum EKF_STATUS_FLAGS src) const {
			
			if (data_.base.field_bit != 160) set_field(&data_, 160, 0);
			
			set_bits(EKF_STATUS_FLAGS_into(src), 4, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void flags( enum com::company::demo:: EKF_STATUS_FLAGS src  ) {}
	void velocity_variance( float src  ) {}
	void pos_horiz_variance( float src  ) {}
	void pos_vert_variance( float src  ) {}
	void compass_variance( float src  ) {}
	void terrain_alt_variance( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: EKF_STATUS_FLAGS flags(  ) {}
	bool flags_exists(){}
	float velocity_variance(  ) {}
	float velocity_variance(  ) {}
	float pos_horiz_variance(  ) {}
	float pos_horiz_variance(  ) {}
	float pos_vert_variance(  ) {}
	float pos_vert_variance(  ) {}
	float compass_variance(  ) {}
	float compass_variance(  ) {}
	float terrain_alt_variance(  ) {}
	float terrain_alt_variance(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct ESTIMATOR_STATUS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const ESTIMATOR_STATUS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 0, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 0); }
		
		float vel_ratio() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 8, 4))); }
		
		void vel_ratio(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 8); }
		
		float pos_horiz_ratio() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		void pos_horiz_ratio(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 12); }
		
		float pos_vert_ratio() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		void pos_vert_ratio(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 16); }
		
		float mag_ratio() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 20, 4))); }
		
		void mag_ratio(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 20); }
		
		float hagl_ratio() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 24, 4))); }
		
		void hagl_ratio(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 24); }
		
		float tas_ratio() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 28, 4))); }
		
		void tas_ratio(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 28); }
		
		float pos_horiz_accuracy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 32, 4))); }
		
		void pos_horiz_accuracy(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 32); }
		
		float pos_vert_accuracy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 36, 4))); }
		
		void pos_vert_accuracy(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 36); }
		
		struct flags_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum ESTIMATOR_STATUS_FLAGS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		flags_ flags() const {
			if (data_.base.field_bit != 320 && !set_field(&data_, 320, -1)) return {0, 0};
			flags_ ret{true, static_cast< enum ESTIMATOR_STATUS_FLAGS > ( ESTIMATOR_STATUS_FLAGS_from(get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void flags(enum ESTIMATOR_STATUS_FLAGS src) const {
			
			if (data_.base.field_bit != 320) set_field(&data_, 320, 0);
			
			set_bits(ESTIMATOR_STATUS_FLAGS_into(src), 4, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void flags( enum com::company::demo:: ESTIMATOR_STATUS_FLAGS src  ) {}
	void vel_ratio( float src  ) {}
	void pos_horiz_ratio( float src  ) {}
	void pos_vert_ratio( float src  ) {}
	void mag_ratio( float src  ) {}
	void hagl_ratio( float src  ) {}
	void tas_ratio( float src  ) {}
	void pos_horiz_accuracy( float src  ) {}
	void pos_vert_accuracy( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	enum com::company::demo:: ESTIMATOR_STATUS_FLAGS flags(  ) {}
	bool flags_exists(){}
	float vel_ratio(  ) {}
	float vel_ratio(  ) {}
	float pos_horiz_ratio(  ) {}
	float pos_horiz_ratio(  ) {}
	float pos_vert_ratio(  ) {}
	float pos_vert_ratio(  ) {}
	float mag_ratio(  ) {}
	float mag_ratio(  ) {}
	float hagl_ratio(  ) {}
	float hagl_ratio(  ) {}
	float tas_ratio(  ) {}
	float tas_ratio(  ) {}
	float pos_horiz_accuracy(  ) {}
	float pos_horiz_accuracy(  ) {}
	float pos_vert_accuracy(  ) {}
	float pos_vert_accuracy(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct HWSTATUS {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		HWSTATUS(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const HWSTATUS &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 3) == 0);
		}
		
		int16_t Vcc() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void Vcc(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int8_t I2Cerr() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void I2Cerr(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void Vcc( int16_t src  ) {}
	void I2Cerr( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t Vcc(  ) {}
	int16_t Vcc(  ) {}
	int8_t I2Cerr(  ) {}
	int8_t I2Cerr(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct TIMESYNC {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		TIMESYNC(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const TIMESYNC &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 16) == 0);
		}
		
		int64_t tc1() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void tc1(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		int64_t ts1() const { return (static_cast< int64_t > (get_bytes(&data_, 8, 8))); }
		
		void ts1(int64_t src) const { set_bytes((src), 8, &data_, 8); }
		
		
		/*
struct <DST> {
	void tc1( int64_t src  ) {}
	void ts1( int64_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t tc1(  ) {}
	int64_t tc1(  ) {}
	int64_t ts1(  ) {}
	int64_t ts1(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct PARAM_EXT_REQUEST_LIST {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		PARAM_EXT_REQUEST_LIST(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const PARAM_EXT_REQUEST_LIST &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 2) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GLOBAL_POSITION_INT_COV {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const GLOBAL_POSITION_INT_COV &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 0, 8))); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 8, 4))); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 12, 4))); }
		
		int32_t alt() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 16, 4))); }
		
		int32_t relative_alt() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 20, 4))); }
		
		float vx() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 24, 4))); }
		
		float vy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 28, 4))); }
		
		float vz() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 32, 4))); }
		
		
		struct covariance_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, covariance_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, covariance_> end() const { return {*this, 36}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			static constexpr size_t len = 36;
			
		};
		
		struct covariance_ covariance() const {
			struct covariance_ ret{data_.base.bytes + 36};
			return ret;
		}
		
		struct estimator_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_ESTIMATOR_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		estimator_type_ estimator_type() const {
			if (data_.base.field_bit != 1440 && !set_field(&data_, 1440, -1)) return {0, 0};
			estimator_type_ ret{true, static_cast< enum MAV_ESTIMATOR_TYPE > (    static_cast< enum MAV_ESTIMATOR_TYPE >( 1 + get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void estimator_type( enum com::company::demo:: MAV_ESTIMATOR_TYPE src  ) {}
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void alt( int32_t src  ) {}
	void relative_alt( int32_t src  ) {}
	void vx( float src  ) {}
	void vy( float src  ) {}
	void vz( float src  ) {}
	void covariance( const struct com::company::demo::GLOBAL_POSITION_INT_COV :: covariance_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct BUTTON_CHANGE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		BUTTON_CHANGE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const BUTTON_CHANGE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 9) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int32_t last_change_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 4, 4))); }
		
		void last_change_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 4); }
		
		int8_t state() const { return static_cast< int8_t >((&data_)[8] ); }
		
		void state(int8_t src) const { (&data_)[8] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void last_change_ms( int32_t src  ) {}
	void state( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	int32_t last_change_ms(  ) {}
	int32_t last_change_ms(  ) {}
	int8_t state(  ) {}
	int8_t state(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SAFETY_SET_ALLOWED_AREA {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const SAFETY_SET_ALLOWED_AREA &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		float p1x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 2, 4))); }
		
		float p1y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 6, 4))); }
		
		float p1z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 10, 4))); }
		
		float p2x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 14, 4))); }
		
		float p2y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 18, 4))); }
		
		float p2z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 22, 4))); }
		
		
		struct frame_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_FRAME value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		frame_ frame() const {
			if (data_.base.field_bit != 208 && !set_field(&data_, 208, -1)) return {0, 0};
			frame_ ret{true, static_cast< enum MAV_FRAME > (    static_cast< enum MAV_FRAME >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void frame( enum com::company::demo:: MAV_FRAME src  ) {}
	void p1x( float src  ) {}
	void p1y( float src  ) {}
	void p1z( float src  ) {}
	void p2x( float src  ) {}
	void p2y( float src  ) {}
	void p2z( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct UAVCAN_NODE_STATUS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const UAVCAN_NODE_STATUS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t vendor_specific_status_code() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void vendor_specific_status_code(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int32_t uptime_sec() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 2, 4))); }
		
		void uptime_sec(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 2); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 6, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 6); }
		
		int8_t sub_mode() const { return static_cast< int8_t >((data_.base.bytes)[14] ); }
		
		void sub_mode(int8_t src) const { (data_.base.bytes)[14] = (uint8_t) (src); }
		
		struct health_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum UAVCAN_NODE_HEALTH value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		health_ health() const {
			if (data_.base.field_bit != 120 && !set_field(&data_, 120, -1)) return {0, 0};
			health_ ret{true, static_cast< enum UAVCAN_NODE_HEALTH > (    static_cast< enum UAVCAN_NODE_HEALTH >(   get_bits(data_.base.bytes, data_.BIT, 2)))};
			return ret;
		}
		
		
		void health(enum UAVCAN_NODE_HEALTH src) const {
			
			if (data_.base.field_bit != 120) set_field(&data_, 120, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 2, data_.base.bytes, data_.BIT);
		}
		
		
		struct mode_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum UAVCAN_NODE_MODE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mode_ mode() const {
			if (data_.base.field_bit != 121 && !set_field(&data_, 121, -1)) return {0, 0};
			mode_ ret{true, static_cast< enum UAVCAN_NODE_MODE > ( UAVCAN_NODE_MODE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void mode(enum UAVCAN_NODE_MODE src) const {
			
			if (data_.base.field_bit != 121) set_field(&data_, 121, 0);
			
			set_bits(UAVCAN_NODE_MODE_into(src), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void uptime_sec( int32_t src  ) {}
	void health( enum com::company::demo:: UAVCAN_NODE_HEALTH src  ) {}
	void mode( enum com::company::demo:: UAVCAN_NODE_MODE src  ) {}
	void sub_mode( int8_t src  ) {}
	void vendor_specific_status_code( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int32_t uptime_sec(  ) {}
	int32_t uptime_sec(  ) {}
	enum com::company::demo:: UAVCAN_NODE_HEALTH health(  ) {}
	bool health_exists(){}
	enum com::company::demo:: UAVCAN_NODE_MODE mode(  ) {}
	bool mode_exists(){}
	int8_t sub_mode(  ) {}
	int8_t sub_mode(  ) {}
	int16_t vendor_specific_status_code(  ) {}
	int16_t vendor_specific_status_code(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct COLLISION {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const COLLISION &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t id() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		void id(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 0); }
		
		float time_to_minimum_delta() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 4, 4))); }
		
		void time_to_minimum_delta(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 4); }
		
		float altitude_minimum_delta() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 8, 4))); }
		
		void altitude_minimum_delta(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 8); }
		
		float horizontal_minimum_delta() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		void horizontal_minimum_delta(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 12); }
		
		struct sRc_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_COLLISION_SRC value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		sRc_ sRc() const {
			if (data_.base.field_bit != 130 && !set_field(&data_, 130, -1)) return {0, 0};
			sRc_ ret{true, static_cast< enum MAV_COLLISION_SRC > (    static_cast< enum MAV_COLLISION_SRC >(   get_bits(data_.base.bytes, data_.BIT, 1)))};
			return ret;
		}
		
		
		void sRc(enum MAV_COLLISION_SRC src) const {
			
			if (data_.base.field_bit != 130) set_field(&data_, 130, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 1, data_.base.bytes, data_.BIT);
		}
		
		
		struct action_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_COLLISION_ACTION value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		action_ action() const {
			if (data_.base.field_bit != 131 && !set_field(&data_, 131, -1)) return {0, 0};
			action_ ret{true, static_cast< enum MAV_COLLISION_ACTION > (    static_cast< enum MAV_COLLISION_ACTION >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void action(enum MAV_COLLISION_ACTION src) const {
			
			if (data_.base.field_bit != 131) set_field(&data_, 131, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct threat_level_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_COLLISION_THREAT_LEVEL value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		threat_level_ threat_level() const {
			if (data_.base.field_bit != 132 && !set_field(&data_, 132, -1)) return {0, 0};
			threat_level_ ret{true, static_cast< enum MAV_COLLISION_THREAT_LEVEL > (    static_cast< enum MAV_COLLISION_THREAT_LEVEL >(   get_bits(data_.base.bytes, data_.BIT, 2)))};
			return ret;
		}
		
		
		void threat_level(enum MAV_COLLISION_THREAT_LEVEL src) const {
			
			if (data_.base.field_bit != 132) set_field(&data_, 132, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 2, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void sRc( enum com::company::demo:: MAV_COLLISION_SRC src  ) {}
	void id( int32_t src  ) {}
	void action( enum com::company::demo:: MAV_COLLISION_ACTION src  ) {}
	void threat_level( enum com::company::demo:: MAV_COLLISION_THREAT_LEVEL src  ) {}
	void time_to_minimum_delta( float src  ) {}
	void altitude_minimum_delta( float src  ) {}
	void horizontal_minimum_delta( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: MAV_COLLISION_SRC sRc(  ) {}
	bool sRc_exists(){}
	int32_t id(  ) {}
	int32_t id(  ) {}
	enum com::company::demo:: MAV_COLLISION_ACTION action(  ) {}
	bool action_exists(){}
	enum com::company::demo:: MAV_COLLISION_THREAT_LEVEL threat_level(  ) {}
	bool threat_level_exists(){}
	float time_to_minimum_delta(  ) {}
	float time_to_minimum_delta(  ) {}
	float altitude_minimum_delta(  ) {}
	float altitude_minimum_delta(  ) {}
	float horizontal_minimum_delta(  ) {}
	float horizontal_minimum_delta(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GIMBAL_TORQUE_CMD_REPORT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		GIMBAL_TORQUE_CMD_REPORT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const GIMBAL_TORQUE_CMD_REPORT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 8) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		int16_t rl_torque_cmd() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void rl_torque_cmd(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int16_t el_torque_cmd() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		void el_torque_cmd(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 4); }
		
		int16_t az_torque_cmd() const { return (static_cast< int16_t > (get_bytes(&data_, 6, 2))); }
		
		void az_torque_cmd(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 6); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void rl_torque_cmd( int16_t src  ) {}
	void el_torque_cmd( int16_t src  ) {}
	void az_torque_cmd( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int16_t rl_torque_cmd(  ) {}
	int16_t rl_torque_cmd(  ) {}
	int16_t el_torque_cmd(  ) {}
	int16_t el_torque_cmd(  ) {}
	int16_t az_torque_cmd(  ) {}
	int16_t az_torque_cmd(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct ALTITUDE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		ALTITUDE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const ALTITUDE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 32) == 0);
		}
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		float altitude_monotonic() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void altitude_monotonic(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float altitude_amsl() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void altitude_amsl(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		float altitude_local() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		void altitude_local(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 16); }
		
		float altitude_relative() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		void altitude_relative(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 20); }
		
		float altitude_terrain() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void altitude_terrain(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		float bottom_clearance() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void bottom_clearance(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void altitude_monotonic( float src  ) {}
	void altitude_amsl( float src  ) {}
	void altitude_local( float src  ) {}
	void altitude_relative( float src  ) {}
	void altitude_terrain( float src  ) {}
	void bottom_clearance( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	float altitude_monotonic(  ) {}
	float altitude_monotonic(  ) {}
	float altitude_amsl(  ) {}
	float altitude_amsl(  ) {}
	float altitude_local(  ) {}
	float altitude_local(  ) {}
	float altitude_relative(  ) {}
	float altitude_relative(  ) {}
	float altitude_terrain(  ) {}
	float altitude_terrain(  ) {}
	float bottom_clearance(  ) {}
	float bottom_clearance(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct HIL_STATE_QUATERNION {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		HIL_STATE_QUATERNION(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const HIL_STATE_QUATERNION &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 64) == 0);
		}
		
		int16_t ind_airspeed() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void ind_airspeed(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t true_airspeed() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void true_airspeed(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 4, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 4); }
		
		struct attitude_quaternion_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, attitude_quaternion_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, attitude_quaternion_> end() const { return {*this, 4}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 4;
			
		};
		
		struct attitude_quaternion_ attitude_quaternion() const {
			struct attitude_quaternion_ ret{&data_ + 12};
			return ret;
		}
		
		template<typename float_src_container>
			attitude_quaternion_ attitude_quaternion(const float_src_container &src) const {
				auto                        first = src.begin();
				struct attitude_quaternion_ ret{&data_ + 12};
				for (size_t                 i     = 0; i < 4; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		attitude_quaternion_ attitude_quaternion(float *const src) const { return attitude_quaternion(static_cast<float const *>( src)); }
		
		attitude_quaternion_ attitude_quaternion(float const *const src) const {
			struct attitude_quaternion_ ret{&data_ + 12};
			if (src)
				for (size_t             i = 0; i < 4; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		float rollspeed() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void rollspeed(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		float pitchspeed() const { return (intBitsToFloat(get_bytes(&data_, 32, 4))); }
		
		void pitchspeed(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 32); }
		
		float yawspeed() const { return (intBitsToFloat(get_bytes(&data_, 36, 4))); }
		
		void yawspeed(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 36); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 40, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 40); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(&data_, 44, 4))); }
		
		void lon(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 44); }
		
		int32_t alt() const { return (static_cast< int32_t > (get_bytes(&data_, 48, 4))); }
		
		void alt(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 48); }
		
		int16_t vx() const { return (static_cast< int16_t > (get_bytes(&data_, 52, 2))); }
		
		void vx(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 52); }
		
		int16_t vy() const { return (static_cast< int16_t > (get_bytes(&data_, 54, 2))); }
		
		void vy(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 54); }
		
		int16_t vz() const { return (static_cast< int16_t > (get_bytes(&data_, 56, 2))); }
		
		void vz(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 56); }
		
		int16_t xacc() const { return (static_cast< int16_t > (get_bytes(&data_, 58, 2))); }
		
		void xacc(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 58); }
		
		int16_t yacc() const { return (static_cast< int16_t > (get_bytes(&data_, 60, 2))); }
		
		void yacc(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 60); }
		
		int16_t zacc() const { return (static_cast< int16_t > (get_bytes(&data_, 62, 2))); }
		
		void zacc(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 62); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void attitude_quaternion( const struct com::company::demo::HIL_STATE_QUATERNION :: attitude_quaternion_  & src  ) const {}
	void rollspeed( float src  ) {}
	void pitchspeed( float src  ) {}
	void yawspeed( float src  ) {}
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void alt( int32_t src  ) {}
	void vx( int16_t src  ) {}
	void vy( int16_t src  ) {}
	void vz( int16_t src  ) {}
	void ind_airspeed( int16_t src  ) {}
	void true_airspeed( int16_t src  ) {}
	void xacc( int16_t src  ) {}
	void yacc( int16_t src  ) {}
	void zacc( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	std container of flo  attitude_quaternion(  ) {}
	float rollspeed(  ) {}
	float rollspeed(  ) {}
	float pitchspeed(  ) {}
	float pitchspeed(  ) {}
	float yawspeed(  ) {}
	float yawspeed(  ) {}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lon(  ) {}
	int32_t lon(  ) {}
	int32_t alt(  ) {}
	int32_t alt(  ) {}
	int16_t vx(  ) {}
	int16_t vx(  ) {}
	int16_t vy(  ) {}
	int16_t vy(  ) {}
	int16_t vz(  ) {}
	int16_t vz(  ) {}
	int16_t ind_airspeed(  ) {}
	int16_t ind_airspeed(  ) {}
	int16_t true_airspeed(  ) {}
	int16_t true_airspeed(  ) {}
	int16_t xacc(  ) {}
	int16_t xacc(  ) {}
	int16_t yacc(  ) {}
	int16_t yacc(  ) {}
	int16_t zacc(  ) {}
	int16_t zacc(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SENSOR_OFFSETS {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SENSOR_OFFSETS(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SENSOR_OFFSETS &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 42) == 0);
		}
		
		int16_t mag_ofs_x() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void mag_ofs_x(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t mag_ofs_y() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void mag_ofs_y(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int16_t mag_ofs_z() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		void mag_ofs_z(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 4); }
		
		float mag_declination() const { return (intBitsToFloat(get_bytes(&data_, 6, 4))); }
		
		void mag_declination(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 6); }
		
		int32_t raw_press() const { return (static_cast< int32_t > (get_bytes(&data_, 10, 4))); }
		
		void raw_press(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 10); }
		
		int32_t raw_temp() const { return (static_cast< int32_t > (get_bytes(&data_, 14, 4))); }
		
		void raw_temp(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 14); }
		
		float gyro_cal_x() const { return (intBitsToFloat(get_bytes(&data_, 18, 4))); }
		
		void gyro_cal_x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 18); }
		
		float gyro_cal_y() const { return (intBitsToFloat(get_bytes(&data_, 22, 4))); }
		
		void gyro_cal_y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 22); }
		
		float gyro_cal_z() const { return (intBitsToFloat(get_bytes(&data_, 26, 4))); }
		
		void gyro_cal_z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 26); }
		
		float accel_cal_x() const { return (intBitsToFloat(get_bytes(&data_, 30, 4))); }
		
		void accel_cal_x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 30); }
		
		float accel_cal_y() const { return (intBitsToFloat(get_bytes(&data_, 34, 4))); }
		
		void accel_cal_y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 34); }
		
		float accel_cal_z() const { return (intBitsToFloat(get_bytes(&data_, 38, 4))); }
		
		void accel_cal_z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 38); }
		
		
		/*
struct <DST> {
	void mag_ofs_x( int16_t src  ) {}
	void mag_ofs_y( int16_t src  ) {}
	void mag_ofs_z( int16_t src  ) {}
	void mag_declination( float src  ) {}
	void raw_press( int32_t src  ) {}
	void raw_temp( int32_t src  ) {}
	void gyro_cal_x( float src  ) {}
	void gyro_cal_y( float src  ) {}
	void gyro_cal_z( float src  ) {}
	void accel_cal_x( float src  ) {}
	void accel_cal_y( float src  ) {}
	void accel_cal_z( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t mag_ofs_x(  ) {}
	int16_t mag_ofs_x(  ) {}
	int16_t mag_ofs_y(  ) {}
	int16_t mag_ofs_y(  ) {}
	int16_t mag_ofs_z(  ) {}
	int16_t mag_ofs_z(  ) {}
	float mag_declination(  ) {}
	float mag_declination(  ) {}
	int32_t raw_press(  ) {}
	int32_t raw_press(  ) {}
	int32_t raw_temp(  ) {}
	int32_t raw_temp(  ) {}
	float gyro_cal_x(  ) {}
	float gyro_cal_x(  ) {}
	float gyro_cal_y(  ) {}
	float gyro_cal_y(  ) {}
	float gyro_cal_z(  ) {}
	float gyro_cal_z(  ) {}
	float accel_cal_x(  ) {}
	float accel_cal_x(  ) {}
	float accel_cal_y(  ) {}
	float accel_cal_y(  ) {}
	float accel_cal_z(  ) {}
	float accel_cal_z(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct STORAGE_INFORMATION {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		STORAGE_INFORMATION(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const STORAGE_INFORMATION &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 27) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int8_t storage_id() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void storage_id(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		int8_t storage_count() const { return static_cast< int8_t >((&data_)[5] ); }
		
		void storage_count(int8_t src) const { (&data_)[5] = (uint8_t) (src); }
		
		int8_t status() const { return static_cast< int8_t >((&data_)[6] ); }
		
		void status(int8_t src) const { (&data_)[6] = (uint8_t) (src); }
		
		float total_capacity() const { return (intBitsToFloat(get_bytes(&data_, 7, 4))); }
		
		void total_capacity(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 7); }
		
		float used_capacity() const { return (intBitsToFloat(get_bytes(&data_, 11, 4))); }
		
		void used_capacity(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 11); }
		
		float available_capacity() const { return (intBitsToFloat(get_bytes(&data_, 15, 4))); }
		
		void available_capacity(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 15); }
		
		float read_speed() const { return (intBitsToFloat(get_bytes(&data_, 19, 4))); }
		
		void read_speed(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 19); }
		
		float write_speed() const { return (intBitsToFloat(get_bytes(&data_, 23, 4))); }
		
		void write_speed(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 23); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void storage_id( int8_t src  ) {}
	void storage_count( int8_t src  ) {}
	void status( int8_t src  ) {}
	void total_capacity( float src  ) {}
	void used_capacity( float src  ) {}
	void available_capacity( float src  ) {}
	void read_speed( float src  ) {}
	void write_speed( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	int8_t storage_id(  ) {}
	int8_t storage_id(  ) {}
	int8_t storage_count(  ) {}
	int8_t storage_count(  ) {}
	int8_t status(  ) {}
	int8_t status(  ) {}
	float total_capacity(  ) {}
	float total_capacity(  ) {}
	float used_capacity(  ) {}
	float used_capacity(  ) {}
	float available_capacity(  ) {}
	float available_capacity(  ) {}
	float read_speed(  ) {}
	float read_speed(  ) {}
	float write_speed(  ) {}
	float write_speed(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct CAMERA_INFORMATION {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const CAMERA_INFORMATION &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t resolution_h() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void resolution_h(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t resolution_v() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void resolution_v(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		int16_t cam_definition_version() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		void cam_definition_version(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 4); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 6, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 6); }
		
		int32_t firmware_version() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 10, 4))); }
		
		void firmware_version(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 10); }
		
		struct vendor_name_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, vendor_name_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, vendor_name_> end() const { return {*this, 32}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 32;
			
		};
		
		struct vendor_name_ vendor_name() const {
			struct vendor_name_ ret{data_.base.bytes + 14};
			return ret;
		}
		
		template<typename int8_src_container>
			vendor_name_ vendor_name(const int8_src_container &src) const {
				auto                first = src.begin();
				struct vendor_name_ ret{data_.base.bytes + 14};
				for (size_t         i     = 0; i < 32; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		vendor_name_ vendor_name(int8_t *const src) const { return vendor_name(static_cast<int8_t const *>( src)); }
		
		vendor_name_ vendor_name(int8_t const *const src) const {
			struct vendor_name_ ret{data_.base.bytes + 14};
			if (src)
				for (size_t     i = 0; i < 32; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct model_name_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, model_name_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, model_name_> end() const { return {*this, 32}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 32;
			
		};
		
		struct model_name_ model_name() const {
			struct model_name_ ret{data_.base.bytes + 46};
			return ret;
		}
		
		template<typename int8_src_container>
			model_name_ model_name(const int8_src_container &src) const {
				auto               first = src.begin();
				struct model_name_ ret{data_.base.bytes + 46};
				for (size_t        i     = 0; i < 32; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		model_name_ model_name(int8_t *const src) const { return model_name(static_cast<int8_t const *>( src)); }
		
		model_name_ model_name(int8_t const *const src) const {
			struct model_name_ ret{data_.base.bytes + 46};
			if (src)
				for (size_t    i = 0; i < 32; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		float focal_length() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 78, 4))); }
		
		void focal_length(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 78); }
		
		float sensor_size_h() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 82, 4))); }
		
		void sensor_size_h(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 82); }
		
		float sensor_size_v() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 86, 4))); }
		
		void sensor_size_v(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 86); }
		
		int8_t lens_id() const { return static_cast< int8_t >((data_.base.bytes)[90] ); }
		
		void lens_id(int8_t src) const { (data_.base.bytes)[90] = (uint8_t) (src); }
		
		struct flags_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum CAMERA_CAP_FLAGS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		flags_ flags() const {
			if (data_.base.field_bit != 730 && !set_field(&data_, 730, -1)) return {0, 0};
			flags_ ret{true, static_cast< enum CAMERA_CAP_FLAGS > ( CAMERA_CAP_FLAGS_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void flags(enum CAMERA_CAP_FLAGS src) const {
			
			if (data_.base.field_bit != 730) set_field(&data_, 730, 0);
			
			set_bits(CAMERA_CAP_FLAGS_into(src), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct cam_definition_uri_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		cam_definition_uri_ cam_definition_uri() const {
			if (data_.base.field_bit != 731 && !set_field(&data_, 731, -1)) return {0, 0, 0};
			
			cam_definition_uri_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			cam_definition_uri_ cam_definition_uri(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 731) set_field(&data_, 731, len);
				const cam_definition_uri_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		cam_definition_uri_ cam_definition_uri(const char src[], size_t len) const {
			len                         = 255 < len ? 255 : len;
			if (data_.base.field_bit != 731) set_field(&data_, 731, len);
			const cam_definition_uri_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t           i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void vendor_name( const struct com::company::demo::CAMERA_INFORMATION :: vendor_name_  & src  ) const {}
	void model_name( const struct com::company::demo::CAMERA_INFORMATION :: model_name_  & src  ) const {}
	void firmware_version( int32_t src  ) {}
	void focal_length( float src  ) {}
	void sensor_size_h( float src  ) {}
	void sensor_size_v( float src  ) {}
	void resolution_h( int16_t src  ) {}
	void resolution_v( int16_t src  ) {}
	void lens_id( int8_t src  ) {}
	void flags( enum com::company::demo:: CAMERA_CAP_FLAGS src  ) {}
	void cam_definition_version( int16_t src  ) {}
	void cam_definition_uri( const struct com::company::demo::CAMERA_INFORMATION :: cam_definition_uri_::CASE::EXISTS  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	std container of int8  vendor_name(  ) {}
	std container of int8  model_name(  ) {}
	int32_t firmware_version(  ) {}
	int32_t firmware_version(  ) {}
	float focal_length(  ) {}
	float focal_length(  ) {}
	float sensor_size_h(  ) {}
	float sensor_size_h(  ) {}
	float sensor_size_v(  ) {}
	float sensor_size_v(  ) {}
	int16_t resolution_h(  ) {}
	int16_t resolution_h(  ) {}
	int16_t resolution_v(  ) {}
	int16_t resolution_v(  ) {}
	int8_t lens_id(  ) {}
	int8_t lens_id(  ) {}
	enum com::company::demo:: CAMERA_CAP_FLAGS flags(  ) {}
	bool flags_exists(){}
	int16_t cam_definition_version(  ) {}
	int16_t cam_definition_version(  ) {}
	std container of chars  cam_definition_uri(  ) {}
	bool cam_definition_uri_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GPS_STATUS {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		GPS_STATUS(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const GPS_STATUS &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 101) == 0);
		}
		
		int8_t satellites_visible() const { return static_cast< int8_t >((&data_)[0] ); }
		
		
		struct satellite_prn_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, satellite_prn_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, satellite_prn_> end() const { return {*this, 20}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			static constexpr size_t len = 20;
			
		};
		
		struct satellite_prn_ satellite_prn() const {
			struct satellite_prn_ ret{&data_ + 1};
			return ret;
		}
		
		struct satellite_used_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, satellite_used_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, satellite_used_> end() const { return {*this, 20}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			static constexpr size_t len = 20;
			
		};
		
		struct satellite_used_ satellite_used() const {
			struct satellite_used_ ret{&data_ + 21};
			return ret;
		}
		
		struct satellite_elevation_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, satellite_elevation_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, satellite_elevation_> end() const { return {*this, 20}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			static constexpr size_t len = 20;
			
		};
		
		struct satellite_elevation_ satellite_elevation() const {
			struct satellite_elevation_ ret{&data_ + 41};
			return ret;
		}
		
		struct satellite_azimuth_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, satellite_azimuth_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, satellite_azimuth_> end() const { return {*this, 20}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			static constexpr size_t len = 20;
			
		};
		
		struct satellite_azimuth_ satellite_azimuth() const {
			struct satellite_azimuth_ ret{&data_ + 61};
			return ret;
		}
		
		struct satellite_snr_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, satellite_snr_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, satellite_snr_> end() const { return {*this, 20}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			static constexpr size_t len = 20;
			
		};
		
		struct satellite_snr_ satellite_snr() const {
			struct satellite_snr_ ret{&data_ + 81};
			return ret;
		}
		
		
		/*
struct <DST> {
	void satellites_visible( int8_t src  ) {}
	void satellite_prn( const struct com::company::demo::GPS_STATUS :: satellite_prn_  & src  ) const {}
	void satellite_used( const struct com::company::demo::GPS_STATUS :: satellite_used_  & src  ) const {}
	void satellite_elevation( const struct com::company::demo::GPS_STATUS :: satellite_elevation_  & src  ) const {}
	void satellite_azimuth( const struct com::company::demo::GPS_STATUS :: satellite_azimuth_  & src  ) const {}
	void satellite_snr( const struct com::company::demo::GPS_STATUS :: satellite_snr_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct DEVICE_OP_WRITE_REPLY {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		DEVICE_OP_WRITE_REPLY(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const DEVICE_OP_WRITE_REPLY &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 5) == 0);
		}
		
		int32_t request_id() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void request_id(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int8_t result() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void result(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void request_id( int32_t src  ) {}
	void result( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t request_id(  ) {}
	int32_t request_id(  ) {}
	int8_t result(  ) {}
	int8_t result(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct PARAM_SET {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const PARAM_SET &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		float param_value() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 2, 4))); }
		
		
		struct param_id_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		param_id_ param_id() const {
			if (data_.base.field_bit != 50 && !set_field(&data_, 50, -1)) return {0, 0, 0};
			
			param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		
		struct param_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_PARAM_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		param_type_ param_type() const {
			if (data_.base.field_bit != 51 && !set_field(&data_, 51, -1)) return {0, 0};
			param_type_ ret{true, static_cast< enum MAV_PARAM_TYPE > (    static_cast< enum MAV_PARAM_TYPE >( 1 + get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void param_id( const struct com::company::demo::PARAM_SET :: param_id_::CASE::EXISTS  & src  ) const {}
	void param_value( float src  ) {}
	void param_type( enum com::company::demo:: MAV_PARAM_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct TERRAIN_DATA {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		TERRAIN_DATA(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const TERRAIN_DATA &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 43) == 0);
		}
		
		int16_t grid_spacing() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void grid_spacing(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 2, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 2); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(&data_, 6, 4))); }
		
		void lon(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 6); }
		
		int8_t gridbit() const { return static_cast< int8_t >((&data_)[10] ); }
		
		void gridbit(int8_t src) const { (&data_)[10] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int16_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int16_t, daTa_> end() const { return {*this, 16}; }
			
			int16_t get(size_t index) const { return (static_cast< int16_t > (get_bytes(bytes, index * 2, 2))); }
			
			
			void set(int16_t src, size_t index) const {
				
				set_bytes((uint16_t) (src), 2, bytes, index * 2);
			}
			
			static constexpr size_t len = 16;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 11};
			return ret;
		}
		
		template<typename int16_src_container>
			daTa_ daTa(const int16_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 11};
				for (size_t  i     = 0; i < 16; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int16_t *const src) const { return daTa(static_cast<int16_t const *>( src)); }
		
		daTa_ daTa(int16_t const *const src) const {
			struct daTa_    ret{&data_ + 11};
			if (src)
				for (size_t i = 0; i < 16; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void grid_spacing( int16_t src  ) {}
	void gridbit( int8_t src  ) {}
	void daTa( const struct com::company::demo::TERRAIN_DATA :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lon(  ) {}
	int32_t lon(  ) {}
	int16_t grid_spacing(  ) {}
	int16_t grid_spacing(  ) {}
	int8_t gridbit(  ) {}
	int8_t gridbit(  ) {}
	std container of int16  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GIMBAL_CONTROL {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		GIMBAL_CONTROL(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const GIMBAL_CONTROL &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 14) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		float demanded_rate_x() const { return (intBitsToFloat(get_bytes(&data_, 2, 4))); }
		
		void demanded_rate_x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 2); }
		
		float demanded_rate_y() const { return (intBitsToFloat(get_bytes(&data_, 6, 4))); }
		
		void demanded_rate_y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 6); }
		
		float demanded_rate_z() const { return (intBitsToFloat(get_bytes(&data_, 10, 4))); }
		
		void demanded_rate_z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 10); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void demanded_rate_x( float src  ) {}
	void demanded_rate_y( float src  ) {}
	void demanded_rate_z( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	float demanded_rate_x(  ) {}
	float demanded_rate_x(  ) {}
	float demanded_rate_y(  ) {}
	float demanded_rate_y(  ) {}
	float demanded_rate_z(  ) {}
	float demanded_rate_z(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct RC_CHANNELS_OVERRIDE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RC_CHANNELS_OVERRIDE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RC_CHANNELS_OVERRIDE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 18) == 0);
		}
		
		int16_t chan1_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		int16_t chan2_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		int16_t chan3_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		int16_t chan4_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 6, 2))); }
		
		int16_t chan5_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 8, 2))); }
		
		int16_t chan6_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		int16_t chan7_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		int16_t chan8_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 14, 2))); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[16] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[17] ); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void chan1_raw( int16_t src  ) {}
	void chan2_raw( int16_t src  ) {}
	void chan3_raw( int16_t src  ) {}
	void chan4_raw( int16_t src  ) {}
	void chan5_raw( int16_t src  ) {}
	void chan6_raw( int16_t src  ) {}
	void chan7_raw( int16_t src  ) {}
	void chan8_raw( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct SCALED_IMU {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SCALED_IMU(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SCALED_IMU &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 22) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		int16_t xacc() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		int16_t yacc() const { return (static_cast< int16_t > (get_bytes(&data_, 6, 2))); }
		
		int16_t zacc() const { return (static_cast< int16_t > (get_bytes(&data_, 8, 2))); }
		
		int16_t xgyro() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		int16_t ygyro() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		int16_t zgyro() const { return (static_cast< int16_t > (get_bytes(&data_, 14, 2))); }
		
		int16_t xmag() const { return (static_cast< int16_t > (get_bytes(&data_, 16, 2))); }
		
		int16_t ymag() const { return (static_cast< int16_t > (get_bytes(&data_, 18, 2))); }
		
		int16_t zmag() const { return (static_cast< int16_t > (get_bytes(&data_, 20, 2))); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void xacc( int16_t src  ) {}
	void yacc( int16_t src  ) {}
	void zacc( int16_t src  ) {}
	void xgyro( int16_t src  ) {}
	void ygyro( int16_t src  ) {}
	void zgyro( int16_t src  ) {}
	void xmag( int16_t src  ) {}
	void ymag( int16_t src  ) {}
	void zmag( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct VIDEO_STREAM_INFORMATION {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const VIDEO_STREAM_INFORMATION &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t resolution_h() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void resolution_h(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t resolution_v() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void resolution_v(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		int16_t rotation() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		void rotation(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 4); }
		
		int32_t bitrate() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 6, 4))); }
		
		void bitrate(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 6); }
		
		int8_t camera_id() const { return static_cast< int8_t >((data_.base.bytes)[10] ); }
		
		void camera_id(int8_t src) const { (data_.base.bytes)[10] = (uint8_t) (src); }
		
		int8_t status() const { return static_cast< int8_t >((data_.base.bytes)[11] ); }
		
		void status(int8_t src) const { (data_.base.bytes)[11] = (uint8_t) (src); }
		
		float framerate() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		void framerate(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 12); }
		
		struct uri_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		uri_ uri() const {
			if (data_.base.field_bit != 130 && !set_field(&data_, 130, -1)) return {0, 0, 0};
			
			uri_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			uri_ uri(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 130) set_field(&data_, 130, len);
				const uri_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		uri_ uri(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 130) set_field(&data_, 130, len);
			const uri_      ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void camera_id( int8_t src  ) {}
	void status( int8_t src  ) {}
	void framerate( float src  ) {}
	void resolution_h( int16_t src  ) {}
	void resolution_v( int16_t src  ) {}
	void bitrate( int32_t src  ) {}
	void rotation( int16_t src  ) {}
	void uri( const struct com::company::demo::VIDEO_STREAM_INFORMATION :: uri_::CASE::EXISTS  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t camera_id(  ) {}
	int8_t camera_id(  ) {}
	int8_t status(  ) {}
	int8_t status(  ) {}
	float framerate(  ) {}
	float framerate(  ) {}
	int16_t resolution_h(  ) {}
	int16_t resolution_h(  ) {}
	int16_t resolution_v(  ) {}
	int16_t resolution_v(  ) {}
	int32_t bitrate(  ) {}
	int32_t bitrate(  ) {}
	int16_t rotation(  ) {}
	int16_t rotation(  ) {}
	std container of chars  uri(  ) {}
	bool uri_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct AHRS {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		AHRS(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const AHRS &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 28) == 0);
		}
		
		float omegaIx() const { return (intBitsToFloat(get_bytes(&data_, 0, 4))); }
		
		void omegaIx(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 0); }
		
		float omegaIy() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void omegaIy(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float omegaIz() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void omegaIz(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float accel_weight() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void accel_weight(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		float renorm_val() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		void renorm_val(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 16); }
		
		float error_rp() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		void error_rp(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 20); }
		
		float error_yaw() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void error_yaw(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		
		/*
struct <DST> {
	void omegaIx( float src  ) {}
	void omegaIy( float src  ) {}
	void omegaIz( float src  ) {}
	void accel_weight( float src  ) {}
	void renorm_val( float src  ) {}
	void error_rp( float src  ) {}
	void error_yaw( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	float omegaIx(  ) {}
	float omegaIx(  ) {}
	float omegaIy(  ) {}
	float omegaIy(  ) {}
	float omegaIz(  ) {}
	float omegaIz(  ) {}
	float accel_weight(  ) {}
	float accel_weight(  ) {}
	float renorm_val(  ) {}
	float renorm_val(  ) {}
	float error_rp(  ) {}
	float error_rp(  ) {}
	float error_yaw(  ) {}
	float error_yaw(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct DEBUG {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		DEBUG(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const DEBUG &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 9) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int8_t ind() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void ind(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		float value() const { return (intBitsToFloat(get_bytes(&data_, 5, 4))); }
		
		void value(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 5); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void ind( int8_t src  ) {}
	void value( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	int8_t ind(  ) {}
	int8_t ind(  ) {}
	float value(  ) {}
	float value(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct CAMERA_IMAGE_CAPTURED {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const CAMERA_IMAGE_CAPTURED &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 0); }
		
		int64_t time_utc() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 4, 8))); }
		
		void time_utc(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 4); }
		
		int8_t camera_id() const { return static_cast< int8_t >((data_.base.bytes)[12] ); }
		
		void camera_id(int8_t src) const { (data_.base.bytes)[12] = (uint8_t) (src); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 13, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 13); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 17, 4))); }
		
		void lon(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 17); }
		
		int32_t alt() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 21, 4))); }
		
		void alt(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 21); }
		
		int32_t relative_alt() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 25, 4))); }
		
		void relative_alt(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 25); }
		
		struct q_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, q_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, q_> end() const { return {*this, 4}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 4;
			
		};
		
		struct q_ q() const {
			struct q_ ret{data_.base.bytes + 29};
			return ret;
		}
		
		template<typename float_src_container>
			q_ q(const float_src_container &src) const {
				auto        first = src.begin();
				struct q_   ret{data_.base.bytes + 29};
				for (size_t i     = 0; i < 4; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		q_ q(float *const src) const { return q(static_cast<float const *>( src)); }
		
		q_ q(float const *const src) const {
			struct q_       ret{data_.base.bytes + 29};
			if (src)
				for (size_t i = 0; i < 4; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		int32_t image_index() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 45, 4))); }
		
		void image_index(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 45); }
		
		int8_t capture_result() const { return static_cast< int8_t >((data_.base.bytes)[49] ); }
		
		void capture_result(int8_t src) const { (data_.base.bytes)[49] = (uint8_t) (src); }
		
		struct file_url_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		file_url_ file_url() const {
			if (data_.base.field_bit != 402 && !set_field(&data_, 402, -1)) return {0, 0, 0};
			
			file_url_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			file_url_ file_url(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 402) set_field(&data_, 402, len);
				const file_url_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		file_url_ file_url(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 402) set_field(&data_, 402, len);
			const file_url_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void time_utc( int64_t src  ) {}
	void camera_id( int8_t src  ) {}
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void alt( int32_t src  ) {}
	void relative_alt( int32_t src  ) {}
	void q( const struct com::company::demo::CAMERA_IMAGE_CAPTURED :: q_  & src  ) const {}
	void image_index( int32_t src  ) {}
	void capture_result( int8_t src  ) {}
	void file_url( const struct com::company::demo::CAMERA_IMAGE_CAPTURED :: file_url_::CASE::EXISTS  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	int64_t time_utc(  ) {}
	int64_t time_utc(  ) {}
	int8_t camera_id(  ) {}
	int8_t camera_id(  ) {}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lon(  ) {}
	int32_t lon(  ) {}
	int32_t alt(  ) {}
	int32_t alt(  ) {}
	int32_t relative_alt(  ) {}
	int32_t relative_alt(  ) {}
	std container of flo  q(  ) {}
	int32_t image_index(  ) {}
	int32_t image_index(  ) {}
	int8_t capture_result(  ) {}
	int8_t capture_result(  ) {}
	std container of chars  file_url(  ) {}
	bool file_url_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LOG_ENTRY {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LOG_ENTRY(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LOG_ENTRY &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 14) == 0);
		}
		
		int16_t id() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void id(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t num_logs() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void num_logs(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int16_t last_log_num() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		void last_log_num(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 4); }
		
		int32_t time_utc() const { return (static_cast< int32_t > (get_bytes(&data_, 6, 4))); }
		
		void time_utc(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 6); }
		
		int32_t size() const { return (static_cast< int32_t > (get_bytes(&data_, 10, 4))); }
		
		void size(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 10); }
		
		
		/*
struct <DST> {
	void id( int16_t src  ) {}
	void num_logs( int16_t src  ) {}
	void last_log_num( int16_t src  ) {}
	void time_utc( int32_t src  ) {}
	void size( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t id(  ) {}
	int16_t id(  ) {}
	int16_t num_logs(  ) {}
	int16_t num_logs(  ) {}
	int16_t last_log_num(  ) {}
	int16_t last_log_num(  ) {}
	int32_t time_utc(  ) {}
	int32_t time_utc(  ) {}
	int32_t size(  ) {}
	int32_t size(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct ACTUATOR_CONTROL_TARGET {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		ACTUATOR_CONTROL_TARGET(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const ACTUATOR_CONTROL_TARGET &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 41) == 0);
		}
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		int8_t group_mlx() const { return static_cast< int8_t >((&data_)[8] ); }
		
		void group_mlx(int8_t src) const { (&data_)[8] = (uint8_t) (src); }
		
		struct controls_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, controls_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, controls_> end() const { return {*this, 8}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 8;
			
		};
		
		struct controls_ controls() const {
			struct controls_ ret{&data_ + 9};
			return ret;
		}
		
		template<typename float_src_container>
			controls_ controls(const float_src_container &src) const {
				auto             first = src.begin();
				struct controls_ ret{&data_ + 9};
				for (size_t      i     = 0; i < 8; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		controls_ controls(float *const src) const { return controls(static_cast<float const *>( src)); }
		
		controls_ controls(float const *const src) const {
			struct controls_ ret{&data_ + 9};
			if (src)
				for (size_t  i = 0; i < 8; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void group_mlx( int8_t src  ) {}
	void controls( const struct com::company::demo::ACTUATOR_CONTROL_TARGET :: controls_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int8_t group_mlx(  ) {}
	int8_t group_mlx(  ) {}
	std container of flo  controls(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct HIGH_LATENCY {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const HIGH_LATENCY &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t heading() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void heading(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t wp_distance() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void wp_distance(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		int32_t custom_mode() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 4, 4))); }
		
		void custom_mode(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 4); }
		
		int16_t roll() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 8, 2))); }
		
		void roll(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 8); }
		
		int16_t pitch() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 10, 2))); }
		
		void pitch(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 10); }
		
		int8_t throttle() const { return static_cast< int8_t >((data_.base.bytes)[12] ); }
		
		void throttle(int8_t src) const { (data_.base.bytes)[12] = (uint8_t) (src); }
		
		int16_t heading_sp() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 13, 2))); }
		
		void heading_sp(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 13); }
		
		int32_t latitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 15, 4))); }
		
		void latitude(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 15); }
		
		int32_t longitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 19, 4))); }
		
		void longitude(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 19); }
		
		int16_t altitude_amsl() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 23, 2))); }
		
		void altitude_amsl(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 23); }
		
		int16_t altitude_sp() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 25, 2))); }
		
		void altitude_sp(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 25); }
		
		int8_t airspeed() const { return static_cast< int8_t >((data_.base.bytes)[27] ); }
		
		void airspeed(int8_t src) const { (data_.base.bytes)[27] = (uint8_t) (src); }
		
		int8_t airspeed_sp() const { return static_cast< int8_t >((data_.base.bytes)[28] ); }
		
		void airspeed_sp(int8_t src) const { (data_.base.bytes)[28] = (uint8_t) (src); }
		
		int8_t groundspeed() const { return static_cast< int8_t >((data_.base.bytes)[29] ); }
		
		void groundspeed(int8_t src) const { (data_.base.bytes)[29] = (uint8_t) (src); }
		
		int8_t climb_rate() const { return static_cast< int8_t >((data_.base.bytes)[30] ); }
		
		void climb_rate(int8_t src) const { (data_.base.bytes)[30] = (uint8_t) (src); }
		
		int8_t gps_nsat() const { return static_cast< int8_t >((data_.base.bytes)[31] ); }
		
		void gps_nsat(int8_t src) const { (data_.base.bytes)[31] = (uint8_t) (src); }
		
		int8_t battery_remaining() const { return static_cast< int8_t >((data_.base.bytes)[32] ); }
		
		void battery_remaining(int8_t src) const { (data_.base.bytes)[32] = (uint8_t) (src); }
		
		int8_t temperature() const { return static_cast< int8_t >((data_.base.bytes)[33] ); }
		
		void temperature(int8_t src) const { (data_.base.bytes)[33] = (uint8_t) (src); }
		
		int8_t temperature_air() const { return static_cast< int8_t >((data_.base.bytes)[34] ); }
		
		void temperature_air(int8_t src) const { (data_.base.bytes)[34] = (uint8_t) (src); }
		
		int8_t failsafe() const { return static_cast< int8_t >((data_.base.bytes)[35] ); }
		
		void failsafe(int8_t src) const { (data_.base.bytes)[35] = (uint8_t) (src); }
		
		int8_t wp_num() const { return static_cast< int8_t >((data_.base.bytes)[36] ); }
		
		void wp_num(int8_t src) const { (data_.base.bytes)[36] = (uint8_t) (src); }
		
		struct base_mode_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MODE_FLAG value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		base_mode_ base_mode() const {
			if (data_.base.field_bit != 298 && !set_field(&data_, 298, -1)) return {0, 0};
			base_mode_ ret{true, static_cast< enum MAV_MODE_FLAG > ( MAV_MODE_FLAG_from(get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void base_mode(enum MAV_MODE_FLAG src) const {
			
			if (data_.base.field_bit != 298) set_field(&data_, 298, 0);
			
			set_bits(MAV_MODE_FLAG_into(src), 4, data_.base.bytes, data_.BIT);
		}
		
		
		struct landed_state_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_LANDED_STATE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		landed_state_ landed_state() const {
			if (data_.base.field_bit != 299 && !set_field(&data_, 299, -1)) return {0, 0};
			landed_state_ ret{true, static_cast< enum MAV_LANDED_STATE > (    static_cast< enum MAV_LANDED_STATE >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void landed_state(enum MAV_LANDED_STATE src) const {
			
			if (data_.base.field_bit != 299) set_field(&data_, 299, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct gps_fix_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GPS_FIX_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		gps_fix_type_ gps_fix_type() const {
			if (data_.base.field_bit != 300 && !set_field(&data_, 300, -1)) return {0, 0};
			gps_fix_type_ ret{true, static_cast< enum GPS_FIX_TYPE > (    static_cast< enum GPS_FIX_TYPE >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void gps_fix_type(enum GPS_FIX_TYPE src) const {
			
			if (data_.base.field_bit != 300) set_field(&data_, 300, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 4, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void base_mode( enum com::company::demo:: MAV_MODE_FLAG src  ) {}
	void custom_mode( int32_t src  ) {}
	void landed_state( enum com::company::demo:: MAV_LANDED_STATE src  ) {}
	void roll( int16_t src  ) {}
	void pitch( int16_t src  ) {}
	void heading( int16_t src  ) {}
	void throttle( int8_t src  ) {}
	void heading_sp( int16_t src  ) {}
	void latitude( int32_t src  ) {}
	void longitude( int32_t src  ) {}
	void altitude_amsl( int16_t src  ) {}
	void altitude_sp( int16_t src  ) {}
	void airspeed( int8_t src  ) {}
	void airspeed_sp( int8_t src  ) {}
	void groundspeed( int8_t src  ) {}
	void climb_rate( int8_t src  ) {}
	void gps_nsat( int8_t src  ) {}
	void gps_fix_type( enum com::company::demo:: GPS_FIX_TYPE src  ) {}
	void battery_remaining( int8_t src  ) {}
	void temperature( int8_t src  ) {}
	void temperature_air( int8_t src  ) {}
	void failsafe( int8_t src  ) {}
	void wp_num( int8_t src  ) {}
	void wp_distance( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: MAV_MODE_FLAG base_mode(  ) {}
	bool base_mode_exists(){}
	int32_t custom_mode(  ) {}
	int32_t custom_mode(  ) {}
	enum com::company::demo:: MAV_LANDED_STATE landed_state(  ) {}
	bool landed_state_exists(){}
	int16_t roll(  ) {}
	int16_t roll(  ) {}
	int16_t pitch(  ) {}
	int16_t pitch(  ) {}
	int16_t heading(  ) {}
	int16_t heading(  ) {}
	int8_t throttle(  ) {}
	int8_t throttle(  ) {}
	int16_t heading_sp(  ) {}
	int16_t heading_sp(  ) {}
	int32_t latitude(  ) {}
	int32_t latitude(  ) {}
	int32_t longitude(  ) {}
	int32_t longitude(  ) {}
	int16_t altitude_amsl(  ) {}
	int16_t altitude_amsl(  ) {}
	int16_t altitude_sp(  ) {}
	int16_t altitude_sp(  ) {}
	int8_t airspeed(  ) {}
	int8_t airspeed(  ) {}
	int8_t airspeed_sp(  ) {}
	int8_t airspeed_sp(  ) {}
	int8_t groundspeed(  ) {}
	int8_t groundspeed(  ) {}
	int8_t climb_rate(  ) {}
	int8_t climb_rate(  ) {}
	int8_t gps_nsat(  ) {}
	int8_t gps_nsat(  ) {}
	enum com::company::demo:: GPS_FIX_TYPE gps_fix_type(  ) {}
	bool gps_fix_type_exists(){}
	int8_t battery_remaining(  ) {}
	int8_t battery_remaining(  ) {}
	int8_t temperature(  ) {}
	int8_t temperature(  ) {}
	int8_t temperature_air(  ) {}
	int8_t temperature_air(  ) {}
	int8_t failsafe(  ) {}
	int8_t failsafe(  ) {}
	int8_t wp_num(  ) {}
	int8_t wp_num(  ) {}
	int16_t wp_distance(  ) {}
	int16_t wp_distance(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct PARAM_REQUEST_READ {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const PARAM_REQUEST_READ &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		int16_t param_index() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		
		struct param_id_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		param_id_ param_id() const {
			if (data_.base.field_bit != 34 && !set_field(&data_, 34, -1)) return {0, 0, 0};
			
			param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void param_id( const struct com::company::demo::PARAM_REQUEST_READ :: param_id_::CASE::EXISTS  & src  ) const {}
	void param_index( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct SET_ATTITUDE_TARGET {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SET_ATTITUDE_TARGET(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SET_ATTITUDE_TARGET &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 39) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[4] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[5] ); }
		
		int8_t type_mask() const { return static_cast< int8_t >((&data_)[6] ); }
		
		
		struct q_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, q_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, q_> end() const { return {*this, 4}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			static constexpr size_t len = 4;
			
		};
		
		struct q_ q() const {
			struct q_ ret{&data_ + 7};
			return ret;
		}
		
		float body_roll_rate() const { return (intBitsToFloat(get_bytes(&data_, 23, 4))); }
		
		float body_pitch_rate() const { return (intBitsToFloat(get_bytes(&data_, 27, 4))); }
		
		float body_yaw_rate() const { return (intBitsToFloat(get_bytes(&data_, 31, 4))); }
		
		float thrust() const { return (intBitsToFloat(get_bytes(&data_, 35, 4))); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void type_mask( int8_t src  ) {}
	void q( const struct com::company::demo::SET_ATTITUDE_TARGET :: q_  & src  ) const {}
	void body_roll_rate( float src  ) {}
	void body_pitch_rate( float src  ) {}
	void body_yaw_rate( float src  ) {}
	void thrust( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct FOLLOW_TARGET {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		FOLLOW_TARGET(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const FOLLOW_TARGET &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 93) == 0);
		}
		
		int64_t timestamp() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void timestamp(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		int64_t custom_state() const { return (static_cast< int64_t > (get_bytes(&data_, 8, 8))); }
		
		void custom_state(int64_t src) const { set_bytes((src), 8, &data_, 8); }
		
		int8_t est_capabilities() const { return static_cast< int8_t >((&data_)[16] ); }
		
		void est_capabilities(int8_t src) const { (&data_)[16] = (uint8_t) (src); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 17, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 17); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(&data_, 21, 4))); }
		
		void lon(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 21); }
		
		float alt() const { return (intBitsToFloat(get_bytes(&data_, 25, 4))); }
		
		void alt(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 25); }
		
		struct vel_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, vel_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, vel_> end() const { return {*this, 3}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 3;
			
		};
		
		struct vel_ vel() const {
			struct vel_ ret{&data_ + 29};
			return ret;
		}
		
		template<typename float_src_container>
			vel_ vel(const float_src_container &src) const {
				auto        first = src.begin();
				struct vel_ ret{&data_ + 29};
				for (size_t i     = 0; i < 3; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		vel_ vel(float *const src) const { return vel(static_cast<float const *>( src)); }
		
		vel_ vel(float const *const src) const {
			struct vel_     ret{&data_ + 29};
			if (src)
				for (size_t i = 0; i < 3; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct acc_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, acc_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, acc_> end() const { return {*this, 3}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 3;
			
		};
		
		struct acc_ acc() const {
			struct acc_ ret{&data_ + 41};
			return ret;
		}
		
		template<typename float_src_container>
			acc_ acc(const float_src_container &src) const {
				auto        first = src.begin();
				struct acc_ ret{&data_ + 41};
				for (size_t i     = 0; i < 3; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		acc_ acc(float *const src) const { return acc(static_cast<float const *>( src)); }
		
		acc_ acc(float const *const src) const {
			struct acc_     ret{&data_ + 41};
			if (src)
				for (size_t i = 0; i < 3; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct attitude_q_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, attitude_q_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, attitude_q_> end() const { return {*this, 4}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 4;
			
		};
		
		struct attitude_q_ attitude_q() const {
			struct attitude_q_ ret{&data_ + 53};
			return ret;
		}
		
		template<typename float_src_container>
			attitude_q_ attitude_q(const float_src_container &src) const {
				auto               first = src.begin();
				struct attitude_q_ ret{&data_ + 53};
				for (size_t        i     = 0; i < 4; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		attitude_q_ attitude_q(float *const src) const { return attitude_q(static_cast<float const *>( src)); }
		
		attitude_q_ attitude_q(float const *const src) const {
			struct attitude_q_ ret{&data_ + 53};
			if (src)
				for (size_t    i = 0; i < 4; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct rates_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, rates_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, rates_> end() const { return {*this, 3}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 3;
			
		};
		
		struct rates_ rates() const {
			struct rates_ ret{&data_ + 69};
			return ret;
		}
		
		template<typename float_src_container>
			rates_ rates(const float_src_container &src) const {
				auto          first = src.begin();
				struct rates_ ret{&data_ + 69};
				for (size_t   i     = 0; i < 3; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		rates_ rates(float *const src) const { return rates(static_cast<float const *>( src)); }
		
		rates_ rates(float const *const src) const {
			struct rates_   ret{&data_ + 69};
			if (src)
				for (size_t i = 0; i < 3; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct position_cov_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, position_cov_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, position_cov_> end() const { return {*this, 3}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 3;
			
		};
		
		struct position_cov_ position_cov() const {
			struct position_cov_ ret{&data_ + 81};
			return ret;
		}
		
		template<typename float_src_container>
			position_cov_ position_cov(const float_src_container &src) const {
				auto                 first = src.begin();
				struct position_cov_ ret{&data_ + 81};
				for (size_t          i     = 0; i < 3; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		position_cov_ position_cov(float *const src) const { return position_cov(static_cast<float const *>( src)); }
		
		position_cov_ position_cov(float const *const src) const {
			struct position_cov_ ret{&data_ + 81};
			if (src)
				for (size_t      i = 0; i < 3; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void timestamp( int64_t src  ) {}
	void est_capabilities( int8_t src  ) {}
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void alt( float src  ) {}
	void vel( const struct com::company::demo::FOLLOW_TARGET :: vel_  & src  ) const {}
	void acc( const struct com::company::demo::FOLLOW_TARGET :: acc_  & src  ) const {}
	void attitude_q( const struct com::company::demo::FOLLOW_TARGET :: attitude_q_  & src  ) const {}
	void rates( const struct com::company::demo::FOLLOW_TARGET :: rates_  & src  ) const {}
	void position_cov( const struct com::company::demo::FOLLOW_TARGET :: position_cov_  & src  ) const {}
	void custom_state( int64_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t timestamp(  ) {}
	int64_t timestamp(  ) {}
	int8_t est_capabilities(  ) {}
	int8_t est_capabilities(  ) {}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lon(  ) {}
	int32_t lon(  ) {}
	float alt(  ) {}
	float alt(  ) {}
	std container of flo  vel(  ) {}
	std container of flo  acc(  ) {}
	std container of flo  attitude_q(  ) {}
	std container of flo  rates(  ) {}
	std container of flo  position_cov(  ) {}
	int64_t custom_state(  ) {}
	int64_t custom_state(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct HIL_STATE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		HIL_STATE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const HIL_STATE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 56) == 0);
		}
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		float rollspeed() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		float pitchspeed() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		float yawspeed() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 32, 4))); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(&data_, 36, 4))); }
		
		int32_t alt() const { return (static_cast< int32_t > (get_bytes(&data_, 40, 4))); }
		
		int16_t vx() const { return (static_cast< int16_t > (get_bytes(&data_, 44, 2))); }
		
		int16_t vy() const { return (static_cast< int16_t > (get_bytes(&data_, 46, 2))); }
		
		int16_t vz() const { return (static_cast< int16_t > (get_bytes(&data_, 48, 2))); }
		
		int16_t xacc() const { return (static_cast< int16_t > (get_bytes(&data_, 50, 2))); }
		
		int16_t yacc() const { return (static_cast< int16_t > (get_bytes(&data_, 52, 2))); }
		
		int16_t zacc() const { return (static_cast< int16_t > (get_bytes(&data_, 54, 2))); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
	void rollspeed( float src  ) {}
	void pitchspeed( float src  ) {}
	void yawspeed( float src  ) {}
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void alt( int32_t src  ) {}
	void vx( int16_t src  ) {}
	void vy( int16_t src  ) {}
	void vz( int16_t src  ) {}
	void xacc( int16_t src  ) {}
	void yacc( int16_t src  ) {}
	void zacc( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct HOME_POSITION {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const HOME_POSITION &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t latitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		void latitude(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 0); }
		
		int32_t longitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 4, 4))); }
		
		void longitude(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 4); }
		
		int32_t altitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 8, 4))); }
		
		void altitude(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 8); }
		
		float x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		void x(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 12); }
		
		float y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		void y(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 16); }
		
		float z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 20, 4))); }
		
		void z(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 20); }
		
		struct q_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, q_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, q_> end() const { return {*this, 4}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 4;
			
		};
		
		struct q_ q() const {
			struct q_ ret{data_.base.bytes + 24};
			return ret;
		}
		
		template<typename float_src_container>
			q_ q(const float_src_container &src) const {
				auto        first = src.begin();
				struct q_   ret{data_.base.bytes + 24};
				for (size_t i     = 0; i < 4; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		q_ q(float *const src) const { return q(static_cast<float const *>( src)); }
		
		q_ q(float const *const src) const {
			struct q_       ret{data_.base.bytes + 24};
			if (src)
				for (size_t i = 0; i < 4; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		float approach_x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 40, 4))); }
		
		void approach_x(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 40); }
		
		float approach_y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 44, 4))); }
		
		void approach_y(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 44); }
		
		float approach_z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 48, 4))); }
		
		void approach_z(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 48); }
		
		struct time_usec_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int64_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		time_usec_ time_usec() const {
			if (data_.base.field_bit != 416 && !set_field(&data_, 416, -1)) return {0, 0};
			time_usec_ ret{true, static_cast< int64_t > ((static_cast< int64_t > (get_bytes(data_.base.bytes, data_.BYTE, 8))))};
			return ret;
		}
		
		
		void time_usec(int64_t src) const {
			
			if (data_.base.field_bit != 416) set_field(&data_, 416, 0);
			
			set_bytes((src), 8, data_.base.bytes, data_.BYTE);
		}
		
		
		/*
struct <DST> {
	void latitude( int32_t src  ) {}
	void longitude( int32_t src  ) {}
	void altitude( int32_t src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void q( const struct com::company::demo::HOME_POSITION :: q_  & src  ) const {}
	void approach_x( float src  ) {}
	void approach_y( float src  ) {}
	void approach_z( float src  ) {}
	void time_usec( int64_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t latitude(  ) {}
	int32_t latitude(  ) {}
	int32_t longitude(  ) {}
	int32_t longitude(  ) {}
	int32_t altitude(  ) {}
	int32_t altitude(  ) {}
	float x(  ) {}
	float x(  ) {}
	float y(  ) {}
	float y(  ) {}
	float z(  ) {}
	float z(  ) {}
	std container of flo  q(  ) {}
	float approach_x(  ) {}
	float approach_x(  ) {}
	float approach_y(  ) {}
	float approach_y(  ) {}
	float approach_z(  ) {}
	float approach_z(  ) {}
	int64_t time_usec(  ) {}
	bool time_usec_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct FENCE_STATUS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const FENCE_STATUS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t breach_count() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void breach_count(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int32_t breach_time() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 2, 4))); }
		
		void breach_time(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 2); }
		
		int8_t breach_status() const { return static_cast< int8_t >((data_.base.bytes)[6] ); }
		
		void breach_status(int8_t src) const { (data_.base.bytes)[6] = (uint8_t) (src); }
		
		struct breach_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum FENCE_BREACH value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		breach_type_ breach_type() const {
			if (data_.base.field_bit != 56 && !set_field(&data_, 56, -1)) return {0, 0};
			breach_type_ ret{true, static_cast< enum FENCE_BREACH > (    static_cast< enum FENCE_BREACH >(   get_bits(data_.base.bytes, data_.BIT, 2)))};
			return ret;
		}
		
		
		void breach_type(enum FENCE_BREACH src) const {
			
			if (data_.base.field_bit != 56) set_field(&data_, 56, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 2, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void breach_status( int8_t src  ) {}
	void breach_count( int16_t src  ) {}
	void breach_type( enum com::company::demo:: FENCE_BREACH src  ) {}
	void breach_time( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t breach_status(  ) {}
	int8_t breach_status(  ) {}
	int16_t breach_count(  ) {}
	int16_t breach_count(  ) {}
	enum com::company::demo:: FENCE_BREACH breach_type(  ) {}
	bool breach_type_exists(){}
	int32_t breach_time(  ) {}
	int32_t breach_time(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct REMOTE_LOG_BLOCK_STATUS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const REMOTE_LOG_BLOCK_STATUS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t seqno() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		void seqno(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 0); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[4] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[4] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[5] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[5] = (uint8_t) (src); }
		
		struct status_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_REMOTE_LOG_DATA_BLOCK_STATUSES value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		status_ status() const {
			if (data_.base.field_bit != 48 && !set_field(&data_, 48, -1)) return {0, 0};
			status_ ret{true, static_cast< enum MAV_REMOTE_LOG_DATA_BLOCK_STATUSES > (    static_cast< enum MAV_REMOTE_LOG_DATA_BLOCK_STATUSES >(   get_bits(data_.base.bytes, data_.BIT, 1)))};
			return ret;
		}
		
		
		void status(enum MAV_REMOTE_LOG_DATA_BLOCK_STATUSES src) const {
			
			if (data_.base.field_bit != 48) set_field(&data_, 48, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 1, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void seqno( int32_t src  ) {}
	void status( enum com::company::demo:: MAV_REMOTE_LOG_DATA_BLOCK_STATUSES src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int32_t seqno(  ) {}
	int32_t seqno(  ) {}
	enum com::company::demo:: MAV_REMOTE_LOG_DATA_BLOCK_STATUSES status(  ) {}
	bool status_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct OBSTACLE_DISTANCE {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const OBSTACLE_DISTANCE &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct distances_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int16_t, distances_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int16_t, distances_> end() const { return {*this, 72}; }
			
			int16_t get(size_t index) const { return (static_cast< int16_t > (get_bytes(bytes, index * 2, 2))); }
			
			
			void set(int16_t src, size_t index) const {
				
				set_bytes((uint16_t) (src), 2, bytes, index * 2);
			}
			
			static constexpr size_t len = 72;
			
		};
		
		struct distances_ distances() const {
			struct distances_ ret{data_.base.bytes + 0};
			return ret;
		}
		
		template<typename int16_src_container>
			distances_ distances(const int16_src_container &src) const {
				auto              first = src.begin();
				struct distances_ ret{data_.base.bytes + 0};
				for (size_t       i     = 0; i < 72; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		distances_ distances(int16_t *const src) const { return distances(static_cast<int16_t const *>( src)); }
		
		distances_ distances(int16_t const *const src) const {
			struct distances_ ret{data_.base.bytes + 0};
			if (src)
				for (size_t   i = 0; i < 72; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		int16_t min_distance() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 144, 2))); }
		
		void min_distance(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 144); }
		
		int16_t max_distance() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 146, 2))); }
		
		void max_distance(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 146); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 148, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 148); }
		
		int8_t increment() const { return static_cast< int8_t >((data_.base.bytes)[156] ); }
		
		void increment(int8_t src) const { (data_.base.bytes)[156] = (uint8_t) (src); }
		
		struct sensor_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_DISTANCE_SENSOR value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		sensor_type_ sensor_type() const {
			if (data_.base.field_bit != 1256 && !set_field(&data_, 1256, -1)) return {0, 0};
			sensor_type_ ret{true, static_cast< enum MAV_DISTANCE_SENSOR > (    static_cast< enum MAV_DISTANCE_SENSOR >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void sensor_type(enum MAV_DISTANCE_SENSOR src) const {
			
			if (data_.base.field_bit != 1256) set_field(&data_, 1256, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void sensor_type( enum com::company::demo:: MAV_DISTANCE_SENSOR src  ) {}
	void distances( const struct com::company::demo::OBSTACLE_DISTANCE :: distances_  & src  ) const {}
	void increment( int8_t src  ) {}
	void min_distance( int16_t src  ) {}
	void max_distance( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	enum com::company::demo:: MAV_DISTANCE_SENSOR sensor_type(  ) {}
	bool sensor_type_exists(){}
	std container of int16  distances(  ) {}
	int8_t increment(  ) {}
	int8_t increment(  ) {}
	int16_t min_distance(  ) {}
	int16_t min_distance(  ) {}
	int16_t max_distance(  ) {}
	int16_t max_distance(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GPS2_RAW {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const GPS2_RAW &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t eph() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void eph(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t epv() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void epv(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		int16_t vel() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		void vel(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 4); }
		
		int16_t cog() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 6, 2))); }
		
		void cog(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 6); }
		
		int32_t dgps_age() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 8, 4))); }
		
		void dgps_age(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 8); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 12, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 12); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 20, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 20); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 24, 4))); }
		
		void lon(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 24); }
		
		int32_t alt() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 28, 4))); }
		
		void alt(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 28); }
		
		int8_t satellites_visible() const { return static_cast< int8_t >((data_.base.bytes)[32] ); }
		
		void satellites_visible(int8_t src) const { (data_.base.bytes)[32] = (uint8_t) (src); }
		
		int8_t dgps_numch() const { return static_cast< int8_t >((data_.base.bytes)[33] ); }
		
		void dgps_numch(int8_t src) const { (data_.base.bytes)[33] = (uint8_t) (src); }
		
		struct fix_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GPS_FIX_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		fix_type_ fix_type() const {
			if (data_.base.field_bit != 272 && !set_field(&data_, 272, -1)) return {0, 0};
			fix_type_ ret{true, static_cast< enum GPS_FIX_TYPE > (    static_cast< enum GPS_FIX_TYPE >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void fix_type(enum GPS_FIX_TYPE src) const {
			
			if (data_.base.field_bit != 272) set_field(&data_, 272, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 4, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void fix_type( enum com::company::demo:: GPS_FIX_TYPE src  ) {}
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void alt( int32_t src  ) {}
	void eph( int16_t src  ) {}
	void epv( int16_t src  ) {}
	void vel( int16_t src  ) {}
	void cog( int16_t src  ) {}
	void satellites_visible( int8_t src  ) {}
	void dgps_numch( int8_t src  ) {}
	void dgps_age( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	enum com::company::demo:: GPS_FIX_TYPE fix_type(  ) {}
	bool fix_type_exists(){}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lon(  ) {}
	int32_t lon(  ) {}
	int32_t alt(  ) {}
	int32_t alt(  ) {}
	int16_t eph(  ) {}
	int16_t eph(  ) {}
	int16_t epv(  ) {}
	int16_t epv(  ) {}
	int16_t vel(  ) {}
	int16_t vel(  ) {}
	int16_t cog(  ) {}
	int16_t cog(  ) {}
	int8_t satellites_visible(  ) {}
	int8_t satellites_visible(  ) {}
	int8_t dgps_numch(  ) {}
	int8_t dgps_numch(  ) {}
	int32_t dgps_age(  ) {}
	int32_t dgps_age(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct REQUEST_DATA_STREAM {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		REQUEST_DATA_STREAM(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const REQUEST_DATA_STREAM &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 6) == 0);
		}
		
		int16_t req_message_rate() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[2] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[3] ); }
		
		int8_t req_stream_id() const { return static_cast< int8_t >((&data_)[4] ); }
		
		int8_t start_stop() const { return static_cast< int8_t >((&data_)[5] ); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void req_stream_id( int8_t src  ) {}
	void req_message_rate( int16_t src  ) {}
	void start_stop( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct MEMORY_VECT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		MEMORY_VECT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const MEMORY_VECT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 36) == 0);
		}
		
		int16_t address() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void address(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int8_t ver() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void ver(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		int8_t typE() const { return static_cast< int8_t >((&data_)[3] ); }
		
		void typE(int8_t src) const { (&data_)[3] = (uint8_t) (src); }
		
		struct value_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, value_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, value_> end() const { return {*this, 32}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 32;
			
		};
		
		struct value_ value() const {
			struct value_ ret{&data_ + 4};
			return ret;
		}
		
		template<typename int8_src_container>
			value_ value(const int8_src_container &src) const {
				auto          first = src.begin();
				struct value_ ret{&data_ + 4};
				for (size_t   i     = 0; i < 32; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		value_ value(int8_t *const src) const { return value(static_cast<int8_t const *>( src)); }
		
		value_ value(int8_t const *const src) const {
			struct value_   ret{&data_ + 4};
			if (src)
				for (size_t i = 0; i < 32; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void address( int16_t src  ) {}
	void ver( int8_t src  ) {}
	void typE( int8_t src  ) {}
	void value( const struct com::company::demo::MEMORY_VECT :: value_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t address(  ) {}
	int16_t address(  ) {}
	int8_t ver(  ) {}
	int8_t ver(  ) {}
	int8_t typE(  ) {}
	int8_t typE(  ) {}
	std container of int8  value(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct PARAM_EXT_REQUEST_READ {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const PARAM_EXT_REQUEST_READ &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[1] = (uint8_t) (src); }
		
		int16_t param_index() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void param_index(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		struct param_id_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		param_id_ param_id() const {
			if (data_.base.field_bit != 34 && !set_field(&data_, 34, -1)) return {0, 0, 0};
			
			param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			param_id_ param_id(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 34) set_field(&data_, 34, len);
				const param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		param_id_ param_id(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 34) set_field(&data_, 34, len);
			const param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void param_id( const struct com::company::demo::PARAM_EXT_REQUEST_READ :: param_id_::CASE::EXISTS  & src  ) const {}
	void param_index( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	std container of chars  param_id(  ) {}
	bool param_id_exists(){}
	int16_t param_index(  ) {}
	int16_t param_index(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct HIL_CONTROLS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const HIL_CONTROLS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 0, 8))); }
		
		float roll_ailerons() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 8, 4))); }
		
		float pitch_elevator() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		float yaw_rudder() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		float throttle() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 20, 4))); }
		
		float aux1() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 24, 4))); }
		
		float aux2() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 28, 4))); }
		
		float aux3() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 32, 4))); }
		
		float aux4() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 36, 4))); }
		
		int8_t nav_mode() const { return static_cast< int8_t >((data_.base.bytes)[40] ); }
		
		
		struct mode_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MODE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mode_ mode() const {
			if (data_.base.field_bit != 328 && !set_field(&data_, 328, -1)) return {0, 0};
			mode_ ret{true, static_cast< enum MAV_MODE > ( MAV_MODE_from(get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void roll_ailerons( float src  ) {}
	void pitch_elevator( float src  ) {}
	void yaw_rudder( float src  ) {}
	void throttle( float src  ) {}
	void aux1( float src  ) {}
	void aux2( float src  ) {}
	void aux3( float src  ) {}
	void aux4( float src  ) {}
	void mode( enum com::company::demo:: MAV_MODE src  ) {}
	void nav_mode( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct HIL_SENSOR {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		HIL_SENSOR(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const HIL_SENSOR &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 64) == 0);
		}
		
		int32_t fields_updated() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void fields_updated(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 4, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 4); }
		
		float xacc() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void xacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		float yacc() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		void yacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 16); }
		
		float zacc() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		void zacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 20); }
		
		float xgyro() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void xgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		float ygyro() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void ygyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		float zgyro() const { return (intBitsToFloat(get_bytes(&data_, 32, 4))); }
		
		void zgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 32); }
		
		float xmag() const { return (intBitsToFloat(get_bytes(&data_, 36, 4))); }
		
		void xmag(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 36); }
		
		float ymag() const { return (intBitsToFloat(get_bytes(&data_, 40, 4))); }
		
		void ymag(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 40); }
		
		float zmag() const { return (intBitsToFloat(get_bytes(&data_, 44, 4))); }
		
		void zmag(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 44); }
		
		float abs_pressure() const { return (intBitsToFloat(get_bytes(&data_, 48, 4))); }
		
		void abs_pressure(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 48); }
		
		float diff_pressure() const { return (intBitsToFloat(get_bytes(&data_, 52, 4))); }
		
		void diff_pressure(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 52); }
		
		float pressure_alt() const { return (intBitsToFloat(get_bytes(&data_, 56, 4))); }
		
		void pressure_alt(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 56); }
		
		float temperature() const { return (intBitsToFloat(get_bytes(&data_, 60, 4))); }
		
		void temperature(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 60); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void xacc( float src  ) {}
	void yacc( float src  ) {}
	void zacc( float src  ) {}
	void xgyro( float src  ) {}
	void ygyro( float src  ) {}
	void zgyro( float src  ) {}
	void xmag( float src  ) {}
	void ymag( float src  ) {}
	void zmag( float src  ) {}
	void abs_pressure( float src  ) {}
	void diff_pressure( float src  ) {}
	void pressure_alt( float src  ) {}
	void temperature( float src  ) {}
	void fields_updated( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	float xacc(  ) {}
	float xacc(  ) {}
	float yacc(  ) {}
	float yacc(  ) {}
	float zacc(  ) {}
	float zacc(  ) {}
	float xgyro(  ) {}
	float xgyro(  ) {}
	float ygyro(  ) {}
	float ygyro(  ) {}
	float zgyro(  ) {}
	float zgyro(  ) {}
	float xmag(  ) {}
	float xmag(  ) {}
	float ymag(  ) {}
	float ymag(  ) {}
	float zmag(  ) {}
	float zmag(  ) {}
	float abs_pressure(  ) {}
	float abs_pressure(  ) {}
	float diff_pressure(  ) {}
	float diff_pressure(  ) {}
	float pressure_alt(  ) {}
	float pressure_alt(  ) {}
	float temperature(  ) {}
	float temperature(  ) {}
	int32_t fields_updated(  ) {}
	int32_t fields_updated(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SETUP_SIGNING {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SETUP_SIGNING(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SETUP_SIGNING &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 42) == 0);
		}
		
		int64_t initial_timestamp() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void initial_timestamp(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[8] ); }
		
		void target_system(int8_t src) const { (&data_)[8] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[9] ); }
		
		void target_component(int8_t src) const { (&data_)[9] = (uint8_t) (src); }
		
		struct secret_key_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, secret_key_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, secret_key_> end() const { return {*this, 32}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 32;
			
		};
		
		struct secret_key_ secret_key() const {
			struct secret_key_ ret{&data_ + 10};
			return ret;
		}
		
		template<typename int8_src_container>
			secret_key_ secret_key(const int8_src_container &src) const {
				auto               first = src.begin();
				struct secret_key_ ret{&data_ + 10};
				for (size_t        i     = 0; i < 32; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		secret_key_ secret_key(int8_t *const src) const { return secret_key(static_cast<int8_t const *>( src)); }
		
		secret_key_ secret_key(int8_t const *const src) const {
			struct secret_key_ ret{&data_ + 10};
			if (src)
				for (size_t    i = 0; i < 32; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void secret_key( const struct com::company::demo::SETUP_SIGNING :: secret_key_  & src  ) const {}
	void initial_timestamp( int64_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	std container of int8  secret_key(  ) {}
	int64_t initial_timestamp(  ) {}
	int64_t initial_timestamp(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GPS_RTK {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		GPS_RTK(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const GPS_RTK &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 35) == 0);
		}
		
		int16_t wn() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void wn(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int32_t time_last_baseline_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 2, 4))); }
		
		void time_last_baseline_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 2); }
		
		int32_t tow() const { return (static_cast< int32_t > (get_bytes(&data_, 6, 4))); }
		
		void tow(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 6); }
		
		int32_t accuracy() const { return (static_cast< int32_t > (get_bytes(&data_, 10, 4))); }
		
		void accuracy(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 10); }
		
		int8_t rtk_receiver_id() const { return static_cast< int8_t >((&data_)[14] ); }
		
		void rtk_receiver_id(int8_t src) const { (&data_)[14] = (uint8_t) (src); }
		
		int8_t rtk_health() const { return static_cast< int8_t >((&data_)[15] ); }
		
		void rtk_health(int8_t src) const { (&data_)[15] = (uint8_t) (src); }
		
		int8_t rtk_rate() const { return static_cast< int8_t >((&data_)[16] ); }
		
		void rtk_rate(int8_t src) const { (&data_)[16] = (uint8_t) (src); }
		
		int8_t nsats() const { return static_cast< int8_t >((&data_)[17] ); }
		
		void nsats(int8_t src) const { (&data_)[17] = (uint8_t) (src); }
		
		int8_t baseline_coords_type() const { return static_cast< int8_t >((&data_)[18] ); }
		
		void baseline_coords_type(int8_t src) const { (&data_)[18] = (uint8_t) (src); }
		
		int32_t baseline_a_mm() const { return (static_cast< int32_t > (get_bytes(&data_, 19, 4))); }
		
		void baseline_a_mm(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 19); }
		
		int32_t baseline_b_mm() const { return (static_cast< int32_t > (get_bytes(&data_, 23, 4))); }
		
		void baseline_b_mm(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 23); }
		
		int32_t baseline_c_mm() const { return (static_cast< int32_t > (get_bytes(&data_, 27, 4))); }
		
		void baseline_c_mm(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 27); }
		
		int32_t iar_num_hypotheses() const { return (static_cast< int32_t > (get_bytes(&data_, 31, 4))); }
		
		void iar_num_hypotheses(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 31); }
		
		
		/*
struct <DST> {
	void time_last_baseline_ms( int32_t src  ) {}
	void rtk_receiver_id( int8_t src  ) {}
	void wn( int16_t src  ) {}
	void tow( int32_t src  ) {}
	void rtk_health( int8_t src  ) {}
	void rtk_rate( int8_t src  ) {}
	void nsats( int8_t src  ) {}
	void baseline_coords_type( int8_t src  ) {}
	void baseline_a_mm( int32_t src  ) {}
	void baseline_b_mm( int32_t src  ) {}
	void baseline_c_mm( int32_t src  ) {}
	void accuracy( int32_t src  ) {}
	void iar_num_hypotheses( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_last_baseline_ms(  ) {}
	int32_t time_last_baseline_ms(  ) {}
	int8_t rtk_receiver_id(  ) {}
	int8_t rtk_receiver_id(  ) {}
	int16_t wn(  ) {}
	int16_t wn(  ) {}
	int32_t tow(  ) {}
	int32_t tow(  ) {}
	int8_t rtk_health(  ) {}
	int8_t rtk_health(  ) {}
	int8_t rtk_rate(  ) {}
	int8_t rtk_rate(  ) {}
	int8_t nsats(  ) {}
	int8_t nsats(  ) {}
	int8_t baseline_coords_type(  ) {}
	int8_t baseline_coords_type(  ) {}
	int32_t baseline_a_mm(  ) {}
	int32_t baseline_a_mm(  ) {}
	int32_t baseline_b_mm(  ) {}
	int32_t baseline_b_mm(  ) {}
	int32_t baseline_c_mm(  ) {}
	int32_t baseline_c_mm(  ) {}
	int32_t accuracy(  ) {}
	int32_t accuracy(  ) {}
	int32_t iar_num_hypotheses(  ) {}
	int32_t iar_num_hypotheses(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct PARAM_REQUEST_LIST {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		PARAM_REQUEST_LIST(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const PARAM_REQUEST_LIST &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 2) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct UAVIONIX_ADSB_OUT_CFG {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const UAVIONIX_ADSB_OUT_CFG &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t stallSpeed() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void stallSpeed(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int32_t ICAO() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 2, 4))); }
		
		void ICAO(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 2); }
		
		struct callsign_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		callsign_ callsign() const {
			if (data_.base.field_bit != 51 && !set_field(&data_, 51, -1)) return {0, 0, 0};
			
			callsign_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			callsign_ callsign(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 51) set_field(&data_, 51, len);
				const callsign_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		callsign_ callsign(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 51) set_field(&data_, 51, len);
			const callsign_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		struct emitterType_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum ADSB_EMITTER_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		emitterType_ emitterType() const {
			if (data_.base.field_bit != 52 && !set_field(&data_, 52, -1)) return {0, 0};
			emitterType_ ret{true, static_cast< enum ADSB_EMITTER_TYPE > (    static_cast< enum ADSB_EMITTER_TYPE >(   get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		void emitterType(enum ADSB_EMITTER_TYPE src) const {
			
			if (data_.base.field_bit != 52) set_field(&data_, 52, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 5, data_.base.bytes, data_.BIT);
		}
		
		
		struct aircraftSize_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		aircraftSize_ aircraftSize() const {
			if (data_.base.field_bit != 53 && !set_field(&data_, 53, -1)) return {0, 0};
			aircraftSize_ ret{true, static_cast< enum UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE > (    static_cast< enum UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void aircraftSize(enum UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE src) const {
			
			if (data_.base.field_bit != 53) set_field(&data_, 53, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 4, data_.base.bytes, data_.BIT);
		}
		
		
		struct gpsOffsetLat_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		gpsOffsetLat_ gpsOffsetLat() const {
			if (data_.base.field_bit != 54 && !set_field(&data_, 54, -1)) return {0, 0};
			gpsOffsetLat_ ret{true, static_cast< enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT > (    static_cast< enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void gpsOffsetLat(enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT src) const {
			
			if (data_.base.field_bit != 54) set_field(&data_, 54, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct gpsOffsetLon_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		gpsOffsetLon_ gpsOffsetLon() const {
			if (data_.base.field_bit != 55 && !set_field(&data_, 55, -1)) return {0, 0};
			gpsOffsetLon_ ret{true, static_cast< enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON > (    static_cast< enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON >(   get_bits(data_.base.bytes, data_.BIT, 1)))};
			return ret;
		}
		
		
		void gpsOffsetLon(enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON src) const {
			
			if (data_.base.field_bit != 55) set_field(&data_, 55, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 1, data_.base.bytes, data_.BIT);
		}
		
		
		struct rfSelect_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum UAVIONIX_ADSB_OUT_RF_SELECT value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		rfSelect_ rfSelect() const {
			if (data_.base.field_bit != 56 && !set_field(&data_, 56, -1)) return {0, 0};
			rfSelect_ ret{true, static_cast< enum UAVIONIX_ADSB_OUT_RF_SELECT > (    static_cast< enum UAVIONIX_ADSB_OUT_RF_SELECT >(   get_bits(data_.base.bytes, data_.BIT, 2)))};
			return ret;
		}
		
		
		void rfSelect(enum UAVIONIX_ADSB_OUT_RF_SELECT src) const {
			
			if (data_.base.field_bit != 56) set_field(&data_, 56, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 2, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void ICAO( int32_t src  ) {}
	void callsign( const struct com::company::demo::UAVIONIX_ADSB_OUT_CFG :: callsign_::CASE::EXISTS  & src  ) const {}
	void emitterType( enum com::company::demo:: ADSB_EMITTER_TYPE src  ) {}
	void aircraftSize( enum com::company::demo:: UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE src  ) {}
	void gpsOffsetLat( enum com::company::demo:: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT src  ) {}
	void gpsOffsetLon( enum com::company::demo:: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON src  ) {}
	void stallSpeed( int16_t src  ) {}
	void rfSelect( enum com::company::demo:: UAVIONIX_ADSB_OUT_RF_SELECT src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t ICAO(  ) {}
	int32_t ICAO(  ) {}
	std container of chars  callsign(  ) {}
	bool callsign_exists(){}
	enum com::company::demo:: ADSB_EMITTER_TYPE emitterType(  ) {}
	bool emitterType_exists(){}
	enum com::company::demo:: UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE aircraftSize(  ) {}
	bool aircraftSize_exists(){}
	enum com::company::demo:: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT gpsOffsetLat(  ) {}
	bool gpsOffsetLat_exists(){}
	enum com::company::demo:: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON gpsOffsetLon(  ) {}
	bool gpsOffsetLon_exists(){}
	int16_t stallSpeed(  ) {}
	int16_t stallSpeed(  ) {}
	enum com::company::demo:: UAVIONIX_ADSB_OUT_RF_SELECT rfSelect(  ) {}
	bool rfSelect_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LANDING_TARGET {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const LANDING_TARGET &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 0, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 0); }
		
		int8_t target_num() const { return static_cast< int8_t >((data_.base.bytes)[8] ); }
		
		void target_num(int8_t src) const { (data_.base.bytes)[8] = (uint8_t) (src); }
		
		float angle_x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 9, 4))); }
		
		void angle_x(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 9); }
		
		float angle_y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 13, 4))); }
		
		void angle_y(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 13); }
		
		float distance() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 17, 4))); }
		
		void distance(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 17); }
		
		float size_x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 21, 4))); }
		
		void size_x(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 21); }
		
		float size_y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 25, 4))); }
		
		void size_y(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 25); }
		
		struct frame_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_FRAME value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		frame_ frame() const {
			if (data_.base.field_bit != 235 && !set_field(&data_, 235, -1)) return {0, 0};
			frame_ ret{true, static_cast< enum MAV_FRAME > (    static_cast< enum MAV_FRAME >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void frame(enum MAV_FRAME src) const {
			
			if (data_.base.field_bit != 235) set_field(&data_, 235, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 4, data_.base.bytes, data_.BIT);
		}
		
		
		struct x_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const float value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		x_ x() const {
			if (data_.base.field_bit != 236 && !set_field(&data_, 236, -1)) return {0, 0};
			x_ ret{true, static_cast< float > ((intBitsToFloat(get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		void x(float src) const {
			
			if (data_.base.field_bit != 236) set_field(&data_, 236, 0);
			
			set_bytes(floatToIntBits(src), 4, data_.base.bytes, data_.BYTE);
		}
		
		
		struct y_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const float value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		y_ y() const {
			if (data_.base.field_bit != 237 && !set_field(&data_, 237, -1)) return {0, 0};
			y_ ret{true, static_cast< float > ((intBitsToFloat(get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		void y(float src) const {
			
			if (data_.base.field_bit != 237) set_field(&data_, 237, 0);
			
			set_bytes(floatToIntBits(src), 4, data_.base.bytes, data_.BYTE);
		}
		
		
		struct z_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const float value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		z_ z() const {
			if (data_.base.field_bit != 238 && !set_field(&data_, 238, -1)) return {0, 0};
			z_ ret{true, static_cast< float > ((intBitsToFloat(get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		void z(float src) const {
			
			if (data_.base.field_bit != 238) set_field(&data_, 238, 0);
			
			set_bytes(floatToIntBits(src), 4, data_.base.bytes, data_.BYTE);
		}
		
		
		struct q_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const float value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					
					struct q_::Value get(size_t d0) const {
						if (data_.base.field_bit != 239 && !set_field(&data_, 239, -1) || !set_item(&data_, d0, -1)) return {0, 0};
						struct q_::Value ret{true, static_cast< float > ((intBitsToFloat(get_bytes(data_.base.bytes, data_.BYTE, 4))))};
						return ret;
					}
					
					
				} EXISTS;
				
				
			} CASE;
			
			static constexpr size_t d0 = 4;
			
		};
		
		
		void q(float src, size_t d0) const {
			
			if (data_.base.field_bit != 239) set_field(&data_, 239, 0);
			set_item(&data_, d0, 0);
			set_bytes(floatToIntBits(src), 4, data_.base.bytes, data_.BYTE);
		}
		
		
		struct q_ q() const {
			return {data_.base.field_bit == 239 || set_field(&data_, 239, -1), data_};
		}

#define LANDING_TARGET_q_d0(LANDING_TARGET_ptr)\
    for(size_t  d0=0, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_q_exists = LANDING_TARGET_ptr q(); d0 <SIZE_MAX && is_q_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_q_exists = is_q_exists.CASE.EXISTS;   d0 < com::company::demo::LANDING_TARGET::q_::d0 ; ad_hoc_ = 1,  d0++)\
                for(auto src_q = case_q_exists.get(d0); src_q.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct typE_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum LANDING_TARGET_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		typE_ typE() const {
			if (data_.base.field_bit != 240 && !set_field(&data_, 240, -1)) return {0, 0};
			typE_ ret{true, static_cast< enum LANDING_TARGET_TYPE > (    static_cast< enum LANDING_TARGET_TYPE >(   get_bits(data_.base.bytes, data_.BIT, 2)))};
			return ret;
		}
		
		
		void typE(enum LANDING_TARGET_TYPE src) const {
			
			if (data_.base.field_bit != 240) set_field(&data_, 240, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 2, data_.base.bytes, data_.BIT);
		}
		
		
		struct position_valid_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int8_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		position_valid_ position_valid() const {
			if (data_.base.field_bit != 241 && !set_field(&data_, 241, -1)) return {0, 0};
			position_valid_ ret{true, static_cast< int8_t > (      static_cast< int8_t >((data_.base.bytes)[data_.BYTE] ))};
			return ret;
		}
		
		
		void position_valid(int8_t src) const {
			
			if (data_.base.field_bit != 241) set_field(&data_, 241, 0);
			
			(data_.base.bytes)[data_.BYTE] = (uint8_t) (src);
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void target_num( int8_t src  ) {}
	void frame( enum com::company::demo:: MAV_FRAME src  ) {}
	void angle_x( float src  ) {}
	void angle_y( float src  ) {}
	void distance( float src  ) {}
	void size_x( float src  ) {}
	void size_y( float src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void q( float src , size_t d0 ) {}
	void typE( enum com::company::demo:: LANDING_TARGET_TYPE src  ) {}
	void position_valid( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int8_t target_num(  ) {}
	int8_t target_num(  ) {}
	enum com::company::demo:: MAV_FRAME frame(  ) {}
	bool frame_exists(){}
	float angle_x(  ) {}
	float angle_x(  ) {}
	float angle_y(  ) {}
	float angle_y(  ) {}
	float distance(  ) {}
	float distance(  ) {}
	float size_x(  ) {}
	float size_x(  ) {}
	float size_y(  ) {}
	float size_y(  ) {}
	float x(  ) {}
	bool x_exists(){}
	float y(  ) {}
	bool y_exists(){}
	float z(  ) {}
	bool z_exists(){}
	float q(  size_t d0 ) {}
	bool q_exists(){}
	bool q_item_exists( size_t d0){}
	enum com::company::demo:: LANDING_TARGET_TYPE typE(  ) {}
	bool typE_exists(){}
	int8_t position_valid(  ) {}
	bool position_valid_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SET_ACTUATOR_CONTROL_TARGET {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SET_ACTUATOR_CONTROL_TARGET(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SET_ACTUATOR_CONTROL_TARGET &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 43) == 0);
		}
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		int8_t group_mlx() const { return static_cast< int8_t >((&data_)[8] ); }
		
		void group_mlx(int8_t src) const { (&data_)[8] = (uint8_t) (src); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[9] ); }
		
		void target_system(int8_t src) const { (&data_)[9] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[10] ); }
		
		void target_component(int8_t src) const { (&data_)[10] = (uint8_t) (src); }
		
		struct controls_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, controls_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, controls_> end() const { return {*this, 8}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 8;
			
		};
		
		struct controls_ controls() const {
			struct controls_ ret{&data_ + 11};
			return ret;
		}
		
		template<typename float_src_container>
			controls_ controls(const float_src_container &src) const {
				auto             first = src.begin();
				struct controls_ ret{&data_ + 11};
				for (size_t      i     = 0; i < 8; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		controls_ controls(float *const src) const { return controls(static_cast<float const *>( src)); }
		
		controls_ controls(float const *const src) const {
			struct controls_ ret{&data_ + 11};
			if (src)
				for (size_t  i = 0; i < 8; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void group_mlx( int8_t src  ) {}
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void controls( const struct com::company::demo::SET_ACTUATOR_CONTROL_TARGET :: controls_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int8_t group_mlx(  ) {}
	int8_t group_mlx(  ) {}
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	std container of flo  controls(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct CONTROL_SYSTEM_STATE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		CONTROL_SYSTEM_STATE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const CONTROL_SYSTEM_STATE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 100) == 0);
		}
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		float x_acc() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void x_acc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float y_acc() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void y_acc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		float z_acc() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		void z_acc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 16); }
		
		float x_vel() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		void x_vel(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 20); }
		
		float y_vel() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void y_vel(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		float z_vel() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void z_vel(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		float x_pos() const { return (intBitsToFloat(get_bytes(&data_, 32, 4))); }
		
		void x_pos(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 32); }
		
		float y_pos() const { return (intBitsToFloat(get_bytes(&data_, 36, 4))); }
		
		void y_pos(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 36); }
		
		float z_pos() const { return (intBitsToFloat(get_bytes(&data_, 40, 4))); }
		
		void z_pos(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 40); }
		
		float airspeed() const { return (intBitsToFloat(get_bytes(&data_, 44, 4))); }
		
		void airspeed(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 44); }
		
		struct vel_variance_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, vel_variance_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, vel_variance_> end() const { return {*this, 3}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 3;
			
		};
		
		struct vel_variance_ vel_variance() const {
			struct vel_variance_ ret{&data_ + 48};
			return ret;
		}
		
		template<typename float_src_container>
			vel_variance_ vel_variance(const float_src_container &src) const {
				auto                 first = src.begin();
				struct vel_variance_ ret{&data_ + 48};
				for (size_t          i     = 0; i < 3; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		vel_variance_ vel_variance(float *const src) const { return vel_variance(static_cast<float const *>( src)); }
		
		vel_variance_ vel_variance(float const *const src) const {
			struct vel_variance_ ret{&data_ + 48};
			if (src)
				for (size_t      i = 0; i < 3; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct pos_variance_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, pos_variance_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, pos_variance_> end() const { return {*this, 3}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 3;
			
		};
		
		struct pos_variance_ pos_variance() const {
			struct pos_variance_ ret{&data_ + 60};
			return ret;
		}
		
		template<typename float_src_container>
			pos_variance_ pos_variance(const float_src_container &src) const {
				auto                 first = src.begin();
				struct pos_variance_ ret{&data_ + 60};
				for (size_t          i     = 0; i < 3; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		pos_variance_ pos_variance(float *const src) const { return pos_variance(static_cast<float const *>( src)); }
		
		pos_variance_ pos_variance(float const *const src) const {
			struct pos_variance_ ret{&data_ + 60};
			if (src)
				for (size_t      i = 0; i < 3; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct q_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, q_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, q_> end() const { return {*this, 4}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 4;
			
		};
		
		struct q_ q() const {
			struct q_ ret{&data_ + 72};
			return ret;
		}
		
		template<typename float_src_container>
			q_ q(const float_src_container &src) const {
				auto        first = src.begin();
				struct q_   ret{&data_ + 72};
				for (size_t i     = 0; i < 4; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		q_ q(float *const src) const { return q(static_cast<float const *>( src)); }
		
		q_ q(float const *const src) const {
			struct q_       ret{&data_ + 72};
			if (src)
				for (size_t i = 0; i < 4; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		float roll_rate() const { return (intBitsToFloat(get_bytes(&data_, 88, 4))); }
		
		void roll_rate(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 88); }
		
		float pitch_rate() const { return (intBitsToFloat(get_bytes(&data_, 92, 4))); }
		
		void pitch_rate(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 92); }
		
		float yaw_rate() const { return (intBitsToFloat(get_bytes(&data_, 96, 4))); }
		
		void yaw_rate(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 96); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void x_acc( float src  ) {}
	void y_acc( float src  ) {}
	void z_acc( float src  ) {}
	void x_vel( float src  ) {}
	void y_vel( float src  ) {}
	void z_vel( float src  ) {}
	void x_pos( float src  ) {}
	void y_pos( float src  ) {}
	void z_pos( float src  ) {}
	void airspeed( float src  ) {}
	void vel_variance( const struct com::company::demo::CONTROL_SYSTEM_STATE :: vel_variance_  & src  ) const {}
	void pos_variance( const struct com::company::demo::CONTROL_SYSTEM_STATE :: pos_variance_  & src  ) const {}
	void q( const struct com::company::demo::CONTROL_SYSTEM_STATE :: q_  & src  ) const {}
	void roll_rate( float src  ) {}
	void pitch_rate( float src  ) {}
	void yaw_rate( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	float x_acc(  ) {}
	float x_acc(  ) {}
	float y_acc(  ) {}
	float y_acc(  ) {}
	float z_acc(  ) {}
	float z_acc(  ) {}
	float x_vel(  ) {}
	float x_vel(  ) {}
	float y_vel(  ) {}
	float y_vel(  ) {}
	float z_vel(  ) {}
	float z_vel(  ) {}
	float x_pos(  ) {}
	float x_pos(  ) {}
	float y_pos(  ) {}
	float y_pos(  ) {}
	float z_pos(  ) {}
	float z_pos(  ) {}
	float airspeed(  ) {}
	float airspeed(  ) {}
	std container of flo  vel_variance(  ) {}
	std container of flo  pos_variance(  ) {}
	std container of flo  q(  ) {}
	float roll_rate(  ) {}
	float roll_rate(  ) {}
	float pitch_rate(  ) {}
	float pitch_rate(  ) {}
	float yaw_rate(  ) {}
	float yaw_rate(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SET_POSITION_TARGET_GLOBAL_INT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const SET_POSITION_TARGET_GLOBAL_INT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t type_mask() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 2, 4))); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[6] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[7] ); }
		
		int32_t lat_int() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 8, 4))); }
		
		int32_t lon_int() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 12, 4))); }
		
		float alt() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		float vx() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 20, 4))); }
		
		float vy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 24, 4))); }
		
		float vz() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 28, 4))); }
		
		float afx() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 32, 4))); }
		
		float afy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 36, 4))); }
		
		float afz() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 40, 4))); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 44, 4))); }
		
		float yaw_rate() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 48, 4))); }
		
		
		struct coordinate_frame_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_FRAME value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		coordinate_frame_ coordinate_frame() const {
			if (data_.base.field_bit != 416 && !set_field(&data_, 416, -1)) return {0, 0};
			coordinate_frame_ ret{true, static_cast< enum MAV_FRAME > (    static_cast< enum MAV_FRAME >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void coordinate_frame( enum com::company::demo:: MAV_FRAME src  ) {}
	void type_mask( int16_t src  ) {}
	void lat_int( int32_t src  ) {}
	void lon_int( int32_t src  ) {}
	void alt( float src  ) {}
	void vx( float src  ) {}
	void vy( float src  ) {}
	void vz( float src  ) {}
	void afx( float src  ) {}
	void afy( float src  ) {}
	void afz( float src  ) {}
	void yaw( float src  ) {}
	void yaw_rate( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct DATA32 {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		DATA32(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const DATA32 &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 34) == 0);
		}
		
		int8_t typE() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void typE(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t len() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void len(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 32}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 32;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 2};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 2};
				for (size_t  i     = 0; i < 32; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{&data_ + 2};
			if (src)
				for (size_t i = 0; i < 32; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void typE( int8_t src  ) {}
	void len( int8_t src  ) {}
	void daTa( const struct com::company::demo::DATA32 :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t typE(  ) {}
	int8_t typE(  ) {}
	int8_t len(  ) {}
	int8_t len(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct PING33 {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const PING33 &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t TTTT(size_t d0, size_t d1, size_t d2) const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0 + (d0 + d1 * 3 + d2 * 3 * 2) * 4, 4))); }
		
		void TTTT(int32_t src, size_t d0, size_t d1, size_t d2) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 0 + (d0 + d1 * 3 + d2 * 3 * 2) * 4); }
		
		struct TTTT_ {
			static constexpr size_t d0 = 3;
			static constexpr size_t d1 = 2;
			static constexpr size_t d2 = 3;
			
		};
#define PING33_TTTT_d0_d1_d2\
    for(size_t d0=0; d0 <  com::company::demo::PING33::TTTT_::d0 ; d0++)\
        for(size_t d1=0; d1 <  com::company::demo::PING33::TTTT_::d1 ; d1++)\
            for(size_t d2=0; d2 <  com::company::demo::PING33::TTTT_::d2 ; d2++)
		
		int64_t field() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 72, 8))); }
		
		void field(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 72); }
		
		int8_t bit_field() const { return 4 + static_cast< int8_t >((data_.base.bytes)[80] ); }
		
		void bit_field(int8_t src) const { /*use PING33::bit_field_::min_value and PING33::bit_field_::max_value as range validation facilities */   (data_.base.bytes)[80] = (uint8_t) (-4 + src); }
		
		struct bit_field_ {
			
			//value range validation facilities
			static constexpr int8_t min_value = 4;
			static constexpr int8_t max_value = 45;
			
		};
		
		int32_t field6(size_t d0, size_t d1, size_t d2) const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 81 + (d0 + d1 * 3 + d2 * 3 * 2) * 4, 4))); }
		
		void field6(int32_t src, size_t d0, size_t d1, size_t d2) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 81 + (d0 + d1 * 3 + d2 * 3 * 2) * 4); }
		
		struct field6_ {
			static constexpr size_t d0 = 3;
			static constexpr size_t d1 = 2;
			static constexpr size_t d2 = 3;
			
		};
#define PING33_field6_d0_d1_d2\
    for(size_t d0=0; d0 <  com::company::demo::PING33::field6_::d0 ; d0++)\
        for(size_t d1=0; d1 <  com::company::demo::PING33::field6_::d1 ; d1++)\
            for(size_t d2=0; d2 <  com::company::demo::PING33::field6_::d2 ; d2++)
		
		bool testBOOL2() const { return ((data_.base.bytes)[1224 >> 3] & 1 << (1224 & 7)) != 0; }
		
		void testBOOL2(bool src) const {
			if (src) (data_.base.bytes)[1224 >> 3] |= 1 << (1224 & 7);
			else (data_.base.bytes)[1224 >> 3] &= ~(1 << (1224 & 7));
		}
		
		bool testBOOL3() const { return ((data_.base.bytes)[1225 >> 3] & 1 << (1225 & 7)) != 0; }
		
		void testBOOL3(bool src) const {
			if (src) (data_.base.bytes)[1225 >> 3] |= 1 << (1225 & 7);
			else (data_.base.bytes)[1225 >> 3] &= ~(1 << (1225 & 7));
		}
		
		struct testBOOL_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const bool value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		testBOOL_ testBOOL() const {
			if (data_.base.field_bit != 1234 && !set_field(&data_, 1234, -1)) return {0, 0};
			testBOOL_ ret{true, static_cast< bool > (((data_.base.bytes)[data_.BIT >> 3] & 1 << (data_.BIT & 7)) != 0 )};
			return ret;
		}
		
		
		void testBOOL(bool src) const {
			
			if (data_.base.field_bit != 1234) set_field(&data_, 1234, 0);
			
			if (src) (data_.base.bytes)[data_.BIT >> 3] |= 1 << (data_.BIT & 7);
			else (data_.base.bytes)[data_.BIT >> 3] &= ~(1 << (data_.BIT & 7));
		}
		
		
		struct seq_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int64_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		seq_ seq() const {
			if (data_.base.field_bit != 1235 && !set_field(&data_, 1235, -1)) return {0, 0};
			seq_ ret{true, static_cast< int64_t > ((-14 + static_cast< uint32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		void seq(int64_t src) const {
			
			if (data_.base.field_bit != 1235) set_field(&data_, 1235, 0);
			
			set_bytes((14 + src), 4, data_.base.bytes, data_.BYTE);
		}
		
		
		struct field1_ {
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d0() const { return data_.D[0]; }
					
					
					int32_t get(size_t d0, size_t d1, size_t d2) const {
						return (static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 2) * 4, 4)));
					}
					
					
					void set(int32_t src, size_t d0, size_t d1, size_t d2) const {
						
						
						set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 2) * 4);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					field1_ init(size_t d0) const {
						set_field(&data_, 1236, 0, d0);
						struct field1_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			static constexpr size_t d0_max = 7;
			static constexpr size_t d1     = 2;
			static constexpr size_t d2     = 3;
			
		};
		
		
		struct field1_ field1() const {
			return {data_.base.field_bit == 1236 || set_field(&data_, 1236, -1), data_};
		}

#define PING33_field1_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d0max, d1=0, d2=0; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_field1_exists = PING33_ptr field1(); d0 <SIZE_MAX && is_field1_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_field1_exists = is_field1_exists.CASE.EXISTS; d0max = case_field1_exists.d0(),   d0 < d0max ; d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::field1_::d1 ; d1++)\
                    for( d2 = 0; d2 < com::company::demo::PING33::field1_::d2 ; d2++)
		
		struct field12_ {
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					
					int32_t get(size_t d0, size_t d1, size_t d2) const {
						return (static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, 4)));
					}
					
					
				} EXISTS;
				
				
			} CASE;
			
			static constexpr size_t d0 = 3;
			static constexpr size_t d1 = 2;
			static constexpr size_t d2 = 3;
			
		};
		
		
		void field12(int32_t src, size_t d0, size_t d1, size_t d2) const {
			
			if (data_.base.field_bit != 1237) set_field(&data_, 1237, 0);
			set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4);
		}
		
		
		struct field12_ field12() const {
			return {data_.base.field_bit == 1237 || set_field(&data_, 1237, -1), data_};
		}

#define PING33_field12_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_field12_exists = PING33_ptr field12(); d0 <SIZE_MAX && is_field12_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_field12_exists = is_field12_exists.CASE.EXISTS;   d0 < com::company::demo::PING33::field12_::d0 ; d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::field12_::d1 ; d1++)\
                    for( d2 = 0; d2 < com::company::demo::PING33::field12_::d2 ; d2++)
		
		struct field13_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const int32_t value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					
					struct field13_::Value get(size_t d0, size_t d1, size_t d2) const {
						if (data_.base.field_bit != 1238 && !set_field(&data_, 1238, -1) || !set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, -1)) return {0, 0};
						struct field13_::Value ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
						return ret;
					}
					
					
				} EXISTS;
				
				
			} CASE;
			
			static constexpr size_t d0 = 3;
			static constexpr size_t d1 = 2;
			static constexpr size_t d2 = 3;
			
		};
		
		
		void field13(int32_t src, size_t d0, size_t d1, size_t d2) const {
			
			if (data_.base.field_bit != 1238) set_field(&data_, 1238, 0);
			set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, 0);
			set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE);
		}
		
		
		struct field13_ field13() const {
			return {data_.base.field_bit == 1238 || set_field(&data_, 1238, -1), data_};
		}

#define PING33_field13_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_field13_exists = PING33_ptr field13(); d0 <SIZE_MAX && is_field13_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_field13_exists = is_field13_exists.CASE.EXISTS;   d0 < com::company::demo::PING33::field13_::d0 ;  d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::field13_::d1 ; d1++)\
                    for( d2 = 0; d2 < com::company::demo::PING33::field13_::d2 ;ad_hoc_ = 1,  d2++)\
                        for(auto src_field13 = case_field13_exists.get(d0,d1,d2); src_field13.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct WWWWWWWW_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int32_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		WWWWWWWW_ WWWWWWWW() const {
			if (data_.base.field_bit != 1239 && !set_field(&data_, 1239, -1)) return {0, 0};
			WWWWWWWW_ ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		void WWWWWWWW(int32_t src) const {
			
			if (data_.base.field_bit != 1239) set_field(&data_, 1239, 0);
			
			set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE);
		}
		
		
		struct bit_field2_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int8_t value;
					
				} EXISTS;
			}          CASE;
			
			//value range validation facilities
			static constexpr int8_t min_value = 4;
			static constexpr int8_t max_value = 45;
			
		};
		
		
		bit_field2_ bit_field2() const {
			if (data_.base.field_bit != 1240 && !set_field(&data_, 1240, -1)) return {0, 0};
			bit_field2_ ret{true, static_cast< int8_t > (   45 - static_cast< int8_t >((data_.base.bytes)[data_.BYTE] ))};
			return ret;
		}
		
		
		void bit_field2(int8_t src) const {
			/*use PING33::bit_field2_::min_value and PING33::bit_field2_::max_value as range validation facilities */
			if (data_.base.field_bit != 1240) set_field(&data_, 1240, 0);
			
			(data_.base.bytes)[data_.BYTE] = (uint8_t) (45 - src);
		}
		
		
		struct Field_Bits_ {
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					
					int8_t get(size_t d0, size_t d1, size_t d2) const {
						return (4 + static_cast< int8_t > (get_bits(data_.base.bytes, data_.BIT + (d0 + d1 * 3 + d2 * 3 * 3) * 6, 6)));
					}
					
					
				} EXISTS;
				
				
			} CASE;
			
			
			//value range validation facilities
			static constexpr int8_t min_value = 4;
			static constexpr int8_t max_value = 45;
			static constexpr size_t d0        = 3;
			static constexpr size_t d1        = 3;
			static constexpr size_t d2        = 3;
			
		};
		
		
		void Field_Bits(int8_t src, size_t d0, size_t d1, size_t d2) const {
			/*use PING33::Field_Bits_::min_value and PING33::Field_Bits_::max_value as range validation facilities */
			if (data_.base.field_bit != 1241) set_field(&data_, 1241, 0);
			set_bits(-4 + src, 6, data_.base.bytes, data_.BIT + (d0 + d1 * 3 + d2 * 3 * 3) * 6);
		}
		
		
		struct Field_Bits_ Field_Bits() const {
			return {data_.base.field_bit == 1241 || set_field(&data_, 1241, -1), data_};
		}

#define PING33_Field_Bits_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_Field_Bits_exists = PING33_ptr Field_Bits(); d0 <SIZE_MAX && is_Field_Bits_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_Field_Bits_exists = is_Field_Bits_exists.CASE.EXISTS;   d0 < com::company::demo::PING33::Field_Bits_::d0 ; d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::Field_Bits_::d1 ; d1++)\
                    for( d2 = 0; d2 < com::company::demo::PING33::Field_Bits_::d2 ; d2++)
		
		struct SparseFixAllBits_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const int8_t value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d0() const { return data_.D[0]; }
					
					
					struct SparseFixAllBits_::Value get(size_t d0, size_t d1, size_t d2) const {
						if (!set_item(&data_, d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, -1)) return {0, 0};
						struct SparseFixAllBits_::Value ret{true, static_cast< int8_t > ((4 + static_cast< int8_t > (get_bits(data_.base.bytes, data_.BIT, 6))))};
						return ret;
					}
					
					
					void set(int8_t src, size_t d0, size_t d1, size_t d2) const {
						/*use PING33::SparseFixAllBits_::min_value and PING33::SparseFixAllBits_::max_value as range validation facilities */
						
						set_item(&data_, d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, 0);
						set_bits(-4 + src, 6, data_.base.bytes, data_.BIT);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					SparseFixAllBits_ init(size_t d0) const {
						set_field(&data_, 1242, 0, d0);
						struct SparseFixAllBits_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			
			//value range validation facilities
			static constexpr int8_t min_value = 4;
			static constexpr int8_t max_value = 45;
			static constexpr size_t d0_max    = 3;
			static constexpr size_t d1        = 3;
			static constexpr size_t d2        = 3;
			
		};
		
		
		struct SparseFixAllBits_ SparseFixAllBits() const {
			return {data_.base.field_bit == 1242 || set_field(&data_, 1242, -1), data_};
		}

#define PING33_SparseFixAllBits_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d0max, d1=0, d2=0, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_SparseFixAllBits_exists = PING33_ptr SparseFixAllBits(); d0 <SIZE_MAX && is_SparseFixAllBits_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_SparseFixAllBits_exists = is_SparseFixAllBits_exists.CASE.EXISTS; d0max = case_SparseFixAllBits_exists.d0(),   d0 < d0max ;  d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::SparseFixAllBits_::d1 ; d1++)\
                    for( d2 = 0; d2 < com::company::demo::PING33::SparseFixAllBits_::d2 ;ad_hoc_ = 1,  d2++)\
                        for(auto src_SparseFixAllBits = case_SparseFixAllBits_exists.get(d0,d1,d2); src_SparseFixAllBits.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct FixAllBits_ {
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d0() const { return data_.D[0]; }
					
					
					int8_t get(size_t d0, size_t d1, size_t d2) const {
						return (14 + static_cast< int8_t > (get_bits(data_.base.bytes, data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3) * 5, 5)));
					}
					
					
					void set(int8_t src, size_t d0, size_t d1, size_t d2) const {
						/*use PING33::FixAllBits_::min_value and PING33::FixAllBits_::max_value as range validation facilities */
						
						set_bits(-14 + src, 5, data_.base.bytes, data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3) * 5);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					FixAllBits_ init(size_t d0) const {
						set_field(&data_, 1243, 0, d0);
						struct FixAllBits_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			
			//value range validation facilities
			static constexpr int8_t min_value = 14;
			static constexpr int8_t max_value = 45;
			static constexpr size_t d0_max    = 3;
			static constexpr size_t d1        = 3;
			static constexpr size_t d2        = 3;
			
		};
		
		
		struct FixAllBits_ FixAllBits() const {
			return {data_.base.field_bit == 1243 || set_field(&data_, 1243, -1), data_};
		}

#define PING33_FixAllBits_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d0max, d1=0, d2=0; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_FixAllBits_exists = PING33_ptr FixAllBits(); d0 <SIZE_MAX && is_FixAllBits_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_FixAllBits_exists = is_FixAllBits_exists.CASE.EXISTS; d0max = case_FixAllBits_exists.d0(),   d0 < d0max ; d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::FixAllBits_::d1 ; d1++)\
                    for( d2 = 0; d2 < com::company::demo::PING33::FixAllBits_::d2 ; d2++)
		
		struct VarAllBits_ {
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d0() const { return data_.D[0]; }
					
					size_t d2() const { return data_.D[2]; }
					
					
					int8_t get(size_t d0, size_t d1, size_t d2) const {
						return (14 + static_cast< int8_t > (get_bits(data_.base.bytes, data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3) * 5, 5)));
					}
					
					
					void set(int8_t src, size_t d0, size_t d1, size_t d2) const {
						/*use PING33::VarAllBits_::min_value and PING33::VarAllBits_::max_value as range validation facilities */
						
						set_bits(-14 + src, 5, data_.base.bytes, data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3) * 5);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					VarAllBits_ init(size_t d0, size_t d2) const {
						set_field(&data_, 1244, 0, d0, d2);
						struct VarAllBits_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			
			//value range validation facilities
			static constexpr int8_t min_value = 14;
			static constexpr int8_t max_value = 45;
			static constexpr size_t d0_max    = 3;
			static constexpr size_t d1        = 3;
			static constexpr size_t d2_max    = 3;
			
		};
		
		
		struct VarAllBits_ VarAllBits() const {
			return {data_.base.field_bit == 1244 || set_field(&data_, 1244, -1), data_};
		}

#define PING33_VarAllBits_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d0max, d1=0, d2=0, d2max; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_VarAllBits_exists = PING33_ptr VarAllBits(); d0 <SIZE_MAX && is_VarAllBits_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_VarAllBits_exists = is_VarAllBits_exists.CASE.EXISTS; d0max = case_VarAllBits_exists.d0(), d2max = case_VarAllBits_exists.d2(),   d0 < d0max ; d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::VarAllBits_::d1 ; d1++)\
                    for( d2 = 0; d2 < d2max ; d2++)
		
		struct SparseVarAllBits_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const int8_t value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d0() const { return data_.D[0]; }
					
					size_t d2() const { return data_.D[2]; }
					
					
					struct SparseVarAllBits_::Value get(size_t d0, size_t d1, size_t d2) const {
						if (!set_item(&data_, d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, -1)) return {0, 0};
						struct SparseVarAllBits_::Value ret{true, static_cast< int8_t > ((14 + static_cast< int8_t > (get_bits(data_.base.bytes, data_.BIT, 5))))};
						return ret;
					}
					
					
					void set(int8_t src, size_t d0, size_t d1, size_t d2) const {
						/*use PING33::SparseVarAllBits_::min_value and PING33::SparseVarAllBits_::max_value as range validation facilities */
						
						set_item(&data_, d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, 0);
						set_bits(-14 + src, 5, data_.base.bytes, data_.BIT);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					SparseVarAllBits_ init(size_t d0, size_t d2) const {
						set_field(&data_, 1245, 0, d0, d2);
						struct SparseVarAllBits_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			
			//value range validation facilities
			static constexpr int8_t min_value = 14;
			static constexpr int8_t max_value = 45;
			static constexpr size_t d0_max    = 3;
			static constexpr size_t d1        = 3;
			static constexpr size_t d2_max    = 3;
			
		};
		
		
		struct SparseVarAllBits_ SparseVarAllBits() const {
			return {data_.base.field_bit == 1245 || set_field(&data_, 1245, -1), data_};
		}

#define PING33_SparseVarAllBits_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d0max, d1=0, d2=0, d2max, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_SparseVarAllBits_exists = PING33_ptr SparseVarAllBits(); d0 <SIZE_MAX && is_SparseVarAllBits_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_SparseVarAllBits_exists = is_SparseVarAllBits_exists.CASE.EXISTS; d0max = case_SparseVarAllBits_exists.d0(), d2max = case_SparseVarAllBits_exists.d2(),   d0 < d0max ;  d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::SparseVarAllBits_::d1 ; d1++)\
                    for( d2 = 0; d2 < d2max ;ad_hoc_ = 1,  d2++)\
                        for(auto src_SparseVarAllBits = case_SparseVarAllBits_exists.get(d0,d1,d2); src_SparseVarAllBits.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct VarEachBits_ {
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d0() const { return data_.D[0]; }
					
					
					int8_t get(size_t d0, size_t d1, size_t d2) const {
						return (-14 + static_cast< int8_t > (get_bits(data_.base.bytes, data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3) * 6, 6)));
					}
					
					
					void set(int8_t src, size_t d0, size_t d1, size_t d2) const {
						/*use PING33::VarEachBits_::min_value and PING33::VarEachBits_::max_value as range validation facilities */
						
						set_bits(14 + src, 6, data_.base.bytes, data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3) * 6);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					VarEachBits_ init(size_t d0) const {
						set_field(&data_, 1246, 0, d0);
						struct VarEachBits_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			
			//value range validation facilities
			static constexpr int8_t min_value = -14;
			static constexpr int8_t max_value = 45;
			static constexpr size_t d0_max    = 3;
			static constexpr size_t d1        = 3;
			static constexpr size_t d2        = 3;
			
		};
		
		
		struct VarEachBits_ VarEachBits() const {
			return {data_.base.field_bit == 1246 || set_field(&data_, 1246, -1), data_};
		}

#define PING33_VarEachBits_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d0max, d1=0, d2=0; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_VarEachBits_exists = PING33_ptr VarEachBits(); d0 <SIZE_MAX && is_VarEachBits_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_VarEachBits_exists = is_VarEachBits_exists.CASE.EXISTS; d0max = case_VarEachBits_exists.d0(),   d0 < d0max ; d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::VarEachBits_::d1 ; d1++)\
                    for( d2 = 0; d2 < com::company::demo::PING33::VarEachBits_::d2 ; d2++)
		
		struct SparsVarEachBits_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const int16_t value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d0() const { return data_.D[0]; }
					
					
					struct SparsVarEachBits_::Value get(size_t d0, size_t d1, size_t d2) const {
						if (!set_item(&data_, d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, -1)) return {0, 0};
						struct SparsVarEachBits_::Value ret{true, static_cast< int16_t > ((-14 + static_cast< uint16_t > (get_bits(data_.base.bytes, data_.BIT, 9))))};
						return ret;
					}
					
					
					void set(int16_t src, size_t d0, size_t d1, size_t d2) const {
						/*use PING33::SparsVarEachBits_::min_value and PING33::SparsVarEachBits_::max_value as range validation facilities */
						
						set_item(&data_, d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, 0);
						set_bits(14 + src, 9, data_.base.bytes, data_.BIT);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					SparsVarEachBits_ init(size_t d0) const {
						set_field(&data_, 1247, 0, d0);
						struct SparsVarEachBits_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			
			//value range validation facilities
			static constexpr int16_t min_value = -14;
			static constexpr int16_t max_value = 450;
			static constexpr size_t  d0_max    = 3;
			static constexpr size_t  d1        = 3;
			static constexpr size_t  d2        = 3;
			
		};
		
		
		struct SparsVarEachBits_ SparsVarEachBits() const {
			return {data_.base.field_bit == 1247 || set_field(&data_, 1247, -1), data_};
		}

#define PING33_SparsVarEachBits_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d0max, d1=0, d2=0, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_SparsVarEachBits_exists = PING33_ptr SparsVarEachBits(); d0 <SIZE_MAX && is_SparsVarEachBits_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_SparsVarEachBits_exists = is_SparsVarEachBits_exists.CASE.EXISTS; d0max = case_SparsVarEachBits_exists.d0(),   d0 < d0max ;  d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::SparsVarEachBits_::d1 ; d1++)\
                    for( d2 = 0; d2 < com::company::demo::PING33::SparsVarEachBits_::d2 ;ad_hoc_ = 1,  d2++)\
                        for(auto src_SparsVarEachBits = case_SparsVarEachBits_exists.get(d0,d1,d2); src_SparsVarEachBits.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct testBOOLX_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const bool value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		testBOOLX_ testBOOLX() const {
			if (data_.base.field_bit != 1248 && !set_field(&data_, 1248, -1)) return {0, 0};
			testBOOLX_ ret{true, static_cast< bool > (((data_.base.bytes)[data_.BIT >> 3] & 1 << (data_.BIT & 7)) != 0 )};
			return ret;
		}
		
		
		void testBOOLX(bool src) const {
			
			if (data_.base.field_bit != 1248) set_field(&data_, 1248, 0);
			
			if (src) (data_.base.bytes)[data_.BIT >> 3] |= 1 << (data_.BIT & 7);
			else (data_.base.bytes)[data_.BIT >> 3] &= ~(1 << (data_.BIT & 7));
		}
		
		
		struct testBOOL2X_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const bool value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		testBOOL2X_ testBOOL2X() const {
			if (data_.base.field_bit != 1249 && !set_field(&data_, 1249, -1)) return {0, 0};
			testBOOL2X_ ret{true, static_cast< bool > (((data_.base.bytes)[data_.BIT >> 3] & 1 << (data_.BIT & 7)) != 0 )};
			return ret;
		}
		
		
		void testBOOL2X(bool src) const {
			
			if (data_.base.field_bit != 1249) set_field(&data_, 1249, 0);
			
			if (src) (data_.base.bytes)[data_.BIT >> 3] |= 1 << (data_.BIT & 7);
			else (data_.base.bytes)[data_.BIT >> 3] &= ~(1 << (data_.BIT & 7));
		}
		
		
		struct testBOOL3X_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const bool value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		testBOOL3X_ testBOOL3X() const {
			if (data_.base.field_bit != 1250 && !set_field(&data_, 1250, -1)) return {0, 0};
			testBOOL3X_ ret{true, static_cast< bool > (((data_.base.bytes)[data_.BIT >> 3] & 1 << (data_.BIT & 7)) != 0 )};
			return ret;
		}
		
		
		void testBOOL3X(bool src) const {
			
			if (data_.base.field_bit != 1250) set_field(&data_, 1250, 0);
			
			if (src) (data_.base.bytes)[data_.BIT >> 3] |= 1 << (data_.BIT & 7);
			else (data_.base.bytes)[data_.BIT >> 3] &= ~(1 << (data_.BIT & 7));
		}
		
		
		struct MMMMMM_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MODE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		MMMMMM_ MMMMMM() const {
			if (data_.base.field_bit != 1251 && !set_field(&data_, 1251, -1)) return {0, 0};
			MMMMMM_ ret{true, static_cast< enum MAV_MODE > ( MAV_MODE_from(get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void MMMMMM(enum MAV_MODE src) const {
			
			if (data_.base.field_bit != 1251) set_field(&data_, 1251, 0);
			
			set_bits(MAV_MODE_into(src), 4, data_.base.bytes, data_.BIT);
		}
		
		
		struct field44_ {
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d2() const { return data_.D[2]; }
					
					
					int32_t get(size_t d0, size_t d1, size_t d2) const {
						return (static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, 4)));
					}
					
					
					void set(int32_t src, size_t d0, size_t d1, size_t d2) const {
						
						
						set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					field44_ init(size_t d2) const {
						set_field(&data_, 1252, 0, d2);
						struct field44_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			static constexpr size_t d0     = 3;
			static constexpr size_t d1     = 2;
			static constexpr size_t d2_max = 3;
			
		};
		
		
		struct field44_ field44() const {
			return {data_.base.field_bit == 1252 || set_field(&data_, 1252, -1), data_};
		}

#define PING33_field44_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0, d2max; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_field44_exists = PING33_ptr field44(); d0 <SIZE_MAX && is_field44_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_field44_exists = is_field44_exists.CASE.EXISTS; d2max = case_field44_exists.d2(),   d0 < com::company::demo::PING33::field44_::d0 ; d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::field44_::d1 ; d1++)\
                    for( d2 = 0; d2 < d2max ; d2++)
		
		struct field634_ {
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d2() const { return data_.D[2]; }
					
					
					int32_t get(size_t d0, size_t d1, size_t d2) const {
						return (static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, 4)));
					}
					
					
					void set(int32_t src, size_t d0, size_t d1, size_t d2) const {
						
						
						set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					field634_ init(size_t d2) const {
						set_field(&data_, 1253, 0, d2);
						struct field634_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			static constexpr size_t d0     = 3;
			static constexpr size_t d1     = 2;
			static constexpr size_t d2_max = 3;
			
		};
		
		
		struct field634_ field634() const {
			return {data_.base.field_bit == 1253 || set_field(&data_, 1253, -1), data_};
		}

#define PING33_field634_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0, d2max; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_field634_exists = PING33_ptr field634(); d0 <SIZE_MAX && is_field634_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_field634_exists = is_field634_exists.CASE.EXISTS; d2max = case_field634_exists.d2(),   d0 < com::company::demo::PING33::field634_::d0 ; d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::field634_::d1 ; d1++)\
                    for( d2 = 0; d2 < d2max ; d2++)
		
		struct field33344_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const int32_t value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d2() const { return data_.D[2]; }
					
					
					struct field33344_::Value get(size_t d0, size_t d1, size_t d2) const {
						if (!set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, -1)) return {0, 0};
						struct field33344_::Value ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
						return ret;
					}
					
					
					void set(int32_t src, size_t d0, size_t d1, size_t d2) const {
						
						
						set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, 0);
						set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					field33344_ init(size_t d2) const {
						set_field(&data_, 1254, 0, d2);
						struct field33344_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			static constexpr size_t d0     = 3;
			static constexpr size_t d1     = 2;
			static constexpr size_t d2_max = 3;
			
		};
		
		
		struct field33344_ field33344() const {
			return {data_.base.field_bit == 1254 || set_field(&data_, 1254, -1), data_};
		}

#define PING33_field33344_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0, d2max, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_field33344_exists = PING33_ptr field33344(); d0 <SIZE_MAX && is_field33344_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_field33344_exists = is_field33344_exists.CASE.EXISTS; d2max = case_field33344_exists.d2(),   d0 < com::company::demo::PING33::field33344_::d0 ;  d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::field33344_::d1 ; d1++)\
                    for( d2 = 0; d2 < d2max ;ad_hoc_ = 1,  d2++)\
                        for(auto src_field33344 = case_field33344_exists.get(d0,d1,d2); src_field33344.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct field333634_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const int32_t value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d2() const { return data_.D[2]; }
					
					
					struct field333634_::Value get(size_t d0, size_t d1, size_t d2) const {
						if (!set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, -1)) return {0, 0};
						struct field333634_::Value ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
						return ret;
					}
					
					
					void set(int32_t src, size_t d0, size_t d1, size_t d2) const {
						
						
						set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, 0);
						set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					field333634_ init(size_t d2) const {
						set_field(&data_, 1255, 0, d2);
						struct field333634_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			static constexpr size_t d0     = 3;
			static constexpr size_t d1     = 2;
			static constexpr size_t d2_max = 3;
			
		};
		
		
		struct field333634_ field333634() const {
			return {data_.base.field_bit == 1255 || set_field(&data_, 1255, -1), data_};
		}

#define PING33_field333634_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0, d2max, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_field333634_exists = PING33_ptr field333634(); d0 <SIZE_MAX && is_field333634_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_field333634_exists = is_field333634_exists.CASE.EXISTS; d2max = case_field333634_exists.d2(),   d0 < com::company::demo::PING33::field333634_::d0 ;  d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::field333634_::d1 ; d1++)\
                    for( d2 = 0; d2 < d2max ;ad_hoc_ = 1,  d2++)\
                        for(auto src_field333634 = case_field333634_exists.get(d0,d1,d2); src_field333634.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct field___ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const int32_t value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					
					struct field___::Value get(size_t d0, size_t d1, size_t d2) const {
						if (data_.base.field_bit != 1256 && !set_field(&data_, 1256, -1) || !set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, -1)) return {0, 0};
						struct field___::Value ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
						return ret;
					}
					
					
				} EXISTS;
				
				
			} CASE;
			
			static constexpr size_t d0 = 3;
			static constexpr size_t d1 = 2;
			static constexpr size_t d2 = 3;
			
		};
		
		
		void field__(int32_t src, size_t d0, size_t d1, size_t d2) const {
			
			if (data_.base.field_bit != 1256) set_field(&data_, 1256, 0);
			set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, 0);
			set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE);
		}
		
		
		struct field___ field__() const {
			return {data_.base.field_bit == 1256 || set_field(&data_, 1256, -1), data_};
		}

#define PING33_field___d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_field___exists = PING33_ptr field__(); d0 <SIZE_MAX && is_field___exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_field___exists = is_field___exists.CASE.EXISTS;   d0 < com::company::demo::PING33::field___::d0 ;  d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::field___::d1 ; d1++)\
                    for( d2 = 0; d2 < com::company::demo::PING33::field___::d2 ;ad_hoc_ = 1,  d2++)\
                        for(auto src_field__ = case_field___exists.get(d0,d1,d2); src_field__.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct field63_ {
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d2() const { return data_.D[2]; }
					
					
					int32_t get(size_t d0, size_t d1, size_t d2) const {
						return (static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, 4)));
					}
					
					
					void set(int32_t src, size_t d0, size_t d1, size_t d2) const {
						
						
						set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4);
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					field63_ init(size_t d2) const {
						set_field(&data_, 1257, 0, d2);
						struct field63_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			static constexpr size_t d0     = 3;
			static constexpr size_t d1     = 2;
			static constexpr size_t d2_max = 3;
			
		};
		
		
		struct field63_ field63() const {
			return {data_.base.field_bit == 1257 || set_field(&data_, 1257, -1), data_};
		}

#define PING33_field63_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0, d2max; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_field63_exists = PING33_ptr field63(); d0 <SIZE_MAX && is_field63_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_field63_exists = is_field63_exists.CASE.EXISTS; d2max = case_field63_exists.d2(),   d0 < com::company::demo::PING33::field63_::d0 ; d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::field63_::d1 ; d1++)\
                    for( d2 = 0; d2 < d2max ; d2++)
		
		struct uid2_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const int8_t value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					
					struct uid2_::Value get(size_t d0) const {
						if (data_.base.field_bit != 1258 && !set_field(&data_, 1258, -1) || !set_item(&data_, d0, -1)) return {0, 0};
						struct uid2_::Value ret{true, static_cast< int8_t > (      static_cast< int8_t >((data_.base.bytes)[data_.BYTE] ))};
						return ret;
					}
					
					
				} EXISTS;
				
				
			} CASE;
			
			static constexpr size_t d0 = 18;
			
		};
		
		
		void uid2(int8_t src, size_t d0) const {
			
			if (data_.base.field_bit != 1258) set_field(&data_, 1258, 0);
			set_item(&data_, d0, 0);
			(data_.base.bytes)[data_.BYTE] = (uint8_t) (src);
		}
		
		
		struct uid2_ uid2() const {
			return {data_.base.field_bit == 1258 || set_field(&data_, 1258, -1), data_};
		}

#define PING33_uid2_d0(PING33_ptr)\
    for(size_t  d0=0, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_uid2_exists = PING33_ptr uid2(); d0 <SIZE_MAX && is_uid2_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_uid2_exists = is_uid2_exists.CASE.EXISTS;   d0 < com::company::demo::PING33::uid2_::d0 ; ad_hoc_ = 1,  d0++)\
                for(auto src_uid2 = case_uid2_exists.get(d0); src_uid2.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct field2_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const int32_t value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					
					struct field2_::Value get(size_t d0, size_t d1, size_t d2) const {
						if (data_.base.field_bit != 1259 && !set_field(&data_, 1259, -1) || !set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, -1)) return {0, 0};
						struct field2_::Value ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
						return ret;
					}
					
					
				} EXISTS;
				
				
			} CASE;
			
			static constexpr size_t d0 = 3;
			static constexpr size_t d1 = 2;
			static constexpr size_t d2 = 3;
			
		};
		
		
		void field2(int32_t src, size_t d0, size_t d1, size_t d2) const {
			
			if (data_.base.field_bit != 1259) set_field(&data_, 1259, 0);
			set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, 0);
			set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE);
		}
		
		
		struct field2_ field2() const {
			return {data_.base.field_bit == 1259 || set_field(&data_, 1259, -1), data_};
		}

#define PING33_field2_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_field2_exists = PING33_ptr field2(); d0 <SIZE_MAX && is_field2_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_field2_exists = is_field2_exists.CASE.EXISTS;   d0 < com::company::demo::PING33::field2_::d0 ;  d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::field2_::d1 ; d1++)\
                    for( d2 = 0; d2 < com::company::demo::PING33::field2_::d2 ;ad_hoc_ = 1,  d2++)\
                        for(auto src_field2 = case_field2_exists.get(d0,d1,d2); src_field2.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct field4_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const int32_t value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					
					struct field4_::Value get(size_t d0, size_t d1, size_t d2) const {
						if (data_.base.field_bit != 1260 && !set_field(&data_, 1260, -1) || !set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, -1)) return {0, 0};
						struct field4_::Value ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
						return ret;
					}
					
					
				} EXISTS;
				
				
			} CASE;
			
			static constexpr size_t d0 = 3;
			static constexpr size_t d1 = 2;
			static constexpr size_t d2 = 3;
			
		};
		
		
		void field4(int32_t src, size_t d0, size_t d1, size_t d2) const {
			
			if (data_.base.field_bit != 1260) set_field(&data_, 1260, 0);
			set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, 0);
			set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE);
		}
		
		
		struct field4_ field4() const {
			return {data_.base.field_bit == 1260 || set_field(&data_, 1260, -1), data_};
		}

#define PING33_field4_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_field4_exists = PING33_ptr field4(); d0 <SIZE_MAX && is_field4_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_field4_exists = is_field4_exists.CASE.EXISTS;   d0 < com::company::demo::PING33::field4_::d0 ;  d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::field4_::d1 ; d1++)\
                    for( d2 = 0; d2 < com::company::demo::PING33::field4_::d2 ;ad_hoc_ = 1,  d2++)\
                        for(auto src_field4 = case_field4_exists.get(d0,d1,d2); src_field4.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct stringtest1_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		stringtest1_ stringtest1() const {
			if (data_.base.field_bit != 1261 && !set_field(&data_, 1261, -1)) return {0, 0, 0};
			
			stringtest1_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			stringtest1_ stringtest1(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 1261) set_field(&data_, 1261, len);
				const stringtest1_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		stringtest1_ stringtest1(const char src[], size_t len) const {
			len                  = 255 < len ? 255 : len;
			if (data_.base.field_bit != 1261) set_field(&data_, 1261, len);
			const stringtest1_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t    i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		struct stringtest2_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						uint8_t *const bytes;
						const size_t length;
						
						org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
						
						org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
						
						char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
						
						void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					size_t d2() const { return data_.D[2]; }
					
					
					struct stringtest2_::Value get(size_t d0, size_t d1, size_t d2) const {
						if (!set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, -1)) return {0, 0, 0};
						
						struct stringtest2_::Value ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
						return ret;
					}
					
					template<typename char_src_container>
						struct stringtest2_::Value set(const char_src_container &src, size_t d0, size_t d1, size_t d2) const {
							
							auto first = src.begin();
							auto last  = src.end();
							
							auto len = std::distance(first, last);
							len = 255 < len ? 255 : len;
							set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, len);
							const struct stringtest2_::Value ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
							std::copy(first, last, data_.base.bytes + data_.BYTE);
							return ret;
						}
					
					struct stringtest2_::Value set(const char src[], size_t len, size_t d0, size_t d1, size_t d2) const {
						
						len                                = 255 < len ? 255 : len;
						set_item(&data_, d0 + d1 * 3 + d2 * 3 * 2, len);
						const struct stringtest2_::Value ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
						if (src)
							for (size_t                  i = 0; i < len; i++)
								ret.CASE.EXISTS.set(src[i], i);
						return ret;
					}
					
				} EXISTS;
				
				
				struct EMPTY {
					Cursor &data_;
					
					stringtest2_ init(size_t d2) const {
						set_field(&data_, 1262, 0, d2);
						struct stringtest2_ ret{true, data_};
						return ret;
					}
				} EMPTY;
				
				
			} CASE;
			
			static constexpr size_t len_max = 255;
			static constexpr size_t d0      = 3;
			static constexpr size_t d1      = 2;
			static constexpr size_t d2_max  = 3;
			
		};
		
		
		struct stringtest2_ stringtest2() const {
			return {data_.base.field_bit == 1262 || set_field(&data_, 1262, -1), data_};
		}

#define PING33_stringtest2_d0_d1_d2(PING33_ptr)\
    for(size_t  d0=0, d1=0, d2=0, d2max, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_stringtest2_exists = PING33_ptr stringtest2(); d0 <SIZE_MAX && is_stringtest2_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_stringtest2_exists = is_stringtest2_exists.CASE.EXISTS; d2max = case_stringtest2_exists.d2(),   d0 < com::company::demo::PING33::stringtest2_::d0 ;  d0++)\
                for( d1 = 0; d1 < com::company::demo::PING33::stringtest2_::d1 ; d1++)\
                    for( d2 = 0; d2 < d2max ;ad_hoc_ = 1,  d2++)\
                        for(auto src_stringtest2 = case_stringtest2_exists.get(d0,d1,d2); src_stringtest2.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		struct stringtest3_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		stringtest3_ stringtest3() const {
			if (data_.base.field_bit != 1263 && !set_field(&data_, 1263, -1)) return {0, 0, 0};
			
			stringtest3_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			stringtest3_ stringtest3(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 1263) set_field(&data_, 1263, len);
				const stringtest3_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		stringtest3_ stringtest3(const char src[], size_t len) const {
			len                  = 255 < len ? 255 : len;
			if (data_.base.field_bit != 1263) set_field(&data_, 1263, len);
			const stringtest3_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t    i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		struct stringtest4_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		stringtest4_ stringtest4() const {
			if (data_.base.field_bit != 1264 && !set_field(&data_, 1264, -1)) return {0, 0, 0};
			
			stringtest4_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			stringtest4_ stringtest4(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 1264) set_field(&data_, 1264, len);
				const stringtest4_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		stringtest4_ stringtest4(const char src[], size_t len) const {
			len                  = 255 < len ? 255 : len;
			if (data_.base.field_bit != 1264) set_field(&data_, 1264, len);
			const stringtest4_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t    i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		static constexpr int32_t const3         = 56; //56
		static constexpr int32_t stati_cconst1  = 1; //1
		static constexpr float   stati_cconst1D = 1.456; //(float)1.456
		static constexpr float   const3D        = 56.555; //(float)56.555
		
		/*
struct <DST> {
	void testBOOL( bool src  ) {}
	void seq( int64_t src  ) {}
	void field( int64_t src  ) {}
	void field1( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void field1_init( size_t d0 ) const   {}
	void field12( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void field13( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void TTTT( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void WWWWWWWW( int32_t src  ) {}
	void testBOOL2( bool src  ) {}
	void testBOOL3( bool src  ) {}
	void bit_field( int8_t src  ) {}
	void bit_field2( int8_t src  ) {}
	void Field_Bits( int8_t src , size_t d0, size_t d1, size_t d2 ) {}
	void SparseFixAllBits( int8_t src , size_t d0, size_t d1, size_t d2 ) {}
	void SparseFixAllBits_init( size_t d0 ) const   {}
	void FixAllBits( int8_t src , size_t d0, size_t d1, size_t d2 ) {}
	void FixAllBits_init( size_t d0 ) const   {}
	void VarAllBits( int8_t src , size_t d0, size_t d1, size_t d2 ) {}
	void VarAllBits_init( size_t d0,size_t d2 ) const   {}
	void SparseVarAllBits( int8_t src , size_t d0, size_t d1, size_t d2 ) {}
	void SparseVarAllBits_init( size_t d0,size_t d2 ) const   {}
	void VarEachBits( int8_t src , size_t d0, size_t d1, size_t d2 ) {}
	void VarEachBits_init( size_t d0 ) const   {}
	void SparsVarEachBits( int16_t src , size_t d0, size_t d1, size_t d2 ) {}
	void SparsVarEachBits_init( size_t d0 ) const   {}
	void testBOOLX( bool src  ) {}
	void testBOOL2X( bool src  ) {}
	void testBOOL3X( bool src  ) {}
	void MMMMMM( enum com::company::demo:: MAV_MODE src  ) {}
	void field44( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void field44_init( size_t d2 ) const   {}
	void field634( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void field634_init( size_t d2 ) const   {}
	void field33344( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void field33344_init( size_t d2 ) const   {}
	void field333634( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void field333634_init( size_t d2 ) const   {}
	void field__( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void field6( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void field63( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void field63_init( size_t d2 ) const   {}
	void uid2( int8_t src , size_t d0 ) {}
	void field2( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void field4( int32_t src , size_t d0, size_t d1, size_t d2 ) {}
	void stringtest1( const struct com::company::demo::PING33 :: stringtest1_::CASE::EXISTS  & src  ) const {}
	void stringtest2( const struct com::company::demo::PING33 :: stringtest2_::Value::CASE::EXISTS  & src , size_t d0, size_t d1, size_t d2 ) const {}
	void stringtest2_init( size_t d2 ) const   {}
	void stringtest3( const struct com::company::demo::PING33 :: stringtest3_::CASE::EXISTS  & src  ) const {}
	void stringtest4( const struct com::company::demo::PING33 :: stringtest4_::CASE::EXISTS  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	bool testBOOL(  ) {}
	bool testBOOL_exists(){}
	int64_t seq(  ) {}
	bool seq_exists(){}
	int64_t field(  ) {}
	int64_t field(  ) {}
	int32_t field1(  size_t d0, size_t d1, size_t d2 ) {}
	bool field1_exists(  size_t & d0 ){}
	int32_t field12(  size_t d0, size_t d1, size_t d2 ) {}
	bool field12_exists(){}
	int32_t field13(  size_t d0, size_t d1, size_t d2 ) {}
	bool field13_exists(){}
	bool field13_item_exists( size_t d0, size_t d1, size_t d2){}
	int32_t TTTT(  size_t d0, size_t d1, size_t d2 ) {}
	int32_t TTTT(  size_t d0, size_t d1, size_t d2 ) {}
	int32_t WWWWWWWW(  ) {}
	bool WWWWWWWW_exists(){}
	bool testBOOL2(  ) {}
	bool testBOOL2(  ) {}
	bool testBOOL3(  ) {}
	bool testBOOL3(  ) {}
	int8_t bit_field(  ) {}
	int8_t bit_field(  ) {}
	int8_t bit_field2(  ) {}
	bool bit_field2_exists(){}
	int8_t Field_Bits(  size_t d0, size_t d1, size_t d2 ) {}
	bool Field_Bits_exists(){}
	int8_t SparseFixAllBits(  size_t d0, size_t d1, size_t d2 ) {}
	bool SparseFixAllBits_exists(  size_t & d0 ){}
	bool SparseFixAllBits_item_exists( size_t d0, size_t d1, size_t d2){}
	int8_t FixAllBits(  size_t d0, size_t d1, size_t d2 ) {}
	bool FixAllBits_exists(  size_t & d0 ){}
	int8_t VarAllBits(  size_t d0, size_t d1, size_t d2 ) {}
	bool VarAllBits_exists(  size_t & d0, size_t & d2 ){}
	int8_t SparseVarAllBits(  size_t d0, size_t d1, size_t d2 ) {}
	bool SparseVarAllBits_exists(  size_t & d0, size_t & d2 ){}
	bool SparseVarAllBits_item_exists( size_t d0, size_t d1, size_t d2){}
	int8_t VarEachBits(  size_t d0, size_t d1, size_t d2 ) {}
	bool VarEachBits_exists(  size_t & d0 ){}
	int16_t SparsVarEachBits(  size_t d0, size_t d1, size_t d2 ) {}
	bool SparsVarEachBits_exists(  size_t & d0 ){}
	bool SparsVarEachBits_item_exists( size_t d0, size_t d1, size_t d2){}
	bool testBOOLX(  ) {}
	bool testBOOLX_exists(){}
	bool testBOOL2X(  ) {}
	bool testBOOL2X_exists(){}
	bool testBOOL3X(  ) {}
	bool testBOOL3X_exists(){}
	enum com::company::demo:: MAV_MODE MMMMMM(  ) {}
	bool MMMMMM_exists(){}
	int32_t field44(  size_t d0, size_t d1, size_t d2 ) {}
	bool field44_exists(  size_t & d2 ){}
	int32_t field634(  size_t d0, size_t d1, size_t d2 ) {}
	bool field634_exists(  size_t & d2 ){}
	int32_t field33344(  size_t d0, size_t d1, size_t d2 ) {}
	bool field33344_exists(  size_t & d2 ){}
	bool field33344_item_exists( size_t d0, size_t d1, size_t d2){}
	int32_t field333634(  size_t d0, size_t d1, size_t d2 ) {}
	bool field333634_exists(  size_t & d2 ){}
	bool field333634_item_exists( size_t d0, size_t d1, size_t d2){}
	int32_t field__(  size_t d0, size_t d1, size_t d2 ) {}
	bool field___exists(){}
	bool field___item_exists( size_t d0, size_t d1, size_t d2){}
	int32_t field6(  size_t d0, size_t d1, size_t d2 ) {}
	int32_t field6(  size_t d0, size_t d1, size_t d2 ) {}
	int32_t field63(  size_t d0, size_t d1, size_t d2 ) {}
	bool field63_exists(  size_t & d2 ){}
	int8_t uid2(  size_t d0 ) {}
	bool uid2_exists(){}
	bool uid2_item_exists( size_t d0){}
	int32_t field2(  size_t d0, size_t d1, size_t d2 ) {}
	bool field2_exists(){}
	bool field2_item_exists( size_t d0, size_t d1, size_t d2){}
	int32_t field4(  size_t d0, size_t d1, size_t d2 ) {}
	bool field4_exists(){}
	bool field4_item_exists( size_t d0, size_t d1, size_t d2){}
	std container of chars  stringtest1(  ) {}
	bool stringtest1_exists(){}
	std container of chars  stringtest2(  size_t d0, size_t d1, size_t d2 ) {}
	bool stringtest2_exists(  size_t & d2 ){}
	bool stringtest2_item_exists( size_t d0, size_t d1, size_t d2){}
	std container of chars  stringtest3(  ) {}
	bool stringtest3_exists(){}
	std container of chars  stringtest4(  ) {}
	bool stringtest4_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct VFR_HUD {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		VFR_HUD(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const VFR_HUD &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 20) == 0);
		}
		
		int16_t throttle() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		float airspeed() const { return (intBitsToFloat(get_bytes(&data_, 2, 4))); }
		
		float groundspeed() const { return (intBitsToFloat(get_bytes(&data_, 6, 4))); }
		
		int16_t heading() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		float alt() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		float climb() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		
		/*
struct <DST> {
	void airspeed( float src  ) {}
	void groundspeed( float src  ) {}
	void heading( int16_t src  ) {}
	void throttle( int16_t src  ) {}
	void alt( float src  ) {}
	void climb( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct RALLY_POINT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const RALLY_POINT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t land_dir() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void land_dir(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[2] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[3] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[3] = (uint8_t) (src); }
		
		int8_t idx() const { return static_cast< int8_t >((data_.base.bytes)[4] ); }
		
		void idx(int8_t src) const { (data_.base.bytes)[4] = (uint8_t) (src); }
		
		int8_t count() const { return static_cast< int8_t >((data_.base.bytes)[5] ); }
		
		void count(int8_t src) const { (data_.base.bytes)[5] = (uint8_t) (src); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 6, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 6); }
		
		int32_t lng() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 10, 4))); }
		
		void lng(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 10); }
		
		int16_t alt() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 14, 2))); }
		
		void alt(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 14); }
		
		int16_t break_alt() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 16, 2))); }
		
		void break_alt(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 16); }
		
		struct flags_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum RALLY_FLAGS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		flags_ flags() const {
			if (data_.base.field_bit != 144 && !set_field(&data_, 144, -1)) return {0, 0};
			flags_ ret{true, static_cast< enum RALLY_FLAGS > (    static_cast< enum RALLY_FLAGS >( 1 + get_bits(data_.base.bytes, data_.BIT, 1)))};
			return ret;
		}
		
		
		void flags(enum RALLY_FLAGS src) const {
			
			if (data_.base.field_bit != 144) set_field(&data_, 144, 0);
			
			set_bits(static_cast< uintptr_t >(  -1
			src  ), 1, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void idx( int8_t src  ) {}
	void count( int8_t src  ) {}
	void lat( int32_t src  ) {}
	void lng( int32_t src  ) {}
	void alt( int16_t src  ) {}
	void break_alt( int16_t src  ) {}
	void land_dir( int16_t src  ) {}
	void flags( enum com::company::demo:: RALLY_FLAGS src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int8_t idx(  ) {}
	int8_t idx(  ) {}
	int8_t count(  ) {}
	int8_t count(  ) {}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lng(  ) {}
	int32_t lng(  ) {}
	int16_t alt(  ) {}
	int16_t alt(  ) {}
	int16_t break_alt(  ) {}
	int16_t break_alt(  ) {}
	int16_t land_dir(  ) {}
	int16_t land_dir(  ) {}
	enum com::company::demo:: RALLY_FLAGS flags(  ) {}
	bool flags_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MISSION_SET_CURRENT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		MISSION_SET_CURRENT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const MISSION_SET_CURRENT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 4) == 0);
		}
		
		int16_t seq() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[2] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[3] ); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void seq( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct ADAP_TUNING {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const ADAP_TUNING &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		float desired() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 0, 4))); }
		
		void desired(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 0); }
		
		float achieved() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 4, 4))); }
		
		void achieved(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 4); }
		
		float error() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 8, 4))); }
		
		void error(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 8); }
		
		float theta() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		void theta(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 12); }
		
		float omega() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		void omega(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 16); }
		
		float sigma() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 20, 4))); }
		
		void sigma(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 20); }
		
		float theta_dot() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 24, 4))); }
		
		void theta_dot(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 24); }
		
		float omega_dot() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 28, 4))); }
		
		void omega_dot(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 28); }
		
		float sigma_dot() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 32, 4))); }
		
		void sigma_dot(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 32); }
		
		float f() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 36, 4))); }
		
		void f(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 36); }
		
		float f_dot() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 40, 4))); }
		
		void f_dot(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 40); }
		
		float u() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 44, 4))); }
		
		void u(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 44); }
		
		struct axis_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum PID_TUNING_AXIS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		axis_ axis() const {
			if (data_.base.field_bit != 384 && !set_field(&data_, 384, -1)) return {0, 0};
			axis_ ret{true, static_cast< enum PID_TUNING_AXIS > (    static_cast< enum PID_TUNING_AXIS >( 1 + get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void axis(enum PID_TUNING_AXIS src) const {
			
			if (data_.base.field_bit != 384) set_field(&data_, 384, 0);
			
			set_bits(static_cast< uintptr_t >(  -1
			src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void axis( enum com::company::demo:: PID_TUNING_AXIS src  ) {}
	void desired( float src  ) {}
	void achieved( float src  ) {}
	void error( float src  ) {}
	void theta( float src  ) {}
	void omega( float src  ) {}
	void sigma( float src  ) {}
	void theta_dot( float src  ) {}
	void omega_dot( float src  ) {}
	void sigma_dot( float src  ) {}
	void f( float src  ) {}
	void f_dot( float src  ) {}
	void u( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: PID_TUNING_AXIS axis(  ) {}
	bool axis_exists(){}
	float desired(  ) {}
	float desired(  ) {}
	float achieved(  ) {}
	float achieved(  ) {}
	float error(  ) {}
	float error(  ) {}
	float theta(  ) {}
	float theta(  ) {}
	float omega(  ) {}
	float omega(  ) {}
	float sigma(  ) {}
	float sigma(  ) {}
	float theta_dot(  ) {}
	float theta_dot(  ) {}
	float omega_dot(  ) {}
	float omega_dot(  ) {}
	float sigma_dot(  ) {}
	float sigma_dot(  ) {}
	float f(  ) {}
	float f(  ) {}
	float f_dot(  ) {}
	float f_dot(  ) {}
	float u(  ) {}
	float u(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct VIBRATION {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		VIBRATION(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const VIBRATION &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 32) == 0);
		}
		
		int32_t clipping_0() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void clipping_0(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int32_t clipping_1() const { return (static_cast< int32_t > (get_bytes(&data_, 4, 4))); }
		
		void clipping_1(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 4); }
		
		int32_t clipping_2() const { return (static_cast< int32_t > (get_bytes(&data_, 8, 4))); }
		
		void clipping_2(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 8); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 12, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 12); }
		
		float vibration_x() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		void vibration_x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 20); }
		
		float vibration_y() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void vibration_y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		float vibration_z() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void vibration_z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void vibration_x( float src  ) {}
	void vibration_y( float src  ) {}
	void vibration_z( float src  ) {}
	void clipping_0( int32_t src  ) {}
	void clipping_1( int32_t src  ) {}
	void clipping_2( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	float vibration_x(  ) {}
	float vibration_x(  ) {}
	float vibration_y(  ) {}
	float vibration_y(  ) {}
	float vibration_z(  ) {}
	float vibration_z(  ) {}
	int32_t clipping_0(  ) {}
	int32_t clipping_0(  ) {}
	int32_t clipping_1(  ) {}
	int32_t clipping_1(  ) {}
	int32_t clipping_2(  ) {}
	int32_t clipping_2(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct PARAM_EXT_VALUE {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const PARAM_EXT_VALUE &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t param_count() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void param_count(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t param_index() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void param_index(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		struct param_id_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		param_id_ param_id() const {
			if (data_.base.field_bit != 35 && !set_field(&data_, 35, -1)) return {0, 0, 0};
			
			param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			param_id_ param_id(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 35) set_field(&data_, 35, len);
				const param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		param_id_ param_id(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 35) set_field(&data_, 35, len);
			const param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		struct param_value_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		param_value_ param_value() const {
			if (data_.base.field_bit != 36 && !set_field(&data_, 36, -1)) return {0, 0, 0};
			
			param_value_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			param_value_ param_value(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 36) set_field(&data_, 36, len);
				const param_value_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		param_value_ param_value(const char src[], size_t len) const {
			len                  = 255 < len ? 255 : len;
			if (data_.base.field_bit != 36) set_field(&data_, 36, len);
			const param_value_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t    i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		struct param_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_PARAM_EXT_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		param_type_ param_type() const {
			if (data_.base.field_bit != 37 && !set_field(&data_, 37, -1)) return {0, 0};
			param_type_ ret{true, static_cast< enum MAV_PARAM_EXT_TYPE > (    static_cast< enum MAV_PARAM_EXT_TYPE >( 1 + get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void param_type(enum MAV_PARAM_EXT_TYPE src) const {
			
			if (data_.base.field_bit != 37) set_field(&data_, 37, 0);
			
			set_bits(static_cast< uintptr_t >(  -1
			src  ), 4, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void param_id( const struct com::company::demo::PARAM_EXT_VALUE :: param_id_::CASE::EXISTS  & src  ) const {}
	void param_value( const struct com::company::demo::PARAM_EXT_VALUE :: param_value_::CASE::EXISTS  & src  ) const {}
	void param_type( enum com::company::demo:: MAV_PARAM_EXT_TYPE src  ) {}
	void param_count( int16_t src  ) {}
	void param_index( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	std container of chars  param_id(  ) {}
	bool param_id_exists(){}
	std container of chars  param_value(  ) {}
	bool param_value_exists(){}
	enum com::company::demo:: MAV_PARAM_EXT_TYPE param_type(  ) {}
	bool param_type_exists(){}
	int16_t param_count(  ) {}
	int16_t param_count(  ) {}
	int16_t param_index(  ) {}
	int16_t param_index(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct BATTERY2 {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		BATTERY2(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const BATTERY2 &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 4) == 0);
		}
		
		int16_t voltage() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void voltage(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t current_battery() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void current_battery(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		
		/*
struct <DST> {
	void voltage( int16_t src  ) {}
	void current_battery( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t voltage(  ) {}
	int16_t voltage(  ) {}
	int16_t current_battery(  ) {}
	int16_t current_battery(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LIMITS_STATUS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const LIMITS_STATUS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t breach_count() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void breach_count(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int32_t last_trigger() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 2, 4))); }
		
		void last_trigger(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 2); }
		
		int32_t last_action() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 6, 4))); }
		
		void last_action(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 6); }
		
		int32_t last_recovery() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 10, 4))); }
		
		void last_recovery(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 10); }
		
		int32_t last_clear() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 14, 4))); }
		
		void last_clear(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 14); }
		
		struct limits_state_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum LIMITS_STATE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		limits_state_ limits_state() const {
			if (data_.base.field_bit != 146 && !set_field(&data_, 146, -1)) return {0, 0};
			limits_state_ ret{true, static_cast< enum LIMITS_STATE > (    static_cast< enum LIMITS_STATE >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void limits_state(enum LIMITS_STATE src) const {
			
			if (data_.base.field_bit != 146) set_field(&data_, 146, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct mods_enabled_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum LIMIT_MODULE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mods_enabled_ mods_enabled() const {
			if (data_.base.field_bit != 147 && !set_field(&data_, 147, -1)) return {0, 0};
			mods_enabled_ ret{true, static_cast< enum LIMIT_MODULE > ( LIMIT_MODULE_from(get_bits(data_.base.bytes, data_.BIT, 2)))};
			return ret;
		}
		
		
		void mods_enabled(enum LIMIT_MODULE src) const {
			
			if (data_.base.field_bit != 147) set_field(&data_, 147, 0);
			
			set_bits(LIMIT_MODULE_into(src), 2, data_.base.bytes, data_.BIT);
		}
		
		
		struct mods_required_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum LIMIT_MODULE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mods_required_ mods_required() const {
			if (data_.base.field_bit != 148 && !set_field(&data_, 148, -1)) return {0, 0};
			mods_required_ ret{true, static_cast< enum LIMIT_MODULE > ( LIMIT_MODULE_from(get_bits(data_.base.bytes, data_.BIT, 2)))};
			return ret;
		}
		
		
		void mods_required(enum LIMIT_MODULE src) const {
			
			if (data_.base.field_bit != 148) set_field(&data_, 148, 0);
			
			set_bits(LIMIT_MODULE_into(src), 2, data_.base.bytes, data_.BIT);
		}
		
		
		struct mods_triggered_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum LIMIT_MODULE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mods_triggered_ mods_triggered() const {
			if (data_.base.field_bit != 149 && !set_field(&data_, 149, -1)) return {0, 0};
			mods_triggered_ ret{true, static_cast< enum LIMIT_MODULE > ( LIMIT_MODULE_from(get_bits(data_.base.bytes, data_.BIT, 2)))};
			return ret;
		}
		
		
		void mods_triggered(enum LIMIT_MODULE src) const {
			
			if (data_.base.field_bit != 149) set_field(&data_, 149, 0);
			
			set_bits(LIMIT_MODULE_into(src), 2, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void limits_state( enum com::company::demo:: LIMITS_STATE src  ) {}
	void last_trigger( int32_t src  ) {}
	void last_action( int32_t src  ) {}
	void last_recovery( int32_t src  ) {}
	void last_clear( int32_t src  ) {}
	void breach_count( int16_t src  ) {}
	void mods_enabled( enum com::company::demo:: LIMIT_MODULE src  ) {}
	void mods_required( enum com::company::demo:: LIMIT_MODULE src  ) {}
	void mods_triggered( enum com::company::demo:: LIMIT_MODULE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: LIMITS_STATE limits_state(  ) {}
	bool limits_state_exists(){}
	int32_t last_trigger(  ) {}
	int32_t last_trigger(  ) {}
	int32_t last_action(  ) {}
	int32_t last_action(  ) {}
	int32_t last_recovery(  ) {}
	int32_t last_recovery(  ) {}
	int32_t last_clear(  ) {}
	int32_t last_clear(  ) {}
	int16_t breach_count(  ) {}
	int16_t breach_count(  ) {}
	enum com::company::demo:: LIMIT_MODULE mods_enabled(  ) {}
	bool mods_enabled_exists(){}
	enum com::company::demo:: LIMIT_MODULE mods_required(  ) {}
	bool mods_required_exists(){}
	enum com::company::demo:: LIMIT_MODULE mods_triggered(  ) {}
	bool mods_triggered_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct CAMERA_FEEDBACK {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const CAMERA_FEEDBACK &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t img_idx() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void img_idx(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 2, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 2); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[10] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[10] = (uint8_t) (src); }
		
		int8_t cam_idx() const { return static_cast< int8_t >((data_.base.bytes)[11] ); }
		
		void cam_idx(int8_t src) const { (data_.base.bytes)[11] = (uint8_t) (src); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 12, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 12); }
		
		int32_t lng() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 16, 4))); }
		
		void lng(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 16); }
		
		float alt_msl() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 20, 4))); }
		
		void alt_msl(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 20); }
		
		float alt_rel() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 24, 4))); }
		
		void alt_rel(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 24); }
		
		float roll() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 28, 4))); }
		
		void roll(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 28); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 32, 4))); }
		
		void pitch(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 32); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 36, 4))); }
		
		void yaw(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 36); }
		
		float foc_len() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 40, 4))); }
		
		void foc_len(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 40); }
		
		struct flags_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum CAMERA_FEEDBACK_FLAGS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		flags_ flags() const {
			if (data_.base.field_bit != 352 && !set_field(&data_, 352, -1)) return {0, 0};
			flags_ ret{true, static_cast< enum CAMERA_FEEDBACK_FLAGS > (    static_cast< enum CAMERA_FEEDBACK_FLAGS >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void flags(enum CAMERA_FEEDBACK_FLAGS src) const {
			
			if (data_.base.field_bit != 352) set_field(&data_, 352, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void target_system( int8_t src  ) {}
	void cam_idx( int8_t src  ) {}
	void img_idx( int16_t src  ) {}
	void lat( int32_t src  ) {}
	void lng( int32_t src  ) {}
	void alt_msl( float src  ) {}
	void alt_rel( float src  ) {}
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
	void foc_len( float src  ) {}
	void flags( enum com::company::demo:: CAMERA_FEEDBACK_FLAGS src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t cam_idx(  ) {}
	int8_t cam_idx(  ) {}
	int16_t img_idx(  ) {}
	int16_t img_idx(  ) {}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lng(  ) {}
	int32_t lng(  ) {}
	float alt_msl(  ) {}
	float alt_msl(  ) {}
	float alt_rel(  ) {}
	float alt_rel(  ) {}
	float roll(  ) {}
	float roll(  ) {}
	float pitch(  ) {}
	float pitch(  ) {}
	float yaw(  ) {}
	float yaw(  ) {}
	float foc_len(  ) {}
	float foc_len(  ) {}
	enum com::company::demo:: CAMERA_FEEDBACK_FLAGS flags(  ) {}
	bool flags_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct HIL_GPS {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		HIL_GPS(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const HIL_GPS &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 36) == 0);
		}
		
		int16_t eph() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void eph(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t epv() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void epv(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int16_t vel() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		void vel(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 4); }
		
		int16_t cog() const { return (static_cast< int16_t > (get_bytes(&data_, 6, 2))); }
		
		void cog(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 6); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 8, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 8); }
		
		int8_t fix_type() const { return static_cast< int8_t >((&data_)[16] ); }
		
		void fix_type(int8_t src) const { (&data_)[16] = (uint8_t) (src); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 17, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 17); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(&data_, 21, 4))); }
		
		void lon(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 21); }
		
		int32_t alt() const { return (static_cast< int32_t > (get_bytes(&data_, 25, 4))); }
		
		void alt(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 25); }
		
		int16_t vn() const { return (static_cast< int16_t > (get_bytes(&data_, 29, 2))); }
		
		void vn(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 29); }
		
		int16_t ve() const { return (static_cast< int16_t > (get_bytes(&data_, 31, 2))); }
		
		void ve(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 31); }
		
		int16_t vd() const { return (static_cast< int16_t > (get_bytes(&data_, 33, 2))); }
		
		void vd(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 33); }
		
		int8_t satellites_visible() const { return static_cast< int8_t >((&data_)[35] ); }
		
		void satellites_visible(int8_t src) const { (&data_)[35] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void fix_type( int8_t src  ) {}
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void alt( int32_t src  ) {}
	void eph( int16_t src  ) {}
	void epv( int16_t src  ) {}
	void vel( int16_t src  ) {}
	void vn( int16_t src  ) {}
	void ve( int16_t src  ) {}
	void vd( int16_t src  ) {}
	void cog( int16_t src  ) {}
	void satellites_visible( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int8_t fix_type(  ) {}
	int8_t fix_type(  ) {}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lon(  ) {}
	int32_t lon(  ) {}
	int32_t alt(  ) {}
	int32_t alt(  ) {}
	int16_t eph(  ) {}
	int16_t eph(  ) {}
	int16_t epv(  ) {}
	int16_t epv(  ) {}
	int16_t vel(  ) {}
	int16_t vel(  ) {}
	int16_t vn(  ) {}
	int16_t vn(  ) {}
	int16_t ve(  ) {}
	int16_t ve(  ) {}
	int16_t vd(  ) {}
	int16_t vd(  ) {}
	int16_t cog(  ) {}
	int16_t cog(  ) {}
	int8_t satellites_visible(  ) {}
	int8_t satellites_visible(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct NAV_CONTROLLER_OUTPUT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		NAV_CONTROLLER_OUTPUT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const NAV_CONTROLLER_OUTPUT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 26) == 0);
		}
		
		int16_t wp_dist() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		float nav_roll() const { return (intBitsToFloat(get_bytes(&data_, 2, 4))); }
		
		float nav_pitch() const { return (intBitsToFloat(get_bytes(&data_, 6, 4))); }
		
		int16_t nav_bearing() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		int16_t target_bearing() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		float alt_error() const { return (intBitsToFloat(get_bytes(&data_, 14, 4))); }
		
		float aspd_error() const { return (intBitsToFloat(get_bytes(&data_, 18, 4))); }
		
		float xtrack_error() const { return (intBitsToFloat(get_bytes(&data_, 22, 4))); }
		
		
		/*
struct <DST> {
	void nav_roll( float src  ) {}
	void nav_pitch( float src  ) {}
	void nav_bearing( int16_t src  ) {}
	void target_bearing( int16_t src  ) {}
	void wp_dist( int16_t src  ) {}
	void alt_error( float src  ) {}
	void aspd_error( float src  ) {}
	void xtrack_error( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct AUTH_KEY {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const AUTH_KEY &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct key_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		key_ key() const {
			if (data_.base.field_bit != 2 && !set_field(&data_, 2, -1)) return {0, 0, 0};
			
			key_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		
		/*
struct <DST> {
	void key( const struct com::company::demo::AUTH_KEY :: key_::CASE::EXISTS  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct FENCE_FETCH_POINT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		FENCE_FETCH_POINT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const FENCE_FETCH_POINT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 3) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		int8_t idx() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void idx(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void idx( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int8_t idx(  ) {}
	int8_t idx(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct RADIO {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RADIO(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RADIO &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 9) == 0);
		}
		
		int16_t rxerrors() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void rxerrors(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t fixeD() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void fixeD(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int8_t rssi() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void rssi(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		int8_t remrssi() const { return static_cast< int8_t >((&data_)[5] ); }
		
		void remrssi(int8_t src) const { (&data_)[5] = (uint8_t) (src); }
		
		int8_t txbuf() const { return static_cast< int8_t >((&data_)[6] ); }
		
		void txbuf(int8_t src) const { (&data_)[6] = (uint8_t) (src); }
		
		int8_t noise() const { return static_cast< int8_t >((&data_)[7] ); }
		
		void noise(int8_t src) const { (&data_)[7] = (uint8_t) (src); }
		
		int8_t remnoise() const { return static_cast< int8_t >((&data_)[8] ); }
		
		void remnoise(int8_t src) const { (&data_)[8] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void rssi( int8_t src  ) {}
	void remrssi( int8_t src  ) {}
	void txbuf( int8_t src  ) {}
	void noise( int8_t src  ) {}
	void remnoise( int8_t src  ) {}
	void rxerrors( int16_t src  ) {}
	void fixeD( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t rssi(  ) {}
	int8_t rssi(  ) {}
	int8_t remrssi(  ) {}
	int8_t remrssi(  ) {}
	int8_t txbuf(  ) {}
	int8_t txbuf(  ) {}
	int8_t noise(  ) {}
	int8_t noise(  ) {}
	int8_t remnoise(  ) {}
	int8_t remnoise(  ) {}
	int16_t rxerrors(  ) {}
	int16_t rxerrors(  ) {}
	int16_t fixeD(  ) {}
	int16_t fixeD(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LOCAL_POSITION_NED_COV {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const LOCAL_POSITION_NED_COV &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 0, 8))); }
		
		float x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 8, 4))); }
		
		float y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		float z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		float vx() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 20, 4))); }
		
		float vy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 24, 4))); }
		
		float vz() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 28, 4))); }
		
		float ax() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 32, 4))); }
		
		float ay() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 36, 4))); }
		
		float az() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 40, 4))); }
		
		
		struct covariance_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, covariance_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, covariance_> end() const { return {*this, 45}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			static constexpr size_t len = 45;
			
		};
		
		struct covariance_ covariance() const {
			struct covariance_ ret{data_.base.bytes + 44};
			return ret;
		}
		
		struct estimator_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_ESTIMATOR_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		estimator_type_ estimator_type() const {
			if (data_.base.field_bit != 1792 && !set_field(&data_, 1792, -1)) return {0, 0};
			estimator_type_ ret{true, static_cast< enum MAV_ESTIMATOR_TYPE > (    static_cast< enum MAV_ESTIMATOR_TYPE >( 1 + get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void estimator_type( enum com::company::demo:: MAV_ESTIMATOR_TYPE src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void vx( float src  ) {}
	void vy( float src  ) {}
	void vz( float src  ) {}
	void ax( float src  ) {}
	void ay( float src  ) {}
	void az( float src  ) {}
	void covariance( const struct com::company::demo::LOCAL_POSITION_NED_COV :: covariance_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct AIRSPEED_AUTOCAL {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		AIRSPEED_AUTOCAL(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const AIRSPEED_AUTOCAL &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 48) == 0);
		}
		
		float vx() const { return (intBitsToFloat(get_bytes(&data_, 0, 4))); }
		
		void vx(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 0); }
		
		float vy() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void vy(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float vz() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void vz(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float diff_pressure() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void diff_pressure(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		float EAS2TAS() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		void EAS2TAS(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 16); }
		
		float ratio() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		void ratio(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 20); }
		
		float state_x() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void state_x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		float state_y() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void state_y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		float state_z() const { return (intBitsToFloat(get_bytes(&data_, 32, 4))); }
		
		void state_z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 32); }
		
		float Pax() const { return (intBitsToFloat(get_bytes(&data_, 36, 4))); }
		
		void Pax(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 36); }
		
		float Pby() const { return (intBitsToFloat(get_bytes(&data_, 40, 4))); }
		
		void Pby(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 40); }
		
		float Pcz() const { return (intBitsToFloat(get_bytes(&data_, 44, 4))); }
		
		void Pcz(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 44); }
		
		
		/*
struct <DST> {
	void vx( float src  ) {}
	void vy( float src  ) {}
	void vz( float src  ) {}
	void diff_pressure( float src  ) {}
	void EAS2TAS( float src  ) {}
	void ratio( float src  ) {}
	void state_x( float src  ) {}
	void state_y( float src  ) {}
	void state_z( float src  ) {}
	void Pax( float src  ) {}
	void Pby( float src  ) {}
	void Pcz( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	float vx(  ) {}
	float vx(  ) {}
	float vy(  ) {}
	float vy(  ) {}
	float vz(  ) {}
	float vz(  ) {}
	float diff_pressure(  ) {}
	float diff_pressure(  ) {}
	float EAS2TAS(  ) {}
	float EAS2TAS(  ) {}
	float ratio(  ) {}
	float ratio(  ) {}
	float state_x(  ) {}
	float state_x(  ) {}
	float state_y(  ) {}
	float state_y(  ) {}
	float state_z(  ) {}
	float state_z(  ) {}
	float Pax(  ) {}
	float Pax(  ) {}
	float Pby(  ) {}
	float Pby(  ) {}
	float Pcz(  ) {}
	float Pcz(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct ATT_POS_MOCAP {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		ATT_POS_MOCAP(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const ATT_POS_MOCAP &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 36) == 0);
		}
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		struct q_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, q_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, q_> end() const { return {*this, 4}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 4;
			
		};
		
		struct q_ q() const {
			struct q_ ret{&data_ + 8};
			return ret;
		}
		
		template<typename float_src_container>
			q_ q(const float_src_container &src) const {
				auto        first = src.begin();
				struct q_   ret{&data_ + 8};
				for (size_t i     = 0; i < 4; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		q_ q(float *const src) const { return q(static_cast<float const *>( src)); }
		
		q_ q(float const *const src) const {
			struct q_       ret{&data_ + 8};
			if (src)
				for (size_t i = 0; i < 4; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		float x() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		float y() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		float z() const { return (intBitsToFloat(get_bytes(&data_, 32, 4))); }
		
		void z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 32); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void q( const struct com::company::demo::ATT_POS_MOCAP :: q_  & src  ) const {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	std container of flo  q(  ) {}
	float x(  ) {}
	float x(  ) {}
	float y(  ) {}
	float y(  ) {}
	float z(  ) {}
	float z(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct STATUSTEXT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const STATUSTEXT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct severity_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_SEVERITY value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		severity_ severity() const {
			if (data_.base.field_bit != 2 && !set_field(&data_, 2, -1)) return {0, 0};
			severity_ ret{true, static_cast< enum MAV_SEVERITY > (    static_cast< enum MAV_SEVERITY >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void severity(enum MAV_SEVERITY src) const {
			
			if (data_.base.field_bit != 2) set_field(&data_, 2, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct text_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		text_ text() const {
			if (data_.base.field_bit != 3 && !set_field(&data_, 3, -1)) return {0, 0, 0};
			
			text_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			text_ text(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 3) set_field(&data_, 3, len);
				const text_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		text_ text(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 3) set_field(&data_, 3, len);
			const text_     ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void severity( enum com::company::demo:: MAV_SEVERITY src  ) {}
	void text( const struct com::company::demo::STATUSTEXT :: text_::CASE::EXISTS  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: MAV_SEVERITY severity(  ) {}
	bool severity_exists(){}
	std container of chars  text(  ) {}
	bool text_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct PING {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		PING(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const PING &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 14) == 0);
		}
		
		int32_t seq() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 4, 8))); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[12] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[13] ); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void seq( int32_t src  ) {}
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct GOPRO_GET_REQUEST {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const GOPRO_GET_REQUEST &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[1] = (uint8_t) (src); }
		
		struct cmd_id_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GOPRO_COMMAND value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		cmd_id_ cmd_id() const {
			if (data_.base.field_bit != 16 && !set_field(&data_, 16, -1)) return {0, 0};
			cmd_id_ ret{true, static_cast< enum GOPRO_COMMAND > (    static_cast< enum GOPRO_COMMAND >(   get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		void cmd_id(enum GOPRO_COMMAND src) const {
			
			if (data_.base.field_bit != 16) set_field(&data_, 16, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 5, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void cmd_id( enum com::company::demo:: GOPRO_COMMAND src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	enum com::company::demo:: GOPRO_COMMAND cmd_id(  ) {}
	bool cmd_id_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct CAMERA_CAPTURE_STATUS {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		CAMERA_CAPTURE_STATUS(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const CAMERA_CAPTURE_STATUS &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 18) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int32_t recording_time_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 4, 4))); }
		
		void recording_time_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 4); }
		
		int8_t image_status() const { return static_cast< int8_t >((&data_)[8] ); }
		
		void image_status(int8_t src) const { (&data_)[8] = (uint8_t) (src); }
		
		int8_t video_status() const { return static_cast< int8_t >((&data_)[9] ); }
		
		void video_status(int8_t src) const { (&data_)[9] = (uint8_t) (src); }
		
		float image_interval() const { return (intBitsToFloat(get_bytes(&data_, 10, 4))); }
		
		void image_interval(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 10); }
		
		float available_capacity() const { return (intBitsToFloat(get_bytes(&data_, 14, 4))); }
		
		void available_capacity(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 14); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void image_status( int8_t src  ) {}
	void video_status( int8_t src  ) {}
	void image_interval( float src  ) {}
	void recording_time_ms( int32_t src  ) {}
	void available_capacity( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	int8_t image_status(  ) {}
	int8_t image_status(  ) {}
	int8_t video_status(  ) {}
	int8_t video_status(  ) {}
	float image_interval(  ) {}
	float image_interval(  ) {}
	int32_t recording_time_ms(  ) {}
	int32_t recording_time_ms(  ) {}
	float available_capacity(  ) {}
	float available_capacity(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GLOBAL_POSITION_INT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		GLOBAL_POSITION_INT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const GLOBAL_POSITION_INT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 28) == 0);
		}
		
		int16_t hdg() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 2, 4))); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 6, 4))); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(&data_, 10, 4))); }
		
		int32_t alt() const { return (static_cast< int32_t > (get_bytes(&data_, 14, 4))); }
		
		int32_t relative_alt() const { return (static_cast< int32_t > (get_bytes(&data_, 18, 4))); }
		
		int16_t vx() const { return (static_cast< int16_t > (get_bytes(&data_, 22, 2))); }
		
		int16_t vy() const { return (static_cast< int16_t > (get_bytes(&data_, 24, 2))); }
		
		int16_t vz() const { return (static_cast< int16_t > (get_bytes(&data_, 26, 2))); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void alt( int32_t src  ) {}
	void relative_alt( int32_t src  ) {}
	void vx( int16_t src  ) {}
	void vy( int16_t src  ) {}
	void vz( int16_t src  ) {}
	void hdg( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct ENCAPSULATED_DATA {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		ENCAPSULATED_DATA(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const ENCAPSULATED_DATA &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 255) == 0);
		}
		
		int16_t seqnr() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void seqnr(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 253}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 253;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 2};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 2};
				for (size_t  i     = 0; i < 253; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{&data_ + 2};
			if (src)
				for (size_t i = 0; i < 253; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void seqnr( int16_t src  ) {}
	void daTa( const struct com::company::demo::ENCAPSULATED_DATA :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t seqnr(  ) {}
	int16_t seqnr(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GPS_INPUT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const GPS_INPUT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t time_week() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void time_week(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int32_t time_week_ms() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 2, 4))); }
		
		void time_week_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 2); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 6, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 6); }
		
		int8_t gps_id() const { return static_cast< int8_t >((data_.base.bytes)[14] ); }
		
		void gps_id(int8_t src) const { (data_.base.bytes)[14] = (uint8_t) (src); }
		
		int8_t fix_type() const { return static_cast< int8_t >((data_.base.bytes)[15] ); }
		
		void fix_type(int8_t src) const { (data_.base.bytes)[15] = (uint8_t) (src); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 16, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 16); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 20, 4))); }
		
		void lon(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 20); }
		
		float alt() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 24, 4))); }
		
		void alt(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 24); }
		
		float hdop() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 28, 4))); }
		
		void hdop(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 28); }
		
		float vdop() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 32, 4))); }
		
		void vdop(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 32); }
		
		float vn() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 36, 4))); }
		
		void vn(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 36); }
		
		float ve() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 40, 4))); }
		
		void ve(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 40); }
		
		float vd() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 44, 4))); }
		
		void vd(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 44); }
		
		float speed_accuracy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 48, 4))); }
		
		void speed_accuracy(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 48); }
		
		float horiz_accuracy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 52, 4))); }
		
		void horiz_accuracy(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 52); }
		
		float vert_accuracy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 56, 4))); }
		
		void vert_accuracy(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 56); }
		
		int8_t satellites_visible() const { return static_cast< int8_t >((data_.base.bytes)[60] ); }
		
		void satellites_visible(int8_t src) const { (data_.base.bytes)[60] = (uint8_t) (src); }
		
		struct ignore_flags_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GPS_INPUT_IGNORE_FLAGS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		ignore_flags_ ignore_flags() const {
			if (data_.base.field_bit != 488 && !set_field(&data_, 488, -1)) return {0, 0};
			ignore_flags_ ret{true, static_cast< enum GPS_INPUT_IGNORE_FLAGS > ( GPS_INPUT_IGNORE_FLAGS_from(get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void ignore_flags(enum GPS_INPUT_IGNORE_FLAGS src) const {
			
			if (data_.base.field_bit != 488) set_field(&data_, 488, 0);
			
			set_bits(GPS_INPUT_IGNORE_FLAGS_into(src), 4, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void gps_id( int8_t src  ) {}
	void ignore_flags( enum com::company::demo:: GPS_INPUT_IGNORE_FLAGS src  ) {}
	void time_week_ms( int32_t src  ) {}
	void time_week( int16_t src  ) {}
	void fix_type( int8_t src  ) {}
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void alt( float src  ) {}
	void hdop( float src  ) {}
	void vdop( float src  ) {}
	void vn( float src  ) {}
	void ve( float src  ) {}
	void vd( float src  ) {}
	void speed_accuracy( float src  ) {}
	void horiz_accuracy( float src  ) {}
	void vert_accuracy( float src  ) {}
	void satellites_visible( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int8_t gps_id(  ) {}
	int8_t gps_id(  ) {}
	enum com::company::demo:: GPS_INPUT_IGNORE_FLAGS ignore_flags(  ) {}
	bool ignore_flags_exists(){}
	int32_t time_week_ms(  ) {}
	int32_t time_week_ms(  ) {}
	int16_t time_week(  ) {}
	int16_t time_week(  ) {}
	int8_t fix_type(  ) {}
	int8_t fix_type(  ) {}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lon(  ) {}
	int32_t lon(  ) {}
	float alt(  ) {}
	float alt(  ) {}
	float hdop(  ) {}
	float hdop(  ) {}
	float vdop(  ) {}
	float vdop(  ) {}
	float vn(  ) {}
	float vn(  ) {}
	float ve(  ) {}
	float ve(  ) {}
	float vd(  ) {}
	float vd(  ) {}
	float speed_accuracy(  ) {}
	float speed_accuracy(  ) {}
	float horiz_accuracy(  ) {}
	float horiz_accuracy(  ) {}
	float vert_accuracy(  ) {}
	float vert_accuracy(  ) {}
	int8_t satellites_visible(  ) {}
	int8_t satellites_visible(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct COMMAND_LONG {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const COMMAND_LONG &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		int8_t confirmation() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		float param1() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 3, 4))); }
		
		float param2() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 7, 4))); }
		
		float param3() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 11, 4))); }
		
		float param4() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 15, 4))); }
		
		float param5() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 19, 4))); }
		
		float param6() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 23, 4))); }
		
		float param7() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 27, 4))); }
		
		
		struct command_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_CMD value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		command_ command() const {
			if (data_.base.field_bit != 250 && !set_field(&data_, 250, -1)) return {0, 0};
			command_ ret{true, static_cast< enum MAV_CMD > ( MAV_CMD_from(get_bits(data_.base.bytes, data_.BIT, 8)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void command( enum com::company::demo:: MAV_CMD src  ) {}
	void confirmation( int8_t src  ) {}
	void param1( float src  ) {}
	void param2( float src  ) {}
	void param3( float src  ) {}
	void param4( float src  ) {}
	void param5( float src  ) {}
	void param6( float src  ) {}
	void param7( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct COMPASSMOT_STATUS {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		COMPASSMOT_STATUS(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const COMPASSMOT_STATUS &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 20) == 0);
		}
		
		int16_t throttle() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void throttle(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t interference() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void interference(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		float current() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void current(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float CompensationX() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void CompensationX(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float CompensationY() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void CompensationY(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		float CompensationZ() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		void CompensationZ(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 16); }
		
		
		/*
struct <DST> {
	void throttle( int16_t src  ) {}
	void current( float src  ) {}
	void interference( int16_t src  ) {}
	void CompensationX( float src  ) {}
	void CompensationY( float src  ) {}
	void CompensationZ( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t throttle(  ) {}
	int16_t throttle(  ) {}
	float current(  ) {}
	float current(  ) {}
	int16_t interference(  ) {}
	int16_t interference(  ) {}
	float CompensationX(  ) {}
	float CompensationX(  ) {}
	float CompensationY(  ) {}
	float CompensationY(  ) {}
	float CompensationZ(  ) {}
	float CompensationZ(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LOG_REQUEST_DATA {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LOG_REQUEST_DATA(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LOG_REQUEST_DATA &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 12) == 0);
		}
		
		int16_t id() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void id(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int32_t ofs() const { return (static_cast< int32_t > (get_bytes(&data_, 2, 4))); }
		
		void ofs(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 2); }
		
		int32_t count() const { return (static_cast< int32_t > (get_bytes(&data_, 6, 4))); }
		
		void count(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 6); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[10] ); }
		
		void target_system(int8_t src) const { (&data_)[10] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[11] ); }
		
		void target_component(int8_t src) const { (&data_)[11] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void id( int16_t src  ) {}
	void ofs( int32_t src  ) {}
	void count( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int16_t id(  ) {}
	int16_t id(  ) {}
	int32_t ofs(  ) {}
	int32_t ofs(  ) {}
	int32_t count(  ) {}
	int32_t count(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GPS_RAW_INT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const GPS_RAW_INT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t eph() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int16_t epv() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		int16_t vel() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		int16_t cog() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 6, 2))); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 8, 8))); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 16, 4))); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 20, 4))); }
		
		int32_t alt() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 24, 4))); }
		
		int8_t satellites_visible() const { return static_cast< int8_t >((data_.base.bytes)[28] ); }
		
		
		struct fix_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GPS_FIX_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		fix_type_ fix_type() const {
			if (data_.base.field_bit != 234 && !set_field(&data_, 234, -1)) return {0, 0};
			fix_type_ ret{true, static_cast< enum GPS_FIX_TYPE > (    static_cast< enum GPS_FIX_TYPE >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		struct alt_ellipsoid_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int32_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		alt_ellipsoid_ alt_ellipsoid() const {
			if (data_.base.field_bit != 235 && !set_field(&data_, 235, -1)) return {0, 0};
			alt_ellipsoid_ ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		struct h_acc_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int32_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		h_acc_ h_acc() const {
			if (data_.base.field_bit != 236 && !set_field(&data_, 236, -1)) return {0, 0};
			h_acc_ ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		struct v_acc_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int32_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		v_acc_ v_acc() const {
			if (data_.base.field_bit != 237 && !set_field(&data_, 237, -1)) return {0, 0};
			v_acc_ ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		struct vel_acc_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int32_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		vel_acc_ vel_acc() const {
			if (data_.base.field_bit != 238 && !set_field(&data_, 238, -1)) return {0, 0};
			vel_acc_ ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		struct hdg_acc_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int32_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		hdg_acc_ hdg_acc() const {
			if (data_.base.field_bit != 239 && !set_field(&data_, 239, -1)) return {0, 0};
			hdg_acc_ ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void fix_type( enum com::company::demo:: GPS_FIX_TYPE src  ) {}
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void alt( int32_t src  ) {}
	void eph( int16_t src  ) {}
	void epv( int16_t src  ) {}
	void vel( int16_t src  ) {}
	void cog( int16_t src  ) {}
	void satellites_visible( int8_t src  ) {}
	void alt_ellipsoid( int32_t src  ) {}
	void h_acc( int32_t src  ) {}
	void v_acc( int32_t src  ) {}
	void vel_acc( int32_t src  ) {}
	void hdg_acc( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct CAMERA_STATUS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const CAMERA_STATUS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t img_idx() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void img_idx(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 2, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 2); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[10] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[10] = (uint8_t) (src); }
		
		int8_t cam_idx() const { return static_cast< int8_t >((data_.base.bytes)[11] ); }
		
		void cam_idx(int8_t src) const { (data_.base.bytes)[11] = (uint8_t) (src); }
		
		float p1() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		void p1(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 12); }
		
		float p2() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		void p2(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 16); }
		
		float p3() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 20, 4))); }
		
		void p3(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 20); }
		
		float p4() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 24, 4))); }
		
		void p4(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 24); }
		
		struct event_id_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum CAMERA_STATUS_TYPES value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		event_id_ event_id() const {
			if (data_.base.field_bit != 224 && !set_field(&data_, 224, -1)) return {0, 0};
			event_id_ ret{true, static_cast< enum CAMERA_STATUS_TYPES > (    static_cast< enum CAMERA_STATUS_TYPES >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void event_id(enum CAMERA_STATUS_TYPES src) const {
			
			if (data_.base.field_bit != 224) set_field(&data_, 224, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void target_system( int8_t src  ) {}
	void cam_idx( int8_t src  ) {}
	void img_idx( int16_t src  ) {}
	void event_id( enum com::company::demo:: CAMERA_STATUS_TYPES src  ) {}
	void p1( float src  ) {}
	void p2( float src  ) {}
	void p3( float src  ) {}
	void p4( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t cam_idx(  ) {}
	int8_t cam_idx(  ) {}
	int16_t img_idx(  ) {}
	int16_t img_idx(  ) {}
	enum com::company::demo:: CAMERA_STATUS_TYPES event_id(  ) {}
	bool event_id_exists(){}
	float p1(  ) {}
	float p1(  ) {}
	float p2(  ) {}
	float p2(  ) {}
	float p3(  ) {}
	float p3(  ) {}
	float p4(  ) {}
	float p4(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct RC_CHANNELS_SCALED {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RC_CHANNELS_SCALED(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RC_CHANNELS_SCALED &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 22) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		int8_t port() const { return static_cast< int8_t >((&data_)[4] ); }
		
		int16_t chan1_scaled() const { return (static_cast< int16_t > (get_bytes(&data_, 5, 2))); }
		
		int16_t chan2_scaled() const { return (static_cast< int16_t > (get_bytes(&data_, 7, 2))); }
		
		int16_t chan3_scaled() const { return (static_cast< int16_t > (get_bytes(&data_, 9, 2))); }
		
		int16_t chan4_scaled() const { return (static_cast< int16_t > (get_bytes(&data_, 11, 2))); }
		
		int16_t chan5_scaled() const { return (static_cast< int16_t > (get_bytes(&data_, 13, 2))); }
		
		int16_t chan6_scaled() const { return (static_cast< int16_t > (get_bytes(&data_, 15, 2))); }
		
		int16_t chan7_scaled() const { return (static_cast< int16_t > (get_bytes(&data_, 17, 2))); }
		
		int16_t chan8_scaled() const { return (static_cast< int16_t > (get_bytes(&data_, 19, 2))); }
		
		int8_t rssi() const { return static_cast< int8_t >((&data_)[21] ); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void port( int8_t src  ) {}
	void chan1_scaled( int16_t src  ) {}
	void chan2_scaled( int16_t src  ) {}
	void chan3_scaled( int16_t src  ) {}
	void chan4_scaled( int16_t src  ) {}
	void chan5_scaled( int16_t src  ) {}
	void chan6_scaled( int16_t src  ) {}
	void chan7_scaled( int16_t src  ) {}
	void chan8_scaled( int16_t src  ) {}
	void rssi( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct CAMERA_SETTINGS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const CAMERA_SETTINGS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 0); }
		
		struct mode_id_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum CAMERA_MODE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mode_id_ mode_id() const {
			if (data_.base.field_bit != 32 && !set_field(&data_, 32, -1)) return {0, 0};
			mode_id_ ret{true, static_cast< enum CAMERA_MODE > (    static_cast< enum CAMERA_MODE >(   get_bits(data_.base.bytes, data_.BIT, 2)))};
			return ret;
		}
		
		
		void mode_id(enum CAMERA_MODE src) const {
			
			if (data_.base.field_bit != 32) set_field(&data_, 32, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 2, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void mode_id( enum com::company::demo:: CAMERA_MODE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	enum com::company::demo:: CAMERA_MODE mode_id(  ) {}
	bool mode_id_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct DEVICE_OP_READ_REPLY {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		DEVICE_OP_READ_REPLY(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const DEVICE_OP_READ_REPLY &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 135) == 0);
		}
		
		int32_t request_id() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void request_id(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int8_t result() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void result(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		int8_t regstart() const { return static_cast< int8_t >((&data_)[5] ); }
		
		void regstart(int8_t src) const { (&data_)[5] = (uint8_t) (src); }
		
		int8_t count() const { return static_cast< int8_t >((&data_)[6] ); }
		
		void count(int8_t src) const { (&data_)[6] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 128}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 128;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 7};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 7};
				for (size_t  i     = 0; i < 128; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{&data_ + 7};
			if (src)
				for (size_t i = 0; i < 128; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void request_id( int32_t src  ) {}
	void result( int8_t src  ) {}
	void regstart( int8_t src  ) {}
	void count( int8_t src  ) {}
	void daTa( const struct com::company::demo::DEVICE_OP_READ_REPLY :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t request_id(  ) {}
	int32_t request_id(  ) {}
	int8_t result(  ) {}
	int8_t result(  ) {}
	int8_t regstart(  ) {}
	int8_t regstart(  ) {}
	int8_t count(  ) {}
	int8_t count(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct RAW_PRESSURE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RAW_PRESSURE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RAW_PRESSURE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 16) == 0);
		}
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		int16_t press_abs() const { return (static_cast< int16_t > (get_bytes(&data_, 8, 2))); }
		
		int16_t press_diff1() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		int16_t press_diff2() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		int16_t temperature() const { return (static_cast< int16_t > (get_bytes(&data_, 14, 2))); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void press_abs( int16_t src  ) {}
	void press_diff1( int16_t src  ) {}
	void press_diff2( int16_t src  ) {}
	void temperature( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct DIGICAM_CONTROL {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		DIGICAM_CONTROL(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const DIGICAM_CONTROL &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 13) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		int8_t session() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void session(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		int8_t zoom_pos() const { return static_cast< int8_t >((&data_)[3] ); }
		
		void zoom_pos(int8_t src) const { (&data_)[3] = (uint8_t) (src); }
		
		int8_t zoom_step() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void zoom_step(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		int8_t focus_lock() const { return static_cast< int8_t >((&data_)[5] ); }
		
		void focus_lock(int8_t src) const { (&data_)[5] = (uint8_t) (src); }
		
		int8_t shot() const { return static_cast< int8_t >((&data_)[6] ); }
		
		void shot(int8_t src) const { (&data_)[6] = (uint8_t) (src); }
		
		int8_t command_id() const { return static_cast< int8_t >((&data_)[7] ); }
		
		void command_id(int8_t src) const { (&data_)[7] = (uint8_t) (src); }
		
		int8_t extra_param() const { return static_cast< int8_t >((&data_)[8] ); }
		
		void extra_param(int8_t src) const { (&data_)[8] = (uint8_t) (src); }
		
		float extra_value() const { return (intBitsToFloat(get_bytes(&data_, 9, 4))); }
		
		void extra_value(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 9); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void session( int8_t src  ) {}
	void zoom_pos( int8_t src  ) {}
	void zoom_step( int8_t src  ) {}
	void focus_lock( int8_t src  ) {}
	void shot( int8_t src  ) {}
	void command_id( int8_t src  ) {}
	void extra_param( int8_t src  ) {}
	void extra_value( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int8_t session(  ) {}
	int8_t session(  ) {}
	int8_t zoom_pos(  ) {}
	int8_t zoom_pos(  ) {}
	int8_t zoom_step(  ) {}
	int8_t zoom_step(  ) {}
	int8_t focus_lock(  ) {}
	int8_t focus_lock(  ) {}
	int8_t shot(  ) {}
	int8_t shot(  ) {}
	int8_t command_id(  ) {}
	int8_t command_id(  ) {}
	int8_t extra_param(  ) {}
	int8_t extra_param(  ) {}
	float extra_value(  ) {}
	float extra_value(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct NAMED_VALUE_FLOAT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const NAMED_VALUE_FLOAT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 0); }
		
		float value() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 4, 4))); }
		
		void value(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 4); }
		
		struct name_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		name_ name() const {
			if (data_.base.field_bit != 66 && !set_field(&data_, 66, -1)) return {0, 0, 0};
			
			name_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			name_ name(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 66) set_field(&data_, 66, len);
				const name_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		name_ name(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 66) set_field(&data_, 66, len);
			const name_     ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void name( const struct com::company::demo::NAMED_VALUE_FLOAT :: name_::CASE::EXISTS  & src  ) const {}
	void value( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	std container of chars  name(  ) {}
	bool name_exists(){}
	float value(  ) {}
	float value(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GOPRO_HEARTBEAT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const GOPRO_HEARTBEAT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct status_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GOPRO_HEARTBEAT_STATUS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		status_ status() const {
			if (data_.base.field_bit != 2 && !set_field(&data_, 2, -1)) return {0, 0};
			status_ ret{true, static_cast< enum GOPRO_HEARTBEAT_STATUS > (    static_cast< enum GOPRO_HEARTBEAT_STATUS >(   get_bits(data_.base.bytes, data_.BIT, 2)))};
			return ret;
		}
		
		
		void status(enum GOPRO_HEARTBEAT_STATUS src) const {
			
			if (data_.base.field_bit != 2) set_field(&data_, 2, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 2, data_.base.bytes, data_.BIT);
		}
		
		
		struct capture_mode_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GOPRO_CAPTURE_MODE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		capture_mode_ capture_mode() const {
			if (data_.base.field_bit != 3 && !set_field(&data_, 3, -1)) return {0, 0};
			capture_mode_ ret{true, static_cast< enum GOPRO_CAPTURE_MODE > ( GOPRO_CAPTURE_MODE_from(get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void capture_mode(enum GOPRO_CAPTURE_MODE src) const {
			
			if (data_.base.field_bit != 3) set_field(&data_, 3, 0);
			
			set_bits(GOPRO_CAPTURE_MODE_into(src), 4, data_.base.bytes, data_.BIT);
		}
		
		
		struct flags_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GOPRO_HEARTBEAT_FLAGS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		flags_ flags() const {
			if (data_.base.field_bit != 4 && !set_field(&data_, 4, -1)) return {0, 0};
			flags_ ret{true, static_cast< enum GOPRO_HEARTBEAT_FLAGS > (    static_cast< enum GOPRO_HEARTBEAT_FLAGS >( 1 + get_bits(data_.base.bytes, data_.BIT, 1)))};
			return ret;
		}
		
		
		void flags(enum GOPRO_HEARTBEAT_FLAGS src) const {
			
			if (data_.base.field_bit != 4) set_field(&data_, 4, 0);
			
			set_bits(static_cast< uintptr_t >(  -1
			src  ), 1, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void status( enum com::company::demo:: GOPRO_HEARTBEAT_STATUS src  ) {}
	void capture_mode( enum com::company::demo:: GOPRO_CAPTURE_MODE src  ) {}
	void flags( enum com::company::demo:: GOPRO_HEARTBEAT_FLAGS src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: GOPRO_HEARTBEAT_STATUS status(  ) {}
	bool status_exists(){}
	enum com::company::demo:: GOPRO_CAPTURE_MODE capture_mode(  ) {}
	bool capture_mode_exists(){}
	enum com::company::demo:: GOPRO_HEARTBEAT_FLAGS flags(  ) {}
	bool flags_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct ATTITUDE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		ATTITUDE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const ATTITUDE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 28) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		float rollspeed() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		float pitchspeed() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		float yawspeed() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
	void rollspeed( float src  ) {}
	void pitchspeed( float src  ) {}
	void yawspeed( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct MISSION_WRITE_PARTIAL_LIST {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MISSION_WRITE_PARTIAL_LIST &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		int16_t start_index() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		int16_t end_index() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		
		struct mission_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MISSION_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mission_type_ mission_type() const {
			if (data_.base.field_bit != 48 && !set_field(&data_, 48, -1)) return {0, 0};
			mission_type_ ret{true, static_cast< enum MAV_MISSION_TYPE > ( MAV_MISSION_TYPE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void start_index( int16_t src  ) {}
	void end_index( int16_t src  ) {}
	void mission_type( enum com::company::demo:: MAV_MISSION_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct AHRS2 {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		AHRS2(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const AHRS2 &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 24) == 0);
		}
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 0, 4))); }
		
		void roll(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 0); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void pitch(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void yaw(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float altitude() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void altitude(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 16, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 16); }
		
		int32_t lng() const { return (static_cast< int32_t > (get_bytes(&data_, 20, 4))); }
		
		void lng(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 20); }
		
		
		/*
struct <DST> {
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
	void altitude( float src  ) {}
	void lat( int32_t src  ) {}
	void lng( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	float roll(  ) {}
	float roll(  ) {}
	float pitch(  ) {}
	float pitch(  ) {}
	float yaw(  ) {}
	float yaw(  ) {}
	float altitude(  ) {}
	float altitude(  ) {}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lng(  ) {}
	int32_t lng(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LOG_ERASE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LOG_ERASE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LOG_ERASE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 2) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct TERRAIN_REQUEST {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		TERRAIN_REQUEST(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const TERRAIN_REQUEST &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 18) == 0);
		}
		
		int16_t grid_spacing() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void grid_spacing(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int64_t mask() const { return (static_cast< int64_t > (get_bytes(&data_, 2, 8))); }
		
		void mask(int64_t src) const { set_bytes((src), 8, &data_, 2); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 10, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 10); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(&data_, 14, 4))); }
		
		void lon(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 14); }
		
		
		/*
struct <DST> {
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void grid_spacing( int16_t src  ) {}
	void mask( int64_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lon(  ) {}
	int32_t lon(  ) {}
	int16_t grid_spacing(  ) {}
	int16_t grid_spacing(  ) {}
	int64_t mask(  ) {}
	int64_t mask(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MOUNT_STATUS {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		MOUNT_STATUS(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const MOUNT_STATUS &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 14) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		int32_t pointing_a() const { return (static_cast< int32_t > (get_bytes(&data_, 2, 4))); }
		
		void pointing_a(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 2); }
		
		int32_t pointing_b() const { return (static_cast< int32_t > (get_bytes(&data_, 6, 4))); }
		
		void pointing_b(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 6); }
		
		int32_t pointing_c() const { return (static_cast< int32_t > (get_bytes(&data_, 10, 4))); }
		
		void pointing_c(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 10); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void pointing_a( int32_t src  ) {}
	void pointing_b( int32_t src  ) {}
	void pointing_c( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int32_t pointing_a(  ) {}
	int32_t pointing_a(  ) {}
	int32_t pointing_b(  ) {}
	int32_t pointing_b(  ) {}
	int32_t pointing_c(  ) {}
	int32_t pointing_c(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MANUAL_SETPOINT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		MANUAL_SETPOINT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const MANUAL_SETPOINT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 22) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		float thrust() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		int8_t mode_switch() const { return static_cast< int8_t >((&data_)[20] ); }
		
		int8_t manual_override_switch() const { return static_cast< int8_t >((&data_)[21] ); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
	void thrust( float src  ) {}
	void mode_switch( int8_t src  ) {}
	void manual_override_switch( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct PID_TUNING {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const PID_TUNING &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		float desired() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 0, 4))); }
		
		void desired(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 0); }
		
		float achieved() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 4, 4))); }
		
		void achieved(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 4); }
		
		float FF() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 8, 4))); }
		
		void FF(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 8); }
		
		float P() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		void P(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 12); }
		
		float I() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		void I(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 16); }
		
		float D() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 20, 4))); }
		
		void D(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 20); }
		
		struct axis_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum PID_TUNING_AXIS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		axis_ axis() const {
			if (data_.base.field_bit != 192 && !set_field(&data_, 192, -1)) return {0, 0};
			axis_ ret{true, static_cast< enum PID_TUNING_AXIS > (    static_cast< enum PID_TUNING_AXIS >( 1 + get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void axis(enum PID_TUNING_AXIS src) const {
			
			if (data_.base.field_bit != 192) set_field(&data_, 192, 0);
			
			set_bits(static_cast< uintptr_t >(  -1
			src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void axis( enum com::company::demo:: PID_TUNING_AXIS src  ) {}
	void desired( float src  ) {}
	void achieved( float src  ) {}
	void FF( float src  ) {}
	void P( float src  ) {}
	void I( float src  ) {}
	void D( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: PID_TUNING_AXIS axis(  ) {}
	bool axis_exists(){}
	float desired(  ) {}
	float desired(  ) {}
	float achieved(  ) {}
	float achieved(  ) {}
	float FF(  ) {}
	float FF(  ) {}
	float P(  ) {}
	float P(  ) {}
	float I(  ) {}
	float I(  ) {}
	float D(  ) {}
	float D(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SAFETY_ALLOWED_AREA {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const SAFETY_ALLOWED_AREA &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		float p1x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 0, 4))); }
		
		float p1y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 4, 4))); }
		
		float p1z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 8, 4))); }
		
		float p2x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		float p2y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		float p2z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 20, 4))); }
		
		
		struct frame_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_FRAME value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		frame_ frame() const {
			if (data_.base.field_bit != 192 && !set_field(&data_, 192, -1)) return {0, 0};
			frame_ ret{true, static_cast< enum MAV_FRAME > (    static_cast< enum MAV_FRAME >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void frame( enum com::company::demo:: MAV_FRAME src  ) {}
	void p1x( float src  ) {}
	void p1y( float src  ) {}
	void p1z( float src  ) {}
	void p2x( float src  ) {}
	void p2y( float src  ) {}
	void p2z( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct OPTICAL_FLOW_RAD {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		OPTICAL_FLOW_RAD(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const OPTICAL_FLOW_RAD &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 44) == 0);
		}
		
		int32_t integration_time_us() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void integration_time_us(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int32_t time_delta_distance_us() const { return (static_cast< int32_t > (get_bytes(&data_, 4, 4))); }
		
		void time_delta_distance_us(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 4); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 8, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 8); }
		
		int8_t sensor_id() const { return static_cast< int8_t >((&data_)[16] ); }
		
		void sensor_id(int8_t src) const { (&data_)[16] = (uint8_t) (src); }
		
		float integrated_x() const { return (intBitsToFloat(get_bytes(&data_, 17, 4))); }
		
		void integrated_x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 17); }
		
		float integrated_y() const { return (intBitsToFloat(get_bytes(&data_, 21, 4))); }
		
		void integrated_y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 21); }
		
		float integrated_xgyro() const { return (intBitsToFloat(get_bytes(&data_, 25, 4))); }
		
		void integrated_xgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 25); }
		
		float integrated_ygyro() const { return (intBitsToFloat(get_bytes(&data_, 29, 4))); }
		
		void integrated_ygyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 29); }
		
		float integrated_zgyro() const { return (intBitsToFloat(get_bytes(&data_, 33, 4))); }
		
		void integrated_zgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 33); }
		
		int16_t temperature() const { return (static_cast< int16_t > (get_bytes(&data_, 37, 2))); }
		
		void temperature(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 37); }
		
		int8_t quality() const { return static_cast< int8_t >((&data_)[39] ); }
		
		void quality(int8_t src) const { (&data_)[39] = (uint8_t) (src); }
		
		float distance() const { return (intBitsToFloat(get_bytes(&data_, 40, 4))); }
		
		void distance(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 40); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void sensor_id( int8_t src  ) {}
	void integration_time_us( int32_t src  ) {}
	void integrated_x( float src  ) {}
	void integrated_y( float src  ) {}
	void integrated_xgyro( float src  ) {}
	void integrated_ygyro( float src  ) {}
	void integrated_zgyro( float src  ) {}
	void temperature( int16_t src  ) {}
	void quality( int8_t src  ) {}
	void time_delta_distance_us( int32_t src  ) {}
	void distance( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int8_t sensor_id(  ) {}
	int8_t sensor_id(  ) {}
	int32_t integration_time_us(  ) {}
	int32_t integration_time_us(  ) {}
	float integrated_x(  ) {}
	float integrated_x(  ) {}
	float integrated_y(  ) {}
	float integrated_y(  ) {}
	float integrated_xgyro(  ) {}
	float integrated_xgyro(  ) {}
	float integrated_ygyro(  ) {}
	float integrated_ygyro(  ) {}
	float integrated_zgyro(  ) {}
	float integrated_zgyro(  ) {}
	int16_t temperature(  ) {}
	int16_t temperature(  ) {}
	int8_t quality(  ) {}
	int8_t quality(  ) {}
	int32_t time_delta_distance_us(  ) {}
	int32_t time_delta_distance_us(  ) {}
	float distance(  ) {}
	float distance(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LOG_DATA {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LOG_DATA(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LOG_DATA &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 97) == 0);
		}
		
		int16_t id() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void id(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int32_t ofs() const { return (static_cast< int32_t > (get_bytes(&data_, 2, 4))); }
		
		void ofs(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 2); }
		
		int8_t count() const { return static_cast< int8_t >((&data_)[6] ); }
		
		void count(int8_t src) const { (&data_)[6] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 90}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 90;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 7};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 7};
				for (size_t  i     = 0; i < 90; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{&data_ + 7};
			if (src)
				for (size_t i = 0; i < 90; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void id( int16_t src  ) {}
	void ofs( int32_t src  ) {}
	void count( int8_t src  ) {}
	void daTa( const struct com::company::demo::LOG_DATA :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t id(  ) {}
	int16_t id(  ) {}
	int32_t ofs(  ) {}
	int32_t ofs(  ) {}
	int8_t count(  ) {}
	int8_t count(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MISSION_CLEAR_ALL {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MISSION_CLEAR_ALL &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		
		struct mission_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MISSION_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mission_type_ mission_type() const {
			if (data_.base.field_bit != 16 && !set_field(&data_, 16, -1)) return {0, 0};
			mission_type_ ret{true, static_cast< enum MAV_MISSION_TYPE > ( MAV_MISSION_TYPE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void mission_type( enum com::company::demo:: MAV_MISSION_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct AHRS3 {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		AHRS3(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const AHRS3 &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 40) == 0);
		}
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 0, 4))); }
		
		void roll(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 0); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void pitch(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void yaw(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float altitude() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void altitude(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 16, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 16); }
		
		int32_t lng() const { return (static_cast< int32_t > (get_bytes(&data_, 20, 4))); }
		
		void lng(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 20); }
		
		float v1() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void v1(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		float v2() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void v2(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		float v3() const { return (intBitsToFloat(get_bytes(&data_, 32, 4))); }
		
		void v3(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 32); }
		
		float v4() const { return (intBitsToFloat(get_bytes(&data_, 36, 4))); }
		
		void v4(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 36); }
		
		
		/*
struct <DST> {
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
	void altitude( float src  ) {}
	void lat( int32_t src  ) {}
	void lng( int32_t src  ) {}
	void v1( float src  ) {}
	void v2( float src  ) {}
	void v3( float src  ) {}
	void v4( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	float roll(  ) {}
	float roll(  ) {}
	float pitch(  ) {}
	float pitch(  ) {}
	float yaw(  ) {}
	float yaw(  ) {}
	float altitude(  ) {}
	float altitude(  ) {}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lng(  ) {}
	int32_t lng(  ) {}
	float v1(  ) {}
	float v1(  ) {}
	float v2(  ) {}
	float v2(  ) {}
	float v3(  ) {}
	float v3(  ) {}
	float v4(  ) {}
	float v4(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct VICON_POSITION_ESTIMATE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		VICON_POSITION_ESTIMATE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const VICON_POSITION_ESTIMATE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 32) == 0);
		}
		
		int64_t usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void usec(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		float x() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float y() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		float z() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		void z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 16); }
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		void roll(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 20); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void pitch(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void yaw(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		
		/*
struct <DST> {
	void usec( int64_t src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t usec(  ) {}
	int64_t usec(  ) {}
	float x(  ) {}
	float x(  ) {}
	float y(  ) {}
	float y(  ) {}
	float z(  ) {}
	float z(  ) {}
	float roll(  ) {}
	float roll(  ) {}
	float pitch(  ) {}
	float pitch(  ) {}
	float yaw(  ) {}
	float yaw(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GPS2_RTK {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		GPS2_RTK(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const GPS2_RTK &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 35) == 0);
		}
		
		int16_t wn() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void wn(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int32_t time_last_baseline_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 2, 4))); }
		
		void time_last_baseline_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 2); }
		
		int32_t tow() const { return (static_cast< int32_t > (get_bytes(&data_, 6, 4))); }
		
		void tow(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 6); }
		
		int32_t accuracy() const { return (static_cast< int32_t > (get_bytes(&data_, 10, 4))); }
		
		void accuracy(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 10); }
		
		int8_t rtk_receiver_id() const { return static_cast< int8_t >((&data_)[14] ); }
		
		void rtk_receiver_id(int8_t src) const { (&data_)[14] = (uint8_t) (src); }
		
		int8_t rtk_health() const { return static_cast< int8_t >((&data_)[15] ); }
		
		void rtk_health(int8_t src) const { (&data_)[15] = (uint8_t) (src); }
		
		int8_t rtk_rate() const { return static_cast< int8_t >((&data_)[16] ); }
		
		void rtk_rate(int8_t src) const { (&data_)[16] = (uint8_t) (src); }
		
		int8_t nsats() const { return static_cast< int8_t >((&data_)[17] ); }
		
		void nsats(int8_t src) const { (&data_)[17] = (uint8_t) (src); }
		
		int8_t baseline_coords_type() const { return static_cast< int8_t >((&data_)[18] ); }
		
		void baseline_coords_type(int8_t src) const { (&data_)[18] = (uint8_t) (src); }
		
		int32_t baseline_a_mm() const { return (static_cast< int32_t > (get_bytes(&data_, 19, 4))); }
		
		void baseline_a_mm(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 19); }
		
		int32_t baseline_b_mm() const { return (static_cast< int32_t > (get_bytes(&data_, 23, 4))); }
		
		void baseline_b_mm(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 23); }
		
		int32_t baseline_c_mm() const { return (static_cast< int32_t > (get_bytes(&data_, 27, 4))); }
		
		void baseline_c_mm(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 27); }
		
		int32_t iar_num_hypotheses() const { return (static_cast< int32_t > (get_bytes(&data_, 31, 4))); }
		
		void iar_num_hypotheses(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 31); }
		
		
		/*
struct <DST> {
	void time_last_baseline_ms( int32_t src  ) {}
	void rtk_receiver_id( int8_t src  ) {}
	void wn( int16_t src  ) {}
	void tow( int32_t src  ) {}
	void rtk_health( int8_t src  ) {}
	void rtk_rate( int8_t src  ) {}
	void nsats( int8_t src  ) {}
	void baseline_coords_type( int8_t src  ) {}
	void baseline_a_mm( int32_t src  ) {}
	void baseline_b_mm( int32_t src  ) {}
	void baseline_c_mm( int32_t src  ) {}
	void accuracy( int32_t src  ) {}
	void iar_num_hypotheses( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_last_baseline_ms(  ) {}
	int32_t time_last_baseline_ms(  ) {}
	int8_t rtk_receiver_id(  ) {}
	int8_t rtk_receiver_id(  ) {}
	int16_t wn(  ) {}
	int16_t wn(  ) {}
	int32_t tow(  ) {}
	int32_t tow(  ) {}
	int8_t rtk_health(  ) {}
	int8_t rtk_health(  ) {}
	int8_t rtk_rate(  ) {}
	int8_t rtk_rate(  ) {}
	int8_t nsats(  ) {}
	int8_t nsats(  ) {}
	int8_t baseline_coords_type(  ) {}
	int8_t baseline_coords_type(  ) {}
	int32_t baseline_a_mm(  ) {}
	int32_t baseline_a_mm(  ) {}
	int32_t baseline_b_mm(  ) {}
	int32_t baseline_b_mm(  ) {}
	int32_t baseline_c_mm(  ) {}
	int32_t baseline_c_mm(  ) {}
	int32_t accuracy(  ) {}
	int32_t accuracy(  ) {}
	int32_t iar_num_hypotheses(  ) {}
	int32_t iar_num_hypotheses(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MAG_CAL_REPORT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MAG_CAL_REPORT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t compass_id() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		void compass_id(int8_t src) const { (data_.base.bytes)[0] = (uint8_t) (src); }
		
		int8_t cal_mask() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		void cal_mask(int8_t src) const { (data_.base.bytes)[1] = (uint8_t) (src); }
		
		int8_t autosaved() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		void autosaved(int8_t src) const { (data_.base.bytes)[2] = (uint8_t) (src); }
		
		float fitness() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 3, 4))); }
		
		void fitness(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 3); }
		
		float ofs_x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 7, 4))); }
		
		void ofs_x(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 7); }
		
		float ofs_y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 11, 4))); }
		
		void ofs_y(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 11); }
		
		float ofs_z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 15, 4))); }
		
		void ofs_z(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 15); }
		
		float diag_x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 19, 4))); }
		
		void diag_x(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 19); }
		
		float diag_y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 23, 4))); }
		
		void diag_y(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 23); }
		
		float diag_z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 27, 4))); }
		
		void diag_z(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 27); }
		
		float offdiag_x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 31, 4))); }
		
		void offdiag_x(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 31); }
		
		float offdiag_y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 35, 4))); }
		
		void offdiag_y(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 35); }
		
		float offdiag_z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 39, 4))); }
		
		void offdiag_z(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 39); }
		
		struct cal_status_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAG_CAL_STATUS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		cal_status_ cal_status() const {
			if (data_.base.field_bit != 344 && !set_field(&data_, 344, -1)) return {0, 0};
			cal_status_ ret{true, static_cast< enum MAG_CAL_STATUS > (    static_cast< enum MAG_CAL_STATUS >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void cal_status(enum MAG_CAL_STATUS src) const {
			
			if (data_.base.field_bit != 344) set_field(&data_, 344, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void compass_id( int8_t src  ) {}
	void cal_mask( int8_t src  ) {}
	void cal_status( enum com::company::demo:: MAG_CAL_STATUS src  ) {}
	void autosaved( int8_t src  ) {}
	void fitness( float src  ) {}
	void ofs_x( float src  ) {}
	void ofs_y( float src  ) {}
	void ofs_z( float src  ) {}
	void diag_x( float src  ) {}
	void diag_y( float src  ) {}
	void diag_z( float src  ) {}
	void offdiag_x( float src  ) {}
	void offdiag_y( float src  ) {}
	void offdiag_z( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t compass_id(  ) {}
	int8_t compass_id(  ) {}
	int8_t cal_mask(  ) {}
	int8_t cal_mask(  ) {}
	enum com::company::demo:: MAG_CAL_STATUS cal_status(  ) {}
	bool cal_status_exists(){}
	int8_t autosaved(  ) {}
	int8_t autosaved(  ) {}
	float fitness(  ) {}
	float fitness(  ) {}
	float ofs_x(  ) {}
	float ofs_x(  ) {}
	float ofs_y(  ) {}
	float ofs_y(  ) {}
	float ofs_z(  ) {}
	float ofs_z(  ) {}
	float diag_x(  ) {}
	float diag_x(  ) {}
	float diag_y(  ) {}
	float diag_y(  ) {}
	float diag_z(  ) {}
	float diag_z(  ) {}
	float offdiag_x(  ) {}
	float offdiag_x(  ) {}
	float offdiag_y(  ) {}
	float offdiag_y(  ) {}
	float offdiag_z(  ) {}
	float offdiag_z(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LOG_REQUEST_LIST {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LOG_REQUEST_LIST(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LOG_REQUEST_LIST &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 6) == 0);
		}
		
		int16_t start() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void start(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t end() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void end(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void target_system(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[5] ); }
		
		void target_component(int8_t src) const { (&data_)[5] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void start( int16_t src  ) {}
	void end( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int16_t start(  ) {}
	int16_t start(  ) {}
	int16_t end(  ) {}
	int16_t end(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SCALED_PRESSURE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SCALED_PRESSURE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SCALED_PRESSURE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 14) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		float press_abs() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		float press_diff() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		int16_t temperature() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void press_abs( float src  ) {}
	void press_diff( float src  ) {}
	void temperature( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct V2_EXTENSION {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		V2_EXTENSION(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const V2_EXTENSION &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 254) == 0);
		}
		
		int16_t message_type() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void message_type(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int8_t target_network() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void target_network(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[3] ); }
		
		void target_system(int8_t src) const { (&data_)[3] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void target_component(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		struct payload_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, payload_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, payload_> end() const { return {*this, 249}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 249;
			
		};
		
		struct payload_ payload() const {
			struct payload_ ret{&data_ + 5};
			return ret;
		}
		
		template<typename int8_src_container>
			payload_ payload(const int8_src_container &src) const {
				auto            first = src.begin();
				struct payload_ ret{&data_ + 5};
				for (size_t     i     = 0; i < 249; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		payload_ payload(int8_t *const src) const { return payload(static_cast<int8_t const *>( src)); }
		
		payload_ payload(int8_t const *const src) const {
			struct payload_ ret{&data_ + 5};
			if (src)
				for (size_t i = 0; i < 249; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_network( int8_t src  ) {}
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void message_type( int16_t src  ) {}
	void payload( const struct com::company::demo::V2_EXTENSION :: payload_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_network(  ) {}
	int8_t target_network(  ) {}
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int16_t message_type(  ) {}
	int16_t message_type(  ) {}
	std container of int8  payload(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct HEARTBEAT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const HEARTBEAT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t custom_mode() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		int8_t mavlink_version() const { return static_cast< int8_t >((data_.base.bytes)[4] ); }
		
		
		struct typE_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		typE_ typE() const {
			if (data_.base.field_bit != 42 && !set_field(&data_, 42, -1)) return {0, 0};
			typE_ ret{true, static_cast< enum MAV_TYPE > (    static_cast< enum MAV_TYPE >(   get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		struct autopilot_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_AUTOPILOT value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		autopilot_ autopilot() const {
			if (data_.base.field_bit != 43 && !set_field(&data_, 43, -1)) return {0, 0};
			autopilot_ ret{true, static_cast< enum MAV_AUTOPILOT > (    static_cast< enum MAV_AUTOPILOT >(   get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		struct base_mode_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MODE_FLAG value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		base_mode_ base_mode() const {
			if (data_.base.field_bit != 44 && !set_field(&data_, 44, -1)) return {0, 0};
			base_mode_ ret{true, static_cast< enum MAV_MODE_FLAG > ( MAV_MODE_FLAG_from(get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		struct system_status_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_STATE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		system_status_ system_status() const {
			if (data_.base.field_bit != 45 && !set_field(&data_, 45, -1)) return {0, 0};
			system_status_ ret{true, static_cast< enum MAV_STATE > (    static_cast< enum MAV_STATE >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void typE( enum com::company::demo:: MAV_TYPE src  ) {}
	void autopilot( enum com::company::demo:: MAV_AUTOPILOT src  ) {}
	void base_mode( enum com::company::demo:: MAV_MODE_FLAG src  ) {}
	void custom_mode( int32_t src  ) {}
	void system_status( enum com::company::demo:: MAV_STATE src  ) {}
	void mavlink_version( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct PARAM_MAP_RC {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const PARAM_MAP_RC &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		int16_t param_index() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		int8_t parameter_rc_channel_index() const { return static_cast< int8_t >((data_.base.bytes)[4] ); }
		
		float param_value0() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 5, 4))); }
		
		float scale() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 9, 4))); }
		
		float param_value_min() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 13, 4))); }
		
		float param_value_max() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 17, 4))); }
		
		
		struct param_id_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		param_id_ param_id() const {
			if (data_.base.field_bit != 170 && !set_field(&data_, 170, -1)) return {0, 0, 0};
			
			param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void param_id( const struct com::company::demo::PARAM_MAP_RC :: param_id_::CASE::EXISTS  & src  ) const {}
	void param_index( int16_t src  ) {}
	void parameter_rc_channel_index( int8_t src  ) {}
	void param_value0( float src  ) {}
	void scale( float src  ) {}
	void param_value_min( float src  ) {}
	void param_value_max( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct POWER_STATUS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const POWER_STATUS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t Vcc() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void Vcc(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t Vservo() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void Vservo(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		struct flags_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_POWER_STATUS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		flags_ flags() const {
			if (data_.base.field_bit != 32 && !set_field(&data_, 32, -1)) return {0, 0};
			flags_ ret{true, static_cast< enum MAV_POWER_STATUS > ( MAV_POWER_STATUS_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void flags(enum MAV_POWER_STATUS src) const {
			
			if (data_.base.field_bit != 32) set_field(&data_, 32, 0);
			
			set_bits(MAV_POWER_STATUS_into(src), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void Vcc( int16_t src  ) {}
	void Vservo( int16_t src  ) {}
	void flags( enum com::company::demo:: MAV_POWER_STATUS src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t Vcc(  ) {}
	int16_t Vcc(  ) {}
	int16_t Vservo(  ) {}
	int16_t Vservo(  ) {}
	enum com::company::demo:: MAV_POWER_STATUS flags(  ) {}
	bool flags_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct REMOTE_LOG_DATA_BLOCK {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const REMOTE_LOG_DATA_BLOCK &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[1] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 200}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 200;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{data_.base.bytes + 2};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{data_.base.bytes + 2};
				for (size_t  i     = 0; i < 200; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{data_.base.bytes + 2};
			if (src)
				for (size_t i = 0; i < 200; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct seqno_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		seqno_ seqno() const {
			if (data_.base.field_bit != 1616 && !set_field(&data_, 1616, -1)) return {0, 0};
			seqno_ ret{true, static_cast< enum MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS > (    static_cast< enum MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS >( 2147483645 + get_bits(data_.base.bytes, data_.BIT, 1)))};
			return ret;
		}
		
		
		void seqno(enum MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS src) const {
			
			if (data_.base.field_bit != 1616) set_field(&data_, 1616, 0);
			
			set_bits(static_cast< uintptr_t >(  -2147483645
			src  ), 1, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void seqno( enum com::company::demo:: MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS src  ) {}
	void daTa( const struct com::company::demo::REMOTE_LOG_DATA_BLOCK :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	enum com::company::demo:: MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS seqno(  ) {}
	bool seqno_exists(){}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LOGGING_DATA_ACKED {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LOGGING_DATA_ACKED(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LOGGING_DATA_ACKED &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 255) == 0);
		}
		
		int16_t sequence() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void sequence(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void target_system(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[3] ); }
		
		void target_component(int8_t src) const { (&data_)[3] = (uint8_t) (src); }
		
		int8_t length() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void length(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		int8_t first_message_offset() const { return static_cast< int8_t >((&data_)[5] ); }
		
		void first_message_offset(int8_t src) const { (&data_)[5] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 249}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 249;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 6};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 6};
				for (size_t  i     = 0; i < 249; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{&data_ + 6};
			if (src)
				for (size_t i = 0; i < 249; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void sequence( int16_t src  ) {}
	void length( int8_t src  ) {}
	void first_message_offset( int8_t src  ) {}
	void daTa( const struct com::company::demo::LOGGING_DATA_ACKED :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int16_t sequence(  ) {}
	int16_t sequence(  ) {}
	int8_t length(  ) {}
	int8_t length(  ) {}
	int8_t first_message_offset(  ) {}
	int8_t first_message_offset(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct TERRAIN_CHECK {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		TERRAIN_CHECK(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const TERRAIN_CHECK &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 8) == 0);
		}
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(&data_, 4, 4))); }
		
		void lon(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 4); }
		
		
		/*
struct <DST> {
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lon(  ) {}
	int32_t lon(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MOUNT_CONFIGURE {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MOUNT_CONFIGURE &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[1] = (uint8_t) (src); }
		
		int8_t stab_roll() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		void stab_roll(int8_t src) const { (data_.base.bytes)[2] = (uint8_t) (src); }
		
		int8_t stab_pitch() const { return static_cast< int8_t >((data_.base.bytes)[3] ); }
		
		void stab_pitch(int8_t src) const { (data_.base.bytes)[3] = (uint8_t) (src); }
		
		int8_t stab_yaw() const { return static_cast< int8_t >((data_.base.bytes)[4] ); }
		
		void stab_yaw(int8_t src) const { (data_.base.bytes)[4] = (uint8_t) (src); }
		
		struct mount_mode_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MOUNT_MODE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mount_mode_ mount_mode() const {
			if (data_.base.field_bit != 40 && !set_field(&data_, 40, -1)) return {0, 0};
			mount_mode_ ret{true, static_cast< enum MAV_MOUNT_MODE > (    static_cast< enum MAV_MOUNT_MODE >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void mount_mode(enum MAV_MOUNT_MODE src) const {
			
			if (data_.base.field_bit != 40) set_field(&data_, 40, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void mount_mode( enum com::company::demo:: MAV_MOUNT_MODE src  ) {}
	void stab_roll( int8_t src  ) {}
	void stab_pitch( int8_t src  ) {}
	void stab_yaw( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	enum com::company::demo:: MAV_MOUNT_MODE mount_mode(  ) {}
	bool mount_mode_exists(){}
	int8_t stab_roll(  ) {}
	int8_t stab_roll(  ) {}
	int8_t stab_pitch(  ) {}
	int8_t stab_pitch(  ) {}
	int8_t stab_yaw(  ) {}
	int8_t stab_yaw(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MISSION_REQUEST_INT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MISSION_REQUEST_INT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t seq() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[3] ); }
		
		
		struct mission_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MISSION_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mission_type_ mission_type() const {
			if (data_.base.field_bit != 32 && !set_field(&data_, 32, -1)) return {0, 0};
			mission_type_ ret{true, static_cast< enum MAV_MISSION_TYPE > ( MAV_MISSION_TYPE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void seq( int16_t src  ) {}
	void mission_type( enum com::company::demo:: MAV_MISSION_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 28) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		float x() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		float y() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		float z() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct COMMAND_ACK {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const COMMAND_ACK &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct command_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_CMD value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		command_ command() const {
			if (data_.base.field_bit != 2 && !set_field(&data_, 2, -1)) return {0, 0};
			command_ ret{true, static_cast< enum MAV_CMD > ( MAV_CMD_from(get_bits(data_.base.bytes, data_.BIT, 8)))};
			return ret;
		}
		
		
		struct result_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_RESULT value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		result_ result() const {
			if (data_.base.field_bit != 3 && !set_field(&data_, 3, -1)) return {0, 0};
			result_ ret{true, static_cast< enum MAV_RESULT > (    static_cast< enum MAV_RESULT >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		struct progress_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int8_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		progress_ progress() const {
			if (data_.base.field_bit != 4 && !set_field(&data_, 4, -1)) return {0, 0};
			progress_ ret{true, static_cast< int8_t > (      static_cast< int8_t >((data_.base.bytes)[data_.BYTE] ))};
			return ret;
		}
		
		
		struct result_param2_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int32_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		result_param2_ result_param2() const {
			if (data_.base.field_bit != 5 && !set_field(&data_, 5, -1)) return {0, 0};
			result_param2_ ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		struct target_system_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int8_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		target_system_ target_system() const {
			if (data_.base.field_bit != 6 && !set_field(&data_, 6, -1)) return {0, 0};
			target_system_ ret{true, static_cast< int8_t > (      static_cast< int8_t >((data_.base.bytes)[data_.BYTE] ))};
			return ret;
		}
		
		
		struct target_component_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int8_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		target_component_ target_component() const {
			if (data_.base.field_bit != 7 && !set_field(&data_, 7, -1)) return {0, 0};
			target_component_ ret{true, static_cast< int8_t > (      static_cast< int8_t >((data_.base.bytes)[data_.BYTE] ))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void command( enum com::company::demo:: MAV_CMD src  ) {}
	void result( enum com::company::demo:: MAV_RESULT src  ) {}
	void progress( int8_t src  ) {}
	void result_param2( int32_t src  ) {}
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct DATA_STREAM {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		DATA_STREAM(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const DATA_STREAM &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 4) == 0);
		}
		
		int16_t message_rate() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		int8_t stream_id() const { return static_cast< int8_t >((&data_)[2] ); }
		
		int8_t on_off() const { return static_cast< int8_t >((&data_)[3] ); }
		
		
		/*
struct <DST> {
	void stream_id( int8_t src  ) {}
	void message_rate( int16_t src  ) {}
	void on_off( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct MISSION_REQUEST {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MISSION_REQUEST &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t seq() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[3] ); }
		
		
		struct mission_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MISSION_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mission_type_ mission_type() const {
			if (data_.base.field_bit != 32 && !set_field(&data_, 32, -1)) return {0, 0};
			mission_type_ ret{true, static_cast< enum MAV_MISSION_TYPE > ( MAV_MISSION_TYPE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void seq( int16_t src  ) {}
	void mission_type( enum com::company::demo:: MAV_MISSION_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct TERRAIN_REPORT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		TERRAIN_REPORT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const TERRAIN_REPORT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 22) == 0);
		}
		
		int16_t spacing() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void spacing(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t pending() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void pending(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int16_t loaded() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		void loaded(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 4); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 6, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 6); }
		
		int32_t lon() const { return (static_cast< int32_t > (get_bytes(&data_, 10, 4))); }
		
		void lon(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 10); }
		
		float terrain_height() const { return (intBitsToFloat(get_bytes(&data_, 14, 4))); }
		
		void terrain_height(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 14); }
		
		float current_height() const { return (intBitsToFloat(get_bytes(&data_, 18, 4))); }
		
		void current_height(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 18); }
		
		
		/*
struct <DST> {
	void lat( int32_t src  ) {}
	void lon( int32_t src  ) {}
	void spacing( int16_t src  ) {}
	void terrain_height( float src  ) {}
	void current_height( float src  ) {}
	void pending( int16_t src  ) {}
	void loaded( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lon(  ) {}
	int32_t lon(  ) {}
	int16_t spacing(  ) {}
	int16_t spacing(  ) {}
	float terrain_height(  ) {}
	float terrain_height(  ) {}
	float current_height(  ) {}
	float current_height(  ) {}
	int16_t pending(  ) {}
	int16_t pending(  ) {}
	int16_t loaded(  ) {}
	int16_t loaded(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SET_HOME_POSITION {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const SET_HOME_POSITION &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[0] = (uint8_t) (src); }
		
		int32_t latitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 1, 4))); }
		
		void latitude(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 1); }
		
		int32_t longitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 5, 4))); }
		
		void longitude(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 5); }
		
		int32_t altitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 9, 4))); }
		
		void altitude(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 9); }
		
		float x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 13, 4))); }
		
		void x(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 13); }
		
		float y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 17, 4))); }
		
		void y(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 17); }
		
		float z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 21, 4))); }
		
		void z(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 21); }
		
		struct q_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, q_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, q_> end() const { return {*this, 4}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 4;
			
		};
		
		struct q_ q() const {
			struct q_ ret{data_.base.bytes + 25};
			return ret;
		}
		
		template<typename float_src_container>
			q_ q(const float_src_container &src) const {
				auto        first = src.begin();
				struct q_   ret{data_.base.bytes + 25};
				for (size_t i     = 0; i < 4; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		q_ q(float *const src) const { return q(static_cast<float const *>( src)); }
		
		q_ q(float const *const src) const {
			struct q_       ret{data_.base.bytes + 25};
			if (src)
				for (size_t i = 0; i < 4; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		float approach_x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 41, 4))); }
		
		void approach_x(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 41); }
		
		float approach_y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 45, 4))); }
		
		void approach_y(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 45); }
		
		float approach_z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 49, 4))); }
		
		void approach_z(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 49); }
		
		struct time_usec_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int64_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		time_usec_ time_usec() const {
			if (data_.base.field_bit != 424 && !set_field(&data_, 424, -1)) return {0, 0};
			time_usec_ ret{true, static_cast< int64_t > ((static_cast< int64_t > (get_bytes(data_.base.bytes, data_.BYTE, 8))))};
			return ret;
		}
		
		
		void time_usec(int64_t src) const {
			
			if (data_.base.field_bit != 424) set_field(&data_, 424, 0);
			
			set_bytes((src), 8, data_.base.bytes, data_.BYTE);
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void latitude( int32_t src  ) {}
	void longitude( int32_t src  ) {}
	void altitude( int32_t src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void q( const struct com::company::demo::SET_HOME_POSITION :: q_  & src  ) const {}
	void approach_x( float src  ) {}
	void approach_y( float src  ) {}
	void approach_z( float src  ) {}
	void time_usec( int64_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int32_t latitude(  ) {}
	int32_t latitude(  ) {}
	int32_t longitude(  ) {}
	int32_t longitude(  ) {}
	int32_t altitude(  ) {}
	int32_t altitude(  ) {}
	float x(  ) {}
	float x(  ) {}
	float y(  ) {}
	float y(  ) {}
	float z(  ) {}
	float z(  ) {}
	std container of flo  q(  ) {}
	float approach_x(  ) {}
	float approach_x(  ) {}
	float approach_y(  ) {}
	float approach_y(  ) {}
	float approach_z(  ) {}
	float approach_z(  ) {}
	int64_t time_usec(  ) {}
	bool time_usec_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SwitchModeCommand { static Meta meta; };
	
	struct HIL_RC_INPUTS_RAW {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		HIL_RC_INPUTS_RAW(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const HIL_RC_INPUTS_RAW &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 33) == 0);
		}
		
		int16_t chan1_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		int16_t chan2_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		int16_t chan3_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		int16_t chan4_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 6, 2))); }
		
		int16_t chan5_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 8, 2))); }
		
		int16_t chan6_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		int16_t chan7_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		int16_t chan8_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 14, 2))); }
		
		int16_t chan9_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 16, 2))); }
		
		int16_t chan10_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 18, 2))); }
		
		int16_t chan11_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 20, 2))); }
		
		int16_t chan12_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 22, 2))); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 24, 8))); }
		
		int8_t rssi() const { return static_cast< int8_t >((&data_)[32] ); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void chan1_raw( int16_t src  ) {}
	void chan2_raw( int16_t src  ) {}
	void chan3_raw( int16_t src  ) {}
	void chan4_raw( int16_t src  ) {}
	void chan5_raw( int16_t src  ) {}
	void chan6_raw( int16_t src  ) {}
	void chan7_raw( int16_t src  ) {}
	void chan8_raw( int16_t src  ) {}
	void chan9_raw( int16_t src  ) {}
	void chan10_raw( int16_t src  ) {}
	void chan11_raw( int16_t src  ) {}
	void chan12_raw( int16_t src  ) {}
	void rssi( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct SCALED_IMU3 {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SCALED_IMU3(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SCALED_IMU3 &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 22) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int16_t xacc() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		void xacc(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 4); }
		
		int16_t yacc() const { return (static_cast< int16_t > (get_bytes(&data_, 6, 2))); }
		
		void yacc(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 6); }
		
		int16_t zacc() const { return (static_cast< int16_t > (get_bytes(&data_, 8, 2))); }
		
		void zacc(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 8); }
		
		int16_t xgyro() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		void xgyro(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 10); }
		
		int16_t ygyro() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		void ygyro(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 12); }
		
		int16_t zgyro() const { return (static_cast< int16_t > (get_bytes(&data_, 14, 2))); }
		
		void zgyro(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 14); }
		
		int16_t xmag() const { return (static_cast< int16_t > (get_bytes(&data_, 16, 2))); }
		
		void xmag(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 16); }
		
		int16_t ymag() const { return (static_cast< int16_t > (get_bytes(&data_, 18, 2))); }
		
		void ymag(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 18); }
		
		int16_t zmag() const { return (static_cast< int16_t > (get_bytes(&data_, 20, 2))); }
		
		void zmag(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 20); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void xacc( int16_t src  ) {}
	void yacc( int16_t src  ) {}
	void zacc( int16_t src  ) {}
	void xgyro( int16_t src  ) {}
	void ygyro( int16_t src  ) {}
	void zgyro( int16_t src  ) {}
	void xmag( int16_t src  ) {}
	void ymag( int16_t src  ) {}
	void zmag( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	int16_t xacc(  ) {}
	int16_t xacc(  ) {}
	int16_t yacc(  ) {}
	int16_t yacc(  ) {}
	int16_t zacc(  ) {}
	int16_t zacc(  ) {}
	int16_t xgyro(  ) {}
	int16_t xgyro(  ) {}
	int16_t ygyro(  ) {}
	int16_t ygyro(  ) {}
	int16_t zgyro(  ) {}
	int16_t zgyro(  ) {}
	int16_t xmag(  ) {}
	int16_t xmag(  ) {}
	int16_t ymag(  ) {}
	int16_t ymag(  ) {}
	int16_t zmag(  ) {}
	int16_t zmag(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SET_MODE {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const SET_MODE &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t custom_mode() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[4] ); }
		
		
		struct base_mode_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MODE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		base_mode_ base_mode() const {
			if (data_.base.field_bit != 40 && !set_field(&data_, 40, -1)) return {0, 0};
			base_mode_ ret{true, static_cast< enum MAV_MODE > ( MAV_MODE_from(get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void base_mode( enum com::company::demo:: MAV_MODE src  ) {}
	void custom_mode( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct MOUNT_CONTROL {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		MOUNT_CONTROL(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const MOUNT_CONTROL &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 15) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		int32_t input_a() const { return (static_cast< int32_t > (get_bytes(&data_, 2, 4))); }
		
		void input_a(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 2); }
		
		int32_t input_b() const { return (static_cast< int32_t > (get_bytes(&data_, 6, 4))); }
		
		void input_b(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 6); }
		
		int32_t input_c() const { return (static_cast< int32_t > (get_bytes(&data_, 10, 4))); }
		
		void input_c(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 10); }
		
		int8_t save_position() const { return static_cast< int8_t >((&data_)[14] ); }
		
		void save_position(int8_t src) const { (&data_)[14] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void input_a( int32_t src  ) {}
	void input_b( int32_t src  ) {}
	void input_c( int32_t src  ) {}
	void save_position( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int32_t input_a(  ) {}
	int32_t input_a(  ) {}
	int32_t input_b(  ) {}
	int32_t input_b(  ) {}
	int32_t input_c(  ) {}
	int32_t input_c(  ) {}
	int8_t save_position(  ) {}
	int8_t save_position(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct POSITION_TARGET_GLOBAL_INT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const POSITION_TARGET_GLOBAL_INT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t type_mask() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 2, 4))); }
		
		int32_t lat_int() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 6, 4))); }
		
		int32_t lon_int() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 10, 4))); }
		
		float alt() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 14, 4))); }
		
		float vx() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 18, 4))); }
		
		float vy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 22, 4))); }
		
		float vz() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 26, 4))); }
		
		float afx() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 30, 4))); }
		
		float afy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 34, 4))); }
		
		float afz() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 38, 4))); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 42, 4))); }
		
		float yaw_rate() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 46, 4))); }
		
		
		struct coordinate_frame_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_FRAME value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		coordinate_frame_ coordinate_frame() const {
			if (data_.base.field_bit != 400 && !set_field(&data_, 400, -1)) return {0, 0};
			coordinate_frame_ ret{true, static_cast< enum MAV_FRAME > (    static_cast< enum MAV_FRAME >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void coordinate_frame( enum com::company::demo:: MAV_FRAME src  ) {}
	void type_mask( int16_t src  ) {}
	void lat_int( int32_t src  ) {}
	void lon_int( int32_t src  ) {}
	void alt( float src  ) {}
	void vx( float src  ) {}
	void vy( float src  ) {}
	void vz( float src  ) {}
	void afx( float src  ) {}
	void afy( float src  ) {}
	void afz( float src  ) {}
	void yaw( float src  ) {}
	void yaw_rate( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct LED_CONTROL {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LED_CONTROL(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LED_CONTROL &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 29) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		int8_t instance() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void instance(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		int8_t pattern() const { return static_cast< int8_t >((&data_)[3] ); }
		
		void pattern(int8_t src) const { (&data_)[3] = (uint8_t) (src); }
		
		int8_t custom_len() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void custom_len(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		struct custom_bytes_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, custom_bytes_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, custom_bytes_> end() const { return {*this, 24}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 24;
			
		};
		
		struct custom_bytes_ custom_bytes() const {
			struct custom_bytes_ ret{&data_ + 5};
			return ret;
		}
		
		template<typename int8_src_container>
			custom_bytes_ custom_bytes(const int8_src_container &src) const {
				auto                 first = src.begin();
				struct custom_bytes_ ret{&data_ + 5};
				for (size_t          i     = 0; i < 24; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		custom_bytes_ custom_bytes(int8_t *const src) const { return custom_bytes(static_cast<int8_t const *>( src)); }
		
		custom_bytes_ custom_bytes(int8_t const *const src) const {
			struct custom_bytes_ ret{&data_ + 5};
			if (src)
				for (size_t      i = 0; i < 24; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void instance( int8_t src  ) {}
	void pattern( int8_t src  ) {}
	void custom_len( int8_t src  ) {}
	void custom_bytes( const struct com::company::demo::LED_CONTROL :: custom_bytes_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int8_t instance(  ) {}
	int8_t instance(  ) {}
	int8_t pattern(  ) {}
	int8_t pattern(  ) {}
	int8_t custom_len(  ) {}
	int8_t custom_len(  ) {}
	std container of int8  custom_bytes(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SIM_STATE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SIM_STATE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SIM_STATE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 84) == 0);
		}
		
		float q1() const { return (intBitsToFloat(get_bytes(&data_, 0, 4))); }
		
		void q1(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 0); }
		
		float q2() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void q2(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float q3() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void q3(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float q4() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void q4(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		void roll(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 16); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		void pitch(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 20); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void yaw(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		float xacc() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void xacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		float yacc() const { return (intBitsToFloat(get_bytes(&data_, 32, 4))); }
		
		void yacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 32); }
		
		float zacc() const { return (intBitsToFloat(get_bytes(&data_, 36, 4))); }
		
		void zacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 36); }
		
		float xgyro() const { return (intBitsToFloat(get_bytes(&data_, 40, 4))); }
		
		void xgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 40); }
		
		float ygyro() const { return (intBitsToFloat(get_bytes(&data_, 44, 4))); }
		
		void ygyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 44); }
		
		float zgyro() const { return (intBitsToFloat(get_bytes(&data_, 48, 4))); }
		
		void zgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 48); }
		
		float lat() const { return (intBitsToFloat(get_bytes(&data_, 52, 4))); }
		
		void lat(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 52); }
		
		float lon() const { return (intBitsToFloat(get_bytes(&data_, 56, 4))); }
		
		void lon(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 56); }
		
		float alt() const { return (intBitsToFloat(get_bytes(&data_, 60, 4))); }
		
		void alt(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 60); }
		
		float std_dev_horz() const { return (intBitsToFloat(get_bytes(&data_, 64, 4))); }
		
		void std_dev_horz(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 64); }
		
		float std_dev_vert() const { return (intBitsToFloat(get_bytes(&data_, 68, 4))); }
		
		void std_dev_vert(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 68); }
		
		float vn() const { return (intBitsToFloat(get_bytes(&data_, 72, 4))); }
		
		void vn(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 72); }
		
		float ve() const { return (intBitsToFloat(get_bytes(&data_, 76, 4))); }
		
		void ve(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 76); }
		
		float vd() const { return (intBitsToFloat(get_bytes(&data_, 80, 4))); }
		
		void vd(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 80); }
		
		
		/*
struct <DST> {
	void q1( float src  ) {}
	void q2( float src  ) {}
	void q3( float src  ) {}
	void q4( float src  ) {}
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
	void xacc( float src  ) {}
	void yacc( float src  ) {}
	void zacc( float src  ) {}
	void xgyro( float src  ) {}
	void ygyro( float src  ) {}
	void zgyro( float src  ) {}
	void lat( float src  ) {}
	void lon( float src  ) {}
	void alt( float src  ) {}
	void std_dev_horz( float src  ) {}
	void std_dev_vert( float src  ) {}
	void vn( float src  ) {}
	void ve( float src  ) {}
	void vd( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	float q1(  ) {}
	float q1(  ) {}
	float q2(  ) {}
	float q2(  ) {}
	float q3(  ) {}
	float q3(  ) {}
	float q4(  ) {}
	float q4(  ) {}
	float roll(  ) {}
	float roll(  ) {}
	float pitch(  ) {}
	float pitch(  ) {}
	float yaw(  ) {}
	float yaw(  ) {}
	float xacc(  ) {}
	float xacc(  ) {}
	float yacc(  ) {}
	float yacc(  ) {}
	float zacc(  ) {}
	float zacc(  ) {}
	float xgyro(  ) {}
	float xgyro(  ) {}
	float ygyro(  ) {}
	float ygyro(  ) {}
	float zgyro(  ) {}
	float zgyro(  ) {}
	float lat(  ) {}
	float lat(  ) {}
	float lon(  ) {}
	float lon(  ) {}
	float alt(  ) {}
	float alt(  ) {}
	float std_dev_horz(  ) {}
	float std_dev_horz(  ) {}
	float std_dev_vert(  ) {}
	float std_dev_vert(  ) {}
	float vn(  ) {}
	float vn(  ) {}
	float ve(  ) {}
	float ve(  ) {}
	float vd(  ) {}
	float vd(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct WIFI_CONFIG_AP {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const WIFI_CONFIG_AP &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct ssid_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		ssid_ ssid() const {
			if (data_.base.field_bit != 2 && !set_field(&data_, 2, -1)) return {0, 0, 0};
			
			ssid_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			ssid_ ssid(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 2) set_field(&data_, 2, len);
				const ssid_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		ssid_ ssid(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 2) set_field(&data_, 2, len);
			const ssid_     ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		struct password_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		password_ password() const {
			if (data_.base.field_bit != 3 && !set_field(&data_, 3, -1)) return {0, 0, 0};
			
			password_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			password_ password(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 3) set_field(&data_, 3, len);
				const password_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		password_ password(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 3) set_field(&data_, 3, len);
			const password_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void ssid( const struct com::company::demo::WIFI_CONFIG_AP :: ssid_::CASE::EXISTS  & src  ) const {}
	void password( const struct com::company::demo::WIFI_CONFIG_AP :: password_::CASE::EXISTS  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	std container of chars  ssid(  ) {}
	bool ssid_exists(){}
	std container of chars  password(  ) {}
	bool password_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct DATA96 {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		DATA96(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const DATA96 &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 98) == 0);
		}
		
		int8_t typE() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void typE(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t len() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void len(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 96}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 96;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 2};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 2};
				for (size_t  i     = 0; i < 96; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{&data_ + 2};
			if (src)
				for (size_t i = 0; i < 96; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void typE( int8_t src  ) {}
	void len( int8_t src  ) {}
	void daTa( const struct com::company::demo::DATA96 :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t typE(  ) {}
	int8_t typE(  ) {}
	int8_t len(  ) {}
	int8_t len(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct FLIGHT_INFORMATION {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		FLIGHT_INFORMATION(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const FLIGHT_INFORMATION &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 28) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int64_t arming_time_utc() const { return (static_cast< int64_t > (get_bytes(&data_, 4, 8))); }
		
		void arming_time_utc(int64_t src) const { set_bytes((src), 8, &data_, 4); }
		
		int64_t takeoff_time_utc() const { return (static_cast< int64_t > (get_bytes(&data_, 12, 8))); }
		
		void takeoff_time_utc(int64_t src) const { set_bytes((src), 8, &data_, 12); }
		
		int64_t flight_uuid() const { return (static_cast< int64_t > (get_bytes(&data_, 20, 8))); }
		
		void flight_uuid(int64_t src) const { set_bytes((src), 8, &data_, 20); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void arming_time_utc( int64_t src  ) {}
	void takeoff_time_utc( int64_t src  ) {}
	void flight_uuid( int64_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	int64_t arming_time_utc(  ) {}
	int64_t arming_time_utc(  ) {}
	int64_t takeoff_time_utc(  ) {}
	int64_t takeoff_time_utc(  ) {}
	int64_t flight_uuid(  ) {}
	int64_t flight_uuid(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct RC_CHANNELS_RAW {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RC_CHANNELS_RAW(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RC_CHANNELS_RAW &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 22) == 0);
		}
		
		int16_t chan1_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		int16_t chan2_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		int16_t chan3_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		int16_t chan4_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 6, 2))); }
		
		int16_t chan5_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 8, 2))); }
		
		int16_t chan6_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		int16_t chan7_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		int16_t chan8_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 14, 2))); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 16, 4))); }
		
		int8_t port() const { return static_cast< int8_t >((&data_)[20] ); }
		
		int8_t rssi() const { return static_cast< int8_t >((&data_)[21] ); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void port( int8_t src  ) {}
	void chan1_raw( int16_t src  ) {}
	void chan2_raw( int16_t src  ) {}
	void chan3_raw( int16_t src  ) {}
	void chan4_raw( int16_t src  ) {}
	void chan5_raw( int16_t src  ) {}
	void chan6_raw( int16_t src  ) {}
	void chan7_raw( int16_t src  ) {}
	void chan8_raw( int16_t src  ) {}
	void rssi( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct SERVO_OUTPUT_RAW {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const SERVO_OUTPUT_RAW &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t servo1_raw() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int16_t servo2_raw() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		int16_t servo3_raw() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		int16_t servo4_raw() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 6, 2))); }
		
		int16_t servo5_raw() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 8, 2))); }
		
		int16_t servo6_raw() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 10, 2))); }
		
		int16_t servo7_raw() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 12, 2))); }
		
		int16_t servo8_raw() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 14, 2))); }
		
		int32_t time_usec() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 16, 4))); }
		
		int8_t port() const { return static_cast< int8_t >((data_.base.bytes)[20] ); }
		
		
		struct servo9_raw_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int16_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		servo9_raw_ servo9_raw() const {
			if (data_.base.field_bit != 168 && !set_field(&data_, 168, -1)) return {0, 0};
			servo9_raw_ ret{true, static_cast< int16_t > ((static_cast< int16_t > (get_bytes(data_.base.bytes, data_.BYTE, 2))))};
			return ret;
		}
		
		
		struct servo10_raw_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int16_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		servo10_raw_ servo10_raw() const {
			if (data_.base.field_bit != 169 && !set_field(&data_, 169, -1)) return {0, 0};
			servo10_raw_ ret{true, static_cast< int16_t > ((static_cast< int16_t > (get_bytes(data_.base.bytes, data_.BYTE, 2))))};
			return ret;
		}
		
		
		struct servo11_raw_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int16_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		servo11_raw_ servo11_raw() const {
			if (data_.base.field_bit != 170 && !set_field(&data_, 170, -1)) return {0, 0};
			servo11_raw_ ret{true, static_cast< int16_t > ((static_cast< int16_t > (get_bytes(data_.base.bytes, data_.BYTE, 2))))};
			return ret;
		}
		
		
		struct servo12_raw_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int16_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		servo12_raw_ servo12_raw() const {
			if (data_.base.field_bit != 171 && !set_field(&data_, 171, -1)) return {0, 0};
			servo12_raw_ ret{true, static_cast< int16_t > ((static_cast< int16_t > (get_bytes(data_.base.bytes, data_.BYTE, 2))))};
			return ret;
		}
		
		
		struct servo13_raw_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int16_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		servo13_raw_ servo13_raw() const {
			if (data_.base.field_bit != 172 && !set_field(&data_, 172, -1)) return {0, 0};
			servo13_raw_ ret{true, static_cast< int16_t > ((static_cast< int16_t > (get_bytes(data_.base.bytes, data_.BYTE, 2))))};
			return ret;
		}
		
		
		struct servo14_raw_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int16_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		servo14_raw_ servo14_raw() const {
			if (data_.base.field_bit != 173 && !set_field(&data_, 173, -1)) return {0, 0};
			servo14_raw_ ret{true, static_cast< int16_t > ((static_cast< int16_t > (get_bytes(data_.base.bytes, data_.BYTE, 2))))};
			return ret;
		}
		
		
		struct servo15_raw_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int16_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		servo15_raw_ servo15_raw() const {
			if (data_.base.field_bit != 174 && !set_field(&data_, 174, -1)) return {0, 0};
			servo15_raw_ ret{true, static_cast< int16_t > ((static_cast< int16_t > (get_bytes(data_.base.bytes, data_.BYTE, 2))))};
			return ret;
		}
		
		
		struct servo16_raw_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int16_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		servo16_raw_ servo16_raw() const {
			if (data_.base.field_bit != 175 && !set_field(&data_, 175, -1)) return {0, 0};
			servo16_raw_ ret{true, static_cast< int16_t > ((static_cast< int16_t > (get_bytes(data_.base.bytes, data_.BYTE, 2))))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_usec( int32_t src  ) {}
	void port( int8_t src  ) {}
	void servo1_raw( int16_t src  ) {}
	void servo2_raw( int16_t src  ) {}
	void servo3_raw( int16_t src  ) {}
	void servo4_raw( int16_t src  ) {}
	void servo5_raw( int16_t src  ) {}
	void servo6_raw( int16_t src  ) {}
	void servo7_raw( int16_t src  ) {}
	void servo8_raw( int16_t src  ) {}
	void servo9_raw( int16_t src  ) {}
	void servo10_raw( int16_t src  ) {}
	void servo11_raw( int16_t src  ) {}
	void servo12_raw( int16_t src  ) {}
	void servo13_raw( int16_t src  ) {}
	void servo14_raw( int16_t src  ) {}
	void servo15_raw( int16_t src  ) {}
	void servo16_raw( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct MEMINFO {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MEMINFO &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t brkval() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void brkval(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t freemem() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void freemem(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		struct freemem32_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int32_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		freemem32_ freemem32() const {
			if (data_.base.field_bit != 32 && !set_field(&data_, 32, -1)) return {0, 0};
			freemem32_ ret{true, static_cast< int32_t > ((static_cast< int32_t > (get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		void freemem32(int32_t src) const {
			
			if (data_.base.field_bit != 32) set_field(&data_, 32, 0);
			
			set_bytes((uint32_t) (src), 4, data_.base.bytes, data_.BYTE);
		}
		
		
		/*
struct <DST> {
	void brkval( int16_t src  ) {}
	void freemem( int16_t src  ) {}
	void freemem32( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t brkval(  ) {}
	int16_t brkval(  ) {}
	int16_t freemem(  ) {}
	int16_t freemem(  ) {}
	int32_t freemem32(  ) {}
	bool freemem32_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MISSION_ITEM_REACHED {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		MISSION_ITEM_REACHED(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const MISSION_ITEM_REACHED &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 2) == 0);
		}
		
		int16_t seq() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		
		/*
struct <DST> {
	void seq( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct LOGGING_ACK {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LOGGING_ACK(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LOGGING_ACK &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 4) == 0);
		}
		
		int16_t sequence() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void sequence(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void target_system(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[3] ); }
		
		void target_component(int8_t src) const { (&data_)[3] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void sequence( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int16_t sequence(  ) {}
	int16_t sequence(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct VISION_SPEED_ESTIMATE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		VISION_SPEED_ESTIMATE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const VISION_SPEED_ESTIMATE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 20) == 0);
		}
		
		int64_t usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void usec(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		float x() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float y() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		float z() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		void z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 16); }
		
		
		/*
struct <DST> {
	void usec( int64_t src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t usec(  ) {}
	int64_t usec(  ) {}
	float x(  ) {}
	float x(  ) {}
	float y(  ) {}
	float y(  ) {}
	float z(  ) {}
	float z(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct DEBUG_VECT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const DEBUG_VECT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 0, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 0); }
		
		float x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 8, 4))); }
		
		void x(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 8); }
		
		float y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		void y(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 12); }
		
		float z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		void z(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 16); }
		
		struct name_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		name_ name() const {
			if (data_.base.field_bit != 162 && !set_field(&data_, 162, -1)) return {0, 0, 0};
			
			name_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			name_ name(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 162) set_field(&data_, 162, len);
				const name_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		name_ name(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 162) set_field(&data_, 162, len);
			const name_     ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void name( const struct com::company::demo::DEBUG_VECT :: name_::CASE::EXISTS  & src  ) const {}
	void time_usec( int64_t src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	std container of chars  name(  ) {}
	bool name_exists(){}
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	float x(  ) {}
	float x(  ) {}
	float y(  ) {}
	float y(  ) {}
	float z(  ) {}
	float z(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LOG_REQUEST_END {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LOG_REQUEST_END(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LOG_REQUEST_END &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 2) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MISSION_ACK {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MISSION_ACK &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		
		struct typE_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MISSION_RESULT value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		typE_ typE() const {
			if (data_.base.field_bit != 18 && !set_field(&data_, 18, -1)) return {0, 0};
			typE_ ret{true, static_cast< enum MAV_MISSION_RESULT > (    static_cast< enum MAV_MISSION_RESULT >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		struct mission_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MISSION_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mission_type_ mission_type() const {
			if (data_.base.field_bit != 19 && !set_field(&data_, 19, -1)) return {0, 0};
			mission_type_ ret{true, static_cast< enum MAV_MISSION_TYPE > ( MAV_MISSION_TYPE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void typE( enum com::company::demo:: MAV_MISSION_RESULT src  ) {}
	void mission_type( enum com::company::demo:: MAV_MISSION_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct CHANGE_OPERATOR_CONTROL_ACK {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		CHANGE_OPERATOR_CONTROL_ACK(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const CHANGE_OPERATOR_CONTROL_ACK &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 3) == 0);
		}
		
		int8_t gcs_system_id() const { return static_cast< int8_t >((&data_)[0] ); }
		
		int8_t control_request() const { return static_cast< int8_t >((&data_)[1] ); }
		
		int8_t ack() const { return static_cast< int8_t >((&data_)[2] ); }
		
		
		/*
struct <DST> {
	void gcs_system_id( int8_t src  ) {}
	void control_request( int8_t src  ) {}
	void ack( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct MISSION_CURRENT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		MISSION_CURRENT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const MISSION_CURRENT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 2) == 0);
		}
		
		int16_t seq() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		
		/*
struct <DST> {
	void seq( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct SYSTEM_TIME {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SYSTEM_TIME(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SYSTEM_TIME &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 12) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		int64_t time_unix_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 4, 8))); }
		
		
		/*
struct <DST> {
	void time_unix_usec( int64_t src  ) {}
	void time_boot_ms( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct CAMERA_TRIGGER {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		CAMERA_TRIGGER(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const CAMERA_TRIGGER &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 12) == 0);
		}
		
		int32_t seq() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void seq(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 4, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 4); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void seq( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int32_t seq(  ) {}
	int32_t seq(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GOPRO_SET_RESPONSE {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const GOPRO_SET_RESPONSE &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct cmd_id_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GOPRO_COMMAND value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		cmd_id_ cmd_id() const {
			if (data_.base.field_bit != 0 && !set_field(&data_, 0, -1)) return {0, 0};
			cmd_id_ ret{true, static_cast< enum GOPRO_COMMAND > (    static_cast< enum GOPRO_COMMAND >(   get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		void cmd_id(enum GOPRO_COMMAND src) const {
			
			if (data_.base.field_bit != 0) set_field(&data_, 0, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 5, data_.base.bytes, data_.BIT);
		}
		
		
		struct status_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GOPRO_REQUEST_STATUS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		status_ status() const {
			if (data_.base.field_bit != 1 && !set_field(&data_, 1, -1)) return {0, 0};
			status_ ret{true, static_cast< enum GOPRO_REQUEST_STATUS > (    static_cast< enum GOPRO_REQUEST_STATUS >(   get_bits(data_.base.bytes, data_.BIT, 1)))};
			return ret;
		}
		
		
		void status(enum GOPRO_REQUEST_STATUS src) const {
			
			if (data_.base.field_bit != 1) set_field(&data_, 1, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 1, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void cmd_id( enum com::company::demo:: GOPRO_COMMAND src  ) {}
	void status( enum com::company::demo:: GOPRO_REQUEST_STATUS src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: GOPRO_COMMAND cmd_id(  ) {}
	bool cmd_id_exists(){}
	enum com::company::demo:: GOPRO_REQUEST_STATUS status(  ) {}
	bool status_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct VISION_POSITION_ESTIMATE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		VISION_POSITION_ESTIMATE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const VISION_POSITION_ESTIMATE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 32) == 0);
		}
		
		int64_t usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		float x() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		float y() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		float z() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		
		/*
struct <DST> {
	void usec( int64_t src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct MANUAL_CONTROL {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		MANUAL_CONTROL(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const MANUAL_CONTROL &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 11) == 0);
		}
		
		int16_t buttons() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		int8_t target() const { return static_cast< int8_t >((&data_)[2] ); }
		
		int16_t x() const { return (static_cast< int16_t > (get_bytes(&data_, 3, 2))); }
		
		int16_t y() const { return (static_cast< int16_t > (get_bytes(&data_, 5, 2))); }
		
		int16_t z() const { return (static_cast< int16_t > (get_bytes(&data_, 7, 2))); }
		
		int16_t r() const { return (static_cast< int16_t > (get_bytes(&data_, 9, 2))); }
		
		
		/*
struct <DST> {
	void target( int8_t src  ) {}
	void x( int16_t src  ) {}
	void y( int16_t src  ) {}
	void z( int16_t src  ) {}
	void r( int16_t src  ) {}
	void buttons( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct RC_CHANNELS {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RC_CHANNELS(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RC_CHANNELS &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 42) == 0);
		}
		
		int16_t chan1_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		int16_t chan2_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		int16_t chan3_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		int16_t chan4_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 6, 2))); }
		
		int16_t chan5_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 8, 2))); }
		
		int16_t chan6_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		int16_t chan7_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		int16_t chan8_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 14, 2))); }
		
		int16_t chan9_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 16, 2))); }
		
		int16_t chan10_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 18, 2))); }
		
		int16_t chan11_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 20, 2))); }
		
		int16_t chan12_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 22, 2))); }
		
		int16_t chan13_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 24, 2))); }
		
		int16_t chan14_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 26, 2))); }
		
		int16_t chan15_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 28, 2))); }
		
		int16_t chan16_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 30, 2))); }
		
		int16_t chan17_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 32, 2))); }
		
		int16_t chan18_raw() const { return (static_cast< int16_t > (get_bytes(&data_, 34, 2))); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 36, 4))); }
		
		int8_t chancount() const { return static_cast< int8_t >((&data_)[40] ); }
		
		int8_t rssi() const { return static_cast< int8_t >((&data_)[41] ); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void chancount( int8_t src  ) {}
	void chan1_raw( int16_t src  ) {}
	void chan2_raw( int16_t src  ) {}
	void chan3_raw( int16_t src  ) {}
	void chan4_raw( int16_t src  ) {}
	void chan5_raw( int16_t src  ) {}
	void chan6_raw( int16_t src  ) {}
	void chan7_raw( int16_t src  ) {}
	void chan8_raw( int16_t src  ) {}
	void chan9_raw( int16_t src  ) {}
	void chan10_raw( int16_t src  ) {}
	void chan11_raw( int16_t src  ) {}
	void chan12_raw( int16_t src  ) {}
	void chan13_raw( int16_t src  ) {}
	void chan14_raw( int16_t src  ) {}
	void chan15_raw( int16_t src  ) {}
	void chan16_raw( int16_t src  ) {}
	void chan17_raw( int16_t src  ) {}
	void chan18_raw( int16_t src  ) {}
	void rssi( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct PROTOCOL_VERSION {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		PROTOCOL_VERSION(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const PROTOCOL_VERSION &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 22) == 0);
		}
		
		int16_t version() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void version(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t min_version() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void min_version(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int16_t max_version() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		void max_version(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 4); }
		
		struct spec_version_hash_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, spec_version_hash_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, spec_version_hash_> end() const { return {*this, 8}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 8;
			
		};
		
		struct spec_version_hash_ spec_version_hash() const {
			struct spec_version_hash_ ret{&data_ + 6};
			return ret;
		}
		
		template<typename int8_src_container>
			spec_version_hash_ spec_version_hash(const int8_src_container &src) const {
				auto                      first = src.begin();
				struct spec_version_hash_ ret{&data_ + 6};
				for (size_t               i     = 0; i < 8; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		spec_version_hash_ spec_version_hash(int8_t *const src) const { return spec_version_hash(static_cast<int8_t const *>( src)); }
		
		spec_version_hash_ spec_version_hash(int8_t const *const src) const {
			struct spec_version_hash_ ret{&data_ + 6};
			if (src)
				for (size_t           i = 0; i < 8; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct library_version_hash_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, library_version_hash_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, library_version_hash_> end() const { return {*this, 8}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 8;
			
		};
		
		struct library_version_hash_ library_version_hash() const {
			struct library_version_hash_ ret{&data_ + 14};
			return ret;
		}
		
		template<typename int8_src_container>
			library_version_hash_ library_version_hash(const int8_src_container &src) const {
				auto                         first = src.begin();
				struct library_version_hash_ ret{&data_ + 14};
				for (size_t                  i     = 0; i < 8; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		library_version_hash_ library_version_hash(int8_t *const src) const { return library_version_hash(static_cast<int8_t const *>( src)); }
		
		library_version_hash_ library_version_hash(int8_t const *const src) const {
			struct library_version_hash_ ret{&data_ + 14};
			if (src)
				for (size_t              i = 0; i < 8; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void version( int16_t src  ) {}
	void min_version( int16_t src  ) {}
	void max_version( int16_t src  ) {}
	void spec_version_hash( const struct com::company::demo::PROTOCOL_VERSION :: spec_version_hash_  & src  ) const {}
	void library_version_hash( const struct com::company::demo::PROTOCOL_VERSION :: library_version_hash_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t version(  ) {}
	int16_t version(  ) {}
	int16_t min_version(  ) {}
	int16_t min_version(  ) {}
	int16_t max_version(  ) {}
	int16_t max_version(  ) {}
	std container of int8  spec_version_hash(  ) {}
	std container of int8  library_version_hash(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct RALLY_FETCH_POINT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RALLY_FETCH_POINT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RALLY_FETCH_POINT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 3) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		int8_t idx() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void idx(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void idx( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int8_t idx(  ) {}
	int8_t idx(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct PARAM_VALUE {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const PARAM_VALUE &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t param_count() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int16_t param_index() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		float param_value() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 4, 4))); }
		
		
		struct param_id_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		param_id_ param_id() const {
			if (data_.base.field_bit != 66 && !set_field(&data_, 66, -1)) return {0, 0, 0};
			
			param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		
		struct param_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_PARAM_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		param_type_ param_type() const {
			if (data_.base.field_bit != 67 && !set_field(&data_, 67, -1)) return {0, 0};
			param_type_ ret{true, static_cast< enum MAV_PARAM_TYPE > (    static_cast< enum MAV_PARAM_TYPE >( 1 + get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void param_id( const struct com::company::demo::PARAM_VALUE :: param_id_::CASE::EXISTS  & src  ) const {}
	void param_value( float src  ) {}
	void param_type( enum com::company::demo:: MAV_PARAM_TYPE src  ) {}
	void param_count( int16_t src  ) {}
	void param_index( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct BATTERY_STATUS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const BATTERY_STATUS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct voltages_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int16_t, voltages_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int16_t, voltages_> end() const { return {*this, 10}; }
			
			int16_t get(size_t index) const { return (static_cast< int16_t > (get_bytes(bytes, index * 2, 2))); }
			
			
			void set(int16_t src, size_t index) const {
				
				set_bytes((uint16_t) (src), 2, bytes, index * 2);
			}
			
			static constexpr size_t len = 10;
			
		};
		
		struct voltages_ voltages() const {
			struct voltages_ ret{data_.base.bytes + 0};
			return ret;
		}
		
		template<typename int16_src_container>
			voltages_ voltages(const int16_src_container &src) const {
				auto             first = src.begin();
				struct voltages_ ret{data_.base.bytes + 0};
				for (size_t      i     = 0; i < 10; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		voltages_ voltages(int16_t *const src) const { return voltages(static_cast<int16_t const *>( src)); }
		
		voltages_ voltages(int16_t const *const src) const {
			struct voltages_ ret{data_.base.bytes + 0};
			if (src)
				for (size_t  i = 0; i < 10; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		int8_t id() const { return static_cast< int8_t >((data_.base.bytes)[20] ); }
		
		void id(int8_t src) const { (data_.base.bytes)[20] = (uint8_t) (src); }
		
		int16_t temperature() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 21, 2))); }
		
		void temperature(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 21); }
		
		int16_t current_battery() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 23, 2))); }
		
		void current_battery(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 23); }
		
		int32_t current_consumed() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 25, 4))); }
		
		void current_consumed(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 25); }
		
		int32_t energy_consumed() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 29, 4))); }
		
		void energy_consumed(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 29); }
		
		int8_t battery_remaining() const { return static_cast< int8_t >((data_.base.bytes)[33] ); }
		
		void battery_remaining(int8_t src) const { (data_.base.bytes)[33] = (uint8_t) (src); }
		
		struct battery_function_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_BATTERY_FUNCTION value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		battery_function_ battery_function() const {
			if (data_.base.field_bit != 272 && !set_field(&data_, 272, -1)) return {0, 0};
			battery_function_ ret{true, static_cast< enum MAV_BATTERY_FUNCTION > (    static_cast< enum MAV_BATTERY_FUNCTION >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void battery_function(enum MAV_BATTERY_FUNCTION src) const {
			
			if (data_.base.field_bit != 272) set_field(&data_, 272, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct typE_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_BATTERY_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		typE_ typE() const {
			if (data_.base.field_bit != 273 && !set_field(&data_, 273, -1)) return {0, 0};
			typE_ ret{true, static_cast< enum MAV_BATTERY_TYPE > (    static_cast< enum MAV_BATTERY_TYPE >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void typE(enum MAV_BATTERY_TYPE src) const {
			
			if (data_.base.field_bit != 273) set_field(&data_, 273, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void id( int8_t src  ) {}
	void battery_function( enum com::company::demo:: MAV_BATTERY_FUNCTION src  ) {}
	void typE( enum com::company::demo:: MAV_BATTERY_TYPE src  ) {}
	void temperature( int16_t src  ) {}
	void voltages( const struct com::company::demo::BATTERY_STATUS :: voltages_  & src  ) const {}
	void current_battery( int16_t src  ) {}
	void current_consumed( int32_t src  ) {}
	void energy_consumed( int32_t src  ) {}
	void battery_remaining( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t id(  ) {}
	int8_t id(  ) {}
	enum com::company::demo:: MAV_BATTERY_FUNCTION battery_function(  ) {}
	bool battery_function_exists(){}
	enum com::company::demo:: MAV_BATTERY_TYPE typE(  ) {}
	bool typE_exists(){}
	int16_t temperature(  ) {}
	int16_t temperature(  ) {}
	std container of int16  voltages(  ) {}
	int16_t current_battery(  ) {}
	int16_t current_battery(  ) {}
	int32_t current_consumed(  ) {}
	int32_t current_consumed(  ) {}
	int32_t energy_consumed(  ) {}
	int32_t energy_consumed(  ) {}
	int8_t battery_remaining(  ) {}
	int8_t battery_remaining(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SERIAL_CONTROL {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const SERIAL_CONTROL &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t timeout() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void timeout(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int32_t baudrate() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 2, 4))); }
		
		void baudrate(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 2); }
		
		int8_t count() const { return static_cast< int8_t >((data_.base.bytes)[6] ); }
		
		void count(int8_t src) const { (data_.base.bytes)[6] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 70}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 70;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{data_.base.bytes + 7};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{data_.base.bytes + 7};
				for (size_t  i     = 0; i < 70; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{data_.base.bytes + 7};
			if (src)
				for (size_t i = 0; i < 70; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct device_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum SERIAL_CONTROL_DEV value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		device_ device() const {
			if (data_.base.field_bit != 616 && !set_field(&data_, 616, -1)) return {0, 0};
			device_ ret{true, static_cast< enum SERIAL_CONTROL_DEV > ( SERIAL_CONTROL_DEV_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void device(enum SERIAL_CONTROL_DEV src) const {
			
			if (data_.base.field_bit != 616) set_field(&data_, 616, 0);
			
			set_bits(SERIAL_CONTROL_DEV_into(src), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct flags_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum SERIAL_CONTROL_FLAG value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		flags_ flags() const {
			if (data_.base.field_bit != 617 && !set_field(&data_, 617, -1)) return {0, 0};
			flags_ ret{true, static_cast< enum SERIAL_CONTROL_FLAG > ( SERIAL_CONTROL_FLAG_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void flags(enum SERIAL_CONTROL_FLAG src) const {
			
			if (data_.base.field_bit != 617) set_field(&data_, 617, 0);
			
			set_bits(SERIAL_CONTROL_FLAG_into(src), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void device( enum com::company::demo:: SERIAL_CONTROL_DEV src  ) {}
	void flags( enum com::company::demo:: SERIAL_CONTROL_FLAG src  ) {}
	void timeout( int16_t src  ) {}
	void baudrate( int32_t src  ) {}
	void count( int8_t src  ) {}
	void daTa( const struct com::company::demo::SERIAL_CONTROL :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: SERIAL_CONTROL_DEV device(  ) {}
	bool device_exists(){}
	enum com::company::demo:: SERIAL_CONTROL_FLAG flags(  ) {}
	bool flags_exists(){}
	int16_t timeout(  ) {}
	int16_t timeout(  ) {}
	int32_t baudrate(  ) {}
	int32_t baudrate(  ) {}
	int8_t count(  ) {}
	int8_t count(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SET_POSITION_TARGET_LOCAL_NED {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const SET_POSITION_TARGET_LOCAL_NED &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t type_mask() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 2, 4))); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[6] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[7] ); }
		
		float x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 8, 4))); }
		
		float y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		float z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		float vx() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 20, 4))); }
		
		float vy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 24, 4))); }
		
		float vz() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 28, 4))); }
		
		float afx() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 32, 4))); }
		
		float afy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 36, 4))); }
		
		float afz() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 40, 4))); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 44, 4))); }
		
		float yaw_rate() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 48, 4))); }
		
		
		struct coordinate_frame_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_FRAME value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		coordinate_frame_ coordinate_frame() const {
			if (data_.base.field_bit != 416 && !set_field(&data_, 416, -1)) return {0, 0};
			coordinate_frame_ ret{true, static_cast< enum MAV_FRAME > (    static_cast< enum MAV_FRAME >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void coordinate_frame( enum com::company::demo:: MAV_FRAME src  ) {}
	void type_mask( int16_t src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void vx( float src  ) {}
	void vy( float src  ) {}
	void vz( float src  ) {}
	void afx( float src  ) {}
	void afy( float src  ) {}
	void afz( float src  ) {}
	void yaw( float src  ) {}
	void yaw_rate( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct MOUNT_ORIENTATION {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		MOUNT_ORIENTATION(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const MOUNT_ORIENTATION &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 16) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void roll(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void pitch(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void yaw(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	float roll(  ) {}
	float roll(  ) {}
	float pitch(  ) {}
	float pitch(  ) {}
	float yaw(  ) {}
	float yaw(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SET_GPS_GLOBAL_ORIGIN {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const SET_GPS_GLOBAL_ORIGIN &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int32_t latitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 1, 4))); }
		
		int32_t longitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 5, 4))); }
		
		int32_t altitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 9, 4))); }
		
		
		struct time_usec_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int64_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		time_usec_ time_usec() const {
			if (data_.base.field_bit != 104 && !set_field(&data_, 104, -1)) return {0, 0};
			time_usec_ ret{true, static_cast< int64_t > ((static_cast< int64_t > (get_bytes(data_.base.bytes, data_.BYTE, 8))))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void latitude( int32_t src  ) {}
	void longitude( int32_t src  ) {}
	void altitude( int32_t src  ) {}
	void time_usec( int64_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct PARAM_EXT_SET {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const PARAM_EXT_SET &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[1] = (uint8_t) (src); }
		
		struct param_id_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		param_id_ param_id() const {
			if (data_.base.field_bit != 19 && !set_field(&data_, 19, -1)) return {0, 0, 0};
			
			param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			param_id_ param_id(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 19) set_field(&data_, 19, len);
				const param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		param_id_ param_id(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 19) set_field(&data_, 19, len);
			const param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		struct param_value_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		param_value_ param_value() const {
			if (data_.base.field_bit != 20 && !set_field(&data_, 20, -1)) return {0, 0, 0};
			
			param_value_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			param_value_ param_value(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 20) set_field(&data_, 20, len);
				const param_value_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		param_value_ param_value(const char src[], size_t len) const {
			len                  = 255 < len ? 255 : len;
			if (data_.base.field_bit != 20) set_field(&data_, 20, len);
			const param_value_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t    i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		struct param_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_PARAM_EXT_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		param_type_ param_type() const {
			if (data_.base.field_bit != 21 && !set_field(&data_, 21, -1)) return {0, 0};
			param_type_ ret{true, static_cast< enum MAV_PARAM_EXT_TYPE > (    static_cast< enum MAV_PARAM_EXT_TYPE >( 1 + get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void param_type(enum MAV_PARAM_EXT_TYPE src) const {
			
			if (data_.base.field_bit != 21) set_field(&data_, 21, 0);
			
			set_bits(static_cast< uintptr_t >(  -1
			src  ), 4, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void param_id( const struct com::company::demo::PARAM_EXT_SET :: param_id_::CASE::EXISTS  & src  ) const {}
	void param_value( const struct com::company::demo::PARAM_EXT_SET :: param_value_::CASE::EXISTS  & src  ) const {}
	void param_type( enum com::company::demo:: MAV_PARAM_EXT_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	std container of chars  param_id(  ) {}
	bool param_id_exists(){}
	std container of chars  param_value(  ) {}
	bool param_value_exists(){}
	enum com::company::demo:: MAV_PARAM_EXT_TYPE param_type(  ) {}
	bool param_type_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct AUTOPILOT_VERSION {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const AUTOPILOT_VERSION &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t vendor_id() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void vendor_id(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t product_id() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void product_id(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		int32_t flight_sw_version() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 4, 4))); }
		
		void flight_sw_version(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 4); }
		
		int32_t middleware_sw_version() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 8, 4))); }
		
		void middleware_sw_version(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 8); }
		
		int32_t os_sw_version() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 12, 4))); }
		
		void os_sw_version(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 12); }
		
		int32_t board_version() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 16, 4))); }
		
		void board_version(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 16); }
		
		int64_t uid() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 20, 8))); }
		
		void uid(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 20); }
		
		struct flight_custom_version_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, flight_custom_version_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, flight_custom_version_> end() const { return {*this, 8}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 8;
			
		};
		
		struct flight_custom_version_ flight_custom_version() const {
			struct flight_custom_version_ ret{data_.base.bytes + 28};
			return ret;
		}
		
		template<typename int8_src_container>
			flight_custom_version_ flight_custom_version(const int8_src_container &src) const {
				auto                          first = src.begin();
				struct flight_custom_version_ ret{data_.base.bytes + 28};
				for (size_t                   i     = 0; i < 8; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		flight_custom_version_ flight_custom_version(int8_t *const src) const { return flight_custom_version(static_cast<int8_t const *>( src)); }
		
		flight_custom_version_ flight_custom_version(int8_t const *const src) const {
			struct flight_custom_version_ ret{data_.base.bytes + 28};
			if (src)
				for (size_t               i = 0; i < 8; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct middleware_custom_version_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, middleware_custom_version_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, middleware_custom_version_> end() const { return {*this, 8}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 8;
			
		};
		
		struct middleware_custom_version_ middleware_custom_version() const {
			struct middleware_custom_version_ ret{data_.base.bytes + 36};
			return ret;
		}
		
		template<typename int8_src_container>
			middleware_custom_version_ middleware_custom_version(const int8_src_container &src) const {
				auto                              first = src.begin();
				struct middleware_custom_version_ ret{data_.base.bytes + 36};
				for (size_t                       i     = 0; i < 8; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		middleware_custom_version_ middleware_custom_version(int8_t *const src) const { return middleware_custom_version(static_cast<int8_t const *>( src)); }
		
		middleware_custom_version_ middleware_custom_version(int8_t const *const src) const {
			struct middleware_custom_version_ ret{data_.base.bytes + 36};
			if (src)
				for (size_t                   i = 0; i < 8; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct os_custom_version_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, os_custom_version_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, os_custom_version_> end() const { return {*this, 8}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 8;
			
		};
		
		struct os_custom_version_ os_custom_version() const {
			struct os_custom_version_ ret{data_.base.bytes + 44};
			return ret;
		}
		
		template<typename int8_src_container>
			os_custom_version_ os_custom_version(const int8_src_container &src) const {
				auto                      first = src.begin();
				struct os_custom_version_ ret{data_.base.bytes + 44};
				for (size_t               i     = 0; i < 8; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		os_custom_version_ os_custom_version(int8_t *const src) const { return os_custom_version(static_cast<int8_t const *>( src)); }
		
		os_custom_version_ os_custom_version(int8_t const *const src) const {
			struct os_custom_version_ ret{data_.base.bytes + 44};
			if (src)
				for (size_t           i = 0; i < 8; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct capabilities_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_PROTOCOL_CAPABILITY value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		capabilities_ capabilities() const {
			if (data_.base.field_bit != 419 && !set_field(&data_, 419, -1)) return {0, 0};
			capabilities_ ret{true, static_cast< enum MAV_PROTOCOL_CAPABILITY > ( MAV_PROTOCOL_CAPABILITY_from(get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		void capabilities(enum MAV_PROTOCOL_CAPABILITY src) const {
			
			if (data_.base.field_bit != 419) set_field(&data_, 419, 0);
			
			set_bits(MAV_PROTOCOL_CAPABILITY_into(src), 5, data_.base.bytes, data_.BIT);
		}
		
		
		struct uid2_ {
			
			struct Value {
				const bool IS_EXISTS;
				union CASE {
					struct EXISTS {
						const int8_t value;
						
					} EXISTS;
				}          CASE;
				
			};
			
			const bool IS_EXISTS;
			union CASE {
				
				struct EXISTS {
					Cursor &data_;
					
					
					struct uid2_::Value get(size_t d0) const {
						if (data_.base.field_bit != 420 && !set_field(&data_, 420, -1) || !set_item(&data_, d0, -1)) return {0, 0};
						struct uid2_::Value ret{true, static_cast< int8_t > (      static_cast< int8_t >((data_.base.bytes)[data_.BYTE] ))};
						return ret;
					}
					
					
				} EXISTS;
				
				
			} CASE;
			
			static constexpr size_t d0 = 18;
			
		};
		
		
		void uid2(int8_t src, size_t d0) const {
			
			if (data_.base.field_bit != 420) set_field(&data_, 420, 0);
			set_item(&data_, d0, 0);
			(data_.base.bytes)[data_.BYTE] = (uint8_t) (src);
		}
		
		
		struct uid2_ uid2() const {
			return {data_.base.field_bit == 420 || set_field(&data_, 420, -1), data_};
		}

#define AUTOPILOT_VERSION_uid2_d0(AUTOPILOT_VERSION_ptr)\
    for(size_t  d0=0, ad_hoc_ = 1; d0 <SIZE_MAX; d0 = SIZE_MAX )\
        for( const auto is_uid2_exists = AUTOPILOT_VERSION_ptr uid2(); d0 <SIZE_MAX && is_uid2_exists.IS_EXISTS; d0 =SIZE_MAX )\
            for( const auto case_uid2_exists = is_uid2_exists.CASE.EXISTS;   d0 < com::company::demo::AUTOPILOT_VERSION::uid2_::d0 ; ad_hoc_ = 1,  d0++)\
                for(auto src_uid2 = case_uid2_exists.get(d0); src_uid2.IS_EXISTS &&   ad_hoc_ ; ad_hoc_ = 0 )
		
		
		/*
struct <DST> {
	void capabilities( enum com::company::demo:: MAV_PROTOCOL_CAPABILITY src  ) {}
	void flight_sw_version( int32_t src  ) {}
	void middleware_sw_version( int32_t src  ) {}
	void os_sw_version( int32_t src  ) {}
	void board_version( int32_t src  ) {}
	void flight_custom_version( const struct com::company::demo::AUTOPILOT_VERSION :: flight_custom_version_  & src  ) const {}
	void middleware_custom_version( const struct com::company::demo::AUTOPILOT_VERSION :: middleware_custom_version_  & src  ) const {}
	void os_custom_version( const struct com::company::demo::AUTOPILOT_VERSION :: os_custom_version_  & src  ) const {}
	void vendor_id( int16_t src  ) {}
	void product_id( int16_t src  ) {}
	void uid( int64_t src  ) {}
	void uid2( int8_t src , size_t d0 ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: MAV_PROTOCOL_CAPABILITY capabilities(  ) {}
	bool capabilities_exists(){}
	int32_t flight_sw_version(  ) {}
	int32_t flight_sw_version(  ) {}
	int32_t middleware_sw_version(  ) {}
	int32_t middleware_sw_version(  ) {}
	int32_t os_sw_version(  ) {}
	int32_t os_sw_version(  ) {}
	int32_t board_version(  ) {}
	int32_t board_version(  ) {}
	std container of int8  flight_custom_version(  ) {}
	std container of int8  middleware_custom_version(  ) {}
	std container of int8  os_custom_version(  ) {}
	int16_t vendor_id(  ) {}
	int16_t vendor_id(  ) {}
	int16_t product_id(  ) {}
	int16_t product_id(  ) {}
	int64_t uid(  ) {}
	int64_t uid(  ) {}
	int8_t uid2(  size_t d0 ) {}
	bool uid2_exists(){}
	bool uid2_item_exists( size_t d0){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MISSION_REQUEST_LIST {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MISSION_REQUEST_LIST &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		
		struct mission_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MISSION_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mission_type_ mission_type() const {
			if (data_.base.field_bit != 16 && !set_field(&data_, 16, -1)) return {0, 0};
			mission_type_ ret{true, static_cast< enum MAV_MISSION_TYPE > ( MAV_MISSION_TYPE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void mission_type( enum com::company::demo:: MAV_MISSION_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct SIMSTATE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SIMSTATE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SIMSTATE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 44) == 0);
		}
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 0, 4))); }
		
		void roll(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 0); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void pitch(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void yaw(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float xacc() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void xacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		float yacc() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		void yacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 16); }
		
		float zacc() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		void zacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 20); }
		
		float xgyro() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void xgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		float ygyro() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void ygyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		float zgyro() const { return (intBitsToFloat(get_bytes(&data_, 32, 4))); }
		
		void zgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 32); }
		
		int32_t lat() const { return (static_cast< int32_t > (get_bytes(&data_, 36, 4))); }
		
		void lat(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 36); }
		
		int32_t lng() const { return (static_cast< int32_t > (get_bytes(&data_, 40, 4))); }
		
		void lng(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 40); }
		
		
		/*
struct <DST> {
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
	void xacc( float src  ) {}
	void yacc( float src  ) {}
	void zacc( float src  ) {}
	void xgyro( float src  ) {}
	void ygyro( float src  ) {}
	void zgyro( float src  ) {}
	void lat( int32_t src  ) {}
	void lng( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	float roll(  ) {}
	float roll(  ) {}
	float pitch(  ) {}
	float pitch(  ) {}
	float yaw(  ) {}
	float yaw(  ) {}
	float xacc(  ) {}
	float xacc(  ) {}
	float yacc(  ) {}
	float yacc(  ) {}
	float zacc(  ) {}
	float zacc(  ) {}
	float xgyro(  ) {}
	float xgyro(  ) {}
	float ygyro(  ) {}
	float ygyro(  ) {}
	float zgyro(  ) {}
	float zgyro(  ) {}
	int32_t lat(  ) {}
	int32_t lat(  ) {}
	int32_t lng(  ) {}
	int32_t lng(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SET_VIDEO_STREAM_SETTINGS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const SET_VIDEO_STREAM_SETTINGS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t resolution_h() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void resolution_h(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t resolution_v() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void resolution_v(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		int16_t rotation() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		void rotation(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 4); }
		
		int32_t bitrate() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 6, 4))); }
		
		void bitrate(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 6); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[10] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[10] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[11] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[11] = (uint8_t) (src); }
		
		int8_t camera_id() const { return static_cast< int8_t >((data_.base.bytes)[12] ); }
		
		void camera_id(int8_t src) const { (data_.base.bytes)[12] = (uint8_t) (src); }
		
		float framerate() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 13, 4))); }
		
		void framerate(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 13); }
		
		struct uri_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		uri_ uri() const {
			if (data_.base.field_bit != 138 && !set_field(&data_, 138, -1)) return {0, 0, 0};
			
			uri_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			uri_ uri(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 138) set_field(&data_, 138, len);
				const uri_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		uri_ uri(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 138) set_field(&data_, 138, len);
			const uri_      ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void camera_id( int8_t src  ) {}
	void framerate( float src  ) {}
	void resolution_h( int16_t src  ) {}
	void resolution_v( int16_t src  ) {}
	void bitrate( int32_t src  ) {}
	void rotation( int16_t src  ) {}
	void uri( const struct com::company::demo::SET_VIDEO_STREAM_SETTINGS :: uri_::CASE::EXISTS  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int8_t camera_id(  ) {}
	int8_t camera_id(  ) {}
	float framerate(  ) {}
	float framerate(  ) {}
	int16_t resolution_h(  ) {}
	int16_t resolution_h(  ) {}
	int16_t resolution_v(  ) {}
	int16_t resolution_v(  ) {}
	int32_t bitrate(  ) {}
	int32_t bitrate(  ) {}
	int16_t rotation(  ) {}
	int16_t rotation(  ) {}
	std container of chars  uri(  ) {}
	bool uri_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct PLAY_TUNE {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const PLAY_TUNE &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[1] = (uint8_t) (src); }
		
		struct tune_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		tune_ tune() const {
			if (data_.base.field_bit != 18 && !set_field(&data_, 18, -1)) return {0, 0, 0};
			
			tune_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			tune_ tune(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 18) set_field(&data_, 18, len);
				const tune_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		tune_ tune(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 18) set_field(&data_, 18, len);
			const tune_     ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void tune( const struct com::company::demo::PLAY_TUNE :: tune_::CASE::EXISTS  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	std container of chars  tune(  ) {}
	bool tune_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct DIGICAM_CONFIGURE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		DIGICAM_CONFIGURE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const DIGICAM_CONFIGURE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 15) == 0);
		}
		
		int16_t shutter_speed() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void shutter_speed(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void target_system(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[3] ); }
		
		void target_component(int8_t src) const { (&data_)[3] = (uint8_t) (src); }
		
		int8_t mode() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void mode(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		int8_t aperture() const { return static_cast< int8_t >((&data_)[5] ); }
		
		void aperture(int8_t src) const { (&data_)[5] = (uint8_t) (src); }
		
		int8_t iso() const { return static_cast< int8_t >((&data_)[6] ); }
		
		void iso(int8_t src) const { (&data_)[6] = (uint8_t) (src); }
		
		int8_t exposure_type() const { return static_cast< int8_t >((&data_)[7] ); }
		
		void exposure_type(int8_t src) const { (&data_)[7] = (uint8_t) (src); }
		
		int8_t command_id() const { return static_cast< int8_t >((&data_)[8] ); }
		
		void command_id(int8_t src) const { (&data_)[8] = (uint8_t) (src); }
		
		int8_t engine_cut_off() const { return static_cast< int8_t >((&data_)[9] ); }
		
		void engine_cut_off(int8_t src) const { (&data_)[9] = (uint8_t) (src); }
		
		int8_t extra_param() const { return static_cast< int8_t >((&data_)[10] ); }
		
		void extra_param(int8_t src) const { (&data_)[10] = (uint8_t) (src); }
		
		float extra_value() const { return (intBitsToFloat(get_bytes(&data_, 11, 4))); }
		
		void extra_value(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 11); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void mode( int8_t src  ) {}
	void shutter_speed( int16_t src  ) {}
	void aperture( int8_t src  ) {}
	void iso( int8_t src  ) {}
	void exposure_type( int8_t src  ) {}
	void command_id( int8_t src  ) {}
	void engine_cut_off( int8_t src  ) {}
	void extra_param( int8_t src  ) {}
	void extra_value( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int8_t mode(  ) {}
	int8_t mode(  ) {}
	int16_t shutter_speed(  ) {}
	int16_t shutter_speed(  ) {}
	int8_t aperture(  ) {}
	int8_t aperture(  ) {}
	int8_t iso(  ) {}
	int8_t iso(  ) {}
	int8_t exposure_type(  ) {}
	int8_t exposure_type(  ) {}
	int8_t command_id(  ) {}
	int8_t command_id(  ) {}
	int8_t engine_cut_off(  ) {}
	int8_t engine_cut_off(  ) {}
	int8_t extra_param(  ) {}
	int8_t extra_param(  ) {}
	float extra_value(  ) {}
	float extra_value(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SCALED_PRESSURE3 {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SCALED_PRESSURE3(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SCALED_PRESSURE3 &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 14) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		float press_abs() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void press_abs(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float press_diff() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void press_diff(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		int16_t temperature() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		void temperature(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 12); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void press_abs( float src  ) {}
	void press_diff( float src  ) {}
	void temperature( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	float press_abs(  ) {}
	float press_abs(  ) {}
	float press_diff(  ) {}
	float press_diff(  ) {}
	int16_t temperature(  ) {}
	int16_t temperature(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MISSION_REQUEST_PARTIAL_LIST {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MISSION_REQUEST_PARTIAL_LIST &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		int16_t start_index() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		int16_t end_index() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		
		struct mission_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MISSION_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mission_type_ mission_type() const {
			if (data_.base.field_bit != 48 && !set_field(&data_, 48, -1)) return {0, 0};
			mission_type_ ret{true, static_cast< enum MAV_MISSION_TYPE > ( MAV_MISSION_TYPE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void start_index( int16_t src  ) {}
	void end_index( int16_t src  ) {}
	void mission_type( enum com::company::demo:: MAV_MISSION_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct PARAM_EXT_ACK {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const PARAM_EXT_ACK &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct param_id_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		param_id_ param_id() const {
			if (data_.base.field_bit != 3 && !set_field(&data_, 3, -1)) return {0, 0, 0};
			
			param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			param_id_ param_id(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 3) set_field(&data_, 3, len);
				const param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		param_id_ param_id(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 3) set_field(&data_, 3, len);
			const param_id_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		struct param_value_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		param_value_ param_value() const {
			if (data_.base.field_bit != 4 && !set_field(&data_, 4, -1)) return {0, 0, 0};
			
			param_value_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			param_value_ param_value(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 4) set_field(&data_, 4, len);
				const param_value_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		param_value_ param_value(const char src[], size_t len) const {
			len                  = 255 < len ? 255 : len;
			if (data_.base.field_bit != 4) set_field(&data_, 4, len);
			const param_value_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t    i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		struct param_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_PARAM_EXT_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		param_type_ param_type() const {
			if (data_.base.field_bit != 5 && !set_field(&data_, 5, -1)) return {0, 0};
			param_type_ ret{true, static_cast< enum MAV_PARAM_EXT_TYPE > (    static_cast< enum MAV_PARAM_EXT_TYPE >( 1 + get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		void param_type(enum MAV_PARAM_EXT_TYPE src) const {
			
			if (data_.base.field_bit != 5) set_field(&data_, 5, 0);
			
			set_bits(static_cast< uintptr_t >(  -1
			src  ), 4, data_.base.bytes, data_.BIT);
		}
		
		
		struct param_result_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum PARAM_ACK value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		param_result_ param_result() const {
			if (data_.base.field_bit != 6 && !set_field(&data_, 6, -1)) return {0, 0};
			param_result_ ret{true, static_cast< enum PARAM_ACK > (    static_cast< enum PARAM_ACK >(   get_bits(data_.base.bytes, data_.BIT, 2)))};
			return ret;
		}
		
		
		void param_result(enum PARAM_ACK src) const {
			
			if (data_.base.field_bit != 6) set_field(&data_, 6, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 2, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void param_id( const struct com::company::demo::PARAM_EXT_ACK :: param_id_::CASE::EXISTS  & src  ) const {}
	void param_value( const struct com::company::demo::PARAM_EXT_ACK :: param_value_::CASE::EXISTS  & src  ) const {}
	void param_type( enum com::company::demo:: MAV_PARAM_EXT_TYPE src  ) {}
	void param_result( enum com::company::demo:: PARAM_ACK src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	std container of chars  param_id(  ) {}
	bool param_id_exists(){}
	std container of chars  param_value(  ) {}
	bool param_value_exists(){}
	enum com::company::demo:: MAV_PARAM_EXT_TYPE param_type(  ) {}
	bool param_type_exists(){}
	enum com::company::demo:: PARAM_ACK param_result(  ) {}
	bool param_result_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct UAVCAN_NODE_INFO {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const UAVCAN_NODE_INFO &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t uptime_sec() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		void uptime_sec(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 0); }
		
		int32_t sw_vcs_commit() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 4, 4))); }
		
		void sw_vcs_commit(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 4); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 8, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, data_.base.bytes, 8); }
		
		int8_t hw_version_major() const { return static_cast< int8_t >((data_.base.bytes)[16] ); }
		
		void hw_version_major(int8_t src) const { (data_.base.bytes)[16] = (uint8_t) (src); }
		
		int8_t hw_version_minor() const { return static_cast< int8_t >((data_.base.bytes)[17] ); }
		
		void hw_version_minor(int8_t src) const { (data_.base.bytes)[17] = (uint8_t) (src); }
		
		struct hw_unique_id_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, hw_unique_id_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, hw_unique_id_> end() const { return {*this, 16}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 16;
			
		};
		
		struct hw_unique_id_ hw_unique_id() const {
			struct hw_unique_id_ ret{data_.base.bytes + 18};
			return ret;
		}
		
		template<typename int8_src_container>
			hw_unique_id_ hw_unique_id(const int8_src_container &src) const {
				auto                 first = src.begin();
				struct hw_unique_id_ ret{data_.base.bytes + 18};
				for (size_t          i     = 0; i < 16; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		hw_unique_id_ hw_unique_id(int8_t *const src) const { return hw_unique_id(static_cast<int8_t const *>( src)); }
		
		hw_unique_id_ hw_unique_id(int8_t const *const src) const {
			struct hw_unique_id_ ret{data_.base.bytes + 18};
			if (src)
				for (size_t      i = 0; i < 16; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		int8_t sw_version_major() const { return static_cast< int8_t >((data_.base.bytes)[34] ); }
		
		void sw_version_major(int8_t src) const { (data_.base.bytes)[34] = (uint8_t) (src); }
		
		int8_t sw_version_minor() const { return static_cast< int8_t >((data_.base.bytes)[35] ); }
		
		void sw_version_minor(int8_t src) const { (data_.base.bytes)[35] = (uint8_t) (src); }
		
		struct name_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		name_ name() const {
			if (data_.base.field_bit != 290 && !set_field(&data_, 290, -1)) return {0, 0, 0};
			
			name_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			name_ name(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 290) set_field(&data_, 290, len);
				const name_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		name_ name(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 290) set_field(&data_, 290, len);
			const name_     ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void uptime_sec( int32_t src  ) {}
	void name( const struct com::company::demo::UAVCAN_NODE_INFO :: name_::CASE::EXISTS  & src  ) const {}
	void hw_version_major( int8_t src  ) {}
	void hw_version_minor( int8_t src  ) {}
	void hw_unique_id( const struct com::company::demo::UAVCAN_NODE_INFO :: hw_unique_id_  & src  ) const {}
	void sw_version_major( int8_t src  ) {}
	void sw_version_minor( int8_t src  ) {}
	void sw_vcs_commit( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int32_t uptime_sec(  ) {}
	int32_t uptime_sec(  ) {}
	std container of chars  name(  ) {}
	bool name_exists(){}
	int8_t hw_version_major(  ) {}
	int8_t hw_version_major(  ) {}
	int8_t hw_version_minor(  ) {}
	int8_t hw_version_minor(  ) {}
	std container of int8  hw_unique_id(  ) {}
	int8_t sw_version_major(  ) {}
	int8_t sw_version_major(  ) {}
	int8_t sw_version_minor(  ) {}
	int8_t sw_version_minor(  ) {}
	int32_t sw_vcs_commit(  ) {}
	int32_t sw_vcs_commit(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct DATA16 {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		DATA16(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const DATA16 &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 18) == 0);
		}
		
		int8_t typE() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void typE(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t len() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void len(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 16}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 16;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 2};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 2};
				for (size_t  i     = 0; i < 16; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{&data_ + 2};
			if (src)
				for (size_t i = 0; i < 16; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void typE( int8_t src  ) {}
	void len( int8_t src  ) {}
	void daTa( const struct com::company::demo::DATA16 :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t typE(  ) {}
	int8_t typE(  ) {}
	int8_t len(  ) {}
	int8_t len(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SET_MAG_OFFSETS {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SET_MAG_OFFSETS(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SET_MAG_OFFSETS &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 8) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		int16_t mag_ofs_x() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void mag_ofs_x(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int16_t mag_ofs_y() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		void mag_ofs_y(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 4); }
		
		int16_t mag_ofs_z() const { return (static_cast< int16_t > (get_bytes(&data_, 6, 2))); }
		
		void mag_ofs_z(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 6); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void mag_ofs_x( int16_t src  ) {}
	void mag_ofs_y( int16_t src  ) {}
	void mag_ofs_z( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int16_t mag_ofs_x(  ) {}
	int16_t mag_ofs_x(  ) {}
	int16_t mag_ofs_y(  ) {}
	int16_t mag_ofs_y(  ) {}
	int16_t mag_ofs_z(  ) {}
	int16_t mag_ofs_z(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct AP_ADC {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		AP_ADC(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const AP_ADC &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 12) == 0);
		}
		
		int16_t adc1() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void adc1(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t adc2() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void adc2(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int16_t adc3() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		void adc3(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 4); }
		
		int16_t adc4() const { return (static_cast< int16_t > (get_bytes(&data_, 6, 2))); }
		
		void adc4(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 6); }
		
		int16_t adc5() const { return (static_cast< int16_t > (get_bytes(&data_, 8, 2))); }
		
		void adc5(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 8); }
		
		int16_t adc6() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		void adc6(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 10); }
		
		
		/*
struct <DST> {
	void adc1( int16_t src  ) {}
	void adc2( int16_t src  ) {}
	void adc3( int16_t src  ) {}
	void adc4( int16_t src  ) {}
	void adc5( int16_t src  ) {}
	void adc6( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int16_t adc1(  ) {}
	int16_t adc1(  ) {}
	int16_t adc2(  ) {}
	int16_t adc2(  ) {}
	int16_t adc3(  ) {}
	int16_t adc3(  ) {}
	int16_t adc4(  ) {}
	int16_t adc4(  ) {}
	int16_t adc5(  ) {}
	int16_t adc5(  ) {}
	int16_t adc6(  ) {}
	int16_t adc6(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct WIND {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		WIND(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const WIND &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 12) == 0);
		}
		
		float direction() const { return (intBitsToFloat(get_bytes(&data_, 0, 4))); }
		
		void direction(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 0); }
		
		float speed() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void speed(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float speed_z() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void speed_z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		
		/*
struct <DST> {
	void direction( float src  ) {}
	void speed( float src  ) {}
	void speed_z( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	float direction(  ) {}
	float direction(  ) {}
	float speed(  ) {}
	float speed(  ) {}
	float speed_z(  ) {}
	float speed_z(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct AUTOPILOT_VERSION_REQUEST {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		AUTOPILOT_VERSION_REQUEST(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const AUTOPILOT_VERSION_REQUEST &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 2) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LOCAL_POSITION_NED {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LOCAL_POSITION_NED(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LOCAL_POSITION_NED &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 28) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		float x() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		float y() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		float z() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		float vx() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		float vy() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		float vz() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void vx( float src  ) {}
	void vy( float src  ) {}
	void vz( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct DATA_TRANSMISSION_HANDSHAKE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		DATA_TRANSMISSION_HANDSHAKE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const DATA_TRANSMISSION_HANDSHAKE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 13) == 0);
		}
		
		int16_t width() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void width(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t height() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void height(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int16_t packets() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		void packets(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 4); }
		
		int32_t size() const { return (static_cast< int32_t > (get_bytes(&data_, 6, 4))); }
		
		void size(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 6); }
		
		int8_t typE() const { return static_cast< int8_t >((&data_)[10] ); }
		
		void typE(int8_t src) const { (&data_)[10] = (uint8_t) (src); }
		
		int8_t payload() const { return static_cast< int8_t >((&data_)[11] ); }
		
		void payload(int8_t src) const { (&data_)[11] = (uint8_t) (src); }
		
		int8_t jpg_quality() const { return static_cast< int8_t >((&data_)[12] ); }
		
		void jpg_quality(int8_t src) const { (&data_)[12] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void typE( int8_t src  ) {}
	void size( int32_t src  ) {}
	void width( int16_t src  ) {}
	void height( int16_t src  ) {}
	void packets( int16_t src  ) {}
	void payload( int8_t src  ) {}
	void jpg_quality( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t typE(  ) {}
	int8_t typE(  ) {}
	int32_t size(  ) {}
	int32_t size(  ) {}
	int16_t width(  ) {}
	int16_t width(  ) {}
	int16_t height(  ) {}
	int16_t height(  ) {}
	int16_t packets(  ) {}
	int16_t packets(  ) {}
	int8_t payload(  ) {}
	int8_t payload(  ) {}
	int8_t jpg_quality(  ) {}
	int8_t jpg_quality(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GPS_GLOBAL_ORIGIN {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const GPS_GLOBAL_ORIGIN &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t latitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		int32_t longitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 4, 4))); }
		
		int32_t altitude() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 8, 4))); }
		
		
		struct time_usec_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const int64_t value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		time_usec_ time_usec() const {
			if (data_.base.field_bit != 96 && !set_field(&data_, 96, -1)) return {0, 0};
			time_usec_ ret{true, static_cast< int64_t > ((static_cast< int64_t > (get_bytes(data_.base.bytes, data_.BYTE, 8))))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void latitude( int32_t src  ) {}
	void longitude( int32_t src  ) {}
	void altitude( int32_t src  ) {}
	void time_usec( int64_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct SCALED_IMU2 {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SCALED_IMU2(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SCALED_IMU2 &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 22) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int16_t xacc() const { return (static_cast< int16_t > (get_bytes(&data_, 4, 2))); }
		
		void xacc(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 4); }
		
		int16_t yacc() const { return (static_cast< int16_t > (get_bytes(&data_, 6, 2))); }
		
		void yacc(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 6); }
		
		int16_t zacc() const { return (static_cast< int16_t > (get_bytes(&data_, 8, 2))); }
		
		void zacc(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 8); }
		
		int16_t xgyro() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		void xgyro(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 10); }
		
		int16_t ygyro() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		void ygyro(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 12); }
		
		int16_t zgyro() const { return (static_cast< int16_t > (get_bytes(&data_, 14, 2))); }
		
		void zgyro(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 14); }
		
		int16_t xmag() const { return (static_cast< int16_t > (get_bytes(&data_, 16, 2))); }
		
		void xmag(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 16); }
		
		int16_t ymag() const { return (static_cast< int16_t > (get_bytes(&data_, 18, 2))); }
		
		void ymag(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 18); }
		
		int16_t zmag() const { return (static_cast< int16_t > (get_bytes(&data_, 20, 2))); }
		
		void zmag(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 20); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void xacc( int16_t src  ) {}
	void yacc( int16_t src  ) {}
	void zacc( int16_t src  ) {}
	void xgyro( int16_t src  ) {}
	void ygyro( int16_t src  ) {}
	void zgyro( int16_t src  ) {}
	void xmag( int16_t src  ) {}
	void ymag( int16_t src  ) {}
	void zmag( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	int16_t xacc(  ) {}
	int16_t xacc(  ) {}
	int16_t yacc(  ) {}
	int16_t yacc(  ) {}
	int16_t zacc(  ) {}
	int16_t zacc(  ) {}
	int16_t xgyro(  ) {}
	int16_t xgyro(  ) {}
	int16_t ygyro(  ) {}
	int16_t ygyro(  ) {}
	int16_t zgyro(  ) {}
	int16_t zgyro(  ) {}
	int16_t xmag(  ) {}
	int16_t xmag(  ) {}
	int16_t ymag(  ) {}
	int16_t ymag(  ) {}
	int16_t zmag(  ) {}
	int16_t zmag(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct ATTITUDE_QUATERNION {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		ATTITUDE_QUATERNION(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const ATTITUDE_QUATERNION &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 32) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		float q1() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		float q2() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		float q3() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		float q4() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		float rollspeed() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		float pitchspeed() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		float yawspeed() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void q1( float src  ) {}
	void q2( float src  ) {}
	void q3( float src  ) {}
	void q4( float src  ) {}
	void rollspeed( float src  ) {}
	void pitchspeed( float src  ) {}
	void yawspeed( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct DATA64 {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		DATA64(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const DATA64 &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 66) == 0);
		}
		
		int8_t typE() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void typE(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t len() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void len(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 64}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 64;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 2};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 2};
				for (size_t  i     = 0; i < 64; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{&data_ + 2};
			if (src)
				for (size_t i = 0; i < 64; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void typE( int8_t src  ) {}
	void len( int8_t src  ) {}
	void daTa( const struct com::company::demo::DATA64 :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t typE(  ) {}
	int8_t typE(  ) {}
	int8_t len(  ) {}
	int8_t len(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct HIL_ACTUATOR_CONTROLS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const HIL_ACTUATOR_CONTROLS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 0, 8))); }
		
		int64_t flags() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 8, 8))); }
		
		
		struct controls_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, controls_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, controls_> end() const { return {*this, 16}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			static constexpr size_t len = 16;
			
		};
		
		struct controls_ controls() const {
			struct controls_ ret{data_.base.bytes + 16};
			return ret;
		}
		
		struct mode_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MODE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mode_ mode() const {
			if (data_.base.field_bit != 640 && !set_field(&data_, 640, -1)) return {0, 0};
			mode_ ret{true, static_cast< enum MAV_MODE > ( MAV_MODE_from(get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void controls( const struct com::company::demo::HIL_ACTUATOR_CONTROLS :: controls_  & src  ) const {}
	void mode( enum com::company::demo:: MAV_MODE src  ) {}
	void flags( int64_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct POSITION_TARGET_LOCAL_NED {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const POSITION_TARGET_LOCAL_NED &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t type_mask() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 2, 4))); }
		
		float x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 6, 4))); }
		
		float y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 10, 4))); }
		
		float z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 14, 4))); }
		
		float vx() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 18, 4))); }
		
		float vy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 22, 4))); }
		
		float vz() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 26, 4))); }
		
		float afx() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 30, 4))); }
		
		float afy() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 34, 4))); }
		
		float afz() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 38, 4))); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 42, 4))); }
		
		float yaw_rate() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 46, 4))); }
		
		
		struct coordinate_frame_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_FRAME value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		coordinate_frame_ coordinate_frame() const {
			if (data_.base.field_bit != 400 && !set_field(&data_, 400, -1)) return {0, 0};
			coordinate_frame_ ret{true, static_cast< enum MAV_FRAME > (    static_cast< enum MAV_FRAME >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void coordinate_frame( enum com::company::demo:: MAV_FRAME src  ) {}
	void type_mask( int16_t src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void vx( float src  ) {}
	void vy( float src  ) {}
	void vz( float src  ) {}
	void afx( float src  ) {}
	void afy( float src  ) {}
	void afz( float src  ) {}
	void yaw( float src  ) {}
	void yaw_rate( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct GIMBAL_REPORT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		GIMBAL_REPORT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const GIMBAL_REPORT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 42) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		float delta_time() const { return (intBitsToFloat(get_bytes(&data_, 2, 4))); }
		
		void delta_time(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 2); }
		
		float delta_angle_x() const { return (intBitsToFloat(get_bytes(&data_, 6, 4))); }
		
		void delta_angle_x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 6); }
		
		float delta_angle_y() const { return (intBitsToFloat(get_bytes(&data_, 10, 4))); }
		
		void delta_angle_y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 10); }
		
		float delta_angle_z() const { return (intBitsToFloat(get_bytes(&data_, 14, 4))); }
		
		void delta_angle_z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 14); }
		
		float delta_velocity_x() const { return (intBitsToFloat(get_bytes(&data_, 18, 4))); }
		
		void delta_velocity_x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 18); }
		
		float delta_velocity_y() const { return (intBitsToFloat(get_bytes(&data_, 22, 4))); }
		
		void delta_velocity_y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 22); }
		
		float delta_velocity_z() const { return (intBitsToFloat(get_bytes(&data_, 26, 4))); }
		
		void delta_velocity_z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 26); }
		
		float joint_roll() const { return (intBitsToFloat(get_bytes(&data_, 30, 4))); }
		
		void joint_roll(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 30); }
		
		float joint_el() const { return (intBitsToFloat(get_bytes(&data_, 34, 4))); }
		
		void joint_el(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 34); }
		
		float joint_az() const { return (intBitsToFloat(get_bytes(&data_, 38, 4))); }
		
		void joint_az(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 38); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void delta_time( float src  ) {}
	void delta_angle_x( float src  ) {}
	void delta_angle_y( float src  ) {}
	void delta_angle_z( float src  ) {}
	void delta_velocity_x( float src  ) {}
	void delta_velocity_y( float src  ) {}
	void delta_velocity_z( float src  ) {}
	void joint_roll( float src  ) {}
	void joint_el( float src  ) {}
	void joint_az( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	float delta_time(  ) {}
	float delta_time(  ) {}
	float delta_angle_x(  ) {}
	float delta_angle_x(  ) {}
	float delta_angle_y(  ) {}
	float delta_angle_y(  ) {}
	float delta_angle_z(  ) {}
	float delta_angle_z(  ) {}
	float delta_velocity_x(  ) {}
	float delta_velocity_x(  ) {}
	float delta_velocity_y(  ) {}
	float delta_velocity_y(  ) {}
	float delta_velocity_z(  ) {}
	float delta_velocity_z(  ) {}
	float joint_roll(  ) {}
	float joint_roll(  ) {}
	float joint_el(  ) {}
	float joint_el(  ) {}
	float joint_az(  ) {}
	float joint_az(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct DEVICE_OP_WRITE {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const DEVICE_OP_WRITE &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t request_id() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		void request_id(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 0); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[4] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[4] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[5] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[5] = (uint8_t) (src); }
		
		int8_t bus() const { return static_cast< int8_t >((data_.base.bytes)[6] ); }
		
		void bus(int8_t src) const { (data_.base.bytes)[6] = (uint8_t) (src); }
		
		int8_t address() const { return static_cast< int8_t >((data_.base.bytes)[7] ); }
		
		void address(int8_t src) const { (data_.base.bytes)[7] = (uint8_t) (src); }
		
		int8_t regstart() const { return static_cast< int8_t >((data_.base.bytes)[8] ); }
		
		void regstart(int8_t src) const { (data_.base.bytes)[8] = (uint8_t) (src); }
		
		int8_t count() const { return static_cast< int8_t >((data_.base.bytes)[9] ); }
		
		void count(int8_t src) const { (data_.base.bytes)[9] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 128}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 128;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{data_.base.bytes + 10};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{data_.base.bytes + 10};
				for (size_t  i     = 0; i < 128; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{data_.base.bytes + 10};
			if (src)
				for (size_t i = 0; i < 128; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct bustype_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum DEVICE_OP_BUSTYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		bustype_ bustype() const {
			if (data_.base.field_bit != 1106 && !set_field(&data_, 1106, -1)) return {0, 0};
			bustype_ ret{true, static_cast< enum DEVICE_OP_BUSTYPE > (    static_cast< enum DEVICE_OP_BUSTYPE >(   get_bits(data_.base.bytes, data_.BIT, 1)))};
			return ret;
		}
		
		
		void bustype(enum DEVICE_OP_BUSTYPE src) const {
			
			if (data_.base.field_bit != 1106) set_field(&data_, 1106, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 1, data_.base.bytes, data_.BIT);
		}
		
		
		struct busname_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		busname_ busname() const {
			if (data_.base.field_bit != 1107 && !set_field(&data_, 1107, -1)) return {0, 0, 0};
			
			busname_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			busname_ busname(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 1107) set_field(&data_, 1107, len);
				const busname_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		busname_ busname(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 1107) set_field(&data_, 1107, len);
			const busname_  ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void request_id( int32_t src  ) {}
	void bustype( enum com::company::demo:: DEVICE_OP_BUSTYPE src  ) {}
	void bus( int8_t src  ) {}
	void address( int8_t src  ) {}
	void busname( const struct com::company::demo::DEVICE_OP_WRITE :: busname_::CASE::EXISTS  & src  ) const {}
	void regstart( int8_t src  ) {}
	void count( int8_t src  ) {}
	void daTa( const struct com::company::demo::DEVICE_OP_WRITE :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int32_t request_id(  ) {}
	int32_t request_id(  ) {}
	enum com::company::demo:: DEVICE_OP_BUSTYPE bustype(  ) {}
	bool bustype_exists(){}
	int8_t bus(  ) {}
	int8_t bus(  ) {}
	int8_t address(  ) {}
	int8_t address(  ) {}
	std container of chars  busname(  ) {}
	bool busname_exists(){}
	int8_t regstart(  ) {}
	int8_t regstart(  ) {}
	int8_t count(  ) {}
	int8_t count(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct DISTANCE_SENSOR {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const DISTANCE_SENSOR &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t min_distance() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void min_distance(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t max_distance() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void max_distance(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		int16_t current_distance() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		void current_distance(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 4); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 6, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 6); }
		
		int8_t id() const { return static_cast< int8_t >((data_.base.bytes)[10] ); }
		
		void id(int8_t src) const { (data_.base.bytes)[10] = (uint8_t) (src); }
		
		int8_t covariance() const { return static_cast< int8_t >((data_.base.bytes)[11] ); }
		
		void covariance(int8_t src) const { (data_.base.bytes)[11] = (uint8_t) (src); }
		
		struct typE_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_DISTANCE_SENSOR value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		typE_ typE() const {
			if (data_.base.field_bit != 98 && !set_field(&data_, 98, -1)) return {0, 0};
			typE_ ret{true, static_cast< enum MAV_DISTANCE_SENSOR > (    static_cast< enum MAV_DISTANCE_SENSOR >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void typE(enum MAV_DISTANCE_SENSOR src) const {
			
			if (data_.base.field_bit != 98) set_field(&data_, 98, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct orientation_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_SENSOR_ORIENTATION value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		orientation_ orientation() const {
			if (data_.base.field_bit != 99 && !set_field(&data_, 99, -1)) return {0, 0};
			orientation_ ret{true, static_cast< enum MAV_SENSOR_ORIENTATION > (    static_cast< enum MAV_SENSOR_ORIENTATION >(   get_bits(data_.base.bytes, data_.BIT, 6)))};
			return ret;
		}
		
		
		void orientation(enum MAV_SENSOR_ORIENTATION src) const {
			
			if (data_.base.field_bit != 99) set_field(&data_, 99, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 6, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void min_distance( int16_t src  ) {}
	void max_distance( int16_t src  ) {}
	void current_distance( int16_t src  ) {}
	void typE( enum com::company::demo:: MAV_DISTANCE_SENSOR src  ) {}
	void id( int8_t src  ) {}
	void orientation( enum com::company::demo:: MAV_SENSOR_ORIENTATION src  ) {}
	void covariance( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	int16_t min_distance(  ) {}
	int16_t min_distance(  ) {}
	int16_t max_distance(  ) {}
	int16_t max_distance(  ) {}
	int16_t current_distance(  ) {}
	int16_t current_distance(  ) {}
	enum com::company::demo:: MAV_DISTANCE_SENSOR typE(  ) {}
	bool typE_exists(){}
	int8_t id(  ) {}
	int8_t id(  ) {}
	enum com::company::demo:: MAV_SENSOR_ORIENTATION orientation(  ) {}
	bool orientation_exists(){}
	int8_t covariance(  ) {}
	int8_t covariance(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct HIL_OPTICAL_FLOW {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		HIL_OPTICAL_FLOW(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const HIL_OPTICAL_FLOW &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 44) == 0);
		}
		
		int32_t integration_time_us() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void integration_time_us(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		int32_t time_delta_distance_us() const { return (static_cast< int32_t > (get_bytes(&data_, 4, 4))); }
		
		void time_delta_distance_us(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 4); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 8, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 8); }
		
		int8_t sensor_id() const { return static_cast< int8_t >((&data_)[16] ); }
		
		void sensor_id(int8_t src) const { (&data_)[16] = (uint8_t) (src); }
		
		float integrated_x() const { return (intBitsToFloat(get_bytes(&data_, 17, 4))); }
		
		void integrated_x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 17); }
		
		float integrated_y() const { return (intBitsToFloat(get_bytes(&data_, 21, 4))); }
		
		void integrated_y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 21); }
		
		float integrated_xgyro() const { return (intBitsToFloat(get_bytes(&data_, 25, 4))); }
		
		void integrated_xgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 25); }
		
		float integrated_ygyro() const { return (intBitsToFloat(get_bytes(&data_, 29, 4))); }
		
		void integrated_ygyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 29); }
		
		float integrated_zgyro() const { return (intBitsToFloat(get_bytes(&data_, 33, 4))); }
		
		void integrated_zgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 33); }
		
		int16_t temperature() const { return (static_cast< int16_t > (get_bytes(&data_, 37, 2))); }
		
		void temperature(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 37); }
		
		int8_t quality() const { return static_cast< int8_t >((&data_)[39] ); }
		
		void quality(int8_t src) const { (&data_)[39] = (uint8_t) (src); }
		
		float distance() const { return (intBitsToFloat(get_bytes(&data_, 40, 4))); }
		
		void distance(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 40); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void sensor_id( int8_t src  ) {}
	void integration_time_us( int32_t src  ) {}
	void integrated_x( float src  ) {}
	void integrated_y( float src  ) {}
	void integrated_xgyro( float src  ) {}
	void integrated_ygyro( float src  ) {}
	void integrated_zgyro( float src  ) {}
	void temperature( int16_t src  ) {}
	void quality( int8_t src  ) {}
	void time_delta_distance_us( int32_t src  ) {}
	void distance( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int8_t sensor_id(  ) {}
	int8_t sensor_id(  ) {}
	int32_t integration_time_us(  ) {}
	int32_t integration_time_us(  ) {}
	float integrated_x(  ) {}
	float integrated_x(  ) {}
	float integrated_y(  ) {}
	float integrated_y(  ) {}
	float integrated_xgyro(  ) {}
	float integrated_xgyro(  ) {}
	float integrated_ygyro(  ) {}
	float integrated_ygyro(  ) {}
	float integrated_zgyro(  ) {}
	float integrated_zgyro(  ) {}
	int16_t temperature(  ) {}
	int16_t temperature(  ) {}
	int8_t quality(  ) {}
	int8_t quality(  ) {}
	int32_t time_delta_distance_us(  ) {}
	int32_t time_delta_distance_us(  ) {}
	float distance(  ) {}
	float distance(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SCALED_PRESSURE2 {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		SCALED_PRESSURE2(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const SCALED_PRESSURE2 &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 14) == 0);
		}
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(&data_, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, &data_, 0); }
		
		float press_abs() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void press_abs(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float press_diff() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void press_diff(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		int16_t temperature() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		void temperature(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 12); }
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void press_abs( float src  ) {}
	void press_diff( float src  ) {}
	void temperature( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	float press_abs(  ) {}
	float press_abs(  ) {}
	float press_diff(  ) {}
	float press_diff(  ) {}
	int16_t temperature(  ) {}
	int16_t temperature(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct WIND_COV {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		WIND_COV(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const WIND_COV &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 40) == 0);
		}
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		float wind_x() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void wind_x(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		float wind_y() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		void wind_y(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 12); }
		
		float wind_z() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		void wind_z(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 16); }
		
		float var_horiz() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		void var_horiz(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 20); }
		
		float var_vert() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		void var_vert(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 24); }
		
		float wind_alt() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		void wind_alt(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 28); }
		
		float horiz_accuracy() const { return (intBitsToFloat(get_bytes(&data_, 32, 4))); }
		
		void horiz_accuracy(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 32); }
		
		float vert_accuracy() const { return (intBitsToFloat(get_bytes(&data_, 36, 4))); }
		
		void vert_accuracy(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 36); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void wind_x( float src  ) {}
	void wind_y( float src  ) {}
	void wind_z( float src  ) {}
	void var_horiz( float src  ) {}
	void var_vert( float src  ) {}
	void wind_alt( float src  ) {}
	void horiz_accuracy( float src  ) {}
	void vert_accuracy( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	float wind_x(  ) {}
	float wind_x(  ) {}
	float wind_y(  ) {}
	float wind_y(  ) {}
	float wind_z(  ) {}
	float wind_z(  ) {}
	float var_horiz(  ) {}
	float var_horiz(  ) {}
	float var_vert(  ) {}
	float var_vert(  ) {}
	float wind_alt(  ) {}
	float wind_alt(  ) {}
	float horiz_accuracy(  ) {}
	float horiz_accuracy(  ) {}
	float vert_accuracy(  ) {}
	float vert_accuracy(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct CHANGE_OPERATOR_CONTROL {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const CHANGE_OPERATOR_CONTROL &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t control_request() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		int8_t version() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		
		struct passkey_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		passkey_ passkey() const {
			if (data_.base.field_bit != 26 && !set_field(&data_, 26, -1)) return {0, 0, 0};
			
			passkey_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void control_request( int8_t src  ) {}
	void version( int8_t src  ) {}
	void passkey( const struct com::company::demo::CHANGE_OPERATOR_CONTROL :: passkey_::CASE::EXISTS  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct GOPRO_SET_REQUEST {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const GOPRO_SET_REQUEST &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[1] = (uint8_t) (src); }
		
		struct value_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, value_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, value_> end() const { return {*this, 4}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 4;
			
		};
		
		struct value_ value() const {
			struct value_ ret{data_.base.bytes + 2};
			return ret;
		}
		
		template<typename int8_src_container>
			value_ value(const int8_src_container &src) const {
				auto          first = src.begin();
				struct value_ ret{data_.base.bytes + 2};
				for (size_t   i     = 0; i < 4; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		value_ value(int8_t *const src) const { return value(static_cast<int8_t const *>( src)); }
		
		value_ value(int8_t const *const src) const {
			struct value_   ret{data_.base.bytes + 2};
			if (src)
				for (size_t i = 0; i < 4; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct cmd_id_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GOPRO_COMMAND value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		cmd_id_ cmd_id() const {
			if (data_.base.field_bit != 48 && !set_field(&data_, 48, -1)) return {0, 0};
			cmd_id_ ret{true, static_cast< enum GOPRO_COMMAND > (    static_cast< enum GOPRO_COMMAND >(   get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		void cmd_id(enum GOPRO_COMMAND src) const {
			
			if (data_.base.field_bit != 48) set_field(&data_, 48, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 5, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void cmd_id( enum com::company::demo:: GOPRO_COMMAND src  ) {}
	void value( const struct com::company::demo::GOPRO_SET_REQUEST :: value_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	enum com::company::demo:: GOPRO_COMMAND cmd_id(  ) {}
	bool cmd_id_exists(){}
	std container of int8  value(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct SYS_STATUS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const SYS_STATUS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t load() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int16_t voltage_battery() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		int16_t drop_rate_comm() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		int16_t errors_comm() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 6, 2))); }
		
		int16_t errors_count1() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 8, 2))); }
		
		int16_t errors_count2() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 10, 2))); }
		
		int16_t errors_count3() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 12, 2))); }
		
		int16_t errors_count4() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 14, 2))); }
		
		int16_t current_battery() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 16, 2))); }
		
		int8_t battery_remaining() const { return static_cast< int8_t >((data_.base.bytes)[18] ); }
		
		
		struct onboard_control_sensors_present_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_SYS_STATUS_SENSOR value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		onboard_control_sensors_present_ onboard_control_sensors_present() const {
			if (data_.base.field_bit != 154 && !set_field(&data_, 154, -1)) return {0, 0};
			onboard_control_sensors_present_ ret{true, static_cast< enum MAV_SYS_STATUS_SENSOR > ( MAV_SYS_STATUS_SENSOR_from(get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		struct onboard_control_sensors_enabled_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_SYS_STATUS_SENSOR value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		onboard_control_sensors_enabled_ onboard_control_sensors_enabled() const {
			if (data_.base.field_bit != 155 && !set_field(&data_, 155, -1)) return {0, 0};
			onboard_control_sensors_enabled_ ret{true, static_cast< enum MAV_SYS_STATUS_SENSOR > ( MAV_SYS_STATUS_SENSOR_from(get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		struct onboard_control_sensors_health_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_SYS_STATUS_SENSOR value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		onboard_control_sensors_health_ onboard_control_sensors_health() const {
			if (data_.base.field_bit != 156 && !set_field(&data_, 156, -1)) return {0, 0};
			onboard_control_sensors_health_ ret{true, static_cast< enum MAV_SYS_STATUS_SENSOR > ( MAV_SYS_STATUS_SENSOR_from(get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void onboard_control_sensors_present( enum com::company::demo:: MAV_SYS_STATUS_SENSOR src  ) {}
	void onboard_control_sensors_enabled( enum com::company::demo:: MAV_SYS_STATUS_SENSOR src  ) {}
	void onboard_control_sensors_health( enum com::company::demo:: MAV_SYS_STATUS_SENSOR src  ) {}
	void load( int16_t src  ) {}
	void voltage_battery( int16_t src  ) {}
	void current_battery( int16_t src  ) {}
	void battery_remaining( int8_t src  ) {}
	void drop_rate_comm( int16_t src  ) {}
	void errors_comm( int16_t src  ) {}
	void errors_count1( int16_t src  ) {}
	void errors_count2( int16_t src  ) {}
	void errors_count3( int16_t src  ) {}
	void errors_count4( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct MISSION_ITEM {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MISSION_ITEM &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t seq() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[3] ); }
		
		int8_t current() const { return static_cast< int8_t >((data_.base.bytes)[4] ); }
		
		int8_t autocontinue() const { return static_cast< int8_t >((data_.base.bytes)[5] ); }
		
		float param1() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 6, 4))); }
		
		float param2() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 10, 4))); }
		
		float param3() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 14, 4))); }
		
		float param4() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 18, 4))); }
		
		float x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 22, 4))); }
		
		float y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 26, 4))); }
		
		float z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 30, 4))); }
		
		
		struct frame_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_FRAME value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		frame_ frame() const {
			if (data_.base.field_bit != 274 && !set_field(&data_, 274, -1)) return {0, 0};
			frame_ ret{true, static_cast< enum MAV_FRAME > (    static_cast< enum MAV_FRAME >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		struct command_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_CMD value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		command_ command() const {
			if (data_.base.field_bit != 275 && !set_field(&data_, 275, -1)) return {0, 0};
			command_ ret{true, static_cast< enum MAV_CMD > ( MAV_CMD_from(get_bits(data_.base.bytes, data_.BIT, 8)))};
			return ret;
		}
		
		
		struct mission_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MISSION_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mission_type_ mission_type() const {
			if (data_.base.field_bit != 276 && !set_field(&data_, 276, -1)) return {0, 0};
			mission_type_ ret{true, static_cast< enum MAV_MISSION_TYPE > ( MAV_MISSION_TYPE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void seq( int16_t src  ) {}
	void frame( enum com::company::demo:: MAV_FRAME src  ) {}
	void command( enum com::company::demo:: MAV_CMD src  ) {}
	void current( int8_t src  ) {}
	void autocontinue( int8_t src  ) {}
	void param1( float src  ) {}
	void param2( float src  ) {}
	void param3( float src  ) {}
	void param4( float src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void mission_type( enum com::company::demo:: MAV_MISSION_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct RAW_IMU {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RAW_IMU(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RAW_IMU &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 26) == 0);
		}
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		int16_t xacc() const { return (static_cast< int16_t > (get_bytes(&data_, 8, 2))); }
		
		int16_t yacc() const { return (static_cast< int16_t > (get_bytes(&data_, 10, 2))); }
		
		int16_t zacc() const { return (static_cast< int16_t > (get_bytes(&data_, 12, 2))); }
		
		int16_t xgyro() const { return (static_cast< int16_t > (get_bytes(&data_, 14, 2))); }
		
		int16_t ygyro() const { return (static_cast< int16_t > (get_bytes(&data_, 16, 2))); }
		
		int16_t zgyro() const { return (static_cast< int16_t > (get_bytes(&data_, 18, 2))); }
		
		int16_t xmag() const { return (static_cast< int16_t > (get_bytes(&data_, 20, 2))); }
		
		int16_t ymag() const { return (static_cast< int16_t > (get_bytes(&data_, 22, 2))); }
		
		int16_t zmag() const { return (static_cast< int16_t > (get_bytes(&data_, 24, 2))); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void xacc( int16_t src  ) {}
	void yacc( int16_t src  ) {}
	void zacc( int16_t src  ) {}
	void xgyro( int16_t src  ) {}
	void ygyro( int16_t src  ) {}
	void zgyro( int16_t src  ) {}
	void xmag( int16_t src  ) {}
	void ymag( int16_t src  ) {}
	void zmag( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct COMMAND_INT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const COMMAND_INT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		int8_t current() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		int8_t autocontinue() const { return static_cast< int8_t >((data_.base.bytes)[3] ); }
		
		float param1() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 4, 4))); }
		
		float param2() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 8, 4))); }
		
		float param3() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 12, 4))); }
		
		float param4() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 16, 4))); }
		
		int32_t x() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 20, 4))); }
		
		int32_t y() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 24, 4))); }
		
		float z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 28, 4))); }
		
		
		struct frame_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_FRAME value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		frame_ frame() const {
			if (data_.base.field_bit != 258 && !set_field(&data_, 258, -1)) return {0, 0};
			frame_ ret{true, static_cast< enum MAV_FRAME > (    static_cast< enum MAV_FRAME >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		struct command_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_CMD value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		command_ command() const {
			if (data_.base.field_bit != 259 && !set_field(&data_, 259, -1)) return {0, 0};
			command_ ret{true, static_cast< enum MAV_CMD > ( MAV_CMD_from(get_bits(data_.base.bytes, data_.BIT, 8)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void frame( enum com::company::demo:: MAV_FRAME src  ) {}
	void command( enum com::company::demo:: MAV_CMD src  ) {}
	void current( int8_t src  ) {}
	void autocontinue( int8_t src  ) {}
	void param1( float src  ) {}
	void param2( float src  ) {}
	void param3( float src  ) {}
	void param4( float src  ) {}
	void x( int32_t src  ) {}
	void y( int32_t src  ) {}
	void z( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct OPTICAL_FLOW {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const OPTICAL_FLOW &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(data_.base.bytes, 0, 8))); }
		
		int8_t sensor_id() const { return static_cast< int8_t >((data_.base.bytes)[8] ); }
		
		int16_t flow_x() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 9, 2))); }
		
		int16_t flow_y() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 11, 2))); }
		
		float flow_comp_m_x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 13, 4))); }
		
		float flow_comp_m_y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 17, 4))); }
		
		int8_t quality() const { return static_cast< int8_t >((data_.base.bytes)[21] ); }
		
		float ground_distance() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 22, 4))); }
		
		
		struct flow_rate_x_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const float value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		flow_rate_x_ flow_rate_x() const {
			if (data_.base.field_bit != 208 && !set_field(&data_, 208, -1)) return {0, 0};
			flow_rate_x_ ret{true, static_cast< float > ((intBitsToFloat(get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		struct flow_rate_y_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const float value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		flow_rate_y_ flow_rate_y() const {
			if (data_.base.field_bit != 209 && !set_field(&data_, 209, -1)) return {0, 0};
			flow_rate_y_ ret{true, static_cast< float > ((intBitsToFloat(get_bytes(data_.base.bytes, data_.BYTE, 4))))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void sensor_id( int8_t src  ) {}
	void flow_x( int16_t src  ) {}
	void flow_y( int16_t src  ) {}
	void flow_comp_m_x( float src  ) {}
	void flow_comp_m_y( float src  ) {}
	void quality( int8_t src  ) {}
	void ground_distance( float src  ) {}
	void flow_rate_x( float src  ) {}
	void flow_rate_y( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct MISSION_ITEM_INT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MISSION_ITEM_INT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t seq() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[3] ); }
		
		int8_t current() const { return static_cast< int8_t >((data_.base.bytes)[4] ); }
		
		int8_t autocontinue() const { return static_cast< int8_t >((data_.base.bytes)[5] ); }
		
		float param1() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 6, 4))); }
		
		float param2() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 10, 4))); }
		
		float param3() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 14, 4))); }
		
		float param4() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 18, 4))); }
		
		int32_t x() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 22, 4))); }
		
		int32_t y() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 26, 4))); }
		
		float z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 30, 4))); }
		
		
		struct frame_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_FRAME value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		frame_ frame() const {
			if (data_.base.field_bit != 274 && !set_field(&data_, 274, -1)) return {0, 0};
			frame_ ret{true, static_cast< enum MAV_FRAME > (    static_cast< enum MAV_FRAME >(   get_bits(data_.base.bytes, data_.BIT, 4)))};
			return ret;
		}
		
		
		struct command_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_CMD value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		command_ command() const {
			if (data_.base.field_bit != 275 && !set_field(&data_, 275, -1)) return {0, 0};
			command_ ret{true, static_cast< enum MAV_CMD > ( MAV_CMD_from(get_bits(data_.base.bytes, data_.BIT, 8)))};
			return ret;
		}
		
		
		struct mission_type_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_MISSION_TYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		mission_type_ mission_type() const {
			if (data_.base.field_bit != 276 && !set_field(&data_, 276, -1)) return {0, 0};
			mission_type_ ret{true, static_cast< enum MAV_MISSION_TYPE > ( MAV_MISSION_TYPE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void seq( int16_t src  ) {}
	void frame( enum com::company::demo:: MAV_FRAME src  ) {}
	void command( enum com::company::demo:: MAV_CMD src  ) {}
	void current( int8_t src  ) {}
	void autocontinue( int8_t src  ) {}
	void param1( float src  ) {}
	void param2( float src  ) {}
	void param3( float src  ) {}
	void param4( float src  ) {}
	void x( int32_t src  ) {}
	void y( int32_t src  ) {}
	void z( float src  ) {}
	void mission_type( enum com::company::demo:: MAV_MISSION_TYPE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct VISION_POSITION_DELTA {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		VISION_POSITION_DELTA(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const VISION_POSITION_DELTA &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 44) == 0);
		}
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 0); }
		
		int64_t time_delta_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 8, 8))); }
		
		void time_delta_usec(int64_t src) const { set_bytes((src), 8, &data_, 8); }
		
		struct angle_delta_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, angle_delta_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, angle_delta_> end() const { return {*this, 3}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 3;
			
		};
		
		struct angle_delta_ angle_delta() const {
			struct angle_delta_ ret{&data_ + 16};
			return ret;
		}
		
		template<typename float_src_container>
			angle_delta_ angle_delta(const float_src_container &src) const {
				auto                first = src.begin();
				struct angle_delta_ ret{&data_ + 16};
				for (size_t         i     = 0; i < 3; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		angle_delta_ angle_delta(float *const src) const { return angle_delta(static_cast<float const *>( src)); }
		
		angle_delta_ angle_delta(float const *const src) const {
			struct angle_delta_ ret{&data_ + 16};
			if (src)
				for (size_t     i = 0; i < 3; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct position_delta_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, position_delta_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, position_delta_> end() const { return {*this, 3}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			void set(float src, size_t index) const {
				
				set_bytes(floatToIntBits(src), 4, bytes, index * 4);
			}
			
			static constexpr size_t len = 3;
			
		};
		
		struct position_delta_ position_delta() const {
			struct position_delta_ ret{&data_ + 28};
			return ret;
		}
		
		template<typename float_src_container>
			position_delta_ position_delta(const float_src_container &src) const {
				auto                   first = src.begin();
				struct position_delta_ ret{&data_ + 28};
				for (size_t            i     = 0; i < 3; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		position_delta_ position_delta(float *const src) const { return position_delta(static_cast<float const *>( src)); }
		
		position_delta_ position_delta(float const *const src) const {
			struct position_delta_ ret{&data_ + 28};
			if (src)
				for (size_t        i = 0; i < 3; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		float confidence() const { return (intBitsToFloat(get_bytes(&data_, 40, 4))); }
		
		void confidence(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 40); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void time_delta_usec( int64_t src  ) {}
	void angle_delta( const struct com::company::demo::VISION_POSITION_DELTA :: angle_delta_  & src  ) const {}
	void position_delta( const struct com::company::demo::VISION_POSITION_DELTA :: position_delta_  & src  ) const {}
	void confidence( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	int64_t time_delta_usec(  ) {}
	int64_t time_delta_usec(  ) {}
	std container of flo  angle_delta(  ) {}
	std container of flo  position_delta(  ) {}
	float confidence(  ) {}
	float confidence(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct LOGGING_DATA {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		LOGGING_DATA(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const LOGGING_DATA &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 255) == 0);
		}
		
		int16_t sequence() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void sequence(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void target_system(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[3] ); }
		
		void target_component(int8_t src) const { (&data_)[3] = (uint8_t) (src); }
		
		int8_t length() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void length(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		int8_t first_message_offset() const { return static_cast< int8_t >((&data_)[5] ); }
		
		void first_message_offset(int8_t src) const { (&data_)[5] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 249}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 249;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 6};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 6};
				for (size_t  i     = 0; i < 249; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{&data_ + 6};
			if (src)
				for (size_t i = 0; i < 249; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void sequence( int16_t src  ) {}
	void length( int8_t src  ) {}
	void first_message_offset( int8_t src  ) {}
	void daTa( const struct com::company::demo::LOGGING_DATA :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int16_t sequence(  ) {}
	int16_t sequence(  ) {}
	int8_t length(  ) {}
	int8_t length(  ) {}
	int8_t first_message_offset(  ) {}
	int8_t first_message_offset(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct DEVICE_OP_READ {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const DEVICE_OP_READ &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t request_id() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		void request_id(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 0); }
		
		int8_t target_system() const { return static_cast< int8_t >((data_.base.bytes)[4] ); }
		
		void target_system(int8_t src) const { (data_.base.bytes)[4] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((data_.base.bytes)[5] ); }
		
		void target_component(int8_t src) const { (data_.base.bytes)[5] = (uint8_t) (src); }
		
		int8_t bus() const { return static_cast< int8_t >((data_.base.bytes)[6] ); }
		
		void bus(int8_t src) const { (data_.base.bytes)[6] = (uint8_t) (src); }
		
		int8_t address() const { return static_cast< int8_t >((data_.base.bytes)[7] ); }
		
		void address(int8_t src) const { (data_.base.bytes)[7] = (uint8_t) (src); }
		
		int8_t regstart() const { return static_cast< int8_t >((data_.base.bytes)[8] ); }
		
		void regstart(int8_t src) const { (data_.base.bytes)[8] = (uint8_t) (src); }
		
		int8_t count() const { return static_cast< int8_t >((data_.base.bytes)[9] ); }
		
		void count(int8_t src) const { (data_.base.bytes)[9] = (uint8_t) (src); }
		
		struct bustype_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum DEVICE_OP_BUSTYPE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		bustype_ bustype() const {
			if (data_.base.field_bit != 82 && !set_field(&data_, 82, -1)) return {0, 0};
			bustype_ ret{true, static_cast< enum DEVICE_OP_BUSTYPE > (    static_cast< enum DEVICE_OP_BUSTYPE >(   get_bits(data_.base.bytes, data_.BIT, 1)))};
			return ret;
		}
		
		
		void bustype(enum DEVICE_OP_BUSTYPE src) const {
			
			if (data_.base.field_bit != 82) set_field(&data_, 82, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 1, data_.base.bytes, data_.BIT);
		}
		
		
		struct busname_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		busname_ busname() const {
			if (data_.base.field_bit != 83 && !set_field(&data_, 83, -1)) return {0, 0, 0};
			
			busname_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			busname_ busname(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 83) set_field(&data_, 83, len);
				const busname_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		busname_ busname(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 83) set_field(&data_, 83, len);
			const busname_  ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void request_id( int32_t src  ) {}
	void bustype( enum com::company::demo:: DEVICE_OP_BUSTYPE src  ) {}
	void bus( int8_t src  ) {}
	void address( int8_t src  ) {}
	void busname( const struct com::company::demo::DEVICE_OP_READ :: busname_::CASE::EXISTS  & src  ) const {}
	void regstart( int8_t src  ) {}
	void count( int8_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int32_t request_id(  ) {}
	int32_t request_id(  ) {}
	enum com::company::demo:: DEVICE_OP_BUSTYPE bustype(  ) {}
	bool bustype_exists(){}
	int8_t bus(  ) {}
	int8_t bus(  ) {}
	int8_t address(  ) {}
	int8_t address(  ) {}
	std container of chars  busname(  ) {}
	bool busname_exists(){}
	int8_t regstart(  ) {}
	int8_t regstart(  ) {}
	int8_t count(  ) {}
	int8_t count(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct MAG_CAL_PROGRESS {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const MAG_CAL_PROGRESS &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int8_t compass_id() const { return static_cast< int8_t >((data_.base.bytes)[0] ); }
		
		void compass_id(int8_t src) const { (data_.base.bytes)[0] = (uint8_t) (src); }
		
		int8_t cal_mask() const { return static_cast< int8_t >((data_.base.bytes)[1] ); }
		
		void cal_mask(int8_t src) const { (data_.base.bytes)[1] = (uint8_t) (src); }
		
		int8_t attempt() const { return static_cast< int8_t >((data_.base.bytes)[2] ); }
		
		void attempt(int8_t src) const { (data_.base.bytes)[2] = (uint8_t) (src); }
		
		int8_t completion_pct() const { return static_cast< int8_t >((data_.base.bytes)[3] ); }
		
		void completion_pct(int8_t src) const { (data_.base.bytes)[3] = (uint8_t) (src); }
		
		struct completion_mask_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, completion_mask_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, completion_mask_> end() const { return {*this, 10}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 10;
			
		};
		
		struct completion_mask_ completion_mask() const {
			struct completion_mask_ ret{data_.base.bytes + 4};
			return ret;
		}
		
		template<typename int8_src_container>
			completion_mask_ completion_mask(const int8_src_container &src) const {
				auto                    first = src.begin();
				struct completion_mask_ ret{data_.base.bytes + 4};
				for (size_t             i     = 0; i < 10; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		completion_mask_ completion_mask(int8_t *const src) const { return completion_mask(static_cast<int8_t const *>( src)); }
		
		completion_mask_ completion_mask(int8_t const *const src) const {
			struct completion_mask_ ret{data_.base.bytes + 4};
			if (src)
				for (size_t         i = 0; i < 10; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		float direction_x() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 14, 4))); }
		
		void direction_x(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 14); }
		
		float direction_y() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 18, 4))); }
		
		void direction_y(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 18); }
		
		float direction_z() const { return (intBitsToFloat(get_bytes(data_.base.bytes, 22, 4))); }
		
		void direction_z(float src) const { set_bytes(floatToIntBits(src), 4, data_.base.bytes, 22); }
		
		struct cal_status_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAG_CAL_STATUS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		cal_status_ cal_status() const {
			if (data_.base.field_bit != 208 && !set_field(&data_, 208, -1)) return {0, 0};
			cal_status_ ret{true, static_cast< enum MAG_CAL_STATUS > (    static_cast< enum MAG_CAL_STATUS >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void cal_status(enum MAG_CAL_STATUS src) const {
			
			if (data_.base.field_bit != 208) set_field(&data_, 208, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void compass_id( int8_t src  ) {}
	void cal_mask( int8_t src  ) {}
	void cal_status( enum com::company::demo:: MAG_CAL_STATUS src  ) {}
	void attempt( int8_t src  ) {}
	void completion_pct( int8_t src  ) {}
	void completion_mask( const struct com::company::demo::MAG_CAL_PROGRESS :: completion_mask_  & src  ) const {}
	void direction_x( float src  ) {}
	void direction_y( float src  ) {}
	void direction_z( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t compass_id(  ) {}
	int8_t compass_id(  ) {}
	int8_t cal_mask(  ) {}
	int8_t cal_mask(  ) {}
	enum com::company::demo:: MAG_CAL_STATUS cal_status(  ) {}
	bool cal_status_exists(){}
	int8_t attempt(  ) {}
	int8_t attempt(  ) {}
	int8_t completion_pct(  ) {}
	int8_t completion_pct(  ) {}
	std container of int8  completion_mask(  ) {}
	float direction_x(  ) {}
	float direction_x(  ) {}
	float direction_y(  ) {}
	float direction_y(  ) {}
	float direction_z(  ) {}
	float direction_z(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct HIGHRES_IMU {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		HIGHRES_IMU(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const HIGHRES_IMU &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 62) == 0);
		}
		
		int16_t fields_updated() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void fields_updated(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 2, 8))); }
		
		void time_usec(int64_t src) const { set_bytes((src), 8, &data_, 2); }
		
		float xacc() const { return (intBitsToFloat(get_bytes(&data_, 10, 4))); }
		
		void xacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 10); }
		
		float yacc() const { return (intBitsToFloat(get_bytes(&data_, 14, 4))); }
		
		void yacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 14); }
		
		float zacc() const { return (intBitsToFloat(get_bytes(&data_, 18, 4))); }
		
		void zacc(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 18); }
		
		float xgyro() const { return (intBitsToFloat(get_bytes(&data_, 22, 4))); }
		
		void xgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 22); }
		
		float ygyro() const { return (intBitsToFloat(get_bytes(&data_, 26, 4))); }
		
		void ygyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 26); }
		
		float zgyro() const { return (intBitsToFloat(get_bytes(&data_, 30, 4))); }
		
		void zgyro(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 30); }
		
		float xmag() const { return (intBitsToFloat(get_bytes(&data_, 34, 4))); }
		
		void xmag(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 34); }
		
		float ymag() const { return (intBitsToFloat(get_bytes(&data_, 38, 4))); }
		
		void ymag(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 38); }
		
		float zmag() const { return (intBitsToFloat(get_bytes(&data_, 42, 4))); }
		
		void zmag(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 42); }
		
		float abs_pressure() const { return (intBitsToFloat(get_bytes(&data_, 46, 4))); }
		
		void abs_pressure(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 46); }
		
		float diff_pressure() const { return (intBitsToFloat(get_bytes(&data_, 50, 4))); }
		
		void diff_pressure(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 50); }
		
		float pressure_alt() const { return (intBitsToFloat(get_bytes(&data_, 54, 4))); }
		
		void pressure_alt(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 54); }
		
		float temperature() const { return (intBitsToFloat(get_bytes(&data_, 58, 4))); }
		
		void temperature(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 58); }
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void xacc( float src  ) {}
	void yacc( float src  ) {}
	void zacc( float src  ) {}
	void xgyro( float src  ) {}
	void ygyro( float src  ) {}
	void zgyro( float src  ) {}
	void xmag( float src  ) {}
	void ymag( float src  ) {}
	void zmag( float src  ) {}
	void abs_pressure( float src  ) {}
	void diff_pressure( float src  ) {}
	void pressure_alt( float src  ) {}
	void temperature( float src  ) {}
	void fields_updated( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int64_t time_usec(  ) {}
	int64_t time_usec(  ) {}
	float xacc(  ) {}
	float xacc(  ) {}
	float yacc(  ) {}
	float yacc(  ) {}
	float zacc(  ) {}
	float zacc(  ) {}
	float xgyro(  ) {}
	float xgyro(  ) {}
	float ygyro(  ) {}
	float ygyro(  ) {}
	float zgyro(  ) {}
	float zgyro(  ) {}
	float xmag(  ) {}
	float xmag(  ) {}
	float ymag(  ) {}
	float ymag(  ) {}
	float zmag(  ) {}
	float zmag(  ) {}
	float abs_pressure(  ) {}
	float abs_pressure(  ) {}
	float diff_pressure(  ) {}
	float diff_pressure(  ) {}
	float pressure_alt(  ) {}
	float pressure_alt(  ) {}
	float temperature(  ) {}
	float temperature(  ) {}
	int16_t fields_updated(  ) {}
	int16_t fields_updated(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct EXTENDED_SYS_STATE {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const EXTENDED_SYS_STATE &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct vtol_state_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_VTOL_STATE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		vtol_state_ vtol_state() const {
			if (data_.base.field_bit != 0 && !set_field(&data_, 0, -1)) return {0, 0};
			vtol_state_ ret{true, static_cast< enum MAV_VTOL_STATE > (    static_cast< enum MAV_VTOL_STATE >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void vtol_state(enum MAV_VTOL_STATE src) const {
			
			if (data_.base.field_bit != 0) set_field(&data_, 0, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct landed_state_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum MAV_LANDED_STATE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		landed_state_ landed_state() const {
			if (data_.base.field_bit != 1 && !set_field(&data_, 1, -1)) return {0, 0};
			landed_state_ ret{true, static_cast< enum MAV_LANDED_STATE > (    static_cast< enum MAV_LANDED_STATE >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void landed_state(enum MAV_LANDED_STATE src) const {
			
			if (data_.base.field_bit != 1) set_field(&data_, 1, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void vtol_state( enum com::company::demo:: MAV_VTOL_STATE src  ) {}
	void landed_state( enum com::company::demo:: MAV_LANDED_STATE src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: MAV_VTOL_STATE vtol_state(  ) {}
	bool vtol_state_exists(){}
	enum com::company::demo:: MAV_LANDED_STATE landed_state(  ) {}
	bool landed_state_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct UAVIONIX_ADSB_OUT_DYNAMIC {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const UAVIONIX_ADSB_OUT_DYNAMIC &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int16_t accuracyVert() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 0, 2))); }
		
		void accuracyVert(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 0); }
		
		int16_t accuracyVel() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 2, 2))); }
		
		void accuracyVel(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 2); }
		
		int16_t squawk() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 4, 2))); }
		
		void squawk(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 4); }
		
		int32_t utcTime() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 6, 4))); }
		
		void utcTime(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 6); }
		
		int32_t accuracyHor() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 10, 4))); }
		
		void accuracyHor(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 10); }
		
		int32_t gpsLat() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 14, 4))); }
		
		void gpsLat(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 14); }
		
		int32_t gpsLon() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 18, 4))); }
		
		void gpsLon(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 18); }
		
		int32_t gpsAlt() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 22, 4))); }
		
		void gpsAlt(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 22); }
		
		int8_t numSats() const { return static_cast< int8_t >((data_.base.bytes)[26] ); }
		
		void numSats(int8_t src) const { (data_.base.bytes)[26] = (uint8_t) (src); }
		
		int32_t baroAltMSL() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 27, 4))); }
		
		void baroAltMSL(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 27); }
		
		int16_t velVert() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 31, 2))); }
		
		void velVert(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 31); }
		
		int16_t velNS() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 33, 2))); }
		
		void velNS(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 33); }
		
		int16_t VelEW() const { return (static_cast< int16_t > (get_bytes(data_.base.bytes, 35, 2))); }
		
		void VelEW(int16_t src) const { set_bytes((uint16_t) (src), 2, data_.base.bytes, 35); }
		
		struct gpsFix_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		gpsFix_ gpsFix() const {
			if (data_.base.field_bit != 298 && !set_field(&data_, 298, -1)) return {0, 0};
			gpsFix_ ret{true, static_cast< enum UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX > (    static_cast< enum UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void gpsFix(enum UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX src) const {
			
			if (data_.base.field_bit != 298) set_field(&data_, 298, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct emergencyStatus_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum UAVIONIX_ADSB_EMERGENCY_STATUS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		emergencyStatus_ emergencyStatus() const {
			if (data_.base.field_bit != 299 && !set_field(&data_, 299, -1)) return {0, 0};
			emergencyStatus_ ret{true, static_cast< enum UAVIONIX_ADSB_EMERGENCY_STATUS > (    static_cast< enum UAVIONIX_ADSB_EMERGENCY_STATUS >(   get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void emergencyStatus(enum UAVIONIX_ADSB_EMERGENCY_STATUS src) const {
			
			if (data_.base.field_bit != 299) set_field(&data_, 299, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 3, data_.base.bytes, data_.BIT);
		}
		
		
		struct state_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum UAVIONIX_ADSB_OUT_DYNAMIC_STATE value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		state_ state() const {
			if (data_.base.field_bit != 300 && !set_field(&data_, 300, -1)) return {0, 0};
			state_ ret{true, static_cast< enum UAVIONIX_ADSB_OUT_DYNAMIC_STATE > ( UAVIONIX_ADSB_OUT_DYNAMIC_STATE_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void state(enum UAVIONIX_ADSB_OUT_DYNAMIC_STATE src) const {
			
			if (data_.base.field_bit != 300) set_field(&data_, 300, 0);
			
			set_bits(UAVIONIX_ADSB_OUT_DYNAMIC_STATE_into(src), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void utcTime( int32_t src  ) {}
	void gpsLat( int32_t src  ) {}
	void gpsLon( int32_t src  ) {}
	void gpsAlt( int32_t src  ) {}
	void gpsFix( enum com::company::demo:: UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX src  ) {}
	void numSats( int8_t src  ) {}
	void baroAltMSL( int32_t src  ) {}
	void accuracyHor( int32_t src  ) {}
	void accuracyVert( int16_t src  ) {}
	void accuracyVel( int16_t src  ) {}
	void velVert( int16_t src  ) {}
	void velNS( int16_t src  ) {}
	void VelEW( int16_t src  ) {}
	void emergencyStatus( enum com::company::demo:: UAVIONIX_ADSB_EMERGENCY_STATUS src  ) {}
	void state( enum com::company::demo:: UAVIONIX_ADSB_OUT_DYNAMIC_STATE src  ) {}
	void squawk( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t utcTime(  ) {}
	int32_t utcTime(  ) {}
	int32_t gpsLat(  ) {}
	int32_t gpsLat(  ) {}
	int32_t gpsLon(  ) {}
	int32_t gpsLon(  ) {}
	int32_t gpsAlt(  ) {}
	int32_t gpsAlt(  ) {}
	enum com::company::demo:: UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX gpsFix(  ) {}
	bool gpsFix_exists(){}
	int8_t numSats(  ) {}
	int8_t numSats(  ) {}
	int32_t baroAltMSL(  ) {}
	int32_t baroAltMSL(  ) {}
	int32_t accuracyHor(  ) {}
	int32_t accuracyHor(  ) {}
	int16_t accuracyVert(  ) {}
	int16_t accuracyVert(  ) {}
	int16_t accuracyVel(  ) {}
	int16_t accuracyVel(  ) {}
	int16_t velVert(  ) {}
	int16_t velVert(  ) {}
	int16_t velNS(  ) {}
	int16_t velNS(  ) {}
	int16_t VelEW(  ) {}
	int16_t VelEW(  ) {}
	enum com::company::demo:: UAVIONIX_ADSB_EMERGENCY_STATUS emergencyStatus(  ) {}
	bool emergencyStatus_exists(){}
	enum com::company::demo:: UAVIONIX_ADSB_OUT_DYNAMIC_STATE state(  ) {}
	bool state_exists(){}
	int16_t squawk(  ) {}
	int16_t squawk(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GOPRO_GET_RESPONSE {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const GOPRO_GET_RESPONSE &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct value_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, value_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, value_> end() const { return {*this, 4}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 4;
			
		};
		
		struct value_ value() const {
			struct value_ ret{data_.base.bytes + 0};
			return ret;
		}
		
		template<typename int8_src_container>
			value_ value(const int8_src_container &src) const {
				auto          first = src.begin();
				struct value_ ret{data_.base.bytes + 0};
				for (size_t   i     = 0; i < 4; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		value_ value(int8_t *const src) const { return value(static_cast<int8_t const *>( src)); }
		
		value_ value(int8_t const *const src) const {
			struct value_   ret{data_.base.bytes + 0};
			if (src)
				for (size_t i = 0; i < 4; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		struct cmd_id_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GOPRO_COMMAND value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		cmd_id_ cmd_id() const {
			if (data_.base.field_bit != 32 && !set_field(&data_, 32, -1)) return {0, 0};
			cmd_id_ ret{true, static_cast< enum GOPRO_COMMAND > (    static_cast< enum GOPRO_COMMAND >(   get_bits(data_.base.bytes, data_.BIT, 5)))};
			return ret;
		}
		
		
		void cmd_id(enum GOPRO_COMMAND src) const {
			
			if (data_.base.field_bit != 32) set_field(&data_, 32, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 5, data_.base.bytes, data_.BIT);
		}
		
		
		struct status_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum GOPRO_REQUEST_STATUS value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		status_ status() const {
			if (data_.base.field_bit != 33 && !set_field(&data_, 33, -1)) return {0, 0};
			status_ ret{true, static_cast< enum GOPRO_REQUEST_STATUS > (    static_cast< enum GOPRO_REQUEST_STATUS >(   get_bits(data_.base.bytes, data_.BIT, 1)))};
			return ret;
		}
		
		
		void status(enum GOPRO_REQUEST_STATUS src) const {
			
			if (data_.base.field_bit != 33) set_field(&data_, 33, 0);
			
			set_bits(static_cast< uintptr_t >(    src  ), 1, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void cmd_id( enum com::company::demo:: GOPRO_COMMAND src  ) {}
	void status( enum com::company::demo:: GOPRO_REQUEST_STATUS src  ) {}
	void value( const struct com::company::demo::GOPRO_GET_RESPONSE :: value_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: GOPRO_COMMAND cmd_id(  ) {}
	bool cmd_id_exists(){}
	enum com::company::demo:: GOPRO_REQUEST_STATUS status(  ) {}
	bool status_exists(){}
	std container of int8  value(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GPS_INJECT_DATA {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		GPS_INJECT_DATA(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const GPS_INJECT_DATA &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 113) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		int8_t len() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void len(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 110}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 110;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 3};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 3};
				for (size_t  i     = 0; i < 110; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{&data_ + 3};
			if (src)
				for (size_t i = 0; i < 110; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void len( int8_t src  ) {}
	void daTa( const struct com::company::demo::GPS_INJECT_DATA :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int8_t len(  ) {}
	int8_t len(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		
		struct rfHealth_ {
			const bool IS_EXISTS;
			union CASE {
				struct EXISTS {
					const enum UAVIONIX_ADSB_RF_HEALTH value;
					
				} EXISTS;
			}          CASE;
			
		};
		
		
		rfHealth_ rfHealth() const {
			if (data_.base.field_bit != 0 && !set_field(&data_, 0, -1)) return {0, 0};
			rfHealth_ ret{true, static_cast< enum UAVIONIX_ADSB_RF_HEALTH > ( UAVIONIX_ADSB_RF_HEALTH_from(get_bits(data_.base.bytes, data_.BIT, 3)))};
			return ret;
		}
		
		
		void rfHealth(enum UAVIONIX_ADSB_RF_HEALTH src) const {
			
			if (data_.base.field_bit != 0) set_field(&data_, 0, 0);
			
			set_bits(UAVIONIX_ADSB_RF_HEALTH_into(src), 3, data_.base.bytes, data_.BIT);
		}
		
		
		/*
struct <DST> {
	void rfHealth( enum com::company::demo:: UAVIONIX_ADSB_RF_HEALTH src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	enum com::company::demo:: UAVIONIX_ADSB_RF_HEALTH rfHealth(  ) {}
	bool rfHealth_exists(){}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct ATTITUDE_QUATERNION_COV {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		ATTITUDE_QUATERNION_COV(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const ATTITUDE_QUATERNION_COV &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 72) == 0);
		}
		
		int64_t time_usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		
		struct q_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, q_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, q_> end() const { return {*this, 4}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			static constexpr size_t len = 4;
			
		};
		
		struct q_ q() const {
			struct q_ ret{&data_ + 8};
			return ret;
		}
		
		float rollspeed() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		float pitchspeed() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		float yawspeed() const { return (intBitsToFloat(get_bytes(&data_, 32, 4))); }
		
		
		struct covariance_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<float, covariance_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<float, covariance_> end() const { return {*this, 9}; }
			
			float get(size_t index) const { return (intBitsToFloat(get_bytes(bytes, index * 4, 4))); }
			
			
			static constexpr size_t len = 9;
			
		};
		
		struct covariance_ covariance() const {
			struct covariance_ ret{&data_ + 36};
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_usec( int64_t src  ) {}
	void q( const struct com::company::demo::ATTITUDE_QUATERNION_COV :: q_  & src  ) const {}
	void rollspeed( float src  ) {}
	void pitchspeed( float src  ) {}
	void yawspeed( float src  ) {}
	void covariance( const struct com::company::demo::ATTITUDE_QUATERNION_COV :: covariance_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct NAMED_VALUE_INT {
		static Meta meta;
		
		Cursor &data_;
		
		Pack *unwrap_() {
			Pack *pack = data_.base.pack;
			data_.base.pack  = nullptr;
			data_.base.meta  = nullptr;
			data_.base.bytes = nullptr;
			return pack;
		}
		
		bool operator==(const NAMED_VALUE_INT &rhs) { return org::unirail::utils::is_equal_data(data_, rhs.data_); }
		
		int32_t time_boot_ms() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 0, 4))); }
		
		void time_boot_ms(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 0); }
		
		int32_t value() const { return (static_cast< int32_t > (get_bytes(data_.base.bytes, 4, 4))); }
		
		void value(int32_t src) const { set_bytes((uint32_t) (src), 4, data_.base.bytes, 4); }
		
		struct name_ {
			const bool              IS_EXISTS;
			union CASE {
				struct EXISTS {
					uint8_t *const bytes;
					const size_t length;
					
					org::unirail::utils::iterator<char, EXISTS> begin() const { return {*this}; }
					
					org::unirail::utils::iterator<char, EXISTS> end() const { return {*this, length}; }
					
					char get(size_t index) const { return static_cast< char >((bytes)[index] ); }
					
					void set(char src, size_t index) const { (bytes)[index] = (uint8_t) (src); }
				} EXISTS;
			}                       CASE;
			static constexpr size_t len_max = 255;
			
		};
		
		
		name_ name() const {
			if (data_.base.field_bit != 66 && !set_field(&data_, 66, -1)) return {0, 0, 0};
			
			name_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			return ret;
		}
		
		template<typename char_src_container>
			name_ name(const char_src_container &src) const {
				auto first = src.begin();
				auto last  = src.end();
				
				auto len = std::distance(first, last);
				len = 255 < len ? 255 : len;
				
				if (data_.base.field_bit != 66) set_field(&data_, 66, len);
				const name_ ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
				std::copy(first, last, data_.base.bytes + data_.BYTE);
				return ret;
			}
		
		name_ name(const char src[], size_t len) const {
			len               = 255 < len ? 255 : len;
			if (data_.base.field_bit != 66) set_field(&data_, 66, len);
			const name_     ret{true, data_.base.bytes + data_.BYTE, data_.item_len};
			if (src)
				for (size_t i = 0; i < len; i++)
					ret.CASE.EXISTS.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void time_boot_ms( int32_t src  ) {}
	void name( const struct com::company::demo::NAMED_VALUE_INT :: name_::CASE::EXISTS  & src  ) const {}
	void value( int32_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int32_t time_boot_ms(  ) {}
	int32_t time_boot_ms(  ) {}
	std container of chars  name(  ) {}
	bool name_exists(){}
	int32_t value(  ) {}
	int32_t value(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct RPM {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RPM(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RPM &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 8) == 0);
		}
		
		float rpm1() const { return (intBitsToFloat(get_bytes(&data_, 0, 4))); }
		
		void rpm1(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 0); }
		
		float rpm2() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void rpm2(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		
		/*
struct <DST> {
	void rpm1( float src  ) {}
	void rpm2( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	float rpm1(  ) {}
	float rpm1(  ) {}
	float rpm2(  ) {}
	float rpm2(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GPS_RTCM_DATA {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		GPS_RTCM_DATA(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const GPS_RTCM_DATA &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 182) == 0);
		}
		
		int8_t flags() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void flags(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t len() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void len(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		struct daTa_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, daTa_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, daTa_> end() const { return {*this, 180}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 180;
			
		};
		
		struct daTa_ daTa() const {
			struct daTa_ ret{&data_ + 2};
			return ret;
		}
		
		template<typename int8_src_container>
			daTa_ daTa(const int8_src_container &src) const {
				auto         first = src.begin();
				struct daTa_ ret{&data_ + 2};
				for (size_t  i     = 0; i < 180; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		daTa_ daTa(int8_t *const src) const { return daTa(static_cast<int8_t const *>( src)); }
		
		daTa_ daTa(int8_t const *const src) const {
			struct daTa_    ret{&data_ + 2};
			if (src)
				for (size_t i = 0; i < 180; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void flags( int8_t src  ) {}
	void len( int8_t src  ) {}
	void daTa( const struct com::company::demo::GPS_RTCM_DATA :: daTa_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t flags(  ) {}
	int8_t flags(  ) {}
	int8_t len(  ) {}
	int8_t len(  ) {}
	std container of int8  daTa(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct GLOBAL_VISION_POSITION_ESTIMATE {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		GLOBAL_VISION_POSITION_ESTIMATE(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const GLOBAL_VISION_POSITION_ESTIMATE &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 32) == 0);
		}
		
		int64_t usec() const { return (static_cast< int64_t > (get_bytes(&data_, 0, 8))); }
		
		float x() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		float y() const { return (intBitsToFloat(get_bytes(&data_, 12, 4))); }
		
		float z() const { return (intBitsToFloat(get_bytes(&data_, 16, 4))); }
		
		float roll() const { return (intBitsToFloat(get_bytes(&data_, 20, 4))); }
		
		float pitch() const { return (intBitsToFloat(get_bytes(&data_, 24, 4))); }
		
		float yaw() const { return (intBitsToFloat(get_bytes(&data_, 28, 4))); }
		
		
		/*
struct <DST> {
	void usec( int64_t src  ) {}
	void x( float src  ) {}
	void y( float src  ) {}
	void z( float src  ) {}
	void roll( float src  ) {}
	void pitch( float src  ) {}
	void yaw( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
	};
	
	struct FILE_TRANSFER_PROTOCOL {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		FILE_TRANSFER_PROTOCOL(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const FILE_TRANSFER_PROTOCOL &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 254) == 0);
		}
		
		int8_t target_network() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_network(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_system(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void target_component(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		struct payload_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, payload_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, payload_> end() const { return {*this, 251}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 251;
			
		};
		
		struct payload_ payload() const {
			struct payload_ ret{&data_ + 3};
			return ret;
		}
		
		template<typename int8_src_container>
			payload_ payload(const int8_src_container &src) const {
				auto            first = src.begin();
				struct payload_ ret{&data_ + 3};
				for (size_t     i     = 0; i < 251; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		payload_ payload(int8_t *const src) const { return payload(static_cast<int8_t const *>( src)); }
		
		payload_ payload(int8_t const *const src) const {
			struct payload_ ret{&data_ + 3};
			if (src)
				for (size_t i = 0; i < 251; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void target_network( int8_t src  ) {}
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void payload( const struct com::company::demo::FILE_TRANSFER_PROTOCOL :: payload_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_network(  ) {}
	int8_t target_network(  ) {}
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	std container of int8  payload(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct RANGEFINDER {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RANGEFINDER(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RANGEFINDER &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 8) == 0);
		}
		
		float distance() const { return (intBitsToFloat(get_bytes(&data_, 0, 4))); }
		
		void distance(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 0); }
		
		float voltage() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void voltage(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		
		/*
struct <DST> {
	void distance( float src  ) {}
	void voltage( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	float distance(  ) {}
	float distance(  ) {}
	float voltage(  ) {}
	float voltage(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct RADIO_STATUS {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RADIO_STATUS(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RADIO_STATUS &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 9) == 0);
		}
		
		int16_t rxerrors() const { return (static_cast< int16_t > (get_bytes(&data_, 0, 2))); }
		
		void rxerrors(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 0); }
		
		int16_t fixeD() const { return (static_cast< int16_t > (get_bytes(&data_, 2, 2))); }
		
		void fixeD(int16_t src) const { set_bytes((uint16_t) (src), 2, &data_, 2); }
		
		int8_t rssi() const { return static_cast< int8_t >((&data_)[4] ); }
		
		void rssi(int8_t src) const { (&data_)[4] = (uint8_t) (src); }
		
		int8_t remrssi() const { return static_cast< int8_t >((&data_)[5] ); }
		
		void remrssi(int8_t src) const { (&data_)[5] = (uint8_t) (src); }
		
		int8_t txbuf() const { return static_cast< int8_t >((&data_)[6] ); }
		
		void txbuf(int8_t src) const { (&data_)[6] = (uint8_t) (src); }
		
		int8_t noise() const { return static_cast< int8_t >((&data_)[7] ); }
		
		void noise(int8_t src) const { (&data_)[7] = (uint8_t) (src); }
		
		int8_t remnoise() const { return static_cast< int8_t >((&data_)[8] ); }
		
		void remnoise(int8_t src) const { (&data_)[8] = (uint8_t) (src); }
		
		
		/*
struct <DST> {
	void rssi( int8_t src  ) {}
	void remrssi( int8_t src  ) {}
	void txbuf( int8_t src  ) {}
	void noise( int8_t src  ) {}
	void remnoise( int8_t src  ) {}
	void rxerrors( int16_t src  ) {}
	void fixeD( int16_t src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t rssi(  ) {}
	int8_t rssi(  ) {}
	int8_t remrssi(  ) {}
	int8_t remrssi(  ) {}
	int8_t txbuf(  ) {}
	int8_t txbuf(  ) {}
	int8_t noise(  ) {}
	int8_t noise(  ) {}
	int8_t remnoise(  ) {}
	int8_t remnoise(  ) {}
	int16_t rxerrors(  ) {}
	int16_t rxerrors(  ) {}
	int16_t fixeD(  ) {}
	int16_t fixeD(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct FENCE_POINT {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		FENCE_POINT(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const FENCE_POINT &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 12) == 0);
		}
		
		int8_t target_system() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void target_system(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t target_component() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void target_component(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		int8_t idx() const { return static_cast< int8_t >((&data_)[2] ); }
		
		void idx(int8_t src) const { (&data_)[2] = (uint8_t) (src); }
		
		int8_t count() const { return static_cast< int8_t >((&data_)[3] ); }
		
		void count(int8_t src) const { (&data_)[3] = (uint8_t) (src); }
		
		float lat() const { return (intBitsToFloat(get_bytes(&data_, 4, 4))); }
		
		void lat(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 4); }
		
		float lng() const { return (intBitsToFloat(get_bytes(&data_, 8, 4))); }
		
		void lng(float src) const { set_bytes(floatToIntBits(src), 4, &data_, 8); }
		
		
		/*
struct <DST> {
	void target_system( int8_t src  ) {}
	void target_component( int8_t src  ) {}
	void idx( int8_t src  ) {}
	void count( int8_t src  ) {}
	void lat( float src  ) {}
	void lng( float src  ) {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t target_system(  ) {}
	int8_t target_system(  ) {}
	int8_t target_component(  ) {}
	int8_t target_component(  ) {}
	int8_t idx(  ) {}
	int8_t idx(  ) {}
	int8_t count(  ) {}
	int8_t count(  ) {}
	float lat(  ) {}
	float lat(  ) {}
	float lng(  ) {}
	float lng(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	struct RESOURCE_REQUEST {
		static Meta meta;
		
		Pack    *pack_;
		uint8_t &data_;
		
		RESOURCE_REQUEST(Pack *pack, uint8_t &data) : pack_(pack), data_(data) {}
		
		Pack *unwrap_() {
			Pack *ret = pack_;
			pack_ = nullptr;
			return ret;
		}
		
		bool operator==(const RESOURCE_REQUEST &rhs) {
			return &data_ == &rhs.data_ || (memcmp(&data_, &rhs.data_, 243) == 0);
		}
		
		int8_t request_id() const { return static_cast< int8_t >((&data_)[0] ); }
		
		void request_id(int8_t src) const { (&data_)[0] = (uint8_t) (src); }
		
		int8_t uri_type() const { return static_cast< int8_t >((&data_)[1] ); }
		
		void uri_type(int8_t src) const { (&data_)[1] = (uint8_t) (src); }
		
		struct uri_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, uri_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, uri_> end() const { return {*this, 120}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 120;
			
		};
		
		struct uri_ uri() const {
			struct uri_ ret{&data_ + 2};
			return ret;
		}
		
		template<typename int8_src_container>
			uri_ uri(const int8_src_container &src) const {
				auto        first = src.begin();
				struct uri_ ret{&data_ + 2};
				for (size_t i     = 0; i < 120; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		uri_ uri(int8_t *const src) const { return uri(static_cast<int8_t const *>( src)); }
		
		uri_ uri(int8_t const *const src) const {
			struct uri_     ret{&data_ + 2};
			if (src)
				for (size_t i = 0; i < 120; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		int8_t transfer_type() const { return static_cast< int8_t >((&data_)[122] ); }
		
		void transfer_type(int8_t src) const { (&data_)[122] = (uint8_t) (src); }
		
		struct storage_ {
			uint8_t *bytes;
			size_t length;
			
			org::unirail::utils::iterator<int8_t, storage_> begin() const { return {*this}; }
			
			org::unirail::utils::iterator<int8_t, storage_> end() const { return {*this, 120}; }
			
			int8_t get(size_t index) const { return static_cast< int8_t >((bytes)[index] ); }
			
			
			void set(int8_t src, size_t index) const {
				
				(bytes)[index] = (uint8_t) (src);
			}
			
			static constexpr size_t len = 120;
			
		};
		
		struct storage_ storage() const {
			struct storage_ ret{&data_ + 123};
			return ret;
		}
		
		template<typename int8_src_container>
			storage_ storage(const int8_src_container &src) const {
				auto            first = src.begin();
				struct storage_ ret{&data_ + 123};
				for (size_t     i     = 0; i < 120; i++, ++first)
					ret.set(*first, i);
				return ret;
			}
		
		storage_ storage(int8_t *const src) const { return storage(static_cast<int8_t const *>( src)); }
		
		storage_ storage(int8_t const *const src) const {
			struct storage_ ret{&data_ + 123};
			if (src)
				for (size_t i = 0; i < 120; i++)
					ret.set(src[i], i);
			return ret;
		}
		
		
		/*
struct <DST> {
	void request_id( int8_t src  ) {}
	void uri_type( int8_t src  ) {}
	void uri( const struct com::company::demo::RESOURCE_REQUEST :: uri_  & src  ) const {}
	void transfer_type( int8_t src  ) {}
	void storage( const struct com::company::demo::RESOURCE_REQUEST :: storage_  & src  ) const {}
}
*/
		template<typename DST>
			void push_data_(DST dst) const;
		
		/*
struct <SRC> {
	int8_t request_id(  ) {}
	int8_t request_id(  ) {}
	int8_t uri_type(  ) {}
	int8_t uri_type(  ) {}
	std container of int8  uri(  ) {}
	int8_t transfer_type(  ) {}
	int8_t transfer_type(  ) {}
	std container of int8  storage(  ) {}
}
*/
		template<typename SRC>
			void pull_data_(SRC src);
		
	};
	
	
	template<typename DST>
		void ATTITUDE_TARGET::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.type_mask(type_mask());
			
			dst.q(q());
			
			dst.body_roll_rate(body_roll_rate());
			
			dst.body_pitch_rate(body_pitch_rate());
			
			dst.body_yaw_rate(body_yaw_rate());
			
			dst.thrust(thrust());
			
		}
	
	template<typename DST>
		void MISSION_COUNT::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.count(count());
			auto src_mission_type = mission_type();
			
			if (src_mission_type.IS_EXISTS)
				dst.mission_type(src_mission_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void ADSB_VEHICLE::pull_data_(SRC src) {
			
			ICAO_address(src.ICAO_address());
			
			lat(src.lat());
			
			lon(src.lon());
			
			if (src.altitude_type_exists())
				altitude_type(src.altitude_type());
			
			
			altitude(src.altitude());
			
			heading(src.heading());
			
			hor_velocity(src.hor_velocity());
			
			ver_velocity(src.ver_velocity());
			if (src.callsign_exists())
				callsign(src.callsign());
			
			
			if (src.emitter_type_exists())
				emitter_type(src.emitter_type());
			
			
			tslc(src.tslc());
			
			if (src.flags_exists())
				flags(src.flags());
			
			
			squawk(src.squawk());
			
		}
	
	template<typename DST>
		void ADSB_VEHICLE::push_data_(DST dst) const {
			
			dst.ICAO_address(ICAO_address());
			
			dst.lat(lat());
			
			dst.lon(lon());
			auto src_altitude_type = altitude_type();
			
			if (src_altitude_type.IS_EXISTS)
				dst.altitude_type(src_altitude_type.CASE.EXISTS.value);
			
			
			dst.altitude(altitude());
			
			dst.heading(heading());
			
			dst.hor_velocity(hor_velocity());
			
			dst.ver_velocity(ver_velocity());
			auto src_callsign = callsign();
			
			if (src_callsign.IS_EXISTS)
				dst.callsign(src_callsign.CASE.EXISTS);
			
			auto src_emitter_type = emitter_type();
			
			if (src_emitter_type.IS_EXISTS)
				dst.emitter_type(src_emitter_type.CASE.EXISTS.value);
			
			
			dst.tslc(tslc());
			auto src_flags = flags();
			
			if (src_flags.IS_EXISTS)
				dst.flags(src_flags.CASE.EXISTS.value);
			
			
			dst.squawk(squawk());
			
		}
	
	template<typename SRC>
		void MESSAGE_INTERVAL::pull_data_(SRC src) {
			
			message_id(src.message_id());
			
			interval_us(src.interval_us());
			
		}
	
	template<typename DST>
		void MESSAGE_INTERVAL::push_data_(DST dst) const {
			
			dst.message_id(message_id());
			
			dst.interval_us(interval_us());
			
		}
	
	template<typename SRC>
		void EKF_STATUS_REPORT::pull_data_(SRC src) {
			
			if (src.flags_exists())
				flags(src.flags());
			
			
			velocity_variance(src.velocity_variance());
			
			pos_horiz_variance(src.pos_horiz_variance());
			
			pos_vert_variance(src.pos_vert_variance());
			
			compass_variance(src.compass_variance());
			
			terrain_alt_variance(src.terrain_alt_variance());
			
		}
	
	template<typename DST>
		void EKF_STATUS_REPORT::push_data_(DST dst) const {
			auto src_flags = flags();
			
			if (src_flags.IS_EXISTS)
				dst.flags(src_flags.CASE.EXISTS.value);
			
			
			dst.velocity_variance(velocity_variance());
			
			dst.pos_horiz_variance(pos_horiz_variance());
			
			dst.pos_vert_variance(pos_vert_variance());
			
			dst.compass_variance(compass_variance());
			
			dst.terrain_alt_variance(terrain_alt_variance());
			
		}
	
	template<typename SRC>
		void ESTIMATOR_STATUS::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			if (src.flags_exists())
				flags(src.flags());
			
			
			vel_ratio(src.vel_ratio());
			
			pos_horiz_ratio(src.pos_horiz_ratio());
			
			pos_vert_ratio(src.pos_vert_ratio());
			
			mag_ratio(src.mag_ratio());
			
			hagl_ratio(src.hagl_ratio());
			
			tas_ratio(src.tas_ratio());
			
			pos_horiz_accuracy(src.pos_horiz_accuracy());
			
			pos_vert_accuracy(src.pos_vert_accuracy());
			
		}
	
	template<typename DST>
		void ESTIMATOR_STATUS::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			auto src_flags = flags();
			
			if (src_flags.IS_EXISTS)
				dst.flags(src_flags.CASE.EXISTS.value);
			
			
			dst.vel_ratio(vel_ratio());
			
			dst.pos_horiz_ratio(pos_horiz_ratio());
			
			dst.pos_vert_ratio(pos_vert_ratio());
			
			dst.mag_ratio(mag_ratio());
			
			dst.hagl_ratio(hagl_ratio());
			
			dst.tas_ratio(tas_ratio());
			
			dst.pos_horiz_accuracy(pos_horiz_accuracy());
			
			dst.pos_vert_accuracy(pos_vert_accuracy());
			
		}
	
	template<typename SRC>
		void HWSTATUS::pull_data_(SRC src) {
			
			Vcc(src.Vcc());
			
			I2Cerr(src.I2Cerr());
			
		}
	
	template<typename DST>
		void HWSTATUS::push_data_(DST dst) const {
			
			dst.Vcc(Vcc());
			
			dst.I2Cerr(I2Cerr());
			
		}
	
	template<typename SRC>
		void TIMESYNC::pull_data_(SRC src) {
			
			tc1(src.tc1());
			
			ts1(src.ts1());
			
		}
	
	template<typename DST>
		void TIMESYNC::push_data_(DST dst) const {
			
			dst.tc1(tc1());
			
			dst.ts1(ts1());
			
		}
	
	template<typename SRC>
		void PARAM_EXT_REQUEST_LIST::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
		}
	
	template<typename DST>
		void PARAM_EXT_REQUEST_LIST::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
		}
	
	template<typename DST>
		void GLOBAL_POSITION_INT_COV::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			auto src_estimator_type = estimator_type();
			
			if (src_estimator_type.IS_EXISTS)
				dst.estimator_type(src_estimator_type.CASE.EXISTS.value);
			
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.alt(alt());
			
			dst.relative_alt(relative_alt());
			
			dst.vx(vx());
			
			dst.vy(vy());
			
			dst.vz(vz());
			
			dst.covariance(covariance());
			
		}
	
	template<typename SRC>
		void BUTTON_CHANGE::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			last_change_ms(src.last_change_ms());
			
			state(src.state());
			
		}
	
	template<typename DST>
		void BUTTON_CHANGE::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.last_change_ms(last_change_ms());
			
			dst.state(state());
			
		}
	
	template<typename DST>
		void SAFETY_SET_ALLOWED_AREA::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_frame = frame();
			
			if (src_frame.IS_EXISTS)
				dst.frame(src_frame.CASE.EXISTS.value);
			
			
			dst.p1x(p1x());
			
			dst.p1y(p1y());
			
			dst.p1z(p1z());
			
			dst.p2x(p2x());
			
			dst.p2y(p2y());
			
			dst.p2z(p2z());
			
		}
	
	template<typename SRC>
		void UAVCAN_NODE_STATUS::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			uptime_sec(src.uptime_sec());
			
			if (src.health_exists())
				health(src.health());
			
			
			if (src.mode_exists())
				mode(src.mode());
			
			
			sub_mode(src.sub_mode());
			
			vendor_specific_status_code(src.vendor_specific_status_code());
			
		}
	
	template<typename DST>
		void UAVCAN_NODE_STATUS::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.uptime_sec(uptime_sec());
			auto src_health = health();
			
			if (src_health.IS_EXISTS)
				dst.health(src_health.CASE.EXISTS.value);
			
			auto src_mode = mode();
			
			if (src_mode.IS_EXISTS)
				dst.mode(src_mode.CASE.EXISTS.value);
			
			
			dst.sub_mode(sub_mode());
			
			dst.vendor_specific_status_code(vendor_specific_status_code());
			
		}
	
	template<typename SRC>
		void COLLISION::pull_data_(SRC src) {
			
			if (src.sRc_exists())
				sRc(src.sRc());
			
			
			id(src.id());
			
			if (src.action_exists())
				action(src.action());
			
			
			if (src.threat_level_exists())
				threat_level(src.threat_level());
			
			
			time_to_minimum_delta(src.time_to_minimum_delta());
			
			altitude_minimum_delta(src.altitude_minimum_delta());
			
			horizontal_minimum_delta(src.horizontal_minimum_delta());
			
		}
	
	template<typename DST>
		void COLLISION::push_data_(DST dst) const {
			auto src_sRc = sRc();
			
			if (src_sRc.IS_EXISTS)
				dst.sRc(src_sRc.CASE.EXISTS.value);
			
			
			dst.id(id());
			auto src_action = action();
			
			if (src_action.IS_EXISTS)
				dst.action(src_action.CASE.EXISTS.value);
			
			auto src_threat_level = threat_level();
			
			if (src_threat_level.IS_EXISTS)
				dst.threat_level(src_threat_level.CASE.EXISTS.value);
			
			
			dst.time_to_minimum_delta(time_to_minimum_delta());
			
			dst.altitude_minimum_delta(altitude_minimum_delta());
			
			dst.horizontal_minimum_delta(horizontal_minimum_delta());
			
		}
	
	template<typename SRC>
		void GIMBAL_TORQUE_CMD_REPORT::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			rl_torque_cmd(src.rl_torque_cmd());
			
			el_torque_cmd(src.el_torque_cmd());
			
			az_torque_cmd(src.az_torque_cmd());
			
		}
	
	template<typename DST>
		void GIMBAL_TORQUE_CMD_REPORT::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.rl_torque_cmd(rl_torque_cmd());
			
			dst.el_torque_cmd(el_torque_cmd());
			
			dst.az_torque_cmd(az_torque_cmd());
			
		}
	
	template<typename SRC>
		void ALTITUDE::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			altitude_monotonic(src.altitude_monotonic());
			
			altitude_amsl(src.altitude_amsl());
			
			altitude_local(src.altitude_local());
			
			altitude_relative(src.altitude_relative());
			
			altitude_terrain(src.altitude_terrain());
			
			bottom_clearance(src.bottom_clearance());
			
		}
	
	template<typename DST>
		void ALTITUDE::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.altitude_monotonic(altitude_monotonic());
			
			dst.altitude_amsl(altitude_amsl());
			
			dst.altitude_local(altitude_local());
			
			dst.altitude_relative(altitude_relative());
			
			dst.altitude_terrain(altitude_terrain());
			
			dst.bottom_clearance(bottom_clearance());
			
		}
	
	template<typename SRC>
		void HIL_STATE_QUATERNION::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			attitude_quaternion(src.attitude_quaternion());
			
			rollspeed(src.rollspeed());
			
			pitchspeed(src.pitchspeed());
			
			yawspeed(src.yawspeed());
			
			lat(src.lat());
			
			lon(src.lon());
			
			alt(src.alt());
			
			vx(src.vx());
			
			vy(src.vy());
			
			vz(src.vz());
			
			ind_airspeed(src.ind_airspeed());
			
			true_airspeed(src.true_airspeed());
			
			xacc(src.xacc());
			
			yacc(src.yacc());
			
			zacc(src.zacc());
			
		}
	
	template<typename DST>
		void HIL_STATE_QUATERNION::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.attitude_quaternion(attitude_quaternion());
			
			dst.rollspeed(rollspeed());
			
			dst.pitchspeed(pitchspeed());
			
			dst.yawspeed(yawspeed());
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.alt(alt());
			
			dst.vx(vx());
			
			dst.vy(vy());
			
			dst.vz(vz());
			
			dst.ind_airspeed(ind_airspeed());
			
			dst.true_airspeed(true_airspeed());
			
			dst.xacc(xacc());
			
			dst.yacc(yacc());
			
			dst.zacc(zacc());
			
		}
	
	template<typename SRC>
		void SENSOR_OFFSETS::pull_data_(SRC src) {
			
			mag_ofs_x(src.mag_ofs_x());
			
			mag_ofs_y(src.mag_ofs_y());
			
			mag_ofs_z(src.mag_ofs_z());
			
			mag_declination(src.mag_declination());
			
			raw_press(src.raw_press());
			
			raw_temp(src.raw_temp());
			
			gyro_cal_x(src.gyro_cal_x());
			
			gyro_cal_y(src.gyro_cal_y());
			
			gyro_cal_z(src.gyro_cal_z());
			
			accel_cal_x(src.accel_cal_x());
			
			accel_cal_y(src.accel_cal_y());
			
			accel_cal_z(src.accel_cal_z());
			
		}
	
	template<typename DST>
		void SENSOR_OFFSETS::push_data_(DST dst) const {
			
			dst.mag_ofs_x(mag_ofs_x());
			
			dst.mag_ofs_y(mag_ofs_y());
			
			dst.mag_ofs_z(mag_ofs_z());
			
			dst.mag_declination(mag_declination());
			
			dst.raw_press(raw_press());
			
			dst.raw_temp(raw_temp());
			
			dst.gyro_cal_x(gyro_cal_x());
			
			dst.gyro_cal_y(gyro_cal_y());
			
			dst.gyro_cal_z(gyro_cal_z());
			
			dst.accel_cal_x(accel_cal_x());
			
			dst.accel_cal_y(accel_cal_y());
			
			dst.accel_cal_z(accel_cal_z());
			
		}
	
	template<typename SRC>
		void STORAGE_INFORMATION::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			storage_id(src.storage_id());
			
			storage_count(src.storage_count());
			
			status(src.status());
			
			total_capacity(src.total_capacity());
			
			used_capacity(src.used_capacity());
			
			available_capacity(src.available_capacity());
			
			read_speed(src.read_speed());
			
			write_speed(src.write_speed());
			
		}
	
	template<typename DST>
		void STORAGE_INFORMATION::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.storage_id(storage_id());
			
			dst.storage_count(storage_count());
			
			dst.status(status());
			
			dst.total_capacity(total_capacity());
			
			dst.used_capacity(used_capacity());
			
			dst.available_capacity(available_capacity());
			
			dst.read_speed(read_speed());
			
			dst.write_speed(write_speed());
			
		}
	
	template<typename SRC>
		void CAMERA_INFORMATION::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			vendor_name(src.vendor_name());
			
			model_name(src.model_name());
			
			firmware_version(src.firmware_version());
			
			focal_length(src.focal_length());
			
			sensor_size_h(src.sensor_size_h());
			
			sensor_size_v(src.sensor_size_v());
			
			resolution_h(src.resolution_h());
			
			resolution_v(src.resolution_v());
			
			lens_id(src.lens_id());
			
			if (src.flags_exists())
				flags(src.flags());
			
			
			cam_definition_version(src.cam_definition_version());
			if (src.cam_definition_uri_exists())
				cam_definition_uri(src.cam_definition_uri());
			
			
		}
	
	template<typename DST>
		void CAMERA_INFORMATION::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.vendor_name(vendor_name());
			
			dst.model_name(model_name());
			
			dst.firmware_version(firmware_version());
			
			dst.focal_length(focal_length());
			
			dst.sensor_size_h(sensor_size_h());
			
			dst.sensor_size_v(sensor_size_v());
			
			dst.resolution_h(resolution_h());
			
			dst.resolution_v(resolution_v());
			
			dst.lens_id(lens_id());
			auto src_flags = flags();
			
			if (src_flags.IS_EXISTS)
				dst.flags(src_flags.CASE.EXISTS.value);
			
			
			dst.cam_definition_version(cam_definition_version());
			auto src_cam_definition_uri = cam_definition_uri();
			
			if (src_cam_definition_uri.IS_EXISTS)
				dst.cam_definition_uri(src_cam_definition_uri.CASE.EXISTS);
			
			
		}
	
	template<typename DST>
		void GPS_STATUS::push_data_(DST dst) const {
			
			dst.satellites_visible(satellites_visible());
			
			dst.satellite_prn(satellite_prn());
			
			dst.satellite_used(satellite_used());
			
			dst.satellite_elevation(satellite_elevation());
			
			dst.satellite_azimuth(satellite_azimuth());
			
			dst.satellite_snr(satellite_snr());
			
		}
	
	template<typename SRC>
		void DEVICE_OP_WRITE_REPLY::pull_data_(SRC src) {
			
			request_id(src.request_id());
			
			result(src.result());
			
		}
	
	template<typename DST>
		void DEVICE_OP_WRITE_REPLY::push_data_(DST dst) const {
			
			dst.request_id(request_id());
			
			dst.result(result());
			
		}
	
	template<typename DST>
		void PARAM_SET::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_param_id = param_id();
			
			if (src_param_id.IS_EXISTS)
				dst.param_id(src_param_id.CASE.EXISTS);
			
			
			dst.param_value(param_value());
			auto src_param_type = param_type();
			
			if (src_param_type.IS_EXISTS)
				dst.param_type(src_param_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void TERRAIN_DATA::pull_data_(SRC src) {
			
			lat(src.lat());
			
			lon(src.lon());
			
			grid_spacing(src.grid_spacing());
			
			gridbit(src.gridbit());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void TERRAIN_DATA::push_data_(DST dst) const {
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.grid_spacing(grid_spacing());
			
			dst.gridbit(gridbit());
			
			dst.daTa(daTa());
			
		}
	
	template<typename SRC>
		void GIMBAL_CONTROL::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			demanded_rate_x(src.demanded_rate_x());
			
			demanded_rate_y(src.demanded_rate_y());
			
			demanded_rate_z(src.demanded_rate_z());
			
		}
	
	template<typename DST>
		void GIMBAL_CONTROL::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.demanded_rate_x(demanded_rate_x());
			
			dst.demanded_rate_y(demanded_rate_y());
			
			dst.demanded_rate_z(demanded_rate_z());
			
		}
	
	template<typename DST>
		void RC_CHANNELS_OVERRIDE::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.chan1_raw(chan1_raw());
			
			dst.chan2_raw(chan2_raw());
			
			dst.chan3_raw(chan3_raw());
			
			dst.chan4_raw(chan4_raw());
			
			dst.chan5_raw(chan5_raw());
			
			dst.chan6_raw(chan6_raw());
			
			dst.chan7_raw(chan7_raw());
			
			dst.chan8_raw(chan8_raw());
			
		}
	
	template<typename DST>
		void SCALED_IMU::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.xacc(xacc());
			
			dst.yacc(yacc());
			
			dst.zacc(zacc());
			
			dst.xgyro(xgyro());
			
			dst.ygyro(ygyro());
			
			dst.zgyro(zgyro());
			
			dst.xmag(xmag());
			
			dst.ymag(ymag());
			
			dst.zmag(zmag());
			
		}
	
	template<typename SRC>
		void VIDEO_STREAM_INFORMATION::pull_data_(SRC src) {
			
			camera_id(src.camera_id());
			
			status(src.status());
			
			framerate(src.framerate());
			
			resolution_h(src.resolution_h());
			
			resolution_v(src.resolution_v());
			
			bitrate(src.bitrate());
			
			rotation(src.rotation());
			if (src.uri_exists())
				uri(src.uri());
			
			
		}
	
	template<typename DST>
		void VIDEO_STREAM_INFORMATION::push_data_(DST dst) const {
			
			dst.camera_id(camera_id());
			
			dst.status(status());
			
			dst.framerate(framerate());
			
			dst.resolution_h(resolution_h());
			
			dst.resolution_v(resolution_v());
			
			dst.bitrate(bitrate());
			
			dst.rotation(rotation());
			auto src_uri = uri();
			
			if (src_uri.IS_EXISTS)
				dst.uri(src_uri.CASE.EXISTS);
			
			
		}
	
	template<typename SRC>
		void AHRS::pull_data_(SRC src) {
			
			omegaIx(src.omegaIx());
			
			omegaIy(src.omegaIy());
			
			omegaIz(src.omegaIz());
			
			accel_weight(src.accel_weight());
			
			renorm_val(src.renorm_val());
			
			error_rp(src.error_rp());
			
			error_yaw(src.error_yaw());
			
		}
	
	template<typename DST>
		void AHRS::push_data_(DST dst) const {
			
			dst.omegaIx(omegaIx());
			
			dst.omegaIy(omegaIy());
			
			dst.omegaIz(omegaIz());
			
			dst.accel_weight(accel_weight());
			
			dst.renorm_val(renorm_val());
			
			dst.error_rp(error_rp());
			
			dst.error_yaw(error_yaw());
			
		}
	
	template<typename SRC>
		void DEBUG::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			ind(src.ind());
			
			value(src.value());
			
		}
	
	template<typename DST>
		void DEBUG::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.ind(ind());
			
			dst.value(value());
			
		}
	
	template<typename SRC>
		void CAMERA_IMAGE_CAPTURED::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			time_utc(src.time_utc());
			
			camera_id(src.camera_id());
			
			lat(src.lat());
			
			lon(src.lon());
			
			alt(src.alt());
			
			relative_alt(src.relative_alt());
			
			q(src.q());
			
			image_index(src.image_index());
			
			capture_result(src.capture_result());
			if (src.file_url_exists())
				file_url(src.file_url());
			
			
		}
	
	template<typename DST>
		void CAMERA_IMAGE_CAPTURED::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.time_utc(time_utc());
			
			dst.camera_id(camera_id());
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.alt(alt());
			
			dst.relative_alt(relative_alt());
			
			dst.q(q());
			
			dst.image_index(image_index());
			
			dst.capture_result(capture_result());
			auto src_file_url = file_url();
			
			if (src_file_url.IS_EXISTS)
				dst.file_url(src_file_url.CASE.EXISTS);
			
			
		}
	
	template<typename SRC>
		void LOG_ENTRY::pull_data_(SRC src) {
			
			id(src.id());
			
			num_logs(src.num_logs());
			
			last_log_num(src.last_log_num());
			
			time_utc(src.time_utc());
			
			size(src.size());
			
		}
	
	template<typename DST>
		void LOG_ENTRY::push_data_(DST dst) const {
			
			dst.id(id());
			
			dst.num_logs(num_logs());
			
			dst.last_log_num(last_log_num());
			
			dst.time_utc(time_utc());
			
			dst.size(size());
			
		}
	
	template<typename SRC>
		void ACTUATOR_CONTROL_TARGET::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			group_mlx(src.group_mlx());
			
			controls(src.controls());
			
		}
	
	template<typename DST>
		void ACTUATOR_CONTROL_TARGET::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.group_mlx(group_mlx());
			
			dst.controls(controls());
			
		}
	
	template<typename SRC>
		void HIGH_LATENCY::pull_data_(SRC src) {
			
			if (src.base_mode_exists())
				base_mode(src.base_mode());
			
			
			custom_mode(src.custom_mode());
			
			if (src.landed_state_exists())
				landed_state(src.landed_state());
			
			
			roll(src.roll());
			
			pitch(src.pitch());
			
			heading(src.heading());
			
			throttle(src.throttle());
			
			heading_sp(src.heading_sp());
			
			latitude(src.latitude());
			
			longitude(src.longitude());
			
			altitude_amsl(src.altitude_amsl());
			
			altitude_sp(src.altitude_sp());
			
			airspeed(src.airspeed());
			
			airspeed_sp(src.airspeed_sp());
			
			groundspeed(src.groundspeed());
			
			climb_rate(src.climb_rate());
			
			gps_nsat(src.gps_nsat());
			
			if (src.gps_fix_type_exists())
				gps_fix_type(src.gps_fix_type());
			
			
			battery_remaining(src.battery_remaining());
			
			temperature(src.temperature());
			
			temperature_air(src.temperature_air());
			
			failsafe(src.failsafe());
			
			wp_num(src.wp_num());
			
			wp_distance(src.wp_distance());
			
		}
	
	template<typename DST>
		void HIGH_LATENCY::push_data_(DST dst) const {
			auto src_base_mode = base_mode();
			
			if (src_base_mode.IS_EXISTS)
				dst.base_mode(src_base_mode.CASE.EXISTS.value);
			
			
			dst.custom_mode(custom_mode());
			auto src_landed_state = landed_state();
			
			if (src_landed_state.IS_EXISTS)
				dst.landed_state(src_landed_state.CASE.EXISTS.value);
			
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.heading(heading());
			
			dst.throttle(throttle());
			
			dst.heading_sp(heading_sp());
			
			dst.latitude(latitude());
			
			dst.longitude(longitude());
			
			dst.altitude_amsl(altitude_amsl());
			
			dst.altitude_sp(altitude_sp());
			
			dst.airspeed(airspeed());
			
			dst.airspeed_sp(airspeed_sp());
			
			dst.groundspeed(groundspeed());
			
			dst.climb_rate(climb_rate());
			
			dst.gps_nsat(gps_nsat());
			auto src_gps_fix_type = gps_fix_type();
			
			if (src_gps_fix_type.IS_EXISTS)
				dst.gps_fix_type(src_gps_fix_type.CASE.EXISTS.value);
			
			
			dst.battery_remaining(battery_remaining());
			
			dst.temperature(temperature());
			
			dst.temperature_air(temperature_air());
			
			dst.failsafe(failsafe());
			
			dst.wp_num(wp_num());
			
			dst.wp_distance(wp_distance());
			
		}
	
	template<typename DST>
		void PARAM_REQUEST_READ::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_param_id = param_id();
			
			if (src_param_id.IS_EXISTS)
				dst.param_id(src_param_id.CASE.EXISTS);
			
			
			dst.param_index(param_index());
			
		}
	
	template<typename DST>
		void SET_ATTITUDE_TARGET::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.type_mask(type_mask());
			
			dst.q(q());
			
			dst.body_roll_rate(body_roll_rate());
			
			dst.body_pitch_rate(body_pitch_rate());
			
			dst.body_yaw_rate(body_yaw_rate());
			
			dst.thrust(thrust());
			
		}
	
	template<typename SRC>
		void FOLLOW_TARGET::pull_data_(SRC src) {
			
			timestamp(src.timestamp());
			
			est_capabilities(src.est_capabilities());
			
			lat(src.lat());
			
			lon(src.lon());
			
			alt(src.alt());
			
			vel(src.vel());
			
			acc(src.acc());
			
			attitude_q(src.attitude_q());
			
			rates(src.rates());
			
			position_cov(src.position_cov());
			
			custom_state(src.custom_state());
			
		}
	
	template<typename DST>
		void FOLLOW_TARGET::push_data_(DST dst) const {
			
			dst.timestamp(timestamp());
			
			dst.est_capabilities(est_capabilities());
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.alt(alt());
			
			dst.vel(vel());
			
			dst.acc(acc());
			
			dst.attitude_q(attitude_q());
			
			dst.rates(rates());
			
			dst.position_cov(position_cov());
			
			dst.custom_state(custom_state());
			
		}
	
	template<typename DST>
		void HIL_STATE::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
			dst.rollspeed(rollspeed());
			
			dst.pitchspeed(pitchspeed());
			
			dst.yawspeed(yawspeed());
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.alt(alt());
			
			dst.vx(vx());
			
			dst.vy(vy());
			
			dst.vz(vz());
			
			dst.xacc(xacc());
			
			dst.yacc(yacc());
			
			dst.zacc(zacc());
			
		}
	
	template<typename SRC>
		void HOME_POSITION::pull_data_(SRC src) {
			
			latitude(src.latitude());
			
			longitude(src.longitude());
			
			altitude(src.altitude());
			
			x(src.x());
			
			y(src.y());
			
			z(src.z());
			
			q(src.q());
			
			approach_x(src.approach_x());
			
			approach_y(src.approach_y());
			
			approach_z(src.approach_z());
			
			if (src.time_usec_exists())
				time_usec(src.time_usec());
			
			
		}
	
	template<typename DST>
		void HOME_POSITION::push_data_(DST dst) const {
			
			dst.latitude(latitude());
			
			dst.longitude(longitude());
			
			dst.altitude(altitude());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
			dst.q(q());
			
			dst.approach_x(approach_x());
			
			dst.approach_y(approach_y());
			
			dst.approach_z(approach_z());
			auto src_time_usec = time_usec();
			
			if (src_time_usec.IS_EXISTS)
				dst.time_usec(src_time_usec.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void FENCE_STATUS::pull_data_(SRC src) {
			
			breach_status(src.breach_status());
			
			breach_count(src.breach_count());
			
			if (src.breach_type_exists())
				breach_type(src.breach_type());
			
			
			breach_time(src.breach_time());
			
		}
	
	template<typename DST>
		void FENCE_STATUS::push_data_(DST dst) const {
			
			dst.breach_status(breach_status());
			
			dst.breach_count(breach_count());
			auto src_breach_type = breach_type();
			
			if (src_breach_type.IS_EXISTS)
				dst.breach_type(src_breach_type.CASE.EXISTS.value);
			
			
			dst.breach_time(breach_time());
			
		}
	
	template<typename SRC>
		void REMOTE_LOG_BLOCK_STATUS::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			seqno(src.seqno());
			
			if (src.status_exists())
				status(src.status());
			
			
		}
	
	template<typename DST>
		void REMOTE_LOG_BLOCK_STATUS::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.seqno(seqno());
			auto src_status = status();
			
			if (src_status.IS_EXISTS)
				dst.status(src_status.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void OBSTACLE_DISTANCE::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			if (src.sensor_type_exists())
				sensor_type(src.sensor_type());
			
			
			distances(src.distances());
			
			increment(src.increment());
			
			min_distance(src.min_distance());
			
			max_distance(src.max_distance());
			
		}
	
	template<typename DST>
		void OBSTACLE_DISTANCE::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			auto src_sensor_type = sensor_type();
			
			if (src_sensor_type.IS_EXISTS)
				dst.sensor_type(src_sensor_type.CASE.EXISTS.value);
			
			
			dst.distances(distances());
			
			dst.increment(increment());
			
			dst.min_distance(min_distance());
			
			dst.max_distance(max_distance());
			
		}
	
	template<typename SRC>
		void GPS2_RAW::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			if (src.fix_type_exists())
				fix_type(src.fix_type());
			
			
			lat(src.lat());
			
			lon(src.lon());
			
			alt(src.alt());
			
			eph(src.eph());
			
			epv(src.epv());
			
			vel(src.vel());
			
			cog(src.cog());
			
			satellites_visible(src.satellites_visible());
			
			dgps_numch(src.dgps_numch());
			
			dgps_age(src.dgps_age());
			
		}
	
	template<typename DST>
		void GPS2_RAW::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			auto src_fix_type = fix_type();
			
			if (src_fix_type.IS_EXISTS)
				dst.fix_type(src_fix_type.CASE.EXISTS.value);
			
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.alt(alt());
			
			dst.eph(eph());
			
			dst.epv(epv());
			
			dst.vel(vel());
			
			dst.cog(cog());
			
			dst.satellites_visible(satellites_visible());
			
			dst.dgps_numch(dgps_numch());
			
			dst.dgps_age(dgps_age());
			
		}
	
	template<typename DST>
		void REQUEST_DATA_STREAM::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.req_stream_id(req_stream_id());
			
			dst.req_message_rate(req_message_rate());
			
			dst.start_stop(start_stop());
			
		}
	
	template<typename SRC>
		void MEMORY_VECT::pull_data_(SRC src) {
			
			address(src.address());
			
			ver(src.ver());
			
			typE(src.typE());
			
			value(src.value());
			
		}
	
	template<typename DST>
		void MEMORY_VECT::push_data_(DST dst) const {
			
			dst.address(address());
			
			dst.ver(ver());
			
			dst.typE(typE());
			
			dst.value(value());
			
		}
	
	template<typename SRC>
		void PARAM_EXT_REQUEST_READ::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			if (src.param_id_exists())
				param_id(src.param_id());
			
			
			param_index(src.param_index());
			
		}
	
	template<typename DST>
		void PARAM_EXT_REQUEST_READ::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_param_id = param_id();
			
			if (src_param_id.IS_EXISTS)
				dst.param_id(src_param_id.CASE.EXISTS);
			
			
			dst.param_index(param_index());
			
		}
	
	template<typename DST>
		void HIL_CONTROLS::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.roll_ailerons(roll_ailerons());
			
			dst.pitch_elevator(pitch_elevator());
			
			dst.yaw_rudder(yaw_rudder());
			
			dst.throttle(throttle());
			
			dst.aux1(aux1());
			
			dst.aux2(aux2());
			
			dst.aux3(aux3());
			
			dst.aux4(aux4());
			auto src_mode = mode();
			
			if (src_mode.IS_EXISTS)
				dst.mode(src_mode.CASE.EXISTS.value);
			
			
			dst.nav_mode(nav_mode());
			
		}
	
	template<typename SRC>
		void HIL_SENSOR::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			xacc(src.xacc());
			
			yacc(src.yacc());
			
			zacc(src.zacc());
			
			xgyro(src.xgyro());
			
			ygyro(src.ygyro());
			
			zgyro(src.zgyro());
			
			xmag(src.xmag());
			
			ymag(src.ymag());
			
			zmag(src.zmag());
			
			abs_pressure(src.abs_pressure());
			
			diff_pressure(src.diff_pressure());
			
			pressure_alt(src.pressure_alt());
			
			temperature(src.temperature());
			
			fields_updated(src.fields_updated());
			
		}
	
	template<typename DST>
		void HIL_SENSOR::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.xacc(xacc());
			
			dst.yacc(yacc());
			
			dst.zacc(zacc());
			
			dst.xgyro(xgyro());
			
			dst.ygyro(ygyro());
			
			dst.zgyro(zgyro());
			
			dst.xmag(xmag());
			
			dst.ymag(ymag());
			
			dst.zmag(zmag());
			
			dst.abs_pressure(abs_pressure());
			
			dst.diff_pressure(diff_pressure());
			
			dst.pressure_alt(pressure_alt());
			
			dst.temperature(temperature());
			
			dst.fields_updated(fields_updated());
			
		}
	
	template<typename SRC>
		void SETUP_SIGNING::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			secret_key(src.secret_key());
			
			initial_timestamp(src.initial_timestamp());
			
		}
	
	template<typename DST>
		void SETUP_SIGNING::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.secret_key(secret_key());
			
			dst.initial_timestamp(initial_timestamp());
			
		}
	
	template<typename SRC>
		void GPS_RTK::pull_data_(SRC src) {
			
			time_last_baseline_ms(src.time_last_baseline_ms());
			
			rtk_receiver_id(src.rtk_receiver_id());
			
			wn(src.wn());
			
			tow(src.tow());
			
			rtk_health(src.rtk_health());
			
			rtk_rate(src.rtk_rate());
			
			nsats(src.nsats());
			
			baseline_coords_type(src.baseline_coords_type());
			
			baseline_a_mm(src.baseline_a_mm());
			
			baseline_b_mm(src.baseline_b_mm());
			
			baseline_c_mm(src.baseline_c_mm());
			
			accuracy(src.accuracy());
			
			iar_num_hypotheses(src.iar_num_hypotheses());
			
		}
	
	template<typename DST>
		void GPS_RTK::push_data_(DST dst) const {
			
			dst.time_last_baseline_ms(time_last_baseline_ms());
			
			dst.rtk_receiver_id(rtk_receiver_id());
			
			dst.wn(wn());
			
			dst.tow(tow());
			
			dst.rtk_health(rtk_health());
			
			dst.rtk_rate(rtk_rate());
			
			dst.nsats(nsats());
			
			dst.baseline_coords_type(baseline_coords_type());
			
			dst.baseline_a_mm(baseline_a_mm());
			
			dst.baseline_b_mm(baseline_b_mm());
			
			dst.baseline_c_mm(baseline_c_mm());
			
			dst.accuracy(accuracy());
			
			dst.iar_num_hypotheses(iar_num_hypotheses());
			
		}
	
	template<typename DST>
		void PARAM_REQUEST_LIST::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
		}
	
	template<typename SRC>
		void UAVIONIX_ADSB_OUT_CFG::pull_data_(SRC src) {
			
			ICAO(src.ICAO());
			if (src.callsign_exists())
				callsign(src.callsign());
			
			
			if (src.emitterType_exists())
				emitterType(src.emitterType());
			
			
			if (src.aircraftSize_exists())
				aircraftSize(src.aircraftSize());
			
			
			if (src.gpsOffsetLat_exists())
				gpsOffsetLat(src.gpsOffsetLat());
			
			
			if (src.gpsOffsetLon_exists())
				gpsOffsetLon(src.gpsOffsetLon());
			
			
			stallSpeed(src.stallSpeed());
			
			if (src.rfSelect_exists())
				rfSelect(src.rfSelect());
			
			
		}
	
	template<typename DST>
		void UAVIONIX_ADSB_OUT_CFG::push_data_(DST dst) const {
			
			dst.ICAO(ICAO());
			auto src_callsign = callsign();
			
			if (src_callsign.IS_EXISTS)
				dst.callsign(src_callsign.CASE.EXISTS);
			
			auto src_emitterType = emitterType();
			
			if (src_emitterType.IS_EXISTS)
				dst.emitterType(src_emitterType.CASE.EXISTS.value);
			
			auto src_aircraftSize = aircraftSize();
			
			if (src_aircraftSize.IS_EXISTS)
				dst.aircraftSize(src_aircraftSize.CASE.EXISTS.value);
			
			auto src_gpsOffsetLat = gpsOffsetLat();
			
			if (src_gpsOffsetLat.IS_EXISTS)
				dst.gpsOffsetLat(src_gpsOffsetLat.CASE.EXISTS.value);
			
			auto src_gpsOffsetLon = gpsOffsetLon();
			
			if (src_gpsOffsetLon.IS_EXISTS)
				dst.gpsOffsetLon(src_gpsOffsetLon.CASE.EXISTS.value);
			
			
			dst.stallSpeed(stallSpeed());
			auto src_rfSelect = rfSelect();
			
			if (src_rfSelect.IS_EXISTS)
				dst.rfSelect(src_rfSelect.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void LANDING_TARGET::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			target_num(src.target_num());
			
			if (src.frame_exists())
				frame(src.frame());
			
			
			angle_x(src.angle_x());
			
			angle_y(src.angle_y());
			
			distance(src.distance());
			
			size_x(src.size_x());
			
			size_y(src.size_y());
			
			if (src.x_exists())
				x(src.x());
			
			
			if (src.y_exists())
				y(src.y());
			
			
			if (src.z_exists())
				z(src.z());
			
			
			if (src.q_exists())
				for (size_t d0 = 0; d0 < com::company::demo::LANDING_TARGET::q_::d0; d0++) {
					
					if (src.q_item_exists(d0))
						q(src.q(d0), d0);
					
				}
			
			if (src.typE_exists())
				typE(src.typE());
			
			
			if (src.position_valid_exists())
				position_valid(src.position_valid());
			
			
		}
	
	template<typename DST>
		void LANDING_TARGET::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.target_num(target_num());
			auto src_frame = frame();
			
			if (src_frame.IS_EXISTS)
				dst.frame(src_frame.CASE.EXISTS.value);
			
			
			dst.angle_x(angle_x());
			
			dst.angle_y(angle_y());
			
			dst.distance(distance());
			
			dst.size_x(size_x());
			
			dst.size_y(size_y());
			auto src_x = x();
			
			if (src_x.IS_EXISTS)
				dst.x(src_x.CASE.EXISTS.value);
			
			auto src_y = y();
			
			if (src_y.IS_EXISTS)
				dst.y(src_y.CASE.EXISTS.value);
			
			auto src_z = z();
			
			if (src_z.IS_EXISTS)
				dst.z(src_z.CASE.EXISTS.value);
			
			
			LANDING_TARGET_q_d0(EMPTY_ARG) {
							
							dst.q(src_q.CASE.EXISTS.value, d0);
							
						}
			auto src_typE = typE();
			
			if (src_typE.IS_EXISTS)
				dst.typE(src_typE.CASE.EXISTS.value);
			
			auto src_position_valid = position_valid();
			
			if (src_position_valid.IS_EXISTS)
				dst.position_valid(src_position_valid.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void SET_ACTUATOR_CONTROL_TARGET::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			group_mlx(src.group_mlx());
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			controls(src.controls());
			
		}
	
	template<typename DST>
		void SET_ACTUATOR_CONTROL_TARGET::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.group_mlx(group_mlx());
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.controls(controls());
			
		}
	
	template<typename SRC>
		void CONTROL_SYSTEM_STATE::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			x_acc(src.x_acc());
			
			y_acc(src.y_acc());
			
			z_acc(src.z_acc());
			
			x_vel(src.x_vel());
			
			y_vel(src.y_vel());
			
			z_vel(src.z_vel());
			
			x_pos(src.x_pos());
			
			y_pos(src.y_pos());
			
			z_pos(src.z_pos());
			
			airspeed(src.airspeed());
			
			vel_variance(src.vel_variance());
			
			pos_variance(src.pos_variance());
			
			q(src.q());
			
			roll_rate(src.roll_rate());
			
			pitch_rate(src.pitch_rate());
			
			yaw_rate(src.yaw_rate());
			
		}
	
	template<typename DST>
		void CONTROL_SYSTEM_STATE::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.x_acc(x_acc());
			
			dst.y_acc(y_acc());
			
			dst.z_acc(z_acc());
			
			dst.x_vel(x_vel());
			
			dst.y_vel(y_vel());
			
			dst.z_vel(z_vel());
			
			dst.x_pos(x_pos());
			
			dst.y_pos(y_pos());
			
			dst.z_pos(z_pos());
			
			dst.airspeed(airspeed());
			
			dst.vel_variance(vel_variance());
			
			dst.pos_variance(pos_variance());
			
			dst.q(q());
			
			dst.roll_rate(roll_rate());
			
			dst.pitch_rate(pitch_rate());
			
			dst.yaw_rate(yaw_rate());
			
		}
	
	template<typename DST>
		void SET_POSITION_TARGET_GLOBAL_INT::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_coordinate_frame = coordinate_frame();
			
			if (src_coordinate_frame.IS_EXISTS)
				dst.coordinate_frame(src_coordinate_frame.CASE.EXISTS.value);
			
			
			dst.type_mask(type_mask());
			
			dst.lat_int(lat_int());
			
			dst.lon_int(lon_int());
			
			dst.alt(alt());
			
			dst.vx(vx());
			
			dst.vy(vy());
			
			dst.vz(vz());
			
			dst.afx(afx());
			
			dst.afy(afy());
			
			dst.afz(afz());
			
			dst.yaw(yaw());
			
			dst.yaw_rate(yaw_rate());
			
		}
	
	template<typename SRC>
		void DATA32::pull_data_(SRC src) {
			
			typE(src.typE());
			
			len(src.len());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void DATA32::push_data_(DST dst) const {
			
			dst.typE(typE());
			
			dst.len(len());
			
			dst.daTa(daTa());
			
		}
	
	template<typename SRC>
		void PING33::pull_data_(SRC src) {
			
			if (src.testBOOL_exists())
				testBOOL(src.testBOOL());
			
			
			if (src.seq_exists())
				seq(src.seq());
			
			
			field(src.field());
			
			size_t src_field1_d0 = 0;
			
			if (src.field1_exists(src_field1_d0)) {
				const auto  dst_field1 = field1().CASE.EMPTY.init(src_field1_d0).CASE.EXISTS;
				for (size_t d0         = 0; d0 < src_field1_d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::field1_::d1; d1++)
						for (size_t d2 = 0; d2 < com::company::demo::PING33::field1_::d2; d2++) {
							
							
							dst_field1.set(src.field1(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			if (src.field12_exists())
				for (size_t d0 = 0; d0 < com::company::demo::PING33::field12_::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::field12_::d1; d1++)
						for (size_t d2 = 0; d2 < com::company::demo::PING33::field12_::d2; d2++) {
							
							field12(src.field12(d0, d1, d2), d0, d1, d2);
							
						}
			
			if (src.field13_exists())
				for (size_t d0 = 0; d0 < com::company::demo::PING33::field13_::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::field13_::d1; d1++)
						for (size_t d2 = 0; d2 < com::company::demo::PING33::field13_::d2; d2++) {
							
							if (src.field13_item_exists(d0, d1, d2))
								field13(src.field13(d0, d1, d2), d0, d1, d2);
							
						}
			for (size_t d0 = 0; d0 < com::company::demo::PING33::TTTT_::d0; d0++)
				for (size_t d1 = 0; d1 < com::company::demo::PING33::TTTT_::d1; d1++)
					for (size_t d2 = 0; d2 < com::company::demo::PING33::TTTT_::d2; d2++) {
						
						TTTT(src.TTTT(d0, d1, d2), d0, d1, d2);
						
					}
			
			if (src.WWWWWWWW_exists())
				WWWWWWWW(src.WWWWWWWW());
			
			
			testBOOL2(src.testBOOL2());
			
			testBOOL3(src.testBOOL3());
			
			bit_field(src.bit_field());
			
			if (src.bit_field2_exists())
				bit_field2(src.bit_field2());
			
			
			if (src.Field_Bits_exists())
				for (size_t d0 = 0; d0 < com::company::demo::PING33::Field_Bits_::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::Field_Bits_::d1; d1++)
						for (size_t d2 = 0; d2 < com::company::demo::PING33::Field_Bits_::d2; d2++) {
							
							Field_Bits(src.Field_Bits(d0, d1, d2), d0, d1, d2);
							
						}
			
			size_t src_SparseFixAllBits_d0 = 0;
			
			if (src.SparseFixAllBits_exists(src_SparseFixAllBits_d0)) {
				const auto  dst_SparseFixAllBits = SparseFixAllBits().CASE.EMPTY.init(src_SparseFixAllBits_d0).CASE.EXISTS;
				for (size_t d0                   = 0; d0 < src_SparseFixAllBits_d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::SparseFixAllBits_::d1; d1++)
						for (size_t d2 = 0; d2 < com::company::demo::PING33::SparseFixAllBits_::d2; d2++) {
							
							
							if (src.SparseFixAllBits_item_exists(d0, d1, d2))
								dst_SparseFixAllBits.set(src.SparseFixAllBits(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			size_t src_FixAllBits_d0 = 0;
			
			if (src.FixAllBits_exists(src_FixAllBits_d0)) {
				const auto  dst_FixAllBits = FixAllBits().CASE.EMPTY.init(src_FixAllBits_d0).CASE.EXISTS;
				for (size_t d0             = 0; d0 < src_FixAllBits_d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::FixAllBits_::d1; d1++)
						for (size_t d2 = 0; d2 < com::company::demo::PING33::FixAllBits_::d2; d2++) {
							
							
							dst_FixAllBits.set(src.FixAllBits(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			size_t src_VarAllBits_d0 = 0;
			size_t src_VarAllBits_d2 = 0;
			
			if (src.VarAllBits_exists(src_VarAllBits_d0, src_VarAllBits_d2)) {
				const auto  dst_VarAllBits = VarAllBits().CASE.EMPTY.init(src_VarAllBits_d0, src_VarAllBits_d2).CASE.EXISTS;
				for (size_t d0             = 0; d0 < src_VarAllBits_d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::VarAllBits_::d1; d1++)
						for (size_t d2 = 0; d2 < src_VarAllBits_d2; d2++) {
							
							
							dst_VarAllBits.set(src.VarAllBits(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			size_t src_SparseVarAllBits_d0 = 0;
			size_t src_SparseVarAllBits_d2 = 0;
			
			if (src.SparseVarAllBits_exists(src_SparseVarAllBits_d0, src_SparseVarAllBits_d2)) {
				const auto  dst_SparseVarAllBits = SparseVarAllBits().CASE.EMPTY.init(src_SparseVarAllBits_d0, src_SparseVarAllBits_d2).CASE.EXISTS;
				for (size_t d0                   = 0; d0 < src_SparseVarAllBits_d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::SparseVarAllBits_::d1; d1++)
						for (size_t d2 = 0; d2 < src_SparseVarAllBits_d2; d2++) {
							
							
							if (src.SparseVarAllBits_item_exists(d0, d1, d2))
								dst_SparseVarAllBits.set(src.SparseVarAllBits(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			size_t src_VarEachBits_d0 = 0;
			
			if (src.VarEachBits_exists(src_VarEachBits_d0)) {
				const auto  dst_VarEachBits = VarEachBits().CASE.EMPTY.init(src_VarEachBits_d0).CASE.EXISTS;
				for (size_t d0              = 0; d0 < src_VarEachBits_d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::VarEachBits_::d1; d1++)
						for (size_t d2 = 0; d2 < com::company::demo::PING33::VarEachBits_::d2; d2++) {
							
							
							dst_VarEachBits.set(src.VarEachBits(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			size_t src_SparsVarEachBits_d0 = 0;
			
			if (src.SparsVarEachBits_exists(src_SparsVarEachBits_d0)) {
				const auto  dst_SparsVarEachBits = SparsVarEachBits().CASE.EMPTY.init(src_SparsVarEachBits_d0).CASE.EXISTS;
				for (size_t d0                   = 0; d0 < src_SparsVarEachBits_d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::SparsVarEachBits_::d1; d1++)
						for (size_t d2 = 0; d2 < com::company::demo::PING33::SparsVarEachBits_::d2; d2++) {
							
							
							if (src.SparsVarEachBits_item_exists(d0, d1, d2))
								dst_SparsVarEachBits.set(src.SparsVarEachBits(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			if (src.testBOOLX_exists())
				testBOOLX(src.testBOOLX());
			
			
			if (src.testBOOL2X_exists())
				testBOOL2X(src.testBOOL2X());
			
			
			if (src.testBOOL3X_exists())
				testBOOL3X(src.testBOOL3X());
			
			
			if (src.MMMMMM_exists())
				MMMMMM(src.MMMMMM());
			
			
			size_t src_field44_d2 = 0;
			
			if (src.field44_exists(src_field44_d2)) {
				const auto  dst_field44 = field44().CASE.EMPTY.init(src_field44_d2).CASE.EXISTS;
				for (size_t d0          = 0; d0 < com::company::demo::PING33::field44_::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::field44_::d1; d1++)
						for (size_t d2 = 0; d2 < src_field44_d2; d2++) {
							
							
							dst_field44.set(src.field44(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			size_t src_field634_d2 = 0;
			
			if (src.field634_exists(src_field634_d2)) {
				const auto  dst_field634 = field634().CASE.EMPTY.init(src_field634_d2).CASE.EXISTS;
				for (size_t d0           = 0; d0 < com::company::demo::PING33::field634_::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::field634_::d1; d1++)
						for (size_t d2 = 0; d2 < src_field634_d2; d2++) {
							
							
							dst_field634.set(src.field634(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			size_t src_field33344_d2 = 0;
			
			if (src.field33344_exists(src_field33344_d2)) {
				const auto  dst_field33344 = field33344().CASE.EMPTY.init(src_field33344_d2).CASE.EXISTS;
				for (size_t d0             = 0; d0 < com::company::demo::PING33::field33344_::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::field33344_::d1; d1++)
						for (size_t d2 = 0; d2 < src_field33344_d2; d2++) {
							
							
							if (src.field33344_item_exists(d0, d1, d2))
								dst_field33344.set(src.field33344(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			size_t src_field333634_d2 = 0;
			
			if (src.field333634_exists(src_field333634_d2)) {
				const auto  dst_field333634 = field333634().CASE.EMPTY.init(src_field333634_d2).CASE.EXISTS;
				for (size_t d0              = 0; d0 < com::company::demo::PING33::field333634_::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::field333634_::d1; d1++)
						for (size_t d2 = 0; d2 < src_field333634_d2; d2++) {
							
							
							if (src.field333634_item_exists(d0, d1, d2))
								dst_field333634.set(src.field333634(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			if (src.field___exists())
				for (size_t d0 = 0; d0 < com::company::demo::PING33::field___::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::field___::d1; d1++)
						for (size_t d2 = 0; d2 < com::company::demo::PING33::field___::d2; d2++) {
							
							if (src.field___item_exists(d0, d1, d2))
								field__(src.field__(d0, d1, d2), d0, d1, d2);
							
						}
			for (size_t d0 = 0; d0 < com::company::demo::PING33::field6_::d0; d0++)
				for (size_t d1 = 0; d1 < com::company::demo::PING33::field6_::d1; d1++)
					for (size_t d2 = 0; d2 < com::company::demo::PING33::field6_::d2; d2++) {
						
						field6(src.field6(d0, d1, d2), d0, d1, d2);
						
					}
			
			size_t src_field63_d2 = 0;
			
			if (src.field63_exists(src_field63_d2)) {
				const auto  dst_field63 = field63().CASE.EMPTY.init(src_field63_d2).CASE.EXISTS;
				for (size_t d0          = 0; d0 < com::company::demo::PING33::field63_::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::field63_::d1; d1++)
						for (size_t d2 = 0; d2 < src_field63_d2; d2++) {
							
							
							dst_field63.set(src.field63(d0, d1, d2), d0, d1, d2);
							
						}
			}
			
			if (src.uid2_exists())
				for (size_t d0 = 0; d0 < com::company::demo::PING33::uid2_::d0; d0++) {
					
					if (src.uid2_item_exists(d0))
						uid2(src.uid2(d0), d0);
					
				}
			
			if (src.field2_exists())
				for (size_t d0 = 0; d0 < com::company::demo::PING33::field2_::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::field2_::d1; d1++)
						for (size_t d2 = 0; d2 < com::company::demo::PING33::field2_::d2; d2++) {
							
							if (src.field2_item_exists(d0, d1, d2))
								field2(src.field2(d0, d1, d2), d0, d1, d2);
							
						}
			
			if (src.field4_exists())
				for (size_t d0 = 0; d0 < com::company::demo::PING33::field4_::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::field4_::d1; d1++)
						for (size_t d2 = 0; d2 < com::company::demo::PING33::field4_::d2; d2++) {
							
							if (src.field4_item_exists(d0, d1, d2))
								field4(src.field4(d0, d1, d2), d0, d1, d2);
							
						}
			if (src.stringtest1_exists())
				stringtest1(src.stringtest1());
			
			
			size_t src_stringtest2_d2 = 0;
			
			if (src.stringtest2_exists(src_stringtest2_d2)) {
				const auto  dst_stringtest2 = stringtest2().CASE.EMPTY.init(src_stringtest2_d2).CASE.EXISTS;
				for (size_t d0              = 0; d0 < com::company::demo::PING33::stringtest2_::d0; d0++)
					for (size_t d1 = 0; d1 < com::company::demo::PING33::stringtest2_::d1; d1++)
						for (size_t d2 = 0; d2 < src_stringtest2_d2; d2++) {
							
							
							if (src.stringtest2_item_exists(d0, d1, d2))
								dst_stringtest2.set(src.stringtest2(d0, d1, d2), d0, d1, d2);
							
						}
			}
			if (src.stringtest3_exists())
				stringtest3(src.stringtest3());
			
			
			if (src.stringtest4_exists())
				stringtest4(src.stringtest4());
			
			
		}
	
	template<typename DST>
		void PING33::push_data_(DST dst) const {
			auto src_testBOOL = testBOOL();
			
			if (src_testBOOL.IS_EXISTS)
				dst.testBOOL(src_testBOOL.CASE.EXISTS.value);
			
			auto src_seq = seq();
			
			if (src_seq.IS_EXISTS)
				dst.seq(src_seq.CASE.EXISTS.value);
			
			
			dst.field(field());
			
			const auto is_field1_exists = field1();
			if (is_field1_exists.IS_EXISTS) {
				const auto case_field1_exists = is_field1_exists.CASE.EXISTS;
				dst.field1_init(case_field1_exists.d0());
				PING33_field1_d0_d1_d2(EMPTY_ARG) {
									
									dst.field1(case_field1_exists.get(d0, d1, d2), d0, d1, d2);
									
								}
			}
			
			PING33_field12_d0_d1_d2(EMPTY_ARG) {
								
								dst.field12(case_field12_exists.get(d0, d1, d2), d0, d1, d2);
								
							}
			
			PING33_field13_d0_d1_d2(EMPTY_ARG) {
									
									dst.field13(src_field13.CASE.EXISTS.value, d0, d1, d2);
									
								}
			
			PING33_TTTT_d0_d1_d2 {
						
						dst.TTTT(TTTT(d0, d1, d2), d0, d1, d2);
						
					}
			auto src_WWWWWWWW = WWWWWWWW();
			
			if (src_WWWWWWWW.IS_EXISTS)
				dst.WWWWWWWW(src_WWWWWWWW.CASE.EXISTS.value);
			
			
			dst.testBOOL2(testBOOL2());
			
			dst.testBOOL3(testBOOL3());
			
			dst.bit_field(bit_field());
			auto src_bit_field2 = bit_field2();
			
			if (src_bit_field2.IS_EXISTS)
				dst.bit_field2(src_bit_field2.CASE.EXISTS.value);
			
			
			PING33_Field_Bits_d0_d1_d2(EMPTY_ARG) {
								
								dst.Field_Bits(case_Field_Bits_exists.get(d0, d1, d2), d0, d1, d2);
								
							}
			
			const auto is_SparseFixAllBits_exists = SparseFixAllBits();
			if (is_SparseFixAllBits_exists.IS_EXISTS) {
				const auto case_SparseFixAllBits_exists = is_SparseFixAllBits_exists.CASE.EXISTS;
				dst.SparseFixAllBits_init(case_SparseFixAllBits_exists.d0());
				PING33_SparseFixAllBits_d0_d1_d2(EMPTY_ARG) {
										
										dst.SparseFixAllBits(src_SparseFixAllBits.CASE.EXISTS.value, d0, d1, d2);
										
									}
			}
			
			const auto is_FixAllBits_exists = FixAllBits();
			if (is_FixAllBits_exists.IS_EXISTS) {
				const auto case_FixAllBits_exists = is_FixAllBits_exists.CASE.EXISTS;
				dst.FixAllBits_init(case_FixAllBits_exists.d0());
				PING33_FixAllBits_d0_d1_d2(EMPTY_ARG) {
									
									dst.FixAllBits(case_FixAllBits_exists.get(d0, d1, d2), d0, d1, d2);
									
								}
			}
			
			const auto is_VarAllBits_exists = VarAllBits();
			if (is_VarAllBits_exists.IS_EXISTS) {
				const auto case_VarAllBits_exists = is_VarAllBits_exists.CASE.EXISTS;
				dst.VarAllBits_init(case_VarAllBits_exists.d0(), case_VarAllBits_exists.d2());
				PING33_VarAllBits_d0_d1_d2(EMPTY_ARG) {
									
									dst.VarAllBits(case_VarAllBits_exists.get(d0, d1, d2), d0, d1, d2);
									
								}
			}
			
			const auto is_SparseVarAllBits_exists = SparseVarAllBits();
			if (is_SparseVarAllBits_exists.IS_EXISTS) {
				const auto case_SparseVarAllBits_exists = is_SparseVarAllBits_exists.CASE.EXISTS;
				dst.SparseVarAllBits_init(case_SparseVarAllBits_exists.d0(), case_SparseVarAllBits_exists.d2());
				PING33_SparseVarAllBits_d0_d1_d2(EMPTY_ARG) {
										
										dst.SparseVarAllBits(src_SparseVarAllBits.CASE.EXISTS.value, d0, d1, d2);
										
									}
			}
			
			const auto is_VarEachBits_exists = VarEachBits();
			if (is_VarEachBits_exists.IS_EXISTS) {
				const auto case_VarEachBits_exists = is_VarEachBits_exists.CASE.EXISTS;
				dst.VarEachBits_init(case_VarEachBits_exists.d0());
				PING33_VarEachBits_d0_d1_d2(EMPTY_ARG) {
									
									dst.VarEachBits(case_VarEachBits_exists.get(d0, d1, d2), d0, d1, d2);
									
								}
			}
			
			const auto is_SparsVarEachBits_exists = SparsVarEachBits();
			if (is_SparsVarEachBits_exists.IS_EXISTS) {
				const auto case_SparsVarEachBits_exists = is_SparsVarEachBits_exists.CASE.EXISTS;
				dst.SparsVarEachBits_init(case_SparsVarEachBits_exists.d0());
				PING33_SparsVarEachBits_d0_d1_d2(EMPTY_ARG) {
										
										dst.SparsVarEachBits(src_SparsVarEachBits.CASE.EXISTS.value, d0, d1, d2);
										
									}
			}
			auto src_testBOOLX = testBOOLX();
			
			if (src_testBOOLX.IS_EXISTS)
				dst.testBOOLX(src_testBOOLX.CASE.EXISTS.value);
			
			auto src_testBOOL2X = testBOOL2X();
			
			if (src_testBOOL2X.IS_EXISTS)
				dst.testBOOL2X(src_testBOOL2X.CASE.EXISTS.value);
			
			auto src_testBOOL3X = testBOOL3X();
			
			if (src_testBOOL3X.IS_EXISTS)
				dst.testBOOL3X(src_testBOOL3X.CASE.EXISTS.value);
			
			auto src_MMMMMM = MMMMMM();
			
			if (src_MMMMMM.IS_EXISTS)
				dst.MMMMMM(src_MMMMMM.CASE.EXISTS.value);
			
			
			const auto is_field44_exists = field44();
			if (is_field44_exists.IS_EXISTS) {
				const auto case_field44_exists = is_field44_exists.CASE.EXISTS;
				dst.field44_init(case_field44_exists.d2());
				PING33_field44_d0_d1_d2(EMPTY_ARG) {
									
									dst.field44(case_field44_exists.get(d0, d1, d2), d0, d1, d2);
									
								}
			}
			
			const auto is_field634_exists = field634();
			if (is_field634_exists.IS_EXISTS) {
				const auto case_field634_exists = is_field634_exists.CASE.EXISTS;
				dst.field634_init(case_field634_exists.d2());
				PING33_field634_d0_d1_d2(EMPTY_ARG) {
									
									dst.field634(case_field634_exists.get(d0, d1, d2), d0, d1, d2);
									
								}
			}
			
			const auto is_field33344_exists = field33344();
			if (is_field33344_exists.IS_EXISTS) {
				const auto case_field33344_exists = is_field33344_exists.CASE.EXISTS;
				dst.field33344_init(case_field33344_exists.d2());
				PING33_field33344_d0_d1_d2(EMPTY_ARG) {
										
										dst.field33344(src_field33344.CASE.EXISTS.value, d0, d1, d2);
										
									}
			}
			
			const auto is_field333634_exists = field333634();
			if (is_field333634_exists.IS_EXISTS) {
				const auto case_field333634_exists = is_field333634_exists.CASE.EXISTS;
				dst.field333634_init(case_field333634_exists.d2());
				PING33_field333634_d0_d1_d2(EMPTY_ARG) {
										
										dst.field333634(src_field333634.CASE.EXISTS.value, d0, d1, d2);
										
									}
			}
			
			PING33_field___d0_d1_d2(EMPTY_ARG) {
									
									dst.field__(src_field__.CASE.EXISTS.value, d0, d1, d2);
									
								}
			
			PING33_field6_d0_d1_d2 {
						
						dst.field6(field6(d0, d1, d2), d0, d1, d2);
						
					}
			
			const auto is_field63_exists = field63();
			if (is_field63_exists.IS_EXISTS) {
				const auto case_field63_exists = is_field63_exists.CASE.EXISTS;
				dst.field63_init(case_field63_exists.d2());
				PING33_field63_d0_d1_d2(EMPTY_ARG) {
									
									dst.field63(case_field63_exists.get(d0, d1, d2), d0, d1, d2);
									
								}
			}
			
			PING33_uid2_d0(EMPTY_ARG) {
							
							dst.uid2(src_uid2.CASE.EXISTS.value, d0);
							
						}
			
			PING33_field2_d0_d1_d2(EMPTY_ARG) {
									
									dst.field2(src_field2.CASE.EXISTS.value, d0, d1, d2);
									
								}
			
			PING33_field4_d0_d1_d2(EMPTY_ARG) {
									
									dst.field4(src_field4.CASE.EXISTS.value, d0, d1, d2);
									
								}
			auto src_stringtest1 = stringtest1();
			
			if (src_stringtest1.IS_EXISTS)
				dst.stringtest1(src_stringtest1.CASE.EXISTS);
			
			
			const auto is_stringtest2_exists = stringtest2();
			if (is_stringtest2_exists.IS_EXISTS) {
				const auto case_stringtest2_exists = is_stringtest2_exists.CASE.EXISTS;
				dst.stringtest2_init(case_stringtest2_exists.d2());
				PING33_stringtest2_d0_d1_d2(EMPTY_ARG) {
										dst.stringtest2(src_stringtest2.CASE.EXISTS, d0, d1, d2);
									}
			}
			auto       src_stringtest3       = stringtest3();
			
			if (src_stringtest3.IS_EXISTS)
				dst.stringtest3(src_stringtest3.CASE.EXISTS);
			
			auto src_stringtest4 = stringtest4();
			
			if (src_stringtest4.IS_EXISTS)
				dst.stringtest4(src_stringtest4.CASE.EXISTS);
			
			
		}
	
	template<typename DST>
		void VFR_HUD::push_data_(DST dst) const {
			
			dst.airspeed(airspeed());
			
			dst.groundspeed(groundspeed());
			
			dst.heading(heading());
			
			dst.throttle(throttle());
			
			dst.alt(alt());
			
			dst.climb(climb());
			
		}
	
	template<typename SRC>
		void RALLY_POINT::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			idx(src.idx());
			
			count(src.count());
			
			lat(src.lat());
			
			lng(src.lng());
			
			alt(src.alt());
			
			break_alt(src.break_alt());
			
			land_dir(src.land_dir());
			
			if (src.flags_exists())
				flags(src.flags());
			
			
		}
	
	template<typename DST>
		void RALLY_POINT::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.idx(idx());
			
			dst.count(count());
			
			dst.lat(lat());
			
			dst.lng(lng());
			
			dst.alt(alt());
			
			dst.break_alt(break_alt());
			
			dst.land_dir(land_dir());
			auto src_flags = flags();
			
			if (src_flags.IS_EXISTS)
				dst.flags(src_flags.CASE.EXISTS.value);
			
			
		}
	
	template<typename DST>
		void MISSION_SET_CURRENT::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.seq(seq());
			
		}
	
	template<typename SRC>
		void ADAP_TUNING::pull_data_(SRC src) {
			
			if (src.axis_exists())
				axis(src.axis());
			
			
			desired(src.desired());
			
			achieved(src.achieved());
			
			error(src.error());
			
			theta(src.theta());
			
			omega(src.omega());
			
			sigma(src.sigma());
			
			theta_dot(src.theta_dot());
			
			omega_dot(src.omega_dot());
			
			sigma_dot(src.sigma_dot());
			
			f(src.f());
			
			f_dot(src.f_dot());
			
			u(src.u());
			
		}
	
	template<typename DST>
		void ADAP_TUNING::push_data_(DST dst) const {
			auto src_axis = axis();
			
			if (src_axis.IS_EXISTS)
				dst.axis(src_axis.CASE.EXISTS.value);
			
			
			dst.desired(desired());
			
			dst.achieved(achieved());
			
			dst.error(error());
			
			dst.theta(theta());
			
			dst.omega(omega());
			
			dst.sigma(sigma());
			
			dst.theta_dot(theta_dot());
			
			dst.omega_dot(omega_dot());
			
			dst.sigma_dot(sigma_dot());
			
			dst.f(f());
			
			dst.f_dot(f_dot());
			
			dst.u(u());
			
		}
	
	template<typename SRC>
		void VIBRATION::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			vibration_x(src.vibration_x());
			
			vibration_y(src.vibration_y());
			
			vibration_z(src.vibration_z());
			
			clipping_0(src.clipping_0());
			
			clipping_1(src.clipping_1());
			
			clipping_2(src.clipping_2());
			
		}
	
	template<typename DST>
		void VIBRATION::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.vibration_x(vibration_x());
			
			dst.vibration_y(vibration_y());
			
			dst.vibration_z(vibration_z());
			
			dst.clipping_0(clipping_0());
			
			dst.clipping_1(clipping_1());
			
			dst.clipping_2(clipping_2());
			
		}
	
	template<typename SRC>
		void PARAM_EXT_VALUE::pull_data_(SRC src) {
			if (src.param_id_exists())
				param_id(src.param_id());
			
			
			if (src.param_value_exists())
				param_value(src.param_value());
			
			
			if (src.param_type_exists())
				param_type(src.param_type());
			
			
			param_count(src.param_count());
			
			param_index(src.param_index());
			
		}
	
	template<typename DST>
		void PARAM_EXT_VALUE::push_data_(DST dst) const {
			auto src_param_id = param_id();
			
			if (src_param_id.IS_EXISTS)
				dst.param_id(src_param_id.CASE.EXISTS);
			
			auto src_param_value = param_value();
			
			if (src_param_value.IS_EXISTS)
				dst.param_value(src_param_value.CASE.EXISTS);
			
			auto src_param_type = param_type();
			
			if (src_param_type.IS_EXISTS)
				dst.param_type(src_param_type.CASE.EXISTS.value);
			
			
			dst.param_count(param_count());
			
			dst.param_index(param_index());
			
		}
	
	template<typename SRC>
		void BATTERY2::pull_data_(SRC src) {
			
			voltage(src.voltage());
			
			current_battery(src.current_battery());
			
		}
	
	template<typename DST>
		void BATTERY2::push_data_(DST dst) const {
			
			dst.voltage(voltage());
			
			dst.current_battery(current_battery());
			
		}
	
	template<typename SRC>
		void LIMITS_STATUS::pull_data_(SRC src) {
			
			if (src.limits_state_exists())
				limits_state(src.limits_state());
			
			
			last_trigger(src.last_trigger());
			
			last_action(src.last_action());
			
			last_recovery(src.last_recovery());
			
			last_clear(src.last_clear());
			
			breach_count(src.breach_count());
			
			if (src.mods_enabled_exists())
				mods_enabled(src.mods_enabled());
			
			
			if (src.mods_required_exists())
				mods_required(src.mods_required());
			
			
			if (src.mods_triggered_exists())
				mods_triggered(src.mods_triggered());
			
			
		}
	
	template<typename DST>
		void LIMITS_STATUS::push_data_(DST dst) const {
			auto src_limits_state = limits_state();
			
			if (src_limits_state.IS_EXISTS)
				dst.limits_state(src_limits_state.CASE.EXISTS.value);
			
			
			dst.last_trigger(last_trigger());
			
			dst.last_action(last_action());
			
			dst.last_recovery(last_recovery());
			
			dst.last_clear(last_clear());
			
			dst.breach_count(breach_count());
			auto src_mods_enabled = mods_enabled();
			
			if (src_mods_enabled.IS_EXISTS)
				dst.mods_enabled(src_mods_enabled.CASE.EXISTS.value);
			
			auto src_mods_required = mods_required();
			
			if (src_mods_required.IS_EXISTS)
				dst.mods_required(src_mods_required.CASE.EXISTS.value);
			
			auto src_mods_triggered = mods_triggered();
			
			if (src_mods_triggered.IS_EXISTS)
				dst.mods_triggered(src_mods_triggered.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void CAMERA_FEEDBACK::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			target_system(src.target_system());
			
			cam_idx(src.cam_idx());
			
			img_idx(src.img_idx());
			
			lat(src.lat());
			
			lng(src.lng());
			
			alt_msl(src.alt_msl());
			
			alt_rel(src.alt_rel());
			
			roll(src.roll());
			
			pitch(src.pitch());
			
			yaw(src.yaw());
			
			foc_len(src.foc_len());
			
			if (src.flags_exists())
				flags(src.flags());
			
			
		}
	
	template<typename DST>
		void CAMERA_FEEDBACK::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.target_system(target_system());
			
			dst.cam_idx(cam_idx());
			
			dst.img_idx(img_idx());
			
			dst.lat(lat());
			
			dst.lng(lng());
			
			dst.alt_msl(alt_msl());
			
			dst.alt_rel(alt_rel());
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
			dst.foc_len(foc_len());
			auto src_flags = flags();
			
			if (src_flags.IS_EXISTS)
				dst.flags(src_flags.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void HIL_GPS::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			fix_type(src.fix_type());
			
			lat(src.lat());
			
			lon(src.lon());
			
			alt(src.alt());
			
			eph(src.eph());
			
			epv(src.epv());
			
			vel(src.vel());
			
			vn(src.vn());
			
			ve(src.ve());
			
			vd(src.vd());
			
			cog(src.cog());
			
			satellites_visible(src.satellites_visible());
			
		}
	
	template<typename DST>
		void HIL_GPS::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.fix_type(fix_type());
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.alt(alt());
			
			dst.eph(eph());
			
			dst.epv(epv());
			
			dst.vel(vel());
			
			dst.vn(vn());
			
			dst.ve(ve());
			
			dst.vd(vd());
			
			dst.cog(cog());
			
			dst.satellites_visible(satellites_visible());
			
		}
	
	template<typename DST>
		void NAV_CONTROLLER_OUTPUT::push_data_(DST dst) const {
			
			dst.nav_roll(nav_roll());
			
			dst.nav_pitch(nav_pitch());
			
			dst.nav_bearing(nav_bearing());
			
			dst.target_bearing(target_bearing());
			
			dst.wp_dist(wp_dist());
			
			dst.alt_error(alt_error());
			
			dst.aspd_error(aspd_error());
			
			dst.xtrack_error(xtrack_error());
			
		}
	
	template<typename DST>
		void AUTH_KEY::push_data_(DST dst) const {
			auto src_key = key();
			
			if (src_key.IS_EXISTS)
				dst.key(src_key.CASE.EXISTS);
			
			
		}
	
	template<typename SRC>
		void FENCE_FETCH_POINT::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			idx(src.idx());
			
		}
	
	template<typename DST>
		void FENCE_FETCH_POINT::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.idx(idx());
			
		}
	
	template<typename SRC>
		void RADIO::pull_data_(SRC src) {
			
			rssi(src.rssi());
			
			remrssi(src.remrssi());
			
			txbuf(src.txbuf());
			
			noise(src.noise());
			
			remnoise(src.remnoise());
			
			rxerrors(src.rxerrors());
			
			fixeD(src.fixeD());
			
		}
	
	template<typename DST>
		void RADIO::push_data_(DST dst) const {
			
			dst.rssi(rssi());
			
			dst.remrssi(remrssi());
			
			dst.txbuf(txbuf());
			
			dst.noise(noise());
			
			dst.remnoise(remnoise());
			
			dst.rxerrors(rxerrors());
			
			dst.fixeD(fixeD());
			
		}
	
	template<typename DST>
		void LOCAL_POSITION_NED_COV::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			auto src_estimator_type = estimator_type();
			
			if (src_estimator_type.IS_EXISTS)
				dst.estimator_type(src_estimator_type.CASE.EXISTS.value);
			
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
			dst.vx(vx());
			
			dst.vy(vy());
			
			dst.vz(vz());
			
			dst.ax(ax());
			
			dst.ay(ay());
			
			dst.az(az());
			
			dst.covariance(covariance());
			
		}
	
	template<typename SRC>
		void AIRSPEED_AUTOCAL::pull_data_(SRC src) {
			
			vx(src.vx());
			
			vy(src.vy());
			
			vz(src.vz());
			
			diff_pressure(src.diff_pressure());
			
			EAS2TAS(src.EAS2TAS());
			
			ratio(src.ratio());
			
			state_x(src.state_x());
			
			state_y(src.state_y());
			
			state_z(src.state_z());
			
			Pax(src.Pax());
			
			Pby(src.Pby());
			
			Pcz(src.Pcz());
			
		}
	
	template<typename DST>
		void AIRSPEED_AUTOCAL::push_data_(DST dst) const {
			
			dst.vx(vx());
			
			dst.vy(vy());
			
			dst.vz(vz());
			
			dst.diff_pressure(diff_pressure());
			
			dst.EAS2TAS(EAS2TAS());
			
			dst.ratio(ratio());
			
			dst.state_x(state_x());
			
			dst.state_y(state_y());
			
			dst.state_z(state_z());
			
			dst.Pax(Pax());
			
			dst.Pby(Pby());
			
			dst.Pcz(Pcz());
			
		}
	
	template<typename SRC>
		void ATT_POS_MOCAP::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			q(src.q());
			
			x(src.x());
			
			y(src.y());
			
			z(src.z());
			
		}
	
	template<typename DST>
		void ATT_POS_MOCAP::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.q(q());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
		}
	
	template<typename SRC>
		void STATUSTEXT::pull_data_(SRC src) {
			
			if (src.severity_exists())
				severity(src.severity());
			
			
			if (src.text_exists())
				text(src.text());
			
			
		}
	
	template<typename DST>
		void STATUSTEXT::push_data_(DST dst) const {
			auto src_severity = severity();
			
			if (src_severity.IS_EXISTS)
				dst.severity(src_severity.CASE.EXISTS.value);
			
			auto src_text = text();
			
			if (src_text.IS_EXISTS)
				dst.text(src_text.CASE.EXISTS);
			
			
		}
	
	template<typename DST>
		void PING::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.seq(seq());
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
		}
	
	template<typename SRC>
		void GOPRO_GET_REQUEST::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			if (src.cmd_id_exists())
				cmd_id(src.cmd_id());
			
			
		}
	
	template<typename DST>
		void GOPRO_GET_REQUEST::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_cmd_id = cmd_id();
			
			if (src_cmd_id.IS_EXISTS)
				dst.cmd_id(src_cmd_id.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void CAMERA_CAPTURE_STATUS::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			image_status(src.image_status());
			
			video_status(src.video_status());
			
			image_interval(src.image_interval());
			
			recording_time_ms(src.recording_time_ms());
			
			available_capacity(src.available_capacity());
			
		}
	
	template<typename DST>
		void CAMERA_CAPTURE_STATUS::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.image_status(image_status());
			
			dst.video_status(video_status());
			
			dst.image_interval(image_interval());
			
			dst.recording_time_ms(recording_time_ms());
			
			dst.available_capacity(available_capacity());
			
		}
	
	template<typename DST>
		void GLOBAL_POSITION_INT::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.alt(alt());
			
			dst.relative_alt(relative_alt());
			
			dst.vx(vx());
			
			dst.vy(vy());
			
			dst.vz(vz());
			
			dst.hdg(hdg());
			
		}
	
	template<typename SRC>
		void ENCAPSULATED_DATA::pull_data_(SRC src) {
			
			seqnr(src.seqnr());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void ENCAPSULATED_DATA::push_data_(DST dst) const {
			
			dst.seqnr(seqnr());
			
			dst.daTa(daTa());
			
		}
	
	template<typename SRC>
		void GPS_INPUT::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			gps_id(src.gps_id());
			
			if (src.ignore_flags_exists())
				ignore_flags(src.ignore_flags());
			
			
			time_week_ms(src.time_week_ms());
			
			time_week(src.time_week());
			
			fix_type(src.fix_type());
			
			lat(src.lat());
			
			lon(src.lon());
			
			alt(src.alt());
			
			hdop(src.hdop());
			
			vdop(src.vdop());
			
			vn(src.vn());
			
			ve(src.ve());
			
			vd(src.vd());
			
			speed_accuracy(src.speed_accuracy());
			
			horiz_accuracy(src.horiz_accuracy());
			
			vert_accuracy(src.vert_accuracy());
			
			satellites_visible(src.satellites_visible());
			
		}
	
	template<typename DST>
		void GPS_INPUT::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.gps_id(gps_id());
			auto src_ignore_flags = ignore_flags();
			
			if (src_ignore_flags.IS_EXISTS)
				dst.ignore_flags(src_ignore_flags.CASE.EXISTS.value);
			
			
			dst.time_week_ms(time_week_ms());
			
			dst.time_week(time_week());
			
			dst.fix_type(fix_type());
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.alt(alt());
			
			dst.hdop(hdop());
			
			dst.vdop(vdop());
			
			dst.vn(vn());
			
			dst.ve(ve());
			
			dst.vd(vd());
			
			dst.speed_accuracy(speed_accuracy());
			
			dst.horiz_accuracy(horiz_accuracy());
			
			dst.vert_accuracy(vert_accuracy());
			
			dst.satellites_visible(satellites_visible());
			
		}
	
	template<typename DST>
		void COMMAND_LONG::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_command = command();
			
			if (src_command.IS_EXISTS)
				dst.command(src_command.CASE.EXISTS.value);
			
			
			dst.confirmation(confirmation());
			
			dst.param1(param1());
			
			dst.param2(param2());
			
			dst.param3(param3());
			
			dst.param4(param4());
			
			dst.param5(param5());
			
			dst.param6(param6());
			
			dst.param7(param7());
			
		}
	
	template<typename SRC>
		void COMPASSMOT_STATUS::pull_data_(SRC src) {
			
			throttle(src.throttle());
			
			current(src.current());
			
			interference(src.interference());
			
			CompensationX(src.CompensationX());
			
			CompensationY(src.CompensationY());
			
			CompensationZ(src.CompensationZ());
			
		}
	
	template<typename DST>
		void COMPASSMOT_STATUS::push_data_(DST dst) const {
			
			dst.throttle(throttle());
			
			dst.current(current());
			
			dst.interference(interference());
			
			dst.CompensationX(CompensationX());
			
			dst.CompensationY(CompensationY());
			
			dst.CompensationZ(CompensationZ());
			
		}
	
	template<typename SRC>
		void LOG_REQUEST_DATA::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			id(src.id());
			
			ofs(src.ofs());
			
			count(src.count());
			
		}
	
	template<typename DST>
		void LOG_REQUEST_DATA::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.id(id());
			
			dst.ofs(ofs());
			
			dst.count(count());
			
		}
	
	template<typename DST>
		void GPS_RAW_INT::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			auto src_fix_type = fix_type();
			
			if (src_fix_type.IS_EXISTS)
				dst.fix_type(src_fix_type.CASE.EXISTS.value);
			
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.alt(alt());
			
			dst.eph(eph());
			
			dst.epv(epv());
			
			dst.vel(vel());
			
			dst.cog(cog());
			
			dst.satellites_visible(satellites_visible());
			auto src_alt_ellipsoid = alt_ellipsoid();
			
			if (src_alt_ellipsoid.IS_EXISTS)
				dst.alt_ellipsoid(src_alt_ellipsoid.CASE.EXISTS.value);
			
			auto src_h_acc = h_acc();
			
			if (src_h_acc.IS_EXISTS)
				dst.h_acc(src_h_acc.CASE.EXISTS.value);
			
			auto src_v_acc = v_acc();
			
			if (src_v_acc.IS_EXISTS)
				dst.v_acc(src_v_acc.CASE.EXISTS.value);
			
			auto src_vel_acc = vel_acc();
			
			if (src_vel_acc.IS_EXISTS)
				dst.vel_acc(src_vel_acc.CASE.EXISTS.value);
			
			auto src_hdg_acc = hdg_acc();
			
			if (src_hdg_acc.IS_EXISTS)
				dst.hdg_acc(src_hdg_acc.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void CAMERA_STATUS::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			target_system(src.target_system());
			
			cam_idx(src.cam_idx());
			
			img_idx(src.img_idx());
			
			if (src.event_id_exists())
				event_id(src.event_id());
			
			
			p1(src.p1());
			
			p2(src.p2());
			
			p3(src.p3());
			
			p4(src.p4());
			
		}
	
	template<typename DST>
		void CAMERA_STATUS::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.target_system(target_system());
			
			dst.cam_idx(cam_idx());
			
			dst.img_idx(img_idx());
			auto src_event_id = event_id();
			
			if (src_event_id.IS_EXISTS)
				dst.event_id(src_event_id.CASE.EXISTS.value);
			
			
			dst.p1(p1());
			
			dst.p2(p2());
			
			dst.p3(p3());
			
			dst.p4(p4());
			
		}
	
	template<typename DST>
		void RC_CHANNELS_SCALED::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.port(port());
			
			dst.chan1_scaled(chan1_scaled());
			
			dst.chan2_scaled(chan2_scaled());
			
			dst.chan3_scaled(chan3_scaled());
			
			dst.chan4_scaled(chan4_scaled());
			
			dst.chan5_scaled(chan5_scaled());
			
			dst.chan6_scaled(chan6_scaled());
			
			dst.chan7_scaled(chan7_scaled());
			
			dst.chan8_scaled(chan8_scaled());
			
			dst.rssi(rssi());
			
		}
	
	template<typename SRC>
		void CAMERA_SETTINGS::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			if (src.mode_id_exists())
				mode_id(src.mode_id());
			
			
		}
	
	template<typename DST>
		void CAMERA_SETTINGS::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			auto src_mode_id = mode_id();
			
			if (src_mode_id.IS_EXISTS)
				dst.mode_id(src_mode_id.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void DEVICE_OP_READ_REPLY::pull_data_(SRC src) {
			
			request_id(src.request_id());
			
			result(src.result());
			
			regstart(src.regstart());
			
			count(src.count());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void DEVICE_OP_READ_REPLY::push_data_(DST dst) const {
			
			dst.request_id(request_id());
			
			dst.result(result());
			
			dst.regstart(regstart());
			
			dst.count(count());
			
			dst.daTa(daTa());
			
		}
	
	template<typename DST>
		void RAW_PRESSURE::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.press_abs(press_abs());
			
			dst.press_diff1(press_diff1());
			
			dst.press_diff2(press_diff2());
			
			dst.temperature(temperature());
			
		}
	
	template<typename SRC>
		void DIGICAM_CONTROL::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			session(src.session());
			
			zoom_pos(src.zoom_pos());
			
			zoom_step(src.zoom_step());
			
			focus_lock(src.focus_lock());
			
			shot(src.shot());
			
			command_id(src.command_id());
			
			extra_param(src.extra_param());
			
			extra_value(src.extra_value());
			
		}
	
	template<typename DST>
		void DIGICAM_CONTROL::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.session(session());
			
			dst.zoom_pos(zoom_pos());
			
			dst.zoom_step(zoom_step());
			
			dst.focus_lock(focus_lock());
			
			dst.shot(shot());
			
			dst.command_id(command_id());
			
			dst.extra_param(extra_param());
			
			dst.extra_value(extra_value());
			
		}
	
	template<typename SRC>
		void NAMED_VALUE_FLOAT::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			if (src.name_exists())
				name(src.name());
			
			
			value(src.value());
			
		}
	
	template<typename DST>
		void NAMED_VALUE_FLOAT::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			auto src_name = name();
			
			if (src_name.IS_EXISTS)
				dst.name(src_name.CASE.EXISTS);
			
			
			dst.value(value());
			
		}
	
	template<typename SRC>
		void GOPRO_HEARTBEAT::pull_data_(SRC src) {
			
			if (src.status_exists())
				status(src.status());
			
			
			if (src.capture_mode_exists())
				capture_mode(src.capture_mode());
			
			
			if (src.flags_exists())
				flags(src.flags());
			
			
		}
	
	template<typename DST>
		void GOPRO_HEARTBEAT::push_data_(DST dst) const {
			auto src_status = status();
			
			if (src_status.IS_EXISTS)
				dst.status(src_status.CASE.EXISTS.value);
			
			auto src_capture_mode = capture_mode();
			
			if (src_capture_mode.IS_EXISTS)
				dst.capture_mode(src_capture_mode.CASE.EXISTS.value);
			
			auto src_flags = flags();
			
			if (src_flags.IS_EXISTS)
				dst.flags(src_flags.CASE.EXISTS.value);
			
			
		}
	
	template<typename DST>
		void ATTITUDE::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
			dst.rollspeed(rollspeed());
			
			dst.pitchspeed(pitchspeed());
			
			dst.yawspeed(yawspeed());
			
		}
	
	template<typename DST>
		void MISSION_WRITE_PARTIAL_LIST::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.start_index(start_index());
			
			dst.end_index(end_index());
			auto src_mission_type = mission_type();
			
			if (src_mission_type.IS_EXISTS)
				dst.mission_type(src_mission_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void AHRS2::pull_data_(SRC src) {
			
			roll(src.roll());
			
			pitch(src.pitch());
			
			yaw(src.yaw());
			
			altitude(src.altitude());
			
			lat(src.lat());
			
			lng(src.lng());
			
		}
	
	template<typename DST>
		void AHRS2::push_data_(DST dst) const {
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
			dst.altitude(altitude());
			
			dst.lat(lat());
			
			dst.lng(lng());
			
		}
	
	template<typename SRC>
		void LOG_ERASE::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
		}
	
	template<typename DST>
		void LOG_ERASE::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
		}
	
	template<typename SRC>
		void TERRAIN_REQUEST::pull_data_(SRC src) {
			
			lat(src.lat());
			
			lon(src.lon());
			
			grid_spacing(src.grid_spacing());
			
			mask(src.mask());
			
		}
	
	template<typename DST>
		void TERRAIN_REQUEST::push_data_(DST dst) const {
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.grid_spacing(grid_spacing());
			
			dst.mask(mask());
			
		}
	
	template<typename SRC>
		void MOUNT_STATUS::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			pointing_a(src.pointing_a());
			
			pointing_b(src.pointing_b());
			
			pointing_c(src.pointing_c());
			
		}
	
	template<typename DST>
		void MOUNT_STATUS::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.pointing_a(pointing_a());
			
			dst.pointing_b(pointing_b());
			
			dst.pointing_c(pointing_c());
			
		}
	
	template<typename DST>
		void MANUAL_SETPOINT::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
			dst.thrust(thrust());
			
			dst.mode_switch(mode_switch());
			
			dst.manual_override_switch(manual_override_switch());
			
		}
	
	template<typename SRC>
		void PID_TUNING::pull_data_(SRC src) {
			
			if (src.axis_exists())
				axis(src.axis());
			
			
			desired(src.desired());
			
			achieved(src.achieved());
			
			FF(src.FF());
			
			P(src.P());
			
			I(src.I());
			
			D(src.D());
			
		}
	
	template<typename DST>
		void PID_TUNING::push_data_(DST dst) const {
			auto src_axis = axis();
			
			if (src_axis.IS_EXISTS)
				dst.axis(src_axis.CASE.EXISTS.value);
			
			
			dst.desired(desired());
			
			dst.achieved(achieved());
			
			dst.FF(FF());
			
			dst.P(P());
			
			dst.I(I());
			
			dst.D(D());
			
		}
	
	template<typename DST>
		void SAFETY_ALLOWED_AREA::push_data_(DST dst) const {
			auto src_frame = frame();
			
			if (src_frame.IS_EXISTS)
				dst.frame(src_frame.CASE.EXISTS.value);
			
			
			dst.p1x(p1x());
			
			dst.p1y(p1y());
			
			dst.p1z(p1z());
			
			dst.p2x(p2x());
			
			dst.p2y(p2y());
			
			dst.p2z(p2z());
			
		}
	
	template<typename SRC>
		void OPTICAL_FLOW_RAD::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			sensor_id(src.sensor_id());
			
			integration_time_us(src.integration_time_us());
			
			integrated_x(src.integrated_x());
			
			integrated_y(src.integrated_y());
			
			integrated_xgyro(src.integrated_xgyro());
			
			integrated_ygyro(src.integrated_ygyro());
			
			integrated_zgyro(src.integrated_zgyro());
			
			temperature(src.temperature());
			
			quality(src.quality());
			
			time_delta_distance_us(src.time_delta_distance_us());
			
			distance(src.distance());
			
		}
	
	template<typename DST>
		void OPTICAL_FLOW_RAD::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.sensor_id(sensor_id());
			
			dst.integration_time_us(integration_time_us());
			
			dst.integrated_x(integrated_x());
			
			dst.integrated_y(integrated_y());
			
			dst.integrated_xgyro(integrated_xgyro());
			
			dst.integrated_ygyro(integrated_ygyro());
			
			dst.integrated_zgyro(integrated_zgyro());
			
			dst.temperature(temperature());
			
			dst.quality(quality());
			
			dst.time_delta_distance_us(time_delta_distance_us());
			
			dst.distance(distance());
			
		}
	
	template<typename SRC>
		void LOG_DATA::pull_data_(SRC src) {
			
			id(src.id());
			
			ofs(src.ofs());
			
			count(src.count());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void LOG_DATA::push_data_(DST dst) const {
			
			dst.id(id());
			
			dst.ofs(ofs());
			
			dst.count(count());
			
			dst.daTa(daTa());
			
		}
	
	template<typename DST>
		void MISSION_CLEAR_ALL::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_mission_type = mission_type();
			
			if (src_mission_type.IS_EXISTS)
				dst.mission_type(src_mission_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void AHRS3::pull_data_(SRC src) {
			
			roll(src.roll());
			
			pitch(src.pitch());
			
			yaw(src.yaw());
			
			altitude(src.altitude());
			
			lat(src.lat());
			
			lng(src.lng());
			
			v1(src.v1());
			
			v2(src.v2());
			
			v3(src.v3());
			
			v4(src.v4());
			
		}
	
	template<typename DST>
		void AHRS3::push_data_(DST dst) const {
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
			dst.altitude(altitude());
			
			dst.lat(lat());
			
			dst.lng(lng());
			
			dst.v1(v1());
			
			dst.v2(v2());
			
			dst.v3(v3());
			
			dst.v4(v4());
			
		}
	
	template<typename SRC>
		void VICON_POSITION_ESTIMATE::pull_data_(SRC src) {
			
			usec(src.usec());
			
			x(src.x());
			
			y(src.y());
			
			z(src.z());
			
			roll(src.roll());
			
			pitch(src.pitch());
			
			yaw(src.yaw());
			
		}
	
	template<typename DST>
		void VICON_POSITION_ESTIMATE::push_data_(DST dst) const {
			
			dst.usec(usec());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
		}
	
	template<typename SRC>
		void GPS2_RTK::pull_data_(SRC src) {
			
			time_last_baseline_ms(src.time_last_baseline_ms());
			
			rtk_receiver_id(src.rtk_receiver_id());
			
			wn(src.wn());
			
			tow(src.tow());
			
			rtk_health(src.rtk_health());
			
			rtk_rate(src.rtk_rate());
			
			nsats(src.nsats());
			
			baseline_coords_type(src.baseline_coords_type());
			
			baseline_a_mm(src.baseline_a_mm());
			
			baseline_b_mm(src.baseline_b_mm());
			
			baseline_c_mm(src.baseline_c_mm());
			
			accuracy(src.accuracy());
			
			iar_num_hypotheses(src.iar_num_hypotheses());
			
		}
	
	template<typename DST>
		void GPS2_RTK::push_data_(DST dst) const {
			
			dst.time_last_baseline_ms(time_last_baseline_ms());
			
			dst.rtk_receiver_id(rtk_receiver_id());
			
			dst.wn(wn());
			
			dst.tow(tow());
			
			dst.rtk_health(rtk_health());
			
			dst.rtk_rate(rtk_rate());
			
			dst.nsats(nsats());
			
			dst.baseline_coords_type(baseline_coords_type());
			
			dst.baseline_a_mm(baseline_a_mm());
			
			dst.baseline_b_mm(baseline_b_mm());
			
			dst.baseline_c_mm(baseline_c_mm());
			
			dst.accuracy(accuracy());
			
			dst.iar_num_hypotheses(iar_num_hypotheses());
			
		}
	
	template<typename SRC>
		void MAG_CAL_REPORT::pull_data_(SRC src) {
			
			compass_id(src.compass_id());
			
			cal_mask(src.cal_mask());
			
			if (src.cal_status_exists())
				cal_status(src.cal_status());
			
			
			autosaved(src.autosaved());
			
			fitness(src.fitness());
			
			ofs_x(src.ofs_x());
			
			ofs_y(src.ofs_y());
			
			ofs_z(src.ofs_z());
			
			diag_x(src.diag_x());
			
			diag_y(src.diag_y());
			
			diag_z(src.diag_z());
			
			offdiag_x(src.offdiag_x());
			
			offdiag_y(src.offdiag_y());
			
			offdiag_z(src.offdiag_z());
			
		}
	
	template<typename DST>
		void MAG_CAL_REPORT::push_data_(DST dst) const {
			
			dst.compass_id(compass_id());
			
			dst.cal_mask(cal_mask());
			auto src_cal_status = cal_status();
			
			if (src_cal_status.IS_EXISTS)
				dst.cal_status(src_cal_status.CASE.EXISTS.value);
			
			
			dst.autosaved(autosaved());
			
			dst.fitness(fitness());
			
			dst.ofs_x(ofs_x());
			
			dst.ofs_y(ofs_y());
			
			dst.ofs_z(ofs_z());
			
			dst.diag_x(diag_x());
			
			dst.diag_y(diag_y());
			
			dst.diag_z(diag_z());
			
			dst.offdiag_x(offdiag_x());
			
			dst.offdiag_y(offdiag_y());
			
			dst.offdiag_z(offdiag_z());
			
		}
	
	template<typename SRC>
		void LOG_REQUEST_LIST::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			start(src.start());
			
			end(src.end());
			
		}
	
	template<typename DST>
		void LOG_REQUEST_LIST::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.start(start());
			
			dst.end(end());
			
		}
	
	template<typename DST>
		void SCALED_PRESSURE::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.press_abs(press_abs());
			
			dst.press_diff(press_diff());
			
			dst.temperature(temperature());
			
		}
	
	template<typename SRC>
		void V2_EXTENSION::pull_data_(SRC src) {
			
			target_network(src.target_network());
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			message_type(src.message_type());
			
			payload(src.payload());
			
		}
	
	template<typename DST>
		void V2_EXTENSION::push_data_(DST dst) const {
			
			dst.target_network(target_network());
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.message_type(message_type());
			
			dst.payload(payload());
			
		}
	
	template<typename DST>
		void HEARTBEAT::push_data_(DST dst) const {
			auto src_typE = typE();
			
			if (src_typE.IS_EXISTS)
				dst.typE(src_typE.CASE.EXISTS.value);
			
			auto src_autopilot = autopilot();
			
			if (src_autopilot.IS_EXISTS)
				dst.autopilot(src_autopilot.CASE.EXISTS.value);
			
			auto src_base_mode = base_mode();
			
			if (src_base_mode.IS_EXISTS)
				dst.base_mode(src_base_mode.CASE.EXISTS.value);
			
			
			dst.custom_mode(custom_mode());
			auto src_system_status = system_status();
			
			if (src_system_status.IS_EXISTS)
				dst.system_status(src_system_status.CASE.EXISTS.value);
			
			
			dst.mavlink_version(mavlink_version());
			
		}
	
	template<typename DST>
		void PARAM_MAP_RC::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_param_id = param_id();
			
			if (src_param_id.IS_EXISTS)
				dst.param_id(src_param_id.CASE.EXISTS);
			
			
			dst.param_index(param_index());
			
			dst.parameter_rc_channel_index(parameter_rc_channel_index());
			
			dst.param_value0(param_value0());
			
			dst.scale(scale());
			
			dst.param_value_min(param_value_min());
			
			dst.param_value_max(param_value_max());
			
		}
	
	template<typename SRC>
		void POWER_STATUS::pull_data_(SRC src) {
			
			Vcc(src.Vcc());
			
			Vservo(src.Vservo());
			
			if (src.flags_exists())
				flags(src.flags());
			
			
		}
	
	template<typename DST>
		void POWER_STATUS::push_data_(DST dst) const {
			
			dst.Vcc(Vcc());
			
			dst.Vservo(Vservo());
			auto src_flags = flags();
			
			if (src_flags.IS_EXISTS)
				dst.flags(src_flags.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void REMOTE_LOG_DATA_BLOCK::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			if (src.seqno_exists())
				seqno(src.seqno());
			
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void REMOTE_LOG_DATA_BLOCK::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_seqno = seqno();
			
			if (src_seqno.IS_EXISTS)
				dst.seqno(src_seqno.CASE.EXISTS.value);
			
			
			dst.daTa(daTa());
			
		}
	
	template<typename SRC>
		void LOGGING_DATA_ACKED::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			sequence(src.sequence());
			
			length(src.length());
			
			first_message_offset(src.first_message_offset());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void LOGGING_DATA_ACKED::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.sequence(sequence());
			
			dst.length(length());
			
			dst.first_message_offset(first_message_offset());
			
			dst.daTa(daTa());
			
		}
	
	template<typename SRC>
		void TERRAIN_CHECK::pull_data_(SRC src) {
			
			lat(src.lat());
			
			lon(src.lon());
			
		}
	
	template<typename DST>
		void TERRAIN_CHECK::push_data_(DST dst) const {
			
			dst.lat(lat());
			
			dst.lon(lon());
			
		}
	
	template<typename SRC>
		void MOUNT_CONFIGURE::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			if (src.mount_mode_exists())
				mount_mode(src.mount_mode());
			
			
			stab_roll(src.stab_roll());
			
			stab_pitch(src.stab_pitch());
			
			stab_yaw(src.stab_yaw());
			
		}
	
	template<typename DST>
		void MOUNT_CONFIGURE::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_mount_mode = mount_mode();
			
			if (src_mount_mode.IS_EXISTS)
				dst.mount_mode(src_mount_mode.CASE.EXISTS.value);
			
			
			dst.stab_roll(stab_roll());
			
			dst.stab_pitch(stab_pitch());
			
			dst.stab_yaw(stab_yaw());
			
		}
	
	template<typename DST>
		void MISSION_REQUEST_INT::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.seq(seq());
			auto src_mission_type = mission_type();
			
			if (src_mission_type.IS_EXISTS)
				dst.mission_type(src_mission_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename DST>
		void LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
		}
	
	template<typename DST>
		void COMMAND_ACK::push_data_(DST dst) const {
			auto src_command = command();
			
			if (src_command.IS_EXISTS)
				dst.command(src_command.CASE.EXISTS.value);
			
			auto src_result = result();
			
			if (src_result.IS_EXISTS)
				dst.result(src_result.CASE.EXISTS.value);
			
			auto src_progress = progress();
			
			if (src_progress.IS_EXISTS)
				dst.progress(src_progress.CASE.EXISTS.value);
			
			auto src_result_param2 = result_param2();
			
			if (src_result_param2.IS_EXISTS)
				dst.result_param2(src_result_param2.CASE.EXISTS.value);
			
			auto src_target_system = target_system();
			
			if (src_target_system.IS_EXISTS)
				dst.target_system(src_target_system.CASE.EXISTS.value);
			
			auto src_target_component = target_component();
			
			if (src_target_component.IS_EXISTS)
				dst.target_component(src_target_component.CASE.EXISTS.value);
			
			
		}
	
	template<typename DST>
		void DATA_STREAM::push_data_(DST dst) const {
			
			dst.stream_id(stream_id());
			
			dst.message_rate(message_rate());
			
			dst.on_off(on_off());
			
		}
	
	template<typename DST>
		void MISSION_REQUEST::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.seq(seq());
			auto src_mission_type = mission_type();
			
			if (src_mission_type.IS_EXISTS)
				dst.mission_type(src_mission_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void TERRAIN_REPORT::pull_data_(SRC src) {
			
			lat(src.lat());
			
			lon(src.lon());
			
			spacing(src.spacing());
			
			terrain_height(src.terrain_height());
			
			current_height(src.current_height());
			
			pending(src.pending());
			
			loaded(src.loaded());
			
		}
	
	template<typename DST>
		void TERRAIN_REPORT::push_data_(DST dst) const {
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.spacing(spacing());
			
			dst.terrain_height(terrain_height());
			
			dst.current_height(current_height());
			
			dst.pending(pending());
			
			dst.loaded(loaded());
			
		}
	
	template<typename SRC>
		void SET_HOME_POSITION::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			latitude(src.latitude());
			
			longitude(src.longitude());
			
			altitude(src.altitude());
			
			x(src.x());
			
			y(src.y());
			
			z(src.z());
			
			q(src.q());
			
			approach_x(src.approach_x());
			
			approach_y(src.approach_y());
			
			approach_z(src.approach_z());
			
			if (src.time_usec_exists())
				time_usec(src.time_usec());
			
			
		}
	
	template<typename DST>
		void SET_HOME_POSITION::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.latitude(latitude());
			
			dst.longitude(longitude());
			
			dst.altitude(altitude());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
			dst.q(q());
			
			dst.approach_x(approach_x());
			
			dst.approach_y(approach_y());
			
			dst.approach_z(approach_z());
			auto src_time_usec = time_usec();
			
			if (src_time_usec.IS_EXISTS)
				dst.time_usec(src_time_usec.CASE.EXISTS.value);
			
			
		}
	
	template<typename DST>
		void HIL_RC_INPUTS_RAW::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.chan1_raw(chan1_raw());
			
			dst.chan2_raw(chan2_raw());
			
			dst.chan3_raw(chan3_raw());
			
			dst.chan4_raw(chan4_raw());
			
			dst.chan5_raw(chan5_raw());
			
			dst.chan6_raw(chan6_raw());
			
			dst.chan7_raw(chan7_raw());
			
			dst.chan8_raw(chan8_raw());
			
			dst.chan9_raw(chan9_raw());
			
			dst.chan10_raw(chan10_raw());
			
			dst.chan11_raw(chan11_raw());
			
			dst.chan12_raw(chan12_raw());
			
			dst.rssi(rssi());
			
		}
	
	template<typename SRC>
		void SCALED_IMU3::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			xacc(src.xacc());
			
			yacc(src.yacc());
			
			zacc(src.zacc());
			
			xgyro(src.xgyro());
			
			ygyro(src.ygyro());
			
			zgyro(src.zgyro());
			
			xmag(src.xmag());
			
			ymag(src.ymag());
			
			zmag(src.zmag());
			
		}
	
	template<typename DST>
		void SCALED_IMU3::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.xacc(xacc());
			
			dst.yacc(yacc());
			
			dst.zacc(zacc());
			
			dst.xgyro(xgyro());
			
			dst.ygyro(ygyro());
			
			dst.zgyro(zgyro());
			
			dst.xmag(xmag());
			
			dst.ymag(ymag());
			
			dst.zmag(zmag());
			
		}
	
	template<typename DST>
		void SET_MODE::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			auto src_base_mode = base_mode();
			
			if (src_base_mode.IS_EXISTS)
				dst.base_mode(src_base_mode.CASE.EXISTS.value);
			
			
			dst.custom_mode(custom_mode());
			
		}
	
	template<typename SRC>
		void MOUNT_CONTROL::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			input_a(src.input_a());
			
			input_b(src.input_b());
			
			input_c(src.input_c());
			
			save_position(src.save_position());
			
		}
	
	template<typename DST>
		void MOUNT_CONTROL::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.input_a(input_a());
			
			dst.input_b(input_b());
			
			dst.input_c(input_c());
			
			dst.save_position(save_position());
			
		}
	
	template<typename DST>
		void POSITION_TARGET_GLOBAL_INT::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			auto src_coordinate_frame = coordinate_frame();
			
			if (src_coordinate_frame.IS_EXISTS)
				dst.coordinate_frame(src_coordinate_frame.CASE.EXISTS.value);
			
			
			dst.type_mask(type_mask());
			
			dst.lat_int(lat_int());
			
			dst.lon_int(lon_int());
			
			dst.alt(alt());
			
			dst.vx(vx());
			
			dst.vy(vy());
			
			dst.vz(vz());
			
			dst.afx(afx());
			
			dst.afy(afy());
			
			dst.afz(afz());
			
			dst.yaw(yaw());
			
			dst.yaw_rate(yaw_rate());
			
		}
	
	template<typename SRC>
		void LED_CONTROL::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			instance(src.instance());
			
			pattern(src.pattern());
			
			custom_len(src.custom_len());
			
			custom_bytes(src.custom_bytes());
			
		}
	
	template<typename DST>
		void LED_CONTROL::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.instance(instance());
			
			dst.pattern(pattern());
			
			dst.custom_len(custom_len());
			
			dst.custom_bytes(custom_bytes());
			
		}
	
	template<typename SRC>
		void SIM_STATE::pull_data_(SRC src) {
			
			q1(src.q1());
			
			q2(src.q2());
			
			q3(src.q3());
			
			q4(src.q4());
			
			roll(src.roll());
			
			pitch(src.pitch());
			
			yaw(src.yaw());
			
			xacc(src.xacc());
			
			yacc(src.yacc());
			
			zacc(src.zacc());
			
			xgyro(src.xgyro());
			
			ygyro(src.ygyro());
			
			zgyro(src.zgyro());
			
			lat(src.lat());
			
			lon(src.lon());
			
			alt(src.alt());
			
			std_dev_horz(src.std_dev_horz());
			
			std_dev_vert(src.std_dev_vert());
			
			vn(src.vn());
			
			ve(src.ve());
			
			vd(src.vd());
			
		}
	
	template<typename DST>
		void SIM_STATE::push_data_(DST dst) const {
			
			dst.q1(q1());
			
			dst.q2(q2());
			
			dst.q3(q3());
			
			dst.q4(q4());
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
			dst.xacc(xacc());
			
			dst.yacc(yacc());
			
			dst.zacc(zacc());
			
			dst.xgyro(xgyro());
			
			dst.ygyro(ygyro());
			
			dst.zgyro(zgyro());
			
			dst.lat(lat());
			
			dst.lon(lon());
			
			dst.alt(alt());
			
			dst.std_dev_horz(std_dev_horz());
			
			dst.std_dev_vert(std_dev_vert());
			
			dst.vn(vn());
			
			dst.ve(ve());
			
			dst.vd(vd());
			
		}
	
	template<typename SRC>
		void WIFI_CONFIG_AP::pull_data_(SRC src) {
			if (src.ssid_exists())
				ssid(src.ssid());
			
			
			if (src.password_exists())
				password(src.password());
			
			
		}
	
	template<typename DST>
		void WIFI_CONFIG_AP::push_data_(DST dst) const {
			auto src_ssid = ssid();
			
			if (src_ssid.IS_EXISTS)
				dst.ssid(src_ssid.CASE.EXISTS);
			
			auto src_password = password();
			
			if (src_password.IS_EXISTS)
				dst.password(src_password.CASE.EXISTS);
			
			
		}
	
	template<typename SRC>
		void DATA96::pull_data_(SRC src) {
			
			typE(src.typE());
			
			len(src.len());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void DATA96::push_data_(DST dst) const {
			
			dst.typE(typE());
			
			dst.len(len());
			
			dst.daTa(daTa());
			
		}
	
	template<typename SRC>
		void FLIGHT_INFORMATION::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			arming_time_utc(src.arming_time_utc());
			
			takeoff_time_utc(src.takeoff_time_utc());
			
			flight_uuid(src.flight_uuid());
			
		}
	
	template<typename DST>
		void FLIGHT_INFORMATION::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.arming_time_utc(arming_time_utc());
			
			dst.takeoff_time_utc(takeoff_time_utc());
			
			dst.flight_uuid(flight_uuid());
			
		}
	
	template<typename DST>
		void RC_CHANNELS_RAW::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.port(port());
			
			dst.chan1_raw(chan1_raw());
			
			dst.chan2_raw(chan2_raw());
			
			dst.chan3_raw(chan3_raw());
			
			dst.chan4_raw(chan4_raw());
			
			dst.chan5_raw(chan5_raw());
			
			dst.chan6_raw(chan6_raw());
			
			dst.chan7_raw(chan7_raw());
			
			dst.chan8_raw(chan8_raw());
			
			dst.rssi(rssi());
			
		}
	
	template<typename DST>
		void SERVO_OUTPUT_RAW::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.port(port());
			
			dst.servo1_raw(servo1_raw());
			
			dst.servo2_raw(servo2_raw());
			
			dst.servo3_raw(servo3_raw());
			
			dst.servo4_raw(servo4_raw());
			
			dst.servo5_raw(servo5_raw());
			
			dst.servo6_raw(servo6_raw());
			
			dst.servo7_raw(servo7_raw());
			
			dst.servo8_raw(servo8_raw());
			auto src_servo9_raw = servo9_raw();
			
			if (src_servo9_raw.IS_EXISTS)
				dst.servo9_raw(src_servo9_raw.CASE.EXISTS.value);
			
			auto src_servo10_raw = servo10_raw();
			
			if (src_servo10_raw.IS_EXISTS)
				dst.servo10_raw(src_servo10_raw.CASE.EXISTS.value);
			
			auto src_servo11_raw = servo11_raw();
			
			if (src_servo11_raw.IS_EXISTS)
				dst.servo11_raw(src_servo11_raw.CASE.EXISTS.value);
			
			auto src_servo12_raw = servo12_raw();
			
			if (src_servo12_raw.IS_EXISTS)
				dst.servo12_raw(src_servo12_raw.CASE.EXISTS.value);
			
			auto src_servo13_raw = servo13_raw();
			
			if (src_servo13_raw.IS_EXISTS)
				dst.servo13_raw(src_servo13_raw.CASE.EXISTS.value);
			
			auto src_servo14_raw = servo14_raw();
			
			if (src_servo14_raw.IS_EXISTS)
				dst.servo14_raw(src_servo14_raw.CASE.EXISTS.value);
			
			auto src_servo15_raw = servo15_raw();
			
			if (src_servo15_raw.IS_EXISTS)
				dst.servo15_raw(src_servo15_raw.CASE.EXISTS.value);
			
			auto src_servo16_raw = servo16_raw();
			
			if (src_servo16_raw.IS_EXISTS)
				dst.servo16_raw(src_servo16_raw.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void MEMINFO::pull_data_(SRC src) {
			
			brkval(src.brkval());
			
			freemem(src.freemem());
			
			if (src.freemem32_exists())
				freemem32(src.freemem32());
			
			
		}
	
	template<typename DST>
		void MEMINFO::push_data_(DST dst) const {
			
			dst.brkval(brkval());
			
			dst.freemem(freemem());
			auto src_freemem32 = freemem32();
			
			if (src_freemem32.IS_EXISTS)
				dst.freemem32(src_freemem32.CASE.EXISTS.value);
			
			
		}
	
	template<typename DST>
		void MISSION_ITEM_REACHED::push_data_(DST dst) const {
			
			dst.seq(seq());
			
		}
	
	template<typename SRC>
		void LOGGING_ACK::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			sequence(src.sequence());
			
		}
	
	template<typename DST>
		void LOGGING_ACK::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.sequence(sequence());
			
		}
	
	template<typename SRC>
		void VISION_SPEED_ESTIMATE::pull_data_(SRC src) {
			
			usec(src.usec());
			
			x(src.x());
			
			y(src.y());
			
			z(src.z());
			
		}
	
	template<typename DST>
		void VISION_SPEED_ESTIMATE::push_data_(DST dst) const {
			
			dst.usec(usec());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
		}
	
	template<typename SRC>
		void DEBUG_VECT::pull_data_(SRC src) {
			if (src.name_exists())
				name(src.name());
			
			
			time_usec(src.time_usec());
			
			x(src.x());
			
			y(src.y());
			
			z(src.z());
			
		}
	
	template<typename DST>
		void DEBUG_VECT::push_data_(DST dst) const {
			auto src_name = name();
			
			if (src_name.IS_EXISTS)
				dst.name(src_name.CASE.EXISTS);
			
			
			dst.time_usec(time_usec());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
		}
	
	template<typename SRC>
		void LOG_REQUEST_END::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
		}
	
	template<typename DST>
		void LOG_REQUEST_END::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
		}
	
	template<typename DST>
		void MISSION_ACK::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_typE = typE();
			
			if (src_typE.IS_EXISTS)
				dst.typE(src_typE.CASE.EXISTS.value);
			
			auto src_mission_type = mission_type();
			
			if (src_mission_type.IS_EXISTS)
				dst.mission_type(src_mission_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename DST>
		void CHANGE_OPERATOR_CONTROL_ACK::push_data_(DST dst) const {
			
			dst.gcs_system_id(gcs_system_id());
			
			dst.control_request(control_request());
			
			dst.ack(ack());
			
		}
	
	template<typename DST>
		void MISSION_CURRENT::push_data_(DST dst) const {
			
			dst.seq(seq());
			
		}
	
	template<typename DST>
		void SYSTEM_TIME::push_data_(DST dst) const {
			
			dst.time_unix_usec(time_unix_usec());
			
			dst.time_boot_ms(time_boot_ms());
			
		}
	
	template<typename SRC>
		void CAMERA_TRIGGER::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			seq(src.seq());
			
		}
	
	template<typename DST>
		void CAMERA_TRIGGER::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.seq(seq());
			
		}
	
	template<typename SRC>
		void GOPRO_SET_RESPONSE::pull_data_(SRC src) {
			
			if (src.cmd_id_exists())
				cmd_id(src.cmd_id());
			
			
			if (src.status_exists())
				status(src.status());
			
			
		}
	
	template<typename DST>
		void GOPRO_SET_RESPONSE::push_data_(DST dst) const {
			auto src_cmd_id = cmd_id();
			
			if (src_cmd_id.IS_EXISTS)
				dst.cmd_id(src_cmd_id.CASE.EXISTS.value);
			
			auto src_status = status();
			
			if (src_status.IS_EXISTS)
				dst.status(src_status.CASE.EXISTS.value);
			
			
		}
	
	template<typename DST>
		void VISION_POSITION_ESTIMATE::push_data_(DST dst) const {
			
			dst.usec(usec());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
		}
	
	template<typename DST>
		void MANUAL_CONTROL::push_data_(DST dst) const {
			
			dst.target(target());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
			dst.r(r());
			
			dst.buttons(buttons());
			
		}
	
	template<typename DST>
		void RC_CHANNELS::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.chancount(chancount());
			
			dst.chan1_raw(chan1_raw());
			
			dst.chan2_raw(chan2_raw());
			
			dst.chan3_raw(chan3_raw());
			
			dst.chan4_raw(chan4_raw());
			
			dst.chan5_raw(chan5_raw());
			
			dst.chan6_raw(chan6_raw());
			
			dst.chan7_raw(chan7_raw());
			
			dst.chan8_raw(chan8_raw());
			
			dst.chan9_raw(chan9_raw());
			
			dst.chan10_raw(chan10_raw());
			
			dst.chan11_raw(chan11_raw());
			
			dst.chan12_raw(chan12_raw());
			
			dst.chan13_raw(chan13_raw());
			
			dst.chan14_raw(chan14_raw());
			
			dst.chan15_raw(chan15_raw());
			
			dst.chan16_raw(chan16_raw());
			
			dst.chan17_raw(chan17_raw());
			
			dst.chan18_raw(chan18_raw());
			
			dst.rssi(rssi());
			
		}
	
	template<typename SRC>
		void PROTOCOL_VERSION::pull_data_(SRC src) {
			
			version(src.version());
			
			min_version(src.min_version());
			
			max_version(src.max_version());
			
			spec_version_hash(src.spec_version_hash());
			
			library_version_hash(src.library_version_hash());
			
		}
	
	template<typename DST>
		void PROTOCOL_VERSION::push_data_(DST dst) const {
			
			dst.version(version());
			
			dst.min_version(min_version());
			
			dst.max_version(max_version());
			
			dst.spec_version_hash(spec_version_hash());
			
			dst.library_version_hash(library_version_hash());
			
		}
	
	template<typename SRC>
		void RALLY_FETCH_POINT::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			idx(src.idx());
			
		}
	
	template<typename DST>
		void RALLY_FETCH_POINT::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.idx(idx());
			
		}
	
	template<typename DST>
		void PARAM_VALUE::push_data_(DST dst) const {
			auto src_param_id = param_id();
			
			if (src_param_id.IS_EXISTS)
				dst.param_id(src_param_id.CASE.EXISTS);
			
			
			dst.param_value(param_value());
			auto src_param_type = param_type();
			
			if (src_param_type.IS_EXISTS)
				dst.param_type(src_param_type.CASE.EXISTS.value);
			
			
			dst.param_count(param_count());
			
			dst.param_index(param_index());
			
		}
	
	template<typename SRC>
		void BATTERY_STATUS::pull_data_(SRC src) {
			
			id(src.id());
			
			if (src.battery_function_exists())
				battery_function(src.battery_function());
			
			
			if (src.typE_exists())
				typE(src.typE());
			
			
			temperature(src.temperature());
			
			voltages(src.voltages());
			
			current_battery(src.current_battery());
			
			current_consumed(src.current_consumed());
			
			energy_consumed(src.energy_consumed());
			
			battery_remaining(src.battery_remaining());
			
		}
	
	template<typename DST>
		void BATTERY_STATUS::push_data_(DST dst) const {
			
			dst.id(id());
			auto src_battery_function = battery_function();
			
			if (src_battery_function.IS_EXISTS)
				dst.battery_function(src_battery_function.CASE.EXISTS.value);
			
			auto src_typE = typE();
			
			if (src_typE.IS_EXISTS)
				dst.typE(src_typE.CASE.EXISTS.value);
			
			
			dst.temperature(temperature());
			
			dst.voltages(voltages());
			
			dst.current_battery(current_battery());
			
			dst.current_consumed(current_consumed());
			
			dst.energy_consumed(energy_consumed());
			
			dst.battery_remaining(battery_remaining());
			
		}
	
	template<typename SRC>
		void SERIAL_CONTROL::pull_data_(SRC src) {
			
			if (src.device_exists())
				device(src.device());
			
			
			if (src.flags_exists())
				flags(src.flags());
			
			
			timeout(src.timeout());
			
			baudrate(src.baudrate());
			
			count(src.count());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void SERIAL_CONTROL::push_data_(DST dst) const {
			auto src_device = device();
			
			if (src_device.IS_EXISTS)
				dst.device(src_device.CASE.EXISTS.value);
			
			auto src_flags = flags();
			
			if (src_flags.IS_EXISTS)
				dst.flags(src_flags.CASE.EXISTS.value);
			
			
			dst.timeout(timeout());
			
			dst.baudrate(baudrate());
			
			dst.count(count());
			
			dst.daTa(daTa());
			
		}
	
	template<typename DST>
		void SET_POSITION_TARGET_LOCAL_NED::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_coordinate_frame = coordinate_frame();
			
			if (src_coordinate_frame.IS_EXISTS)
				dst.coordinate_frame(src_coordinate_frame.CASE.EXISTS.value);
			
			
			dst.type_mask(type_mask());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
			dst.vx(vx());
			
			dst.vy(vy());
			
			dst.vz(vz());
			
			dst.afx(afx());
			
			dst.afy(afy());
			
			dst.afz(afz());
			
			dst.yaw(yaw());
			
			dst.yaw_rate(yaw_rate());
			
		}
	
	template<typename SRC>
		void MOUNT_ORIENTATION::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			roll(src.roll());
			
			pitch(src.pitch());
			
			yaw(src.yaw());
			
		}
	
	template<typename DST>
		void MOUNT_ORIENTATION::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
		}
	
	template<typename DST>
		void SET_GPS_GLOBAL_ORIGIN::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.latitude(latitude());
			
			dst.longitude(longitude());
			
			dst.altitude(altitude());
			auto src_time_usec = time_usec();
			
			if (src_time_usec.IS_EXISTS)
				dst.time_usec(src_time_usec.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void PARAM_EXT_SET::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			if (src.param_id_exists())
				param_id(src.param_id());
			
			
			if (src.param_value_exists())
				param_value(src.param_value());
			
			
			if (src.param_type_exists())
				param_type(src.param_type());
			
			
		}
	
	template<typename DST>
		void PARAM_EXT_SET::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_param_id = param_id();
			
			if (src_param_id.IS_EXISTS)
				dst.param_id(src_param_id.CASE.EXISTS);
			
			auto src_param_value = param_value();
			
			if (src_param_value.IS_EXISTS)
				dst.param_value(src_param_value.CASE.EXISTS);
			
			auto src_param_type = param_type();
			
			if (src_param_type.IS_EXISTS)
				dst.param_type(src_param_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void AUTOPILOT_VERSION::pull_data_(SRC src) {
			
			if (src.capabilities_exists())
				capabilities(src.capabilities());
			
			
			flight_sw_version(src.flight_sw_version());
			
			middleware_sw_version(src.middleware_sw_version());
			
			os_sw_version(src.os_sw_version());
			
			board_version(src.board_version());
			
			flight_custom_version(src.flight_custom_version());
			
			middleware_custom_version(src.middleware_custom_version());
			
			os_custom_version(src.os_custom_version());
			
			vendor_id(src.vendor_id());
			
			product_id(src.product_id());
			
			uid(src.uid());
			
			if (src.uid2_exists())
				for (size_t d0 = 0; d0 < com::company::demo::AUTOPILOT_VERSION::uid2_::d0; d0++) {
					
					if (src.uid2_item_exists(d0))
						uid2(src.uid2(d0), d0);
					
				}
			
		}
	
	template<typename DST>
		void AUTOPILOT_VERSION::push_data_(DST dst) const {
			auto src_capabilities = capabilities();
			
			if (src_capabilities.IS_EXISTS)
				dst.capabilities(src_capabilities.CASE.EXISTS.value);
			
			
			dst.flight_sw_version(flight_sw_version());
			
			dst.middleware_sw_version(middleware_sw_version());
			
			dst.os_sw_version(os_sw_version());
			
			dst.board_version(board_version());
			
			dst.flight_custom_version(flight_custom_version());
			
			dst.middleware_custom_version(middleware_custom_version());
			
			dst.os_custom_version(os_custom_version());
			
			dst.vendor_id(vendor_id());
			
			dst.product_id(product_id());
			
			dst.uid(uid());
			
			AUTOPILOT_VERSION_uid2_d0(EMPTY_ARG) {
							
							dst.uid2(src_uid2.CASE.EXISTS.value, d0);
							
						}
			
		}
	
	template<typename DST>
		void MISSION_REQUEST_LIST::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_mission_type = mission_type();
			
			if (src_mission_type.IS_EXISTS)
				dst.mission_type(src_mission_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void SIMSTATE::pull_data_(SRC src) {
			
			roll(src.roll());
			
			pitch(src.pitch());
			
			yaw(src.yaw());
			
			xacc(src.xacc());
			
			yacc(src.yacc());
			
			zacc(src.zacc());
			
			xgyro(src.xgyro());
			
			ygyro(src.ygyro());
			
			zgyro(src.zgyro());
			
			lat(src.lat());
			
			lng(src.lng());
			
		}
	
	template<typename DST>
		void SIMSTATE::push_data_(DST dst) const {
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
			dst.xacc(xacc());
			
			dst.yacc(yacc());
			
			dst.zacc(zacc());
			
			dst.xgyro(xgyro());
			
			dst.ygyro(ygyro());
			
			dst.zgyro(zgyro());
			
			dst.lat(lat());
			
			dst.lng(lng());
			
		}
	
	template<typename SRC>
		void SET_VIDEO_STREAM_SETTINGS::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			camera_id(src.camera_id());
			
			framerate(src.framerate());
			
			resolution_h(src.resolution_h());
			
			resolution_v(src.resolution_v());
			
			bitrate(src.bitrate());
			
			rotation(src.rotation());
			if (src.uri_exists())
				uri(src.uri());
			
			
		}
	
	template<typename DST>
		void SET_VIDEO_STREAM_SETTINGS::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.camera_id(camera_id());
			
			dst.framerate(framerate());
			
			dst.resolution_h(resolution_h());
			
			dst.resolution_v(resolution_v());
			
			dst.bitrate(bitrate());
			
			dst.rotation(rotation());
			auto src_uri = uri();
			
			if (src_uri.IS_EXISTS)
				dst.uri(src_uri.CASE.EXISTS);
			
			
		}
	
	template<typename SRC>
		void PLAY_TUNE::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			if (src.tune_exists())
				tune(src.tune());
			
			
		}
	
	template<typename DST>
		void PLAY_TUNE::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_tune = tune();
			
			if (src_tune.IS_EXISTS)
				dst.tune(src_tune.CASE.EXISTS);
			
			
		}
	
	template<typename SRC>
		void DIGICAM_CONFIGURE::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			mode(src.mode());
			
			shutter_speed(src.shutter_speed());
			
			aperture(src.aperture());
			
			iso(src.iso());
			
			exposure_type(src.exposure_type());
			
			command_id(src.command_id());
			
			engine_cut_off(src.engine_cut_off());
			
			extra_param(src.extra_param());
			
			extra_value(src.extra_value());
			
		}
	
	template<typename DST>
		void DIGICAM_CONFIGURE::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.mode(mode());
			
			dst.shutter_speed(shutter_speed());
			
			dst.aperture(aperture());
			
			dst.iso(iso());
			
			dst.exposure_type(exposure_type());
			
			dst.command_id(command_id());
			
			dst.engine_cut_off(engine_cut_off());
			
			dst.extra_param(extra_param());
			
			dst.extra_value(extra_value());
			
		}
	
	template<typename SRC>
		void SCALED_PRESSURE3::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			press_abs(src.press_abs());
			
			press_diff(src.press_diff());
			
			temperature(src.temperature());
			
		}
	
	template<typename DST>
		void SCALED_PRESSURE3::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.press_abs(press_abs());
			
			dst.press_diff(press_diff());
			
			dst.temperature(temperature());
			
		}
	
	template<typename DST>
		void MISSION_REQUEST_PARTIAL_LIST::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.start_index(start_index());
			
			dst.end_index(end_index());
			auto src_mission_type = mission_type();
			
			if (src_mission_type.IS_EXISTS)
				dst.mission_type(src_mission_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void PARAM_EXT_ACK::pull_data_(SRC src) {
			if (src.param_id_exists())
				param_id(src.param_id());
			
			
			if (src.param_value_exists())
				param_value(src.param_value());
			
			
			if (src.param_type_exists())
				param_type(src.param_type());
			
			
			if (src.param_result_exists())
				param_result(src.param_result());
			
			
		}
	
	template<typename DST>
		void PARAM_EXT_ACK::push_data_(DST dst) const {
			auto src_param_id = param_id();
			
			if (src_param_id.IS_EXISTS)
				dst.param_id(src_param_id.CASE.EXISTS);
			
			auto src_param_value = param_value();
			
			if (src_param_value.IS_EXISTS)
				dst.param_value(src_param_value.CASE.EXISTS);
			
			auto src_param_type = param_type();
			
			if (src_param_type.IS_EXISTS)
				dst.param_type(src_param_type.CASE.EXISTS.value);
			
			auto src_param_result = param_result();
			
			if (src_param_result.IS_EXISTS)
				dst.param_result(src_param_result.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void UAVCAN_NODE_INFO::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			uptime_sec(src.uptime_sec());
			if (src.name_exists())
				name(src.name());
			
			
			hw_version_major(src.hw_version_major());
			
			hw_version_minor(src.hw_version_minor());
			
			hw_unique_id(src.hw_unique_id());
			
			sw_version_major(src.sw_version_major());
			
			sw_version_minor(src.sw_version_minor());
			
			sw_vcs_commit(src.sw_vcs_commit());
			
		}
	
	template<typename DST>
		void UAVCAN_NODE_INFO::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.uptime_sec(uptime_sec());
			auto src_name = name();
			
			if (src_name.IS_EXISTS)
				dst.name(src_name.CASE.EXISTS);
			
			
			dst.hw_version_major(hw_version_major());
			
			dst.hw_version_minor(hw_version_minor());
			
			dst.hw_unique_id(hw_unique_id());
			
			dst.sw_version_major(sw_version_major());
			
			dst.sw_version_minor(sw_version_minor());
			
			dst.sw_vcs_commit(sw_vcs_commit());
			
		}
	
	template<typename SRC>
		void DATA16::pull_data_(SRC src) {
			
			typE(src.typE());
			
			len(src.len());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void DATA16::push_data_(DST dst) const {
			
			dst.typE(typE());
			
			dst.len(len());
			
			dst.daTa(daTa());
			
		}
	
	template<typename SRC>
		void SET_MAG_OFFSETS::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			mag_ofs_x(src.mag_ofs_x());
			
			mag_ofs_y(src.mag_ofs_y());
			
			mag_ofs_z(src.mag_ofs_z());
			
		}
	
	template<typename DST>
		void SET_MAG_OFFSETS::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.mag_ofs_x(mag_ofs_x());
			
			dst.mag_ofs_y(mag_ofs_y());
			
			dst.mag_ofs_z(mag_ofs_z());
			
		}
	
	template<typename SRC>
		void AP_ADC::pull_data_(SRC src) {
			
			adc1(src.adc1());
			
			adc2(src.adc2());
			
			adc3(src.adc3());
			
			adc4(src.adc4());
			
			adc5(src.adc5());
			
			adc6(src.adc6());
			
		}
	
	template<typename DST>
		void AP_ADC::push_data_(DST dst) const {
			
			dst.adc1(adc1());
			
			dst.adc2(adc2());
			
			dst.adc3(adc3());
			
			dst.adc4(adc4());
			
			dst.adc5(adc5());
			
			dst.adc6(adc6());
			
		}
	
	template<typename SRC>
		void WIND::pull_data_(SRC src) {
			
			direction(src.direction());
			
			speed(src.speed());
			
			speed_z(src.speed_z());
			
		}
	
	template<typename DST>
		void WIND::push_data_(DST dst) const {
			
			dst.direction(direction());
			
			dst.speed(speed());
			
			dst.speed_z(speed_z());
			
		}
	
	template<typename SRC>
		void AUTOPILOT_VERSION_REQUEST::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
		}
	
	template<typename DST>
		void AUTOPILOT_VERSION_REQUEST::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
		}
	
	template<typename DST>
		void LOCAL_POSITION_NED::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
			dst.vx(vx());
			
			dst.vy(vy());
			
			dst.vz(vz());
			
		}
	
	template<typename SRC>
		void DATA_TRANSMISSION_HANDSHAKE::pull_data_(SRC src) {
			
			typE(src.typE());
			
			size(src.size());
			
			width(src.width());
			
			height(src.height());
			
			packets(src.packets());
			
			payload(src.payload());
			
			jpg_quality(src.jpg_quality());
			
		}
	
	template<typename DST>
		void DATA_TRANSMISSION_HANDSHAKE::push_data_(DST dst) const {
			
			dst.typE(typE());
			
			dst.size(size());
			
			dst.width(width());
			
			dst.height(height());
			
			dst.packets(packets());
			
			dst.payload(payload());
			
			dst.jpg_quality(jpg_quality());
			
		}
	
	template<typename DST>
		void GPS_GLOBAL_ORIGIN::push_data_(DST dst) const {
			
			dst.latitude(latitude());
			
			dst.longitude(longitude());
			
			dst.altitude(altitude());
			auto src_time_usec = time_usec();
			
			if (src_time_usec.IS_EXISTS)
				dst.time_usec(src_time_usec.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void SCALED_IMU2::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			xacc(src.xacc());
			
			yacc(src.yacc());
			
			zacc(src.zacc());
			
			xgyro(src.xgyro());
			
			ygyro(src.ygyro());
			
			zgyro(src.zgyro());
			
			xmag(src.xmag());
			
			ymag(src.ymag());
			
			zmag(src.zmag());
			
		}
	
	template<typename DST>
		void SCALED_IMU2::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.xacc(xacc());
			
			dst.yacc(yacc());
			
			dst.zacc(zacc());
			
			dst.xgyro(xgyro());
			
			dst.ygyro(ygyro());
			
			dst.zgyro(zgyro());
			
			dst.xmag(xmag());
			
			dst.ymag(ymag());
			
			dst.zmag(zmag());
			
		}
	
	template<typename DST>
		void ATTITUDE_QUATERNION::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.q1(q1());
			
			dst.q2(q2());
			
			dst.q3(q3());
			
			dst.q4(q4());
			
			dst.rollspeed(rollspeed());
			
			dst.pitchspeed(pitchspeed());
			
			dst.yawspeed(yawspeed());
			
		}
	
	template<typename SRC>
		void DATA64::pull_data_(SRC src) {
			
			typE(src.typE());
			
			len(src.len());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void DATA64::push_data_(DST dst) const {
			
			dst.typE(typE());
			
			dst.len(len());
			
			dst.daTa(daTa());
			
		}
	
	template<typename DST>
		void HIL_ACTUATOR_CONTROLS::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.controls(controls());
			auto src_mode = mode();
			
			if (src_mode.IS_EXISTS)
				dst.mode(src_mode.CASE.EXISTS.value);
			
			
			dst.flags(flags());
			
		}
	
	template<typename DST>
		void POSITION_TARGET_LOCAL_NED::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			auto src_coordinate_frame = coordinate_frame();
			
			if (src_coordinate_frame.IS_EXISTS)
				dst.coordinate_frame(src_coordinate_frame.CASE.EXISTS.value);
			
			
			dst.type_mask(type_mask());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
			dst.vx(vx());
			
			dst.vy(vy());
			
			dst.vz(vz());
			
			dst.afx(afx());
			
			dst.afy(afy());
			
			dst.afz(afz());
			
			dst.yaw(yaw());
			
			dst.yaw_rate(yaw_rate());
			
		}
	
	template<typename SRC>
		void GIMBAL_REPORT::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			delta_time(src.delta_time());
			
			delta_angle_x(src.delta_angle_x());
			
			delta_angle_y(src.delta_angle_y());
			
			delta_angle_z(src.delta_angle_z());
			
			delta_velocity_x(src.delta_velocity_x());
			
			delta_velocity_y(src.delta_velocity_y());
			
			delta_velocity_z(src.delta_velocity_z());
			
			joint_roll(src.joint_roll());
			
			joint_el(src.joint_el());
			
			joint_az(src.joint_az());
			
		}
	
	template<typename DST>
		void GIMBAL_REPORT::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.delta_time(delta_time());
			
			dst.delta_angle_x(delta_angle_x());
			
			dst.delta_angle_y(delta_angle_y());
			
			dst.delta_angle_z(delta_angle_z());
			
			dst.delta_velocity_x(delta_velocity_x());
			
			dst.delta_velocity_y(delta_velocity_y());
			
			dst.delta_velocity_z(delta_velocity_z());
			
			dst.joint_roll(joint_roll());
			
			dst.joint_el(joint_el());
			
			dst.joint_az(joint_az());
			
		}
	
	template<typename SRC>
		void DEVICE_OP_WRITE::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			request_id(src.request_id());
			
			if (src.bustype_exists())
				bustype(src.bustype());
			
			
			bus(src.bus());
			
			address(src.address());
			if (src.busname_exists())
				busname(src.busname());
			
			
			regstart(src.regstart());
			
			count(src.count());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void DEVICE_OP_WRITE::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.request_id(request_id());
			auto src_bustype = bustype();
			
			if (src_bustype.IS_EXISTS)
				dst.bustype(src_bustype.CASE.EXISTS.value);
			
			
			dst.bus(bus());
			
			dst.address(address());
			auto src_busname = busname();
			
			if (src_busname.IS_EXISTS)
				dst.busname(src_busname.CASE.EXISTS);
			
			
			dst.regstart(regstart());
			
			dst.count(count());
			
			dst.daTa(daTa());
			
		}
	
	template<typename SRC>
		void DISTANCE_SENSOR::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			min_distance(src.min_distance());
			
			max_distance(src.max_distance());
			
			current_distance(src.current_distance());
			
			if (src.typE_exists())
				typE(src.typE());
			
			
			id(src.id());
			
			if (src.orientation_exists())
				orientation(src.orientation());
			
			
			covariance(src.covariance());
			
		}
	
	template<typename DST>
		void DISTANCE_SENSOR::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.min_distance(min_distance());
			
			dst.max_distance(max_distance());
			
			dst.current_distance(current_distance());
			auto src_typE = typE();
			
			if (src_typE.IS_EXISTS)
				dst.typE(src_typE.CASE.EXISTS.value);
			
			
			dst.id(id());
			auto src_orientation = orientation();
			
			if (src_orientation.IS_EXISTS)
				dst.orientation(src_orientation.CASE.EXISTS.value);
			
			
			dst.covariance(covariance());
			
		}
	
	template<typename SRC>
		void HIL_OPTICAL_FLOW::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			sensor_id(src.sensor_id());
			
			integration_time_us(src.integration_time_us());
			
			integrated_x(src.integrated_x());
			
			integrated_y(src.integrated_y());
			
			integrated_xgyro(src.integrated_xgyro());
			
			integrated_ygyro(src.integrated_ygyro());
			
			integrated_zgyro(src.integrated_zgyro());
			
			temperature(src.temperature());
			
			quality(src.quality());
			
			time_delta_distance_us(src.time_delta_distance_us());
			
			distance(src.distance());
			
		}
	
	template<typename DST>
		void HIL_OPTICAL_FLOW::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.sensor_id(sensor_id());
			
			dst.integration_time_us(integration_time_us());
			
			dst.integrated_x(integrated_x());
			
			dst.integrated_y(integrated_y());
			
			dst.integrated_xgyro(integrated_xgyro());
			
			dst.integrated_ygyro(integrated_ygyro());
			
			dst.integrated_zgyro(integrated_zgyro());
			
			dst.temperature(temperature());
			
			dst.quality(quality());
			
			dst.time_delta_distance_us(time_delta_distance_us());
			
			dst.distance(distance());
			
		}
	
	template<typename SRC>
		void SCALED_PRESSURE2::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			
			press_abs(src.press_abs());
			
			press_diff(src.press_diff());
			
			temperature(src.temperature());
			
		}
	
	template<typename DST>
		void SCALED_PRESSURE2::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			
			dst.press_abs(press_abs());
			
			dst.press_diff(press_diff());
			
			dst.temperature(temperature());
			
		}
	
	template<typename SRC>
		void WIND_COV::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			wind_x(src.wind_x());
			
			wind_y(src.wind_y());
			
			wind_z(src.wind_z());
			
			var_horiz(src.var_horiz());
			
			var_vert(src.var_vert());
			
			wind_alt(src.wind_alt());
			
			horiz_accuracy(src.horiz_accuracy());
			
			vert_accuracy(src.vert_accuracy());
			
		}
	
	template<typename DST>
		void WIND_COV::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.wind_x(wind_x());
			
			dst.wind_y(wind_y());
			
			dst.wind_z(wind_z());
			
			dst.var_horiz(var_horiz());
			
			dst.var_vert(var_vert());
			
			dst.wind_alt(wind_alt());
			
			dst.horiz_accuracy(horiz_accuracy());
			
			dst.vert_accuracy(vert_accuracy());
			
		}
	
	template<typename DST>
		void CHANGE_OPERATOR_CONTROL::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.control_request(control_request());
			
			dst.version(version());
			auto src_passkey = passkey();
			
			if (src_passkey.IS_EXISTS)
				dst.passkey(src_passkey.CASE.EXISTS);
			
			
		}
	
	template<typename SRC>
		void GOPRO_SET_REQUEST::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			if (src.cmd_id_exists())
				cmd_id(src.cmd_id());
			
			
			value(src.value());
			
		}
	
	template<typename DST>
		void GOPRO_SET_REQUEST::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_cmd_id = cmd_id();
			
			if (src_cmd_id.IS_EXISTS)
				dst.cmd_id(src_cmd_id.CASE.EXISTS.value);
			
			
			dst.value(value());
			
		}
	
	template<typename DST>
		void SYS_STATUS::push_data_(DST dst) const {
			auto src_onboard_control_sensors_present = onboard_control_sensors_present();
			
			if (src_onboard_control_sensors_present.IS_EXISTS)
				dst.onboard_control_sensors_present(src_onboard_control_sensors_present.CASE.EXISTS.value);
			
			auto src_onboard_control_sensors_enabled = onboard_control_sensors_enabled();
			
			if (src_onboard_control_sensors_enabled.IS_EXISTS)
				dst.onboard_control_sensors_enabled(src_onboard_control_sensors_enabled.CASE.EXISTS.value);
			
			auto src_onboard_control_sensors_health = onboard_control_sensors_health();
			
			if (src_onboard_control_sensors_health.IS_EXISTS)
				dst.onboard_control_sensors_health(src_onboard_control_sensors_health.CASE.EXISTS.value);
			
			
			dst.load(load());
			
			dst.voltage_battery(voltage_battery());
			
			dst.current_battery(current_battery());
			
			dst.battery_remaining(battery_remaining());
			
			dst.drop_rate_comm(drop_rate_comm());
			
			dst.errors_comm(errors_comm());
			
			dst.errors_count1(errors_count1());
			
			dst.errors_count2(errors_count2());
			
			dst.errors_count3(errors_count3());
			
			dst.errors_count4(errors_count4());
			
		}
	
	template<typename DST>
		void MISSION_ITEM::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.seq(seq());
			auto src_frame = frame();
			
			if (src_frame.IS_EXISTS)
				dst.frame(src_frame.CASE.EXISTS.value);
			
			auto src_command = command();
			
			if (src_command.IS_EXISTS)
				dst.command(src_command.CASE.EXISTS.value);
			
			
			dst.current(current());
			
			dst.autocontinue(autocontinue());
			
			dst.param1(param1());
			
			dst.param2(param2());
			
			dst.param3(param3());
			
			dst.param4(param4());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			auto src_mission_type = mission_type();
			
			if (src_mission_type.IS_EXISTS)
				dst.mission_type(src_mission_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename DST>
		void RAW_IMU::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.xacc(xacc());
			
			dst.yacc(yacc());
			
			dst.zacc(zacc());
			
			dst.xgyro(xgyro());
			
			dst.ygyro(ygyro());
			
			dst.zgyro(zgyro());
			
			dst.xmag(xmag());
			
			dst.ymag(ymag());
			
			dst.zmag(zmag());
			
		}
	
	template<typename DST>
		void COMMAND_INT::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			auto src_frame = frame();
			
			if (src_frame.IS_EXISTS)
				dst.frame(src_frame.CASE.EXISTS.value);
			
			auto src_command = command();
			
			if (src_command.IS_EXISTS)
				dst.command(src_command.CASE.EXISTS.value);
			
			
			dst.current(current());
			
			dst.autocontinue(autocontinue());
			
			dst.param1(param1());
			
			dst.param2(param2());
			
			dst.param3(param3());
			
			dst.param4(param4());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
		}
	
	template<typename DST>
		void OPTICAL_FLOW::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.sensor_id(sensor_id());
			
			dst.flow_x(flow_x());
			
			dst.flow_y(flow_y());
			
			dst.flow_comp_m_x(flow_comp_m_x());
			
			dst.flow_comp_m_y(flow_comp_m_y());
			
			dst.quality(quality());
			
			dst.ground_distance(ground_distance());
			auto src_flow_rate_x = flow_rate_x();
			
			if (src_flow_rate_x.IS_EXISTS)
				dst.flow_rate_x(src_flow_rate_x.CASE.EXISTS.value);
			
			auto src_flow_rate_y = flow_rate_y();
			
			if (src_flow_rate_y.IS_EXISTS)
				dst.flow_rate_y(src_flow_rate_y.CASE.EXISTS.value);
			
			
		}
	
	template<typename DST>
		void MISSION_ITEM_INT::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.seq(seq());
			auto src_frame = frame();
			
			if (src_frame.IS_EXISTS)
				dst.frame(src_frame.CASE.EXISTS.value);
			
			auto src_command = command();
			
			if (src_command.IS_EXISTS)
				dst.command(src_command.CASE.EXISTS.value);
			
			
			dst.current(current());
			
			dst.autocontinue(autocontinue());
			
			dst.param1(param1());
			
			dst.param2(param2());
			
			dst.param3(param3());
			
			dst.param4(param4());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			auto src_mission_type = mission_type();
			
			if (src_mission_type.IS_EXISTS)
				dst.mission_type(src_mission_type.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void VISION_POSITION_DELTA::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			time_delta_usec(src.time_delta_usec());
			
			angle_delta(src.angle_delta());
			
			position_delta(src.position_delta());
			
			confidence(src.confidence());
			
		}
	
	template<typename DST>
		void VISION_POSITION_DELTA::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.time_delta_usec(time_delta_usec());
			
			dst.angle_delta(angle_delta());
			
			dst.position_delta(position_delta());
			
			dst.confidence(confidence());
			
		}
	
	template<typename SRC>
		void LOGGING_DATA::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			sequence(src.sequence());
			
			length(src.length());
			
			first_message_offset(src.first_message_offset());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void LOGGING_DATA::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.sequence(sequence());
			
			dst.length(length());
			
			dst.first_message_offset(first_message_offset());
			
			dst.daTa(daTa());
			
		}
	
	template<typename SRC>
		void DEVICE_OP_READ::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			request_id(src.request_id());
			
			if (src.bustype_exists())
				bustype(src.bustype());
			
			
			bus(src.bus());
			
			address(src.address());
			if (src.busname_exists())
				busname(src.busname());
			
			
			regstart(src.regstart());
			
			count(src.count());
			
		}
	
	template<typename DST>
		void DEVICE_OP_READ::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.request_id(request_id());
			auto src_bustype = bustype();
			
			if (src_bustype.IS_EXISTS)
				dst.bustype(src_bustype.CASE.EXISTS.value);
			
			
			dst.bus(bus());
			
			dst.address(address());
			auto src_busname = busname();
			
			if (src_busname.IS_EXISTS)
				dst.busname(src_busname.CASE.EXISTS);
			
			
			dst.regstart(regstart());
			
			dst.count(count());
			
		}
	
	template<typename SRC>
		void MAG_CAL_PROGRESS::pull_data_(SRC src) {
			
			compass_id(src.compass_id());
			
			cal_mask(src.cal_mask());
			
			if (src.cal_status_exists())
				cal_status(src.cal_status());
			
			
			attempt(src.attempt());
			
			completion_pct(src.completion_pct());
			
			completion_mask(src.completion_mask());
			
			direction_x(src.direction_x());
			
			direction_y(src.direction_y());
			
			direction_z(src.direction_z());
			
		}
	
	template<typename DST>
		void MAG_CAL_PROGRESS::push_data_(DST dst) const {
			
			dst.compass_id(compass_id());
			
			dst.cal_mask(cal_mask());
			auto src_cal_status = cal_status();
			
			if (src_cal_status.IS_EXISTS)
				dst.cal_status(src_cal_status.CASE.EXISTS.value);
			
			
			dst.attempt(attempt());
			
			dst.completion_pct(completion_pct());
			
			dst.completion_mask(completion_mask());
			
			dst.direction_x(direction_x());
			
			dst.direction_y(direction_y());
			
			dst.direction_z(direction_z());
			
		}
	
	template<typename SRC>
		void HIGHRES_IMU::pull_data_(SRC src) {
			
			time_usec(src.time_usec());
			
			xacc(src.xacc());
			
			yacc(src.yacc());
			
			zacc(src.zacc());
			
			xgyro(src.xgyro());
			
			ygyro(src.ygyro());
			
			zgyro(src.zgyro());
			
			xmag(src.xmag());
			
			ymag(src.ymag());
			
			zmag(src.zmag());
			
			abs_pressure(src.abs_pressure());
			
			diff_pressure(src.diff_pressure());
			
			pressure_alt(src.pressure_alt());
			
			temperature(src.temperature());
			
			fields_updated(src.fields_updated());
			
		}
	
	template<typename DST>
		void HIGHRES_IMU::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.xacc(xacc());
			
			dst.yacc(yacc());
			
			dst.zacc(zacc());
			
			dst.xgyro(xgyro());
			
			dst.ygyro(ygyro());
			
			dst.zgyro(zgyro());
			
			dst.xmag(xmag());
			
			dst.ymag(ymag());
			
			dst.zmag(zmag());
			
			dst.abs_pressure(abs_pressure());
			
			dst.diff_pressure(diff_pressure());
			
			dst.pressure_alt(pressure_alt());
			
			dst.temperature(temperature());
			
			dst.fields_updated(fields_updated());
			
		}
	
	template<typename SRC>
		void EXTENDED_SYS_STATE::pull_data_(SRC src) {
			
			if (src.vtol_state_exists())
				vtol_state(src.vtol_state());
			
			
			if (src.landed_state_exists())
				landed_state(src.landed_state());
			
			
		}
	
	template<typename DST>
		void EXTENDED_SYS_STATE::push_data_(DST dst) const {
			auto src_vtol_state = vtol_state();
			
			if (src_vtol_state.IS_EXISTS)
				dst.vtol_state(src_vtol_state.CASE.EXISTS.value);
			
			auto src_landed_state = landed_state();
			
			if (src_landed_state.IS_EXISTS)
				dst.landed_state(src_landed_state.CASE.EXISTS.value);
			
			
		}
	
	template<typename SRC>
		void UAVIONIX_ADSB_OUT_DYNAMIC::pull_data_(SRC src) {
			
			utcTime(src.utcTime());
			
			gpsLat(src.gpsLat());
			
			gpsLon(src.gpsLon());
			
			gpsAlt(src.gpsAlt());
			
			if (src.gpsFix_exists())
				gpsFix(src.gpsFix());
			
			
			numSats(src.numSats());
			
			baroAltMSL(src.baroAltMSL());
			
			accuracyHor(src.accuracyHor());
			
			accuracyVert(src.accuracyVert());
			
			accuracyVel(src.accuracyVel());
			
			velVert(src.velVert());
			
			velNS(src.velNS());
			
			VelEW(src.VelEW());
			
			if (src.emergencyStatus_exists())
				emergencyStatus(src.emergencyStatus());
			
			
			if (src.state_exists())
				state(src.state());
			
			
			squawk(src.squawk());
			
		}
	
	template<typename DST>
		void UAVIONIX_ADSB_OUT_DYNAMIC::push_data_(DST dst) const {
			
			dst.utcTime(utcTime());
			
			dst.gpsLat(gpsLat());
			
			dst.gpsLon(gpsLon());
			
			dst.gpsAlt(gpsAlt());
			auto src_gpsFix = gpsFix();
			
			if (src_gpsFix.IS_EXISTS)
				dst.gpsFix(src_gpsFix.CASE.EXISTS.value);
			
			
			dst.numSats(numSats());
			
			dst.baroAltMSL(baroAltMSL());
			
			dst.accuracyHor(accuracyHor());
			
			dst.accuracyVert(accuracyVert());
			
			dst.accuracyVel(accuracyVel());
			
			dst.velVert(velVert());
			
			dst.velNS(velNS());
			
			dst.VelEW(VelEW());
			auto src_emergencyStatus = emergencyStatus();
			
			if (src_emergencyStatus.IS_EXISTS)
				dst.emergencyStatus(src_emergencyStatus.CASE.EXISTS.value);
			
			auto src_state = state();
			
			if (src_state.IS_EXISTS)
				dst.state(src_state.CASE.EXISTS.value);
			
			
			dst.squawk(squawk());
			
		}
	
	template<typename SRC>
		void GOPRO_GET_RESPONSE::pull_data_(SRC src) {
			
			if (src.cmd_id_exists())
				cmd_id(src.cmd_id());
			
			
			if (src.status_exists())
				status(src.status());
			
			
			value(src.value());
			
		}
	
	template<typename DST>
		void GOPRO_GET_RESPONSE::push_data_(DST dst) const {
			auto src_cmd_id = cmd_id();
			
			if (src_cmd_id.IS_EXISTS)
				dst.cmd_id(src_cmd_id.CASE.EXISTS.value);
			
			auto src_status = status();
			
			if (src_status.IS_EXISTS)
				dst.status(src_status.CASE.EXISTS.value);
			
			
			dst.value(value());
			
		}
	
	template<typename SRC>
		void GPS_INJECT_DATA::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			len(src.len());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void GPS_INJECT_DATA::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.len(len());
			
			dst.daTa(daTa());
			
		}
	
	template<typename SRC>
		void UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT::pull_data_(SRC src) {
			
			if (src.rfHealth_exists())
				rfHealth(src.rfHealth());
			
			
		}
	
	template<typename DST>
		void UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT::push_data_(DST dst) const {
			auto src_rfHealth = rfHealth();
			
			if (src_rfHealth.IS_EXISTS)
				dst.rfHealth(src_rfHealth.CASE.EXISTS.value);
			
			
		}
	
	template<typename DST>
		void ATTITUDE_QUATERNION_COV::push_data_(DST dst) const {
			
			dst.time_usec(time_usec());
			
			dst.q(q());
			
			dst.rollspeed(rollspeed());
			
			dst.pitchspeed(pitchspeed());
			
			dst.yawspeed(yawspeed());
			
			dst.covariance(covariance());
			
		}
	
	template<typename SRC>
		void NAMED_VALUE_INT::pull_data_(SRC src) {
			
			time_boot_ms(src.time_boot_ms());
			if (src.name_exists())
				name(src.name());
			
			
			value(src.value());
			
		}
	
	template<typename DST>
		void NAMED_VALUE_INT::push_data_(DST dst) const {
			
			dst.time_boot_ms(time_boot_ms());
			auto src_name = name();
			
			if (src_name.IS_EXISTS)
				dst.name(src_name.CASE.EXISTS);
			
			
			dst.value(value());
			
		}
	
	template<typename SRC>
		void RPM::pull_data_(SRC src) {
			
			rpm1(src.rpm1());
			
			rpm2(src.rpm2());
			
		}
	
	template<typename DST>
		void RPM::push_data_(DST dst) const {
			
			dst.rpm1(rpm1());
			
			dst.rpm2(rpm2());
			
		}
	
	template<typename SRC>
		void GPS_RTCM_DATA::pull_data_(SRC src) {
			
			flags(src.flags());
			
			len(src.len());
			
			daTa(src.daTa());
			
		}
	
	template<typename DST>
		void GPS_RTCM_DATA::push_data_(DST dst) const {
			
			dst.flags(flags());
			
			dst.len(len());
			
			dst.daTa(daTa());
			
		}
	
	template<typename DST>
		void GLOBAL_VISION_POSITION_ESTIMATE::push_data_(DST dst) const {
			
			dst.usec(usec());
			
			dst.x(x());
			
			dst.y(y());
			
			dst.z(z());
			
			dst.roll(roll());
			
			dst.pitch(pitch());
			
			dst.yaw(yaw());
			
		}
	
	template<typename SRC>
		void FILE_TRANSFER_PROTOCOL::pull_data_(SRC src) {
			
			target_network(src.target_network());
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			payload(src.payload());
			
		}
	
	template<typename DST>
		void FILE_TRANSFER_PROTOCOL::push_data_(DST dst) const {
			
			dst.target_network(target_network());
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.payload(payload());
			
		}
	
	template<typename SRC>
		void RANGEFINDER::pull_data_(SRC src) {
			
			distance(src.distance());
			
			voltage(src.voltage());
			
		}
	
	template<typename DST>
		void RANGEFINDER::push_data_(DST dst) const {
			
			dst.distance(distance());
			
			dst.voltage(voltage());
			
		}
	
	template<typename SRC>
		void RADIO_STATUS::pull_data_(SRC src) {
			
			rssi(src.rssi());
			
			remrssi(src.remrssi());
			
			txbuf(src.txbuf());
			
			noise(src.noise());
			
			remnoise(src.remnoise());
			
			rxerrors(src.rxerrors());
			
			fixeD(src.fixeD());
			
		}
	
	template<typename DST>
		void RADIO_STATUS::push_data_(DST dst) const {
			
			dst.rssi(rssi());
			
			dst.remrssi(remrssi());
			
			dst.txbuf(txbuf());
			
			dst.noise(noise());
			
			dst.remnoise(remnoise());
			
			dst.rxerrors(rxerrors());
			
			dst.fixeD(fixeD());
			
		}
	
	template<typename SRC>
		void FENCE_POINT::pull_data_(SRC src) {
			
			target_system(src.target_system());
			
			target_component(src.target_component());
			
			idx(src.idx());
			
			count(src.count());
			
			lat(src.lat());
			
			lng(src.lng());
			
		}
	
	template<typename DST>
		void FENCE_POINT::push_data_(DST dst) const {
			
			dst.target_system(target_system());
			
			dst.target_component(target_component());
			
			dst.idx(idx());
			
			dst.count(count());
			
			dst.lat(lat());
			
			dst.lng(lng());
			
		}
	
	template<typename SRC>
		void RESOURCE_REQUEST::pull_data_(SRC src) {
			
			request_id(src.request_id());
			
			uri_type(src.uri_type());
			
			uri(src.uri());
			
			transfer_type(src.transfer_type());
			
			storage(src.storage());
			
		}
	
	template<typename DST>
		void RESOURCE_REQUEST::push_data_(DST dst) const {
			
			dst.request_id(request_id());
			
			dst.uri_type(uri_type());
			
			dst.uri(uri());
			
			dst.transfer_type(transfer_type());
			
			dst.storage(storage());
			
		}
	
	
	//#######################                 CommunicationChannel                       ##################################
	/*
	static <CHANNEL> * from(Receiver * receiver){}
	static const Pack* pull_sending_pack(Transmitter * transmitter){}
	static bool push_sending_pack(Transmitter * transmitter, Pack * pack){}
*/
	template<typename CHANNEL>
		struct CommunicationChannel {
			CommunicationChannel() {
				receiver.dispatch = dispatch;
				transmitter.pull  = CHANNEL::pull_sending_pack;
			}
			
			Receiver    receiver{};
			Transmitter transmitter{};
			
			size_t packs_into_bytes(uint8_t *dst, size_t dst_bytes) { return ::transmit(&transmitter, dst, dst_bytes); }
			
			/*
											void on_RAW_PRESSURE(  Pack * pack ){}
void on_HIL_RC_INPUTS_RAW(  Pack * pack ){}
void on_HIL_SENSOR(  Pack * pack ){}
void on_MISSION_ACK(  Pack * pack ){}
void on_HEARTBEAT(  Pack * pack ){}
void on_PING33(  Pack * pack ){}
void on_MISSION_REQUEST(  Pack * pack ){}
void on_MISSION_CLEAR_ALL(  Pack * pack ){}
void on_MISSION_REQUEST_LIST(  Pack * pack ){}
void on_TERRAIN_REPORT(  Pack * pack ){}
void on_SET_ACTUATOR_CONTROL_TARGET(  Pack * pack ){}
void on_MISSION_SET_CURRENT(  Pack * pack ){}
void on_DATA_STREAM(  Pack * pack ){}
void on_CHANGE_OPERATOR_CONTROL_ACK(  Pack * pack ){}
void on_LANDING_TARGET(  Pack * pack ){}
void on_CHANGE_OPERATOR_CONTROL(  Pack * pack ){}
void on_PLAY_TUNE(  Pack * pack ){}
void on_SET_HOME_POSITION(  Pack * pack ){}
void on_POSITION_TARGET_GLOBAL_INT(  Pack * pack ){}
void on_SET_POSITION_TARGET_GLOBAL_INT(  Pack * pack ){}
void on_BATTERY_STATUS(  Pack * pack ){}
void on_EXTENDED_SYS_STATE(  Pack * pack ){}
void on_GPS2_RTK(  Pack * pack ){}
void on_VICON_POSITION_ESTIMATE(  Pack * pack ){}
void on_LOG_REQUEST_LIST(  Pack * pack ){}
void on_AUTOPILOT_VERSION(  Pack * pack ){}
void on_CAMERA_INFORMATION(  Pack * pack ){}
void on_GPS_INPUT(  Pack * pack ){}
void on_GPS_RAW_INT(  Pack * pack ){}
void on_SCALED_IMU2(  Pack * pack ){}
void on_ADSB_VEHICLE(  Pack * pack ){}
void on_AUTH_KEY(  Pack * pack ){}
void on_RC_CHANNELS_OVERRIDE(  Pack * pack ){}
void on_MISSION_ITEM_REACHED(  Pack * pack ){}
void on_SERIAL_CONTROL(  Pack * pack ){}
void on_SERVO_OUTPUT_RAW(  Pack * pack ){}
void on_ATTITUDE_QUATERNION_COV(  Pack * pack ){}
void on_ATTITUDE_QUATERNION(  Pack * pack ){}
void on_CAMERA_IMAGE_CAPTURED(  Pack * pack ){}
void on_CONTROL_SYSTEM_STATE(  Pack * pack ){}
void on_MISSION_COUNT(  Pack * pack ){}
void on_CAMERA_SETTINGS(  Pack * pack ){}
void on_HOME_POSITION(  Pack * pack ){}
void on_ATTITUDE_TARGET(  Pack * pack ){}
void on_MANUAL_CONTROL(  Pack * pack ){}
void on_SCALED_PRESSURE3(  Pack * pack ){}
void on_SET_ATTITUDE_TARGET(  Pack * pack ){}
void on_BUTTON_CHANGE(  Pack * pack ){}
void on_STORAGE_INFORMATION(  Pack * pack ){}
void on_MEMORY_VECT(  Pack * pack ){}
void on_GPS_INJECT_DATA(  Pack * pack ){}
void on_POWER_STATUS(  Pack * pack ){}
void on_RC_CHANNELS_SCALED(  Pack * pack ){}
void on_DATA_TRANSMISSION_HANDSHAKE(  Pack * pack ){}
void on_SwitchModeCommand(  ){}
void on_RC_CHANNELS_RAW(  Pack * pack ){}
void on_GLOBAL_VISION_POSITION_ESTIMATE(  Pack * pack ){}
void on_MISSION_ITEM_INT(  Pack * pack ){}
void on_GPS_RTCM_DATA(  Pack * pack ){}
void on_VISION_SPEED_ESTIMATE(  Pack * pack ){}
void on_PARAM_REQUEST_LIST(  Pack * pack ){}
void on_COMMAND_LONG(  Pack * pack ){}
void on_HIL_CONTROLS(  Pack * pack ){}
void on_DISTANCE_SENSOR(  Pack * pack ){}
void on_POSITION_TARGET_LOCAL_NED(  Pack * pack ){}
void on_RAW_IMU(  Pack * pack ){}
void on_OPTICAL_FLOW(  Pack * pack ){}
void on_MISSION_REQUEST_PARTIAL_LIST(  Pack * pack ){}
void on_TERRAIN_REQUEST(  Pack * pack ){}
void on_PARAM_REQUEST_READ(  Pack * pack ){}
void on_LOG_ENTRY(  Pack * pack ){}
void on_MISSION_ITEM(  Pack * pack ){}
void on_FLIGHT_INFORMATION(  Pack * pack ){}
void on_TERRAIN_DATA(  Pack * pack ){}
void on_LOG_REQUEST_END(  Pack * pack ){}
void on_WIND_COV(  Pack * pack ){}
void on_MISSION_WRITE_PARTIAL_LIST(  Pack * pack ){}
void on_LOG_ERASE(  Pack * pack ){}
void on_SYSTEM_TIME(  Pack * pack ){}
void on_VFR_HUD(  Pack * pack ){}
void on_CAMERA_CAPTURE_STATUS(  Pack * pack ){}
void on_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(  Pack * pack ){}
void on_PARAM_SET(  Pack * pack ){}
void on_SETUP_SIGNING(  Pack * pack ){}
void on_SET_GPS_GLOBAL_ORIGIN(  Pack * pack ){}
void on_OPTICAL_FLOW_RAD(  Pack * pack ){}
void on_ATTITUDE(  Pack * pack ){}
void on_LOCAL_POSITION_NED(  Pack * pack ){}
void on_FILE_TRANSFER_PROTOCOL(  Pack * pack ){}
void on_PING(  Pack * pack ){}
void on_PARAM_VALUE(  Pack * pack ){}
void on_HIL_GPS(  Pack * pack ){}
void on_V2_EXTENSION(  Pack * pack ){}
void on_MANUAL_SETPOINT(  Pack * pack ){}
void on_MESSAGE_INTERVAL(  Pack * pack ){}
void on_ACTUATOR_CONTROL_TARGET(  Pack * pack ){}
void on_TERRAIN_CHECK(  Pack * pack ){}
void on_SYS_STATUS(  Pack * pack ){}
void on_HIL_ACTUATOR_CONTROLS(  Pack * pack ){}
void on_SIM_STATE(  Pack * pack ){}
void on_DEBUG(  Pack * pack ){}
void on_GPS2_RAW(  Pack * pack ){}
void on_DEBUG_VECT(  Pack * pack ){}
void on_RESOURCE_REQUEST(  Pack * pack ){}
void on_SCALED_PRESSURE2(  Pack * pack ){}
void on_HIGHRES_IMU(  Pack * pack ){}
void on_HIL_STATE_QUATERNION(  Pack * pack ){}
void on_GPS_STATUS(  Pack * pack ){}
void on_NAMED_VALUE_FLOAT(  Pack * pack ){}
void on_HIL_STATE(  Pack * pack ){}
void on_SCALED_IMU3(  Pack * pack ){}
void on_COMMAND_ACK(  Pack * pack ){}
void on_ATT_POS_MOCAP(  Pack * pack ){}
void on_SCALED_IMU(  Pack * pack ){}
void on_LOCAL_POSITION_NED_COV(  Pack * pack ){}
void on_STATUSTEXT(  Pack * pack ){}
void on_RADIO_STATUS(  Pack * pack ){}
void on_NAMED_VALUE_INT(  Pack * pack ){}
void on_RC_CHANNELS(  Pack * pack ){}
void on_SET_MODE(  Pack * pack ){}
void on_COMMAND_INT(  Pack * pack ){}
void on_SCALED_PRESSURE(  Pack * pack ){}
void on_TIMESYNC(  Pack * pack ){}
void on_GPS_GLOBAL_ORIGIN(  Pack * pack ){}
void on_NAV_CONTROLLER_OUTPUT(  Pack * pack ){}
void on_LOG_DATA(  Pack * pack ){}
void on_MISSION_CURRENT(  Pack * pack ){}
void on_ENCAPSULATED_DATA(  Pack * pack ){}
void on_GLOBAL_POSITION_INT(  Pack * pack ){}
void on_CAMERA_TRIGGER(  Pack * pack ){}
void on_ESTIMATOR_STATUS(  Pack * pack ){}
void on_MISSION_REQUEST_INT(  Pack * pack ){}
void on_REQUEST_DATA_STREAM(  Pack * pack ){}
void on_COLLISION(  Pack * pack ){}
void on_FOLLOW_TARGET(  Pack * pack ){}
void on_SET_POSITION_TARGET_LOCAL_NED(  Pack * pack ){}
void on_GLOBAL_POSITION_INT_COV(  Pack * pack ){}
void on_ALTITUDE(  Pack * pack ){}
void on_SAFETY_SET_ALLOWED_AREA(  Pack * pack ){}
void on_GPS_RTK(  Pack * pack ){}
void on_HIGH_LATENCY(  Pack * pack ){}
void on_SAFETY_ALLOWED_AREA(  Pack * pack ){}
void on_VISION_POSITION_ESTIMATE(  Pack * pack ){}
void on_HIL_OPTICAL_FLOW(  Pack * pack ){}
void on_VIBRATION(  Pack * pack ){}
void on_PARAM_MAP_RC(  Pack * pack ){}
void on_LOG_REQUEST_DATA(  Pack * pack ){}
*/
			static Meta const *dispatch(Receiver *receiver, size_t id, Pack *pack) {
				CHANNEL *channel = CHANNEL::from(receiver);
				using namespace org::unirail;
				switch (id) {
					default: return nullptr;
					case 212:return pack ? channel->on_MISSION_SET_CURRENT(pack), nullptr : &com::company::demo::MISSION_SET_CURRENT::meta;
					case 23:return pack ? channel->on_RC_CHANNELS(pack), nullptr : &com::company::demo::RC_CHANNELS::meta;
					case 52:return pack ? channel->on_GPS_INJECT_DATA(pack), nullptr : &com::company::demo::GPS_INJECT_DATA::meta;
					case 15:return pack ? channel->on_VFR_HUD(pack), nullptr : &com::company::demo::VFR_HUD::meta;
					case 170:return pack ? channel->on_ENCAPSULATED_DATA(pack), nullptr : &com::company::demo::ENCAPSULATED_DATA::meta;
					case 3:return pack ? channel->on_ACTUATOR_CONTROL_TARGET(pack), nullptr : &com::company::demo::ACTUATOR_CONTROL_TARGET::meta;
					case 219:return pack ? channel->on_MANUAL_SETPOINT(pack), nullptr : &com::company::demo::MANUAL_SETPOINT::meta;
					case 158:return pack ? channel->on_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(pack), nullptr : &com::company::demo::LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET::meta;
					case 8:return pack ? channel->on_NAMED_VALUE_FLOAT(pack), nullptr : &com::company::demo::NAMED_VALUE_FLOAT::meta;
					case 34:return pack ? channel->on_ALTITUDE(pack), nullptr : &com::company::demo::ALTITUDE::meta;
					case 149:return pack ? channel->on_DATA_TRANSMISSION_HANDSHAKE(pack), nullptr : &com::company::demo::DATA_TRANSMISSION_HANDSHAKE::meta;
					case 193:return pack ? channel->on_MISSION_CLEAR_ALL(pack), nullptr : &com::company::demo::MISSION_CLEAR_ALL::meta;
					case 139:return pack ? channel->on_PING33(pack), nullptr : &com::company::demo::PING33::meta;
					case 45:return pack ? channel->on_COLLISION(pack), nullptr : &com::company::demo::COLLISION::meta;
					case 46:return pack ? channel->on_TIMESYNC(pack), nullptr : &com::company::demo::TIMESYNC::meta;
					case 215:return pack ? channel->on_FLIGHT_INFORMATION(pack), nullptr : &com::company::demo::FLIGHT_INFORMATION::meta;
					case 106:return pack ? channel->on_ATTITUDE_TARGET(pack), nullptr : &com::company::demo::ATTITUDE_TARGET::meta;
					case 126:return pack ? channel->on_DEBUG(pack), nullptr : &com::company::demo::DEBUG::meta;
					case 27:return pack ? channel->on_FILE_TRANSFER_PROTOCOL(pack), nullptr : &com::company::demo::FILE_TRANSFER_PROTOCOL::meta;
					case 71:return pack ? channel->on_ATTITUDE_QUATERNION(pack), nullptr : &com::company::demo::ATTITUDE_QUATERNION::meta;
					case 107:return pack ? channel->on_RADIO_STATUS(pack), nullptr : &com::company::demo::RADIO_STATUS::meta;
					case 116:return pack ? channel->on_HIL_OPTICAL_FLOW(pack), nullptr : &com::company::demo::HIL_OPTICAL_FLOW::meta;
					case 169:return pack ? channel->on_HIL_SENSOR(pack), nullptr : &com::company::demo::HIL_SENSOR::meta;
					case 124:return pack ? channel->on_STATUSTEXT(pack), nullptr : &com::company::demo::STATUSTEXT::meta;
					case 74:return pack ? channel->on_SET_ATTITUDE_TARGET(pack), nullptr : &com::company::demo::SET_ATTITUDE_TARGET::meta;
					case 31:return pack ? channel->on_DATA_STREAM(pack), nullptr : &com::company::demo::DATA_STREAM::meta;
					case 111:return pack ? channel->on_BATTERY_STATUS(pack), nullptr : &com::company::demo::BATTERY_STATUS::meta;
					case 174:return pack ? channel->on_V2_EXTENSION(pack), nullptr : &com::company::demo::V2_EXTENSION::meta;
					case 218:return pack ? channel->on_SET_POSITION_TARGET_GLOBAL_INT(pack), nullptr : &com::company::demo::SET_POSITION_TARGET_GLOBAL_INT::meta;
					case 48:return pack ? channel->on_GPS_STATUS(pack), nullptr : &com::company::demo::GPS_STATUS::meta;
					case 213:return pack ? channel->on_GPS2_RAW(pack), nullptr : &com::company::demo::GPS2_RAW::meta;
					case 87:return pack ? channel->on_HIGH_LATENCY(pack), nullptr : &com::company::demo::HIGH_LATENCY::meta;
					case 167:return pack ? channel->on_COMMAND_INT(pack), nullptr : &com::company::demo::COMMAND_INT::meta;
					case 78:return pack ? channel->on_ADSB_VEHICLE(pack), nullptr : &com::company::demo::ADSB_VEHICLE::meta;
					case 154:return pack ? channel->on_CHANGE_OPERATOR_CONTROL(pack), nullptr : &com::company::demo::CHANGE_OPERATOR_CONTROL::meta;
					case 163:return pack ? channel->on_RAW_IMU(pack), nullptr : &com::company::demo::RAW_IMU::meta;
					case 56:return pack ? channel->on_GPS_RAW_INT(pack), nullptr : &com::company::demo::GPS_RAW_INT::meta;
					case 18:return pack ? channel->on_SCALED_PRESSURE(pack), nullptr : &com::company::demo::SCALED_PRESSURE::meta;
					case 160:return pack ? channel->on_WIND_COV(pack), nullptr : &com::company::demo::WIND_COV::meta;
					case 173:return pack ? channel->on_TERRAIN_DATA(pack), nullptr : &com::company::demo::TERRAIN_DATA::meta;
					case 19:return pack ? channel->on_RAW_PRESSURE(pack), nullptr : &com::company::demo::RAW_PRESSURE::meta;
					case 108:return pack ? channel->on_SIM_STATE(pack), nullptr : &com::company::demo::SIM_STATE::meta;
					case 201:return pack ? channel->on_NAV_CONTROLLER_OUTPUT(pack), nullptr : &com::company::demo::NAV_CONTROLLER_OUTPUT::meta;
					case 2:return pack ? channel->on_SCALED_IMU3(pack), nullptr : &com::company::demo::SCALED_IMU3::meta;
					case 132:return pack ? channel->on_SYS_STATUS(pack), nullptr : &com::company::demo::SYS_STATUS::meta;
					case 136:return pack ? channel->on_PARAM_VALUE(pack), nullptr : &com::company::demo::PARAM_VALUE::meta;
					case 137:return pack ? channel->on_HIGHRES_IMU(pack), nullptr : &com::company::demo::HIGHRES_IMU::meta;
					case 6:return pack ? channel->on_GLOBAL_POSITION_INT_COV(pack), nullptr : &com::company::demo::GLOBAL_POSITION_INT_COV::meta;
					case 41:return pack ? channel->on_MESSAGE_INTERVAL(pack), nullptr : &com::company::demo::MESSAGE_INTERVAL::meta;
					case 129:return pack ? channel->on_POSITION_TARGET_LOCAL_NED(pack), nullptr : &com::company::demo::POSITION_TARGET_LOCAL_NED::meta;
					case 50:return pack ? channel->on_MISSION_COUNT(pack), nullptr : &com::company::demo::MISSION_COUNT::meta;
					case 200:return pack ? channel->on_ATT_POS_MOCAP(pack), nullptr : &com::company::demo::ATT_POS_MOCAP::meta;
					case 210:return pack ? channel->on_HOME_POSITION(pack), nullptr : &com::company::demo::HOME_POSITION::meta;
					case 148:return pack ? channel->on_RC_CHANNELS_RAW(pack), nullptr : &com::company::demo::RC_CHANNELS_RAW::meta;
					case 202:return pack ? channel->on_OPTICAL_FLOW_RAD(pack), nullptr : &com::company::demo::OPTICAL_FLOW_RAD::meta;
					case 133:return pack ? channel->on_POSITION_TARGET_GLOBAL_INT(pack), nullptr : &com::company::demo::POSITION_TARGET_GLOBAL_INT::meta;
					case 7:return pack ? channel->on_SET_MODE(pack), nullptr : &com::company::demo::SET_MODE::meta;
					case 58:return pack ? channel->on_STORAGE_INFORMATION(pack), nullptr : &com::company::demo::STORAGE_INFORMATION::meta;
					case 25:return pack ? channel->on_MISSION_REQUEST_LIST(pack), nullptr : &com::company::demo::MISSION_REQUEST_LIST::meta;
					case 24:return pack ? channel->on_SAFETY_SET_ALLOWED_AREA(pack), nullptr : &com::company::demo::SAFETY_SET_ALLOWED_AREA::meta;
					case 184:return pack ? channel->on_HIL_RC_INPUTS_RAW(pack), nullptr : &com::company::demo::HIL_RC_INPUTS_RAW::meta;
					case 206:return pack ? channel->on_MISSION_REQUEST_PARTIAL_LIST(pack), nullptr : &com::company::demo::MISSION_REQUEST_PARTIAL_LIST::meta;
					case 85:return pack ? channel->on_MISSION_ACK(pack), nullptr : &com::company::demo::MISSION_ACK::meta;
					case 216:return pack ? channel->on_CAMERA_CAPTURE_STATUS(pack), nullptr : &com::company::demo::CAMERA_CAPTURE_STATUS::meta;
					case 181:return pack ? channel->on_CAMERA_SETTINGS(pack), nullptr : &com::company::demo::CAMERA_SETTINGS::meta;
					case 4:return pack ? channel->on_LOG_ERASE(pack), nullptr : &com::company::demo::LOG_ERASE::meta;
					case 147:return pack ? channel->on_MISSION_REQUEST(pack), nullptr : &com::company::demo::MISSION_REQUEST::meta;
					case 55:return pack ? channel->on_RC_CHANNELS_OVERRIDE(pack), nullptr : &com::company::demo::RC_CHANNELS_OVERRIDE::meta;
					case 82:return pack ? channel->on_HIL_CONTROLS(pack), nullptr : &com::company::demo::HIL_CONTROLS::meta;
					case 156:return pack ? channel->on_POWER_STATUS(pack), nullptr : &com::company::demo::POWER_STATUS::meta;
					case 121:return pack ? channel->on_COMMAND_ACK(pack), nullptr : &com::company::demo::COMMAND_ACK::meta;
					case 103:return pack ? channel->on_VIBRATION(pack), nullptr : &com::company::demo::VIBRATION::meta;
					case 182:return pack ? channel->on_ATTITUDE_QUATERNION_COV(pack), nullptr : &com::company::demo::ATTITUDE_QUATERNION_COV::meta;
					case 176:return pack ? channel->on_EXTENDED_SYS_STATE(pack), nullptr : &com::company::demo::EXTENDED_SYS_STATE::meta;
					case 209:return pack ? channel->on_SET_POSITION_TARGET_LOCAL_NED(pack), nullptr : &com::company::demo::SET_POSITION_TARGET_LOCAL_NED::meta;
					case 180:return pack ? channel->on_LOCAL_POSITION_NED_COV(pack), nullptr : &com::company::demo::LOCAL_POSITION_NED_COV::meta;
					case 189:return pack ? channel->on_MISSION_CURRENT(pack), nullptr : &com::company::demo::MISSION_CURRENT::meta;
					case 145:return pack ? channel->on_MISSION_WRITE_PARTIAL_LIST(pack), nullptr : &com::company::demo::MISSION_WRITE_PARTIAL_LIST::meta;
					case 29:return pack ? channel->on_PARAM_MAP_RC(pack), nullptr : &com::company::demo::PARAM_MAP_RC::meta;
					case 178:return pack ? channel->on_SCALED_IMU2(pack), nullptr : &com::company::demo::SCALED_IMU2::meta;
					case 61:return pack ? channel->on_DISTANCE_SENSOR(pack), nullptr : &com::company::demo::DISTANCE_SENSOR::meta;
					case 60:return pack ? channel->on_AUTOPILOT_VERSION(pack), nullptr : &com::company::demo::AUTOPILOT_VERSION::meta;
					case 120:return pack ? channel->on_RC_CHANNELS_SCALED(pack), nullptr : &com::company::demo::RC_CHANNELS_SCALED::meta;
					case 146:return pack ? channel->on_BUTTON_CHANGE(pack), nullptr : &com::company::demo::BUTTON_CHANGE::meta;
					case 53:return pack ? channel->on_SET_GPS_GLOBAL_ORIGIN(pack), nullptr : &com::company::demo::SET_GPS_GLOBAL_ORIGIN::meta;
					case 152:return pack ? channel->on_TERRAIN_CHECK(pack), nullptr : &com::company::demo::TERRAIN_CHECK::meta;
					case 77:return pack ? channel->on_SET_HOME_POSITION(pack), nullptr : &com::company::demo::SET_HOME_POSITION::meta;
					case 62:return pack ? channel->on_CHANGE_OPERATOR_CONTROL_ACK(pack), nullptr : &com::company::demo::CHANGE_OPERATOR_CONTROL_ACK::meta;
					case 59:return pack ? channel->on_MISSION_ITEM_INT(pack), nullptr : &com::company::demo::MISSION_ITEM_INT::meta;
					case 130:return pack ? channel->on_SCALED_PRESSURE3(pack), nullptr : &com::company::demo::SCALED_PRESSURE3::meta;
					case 39:return pack ? channel->on_FOLLOW_TARGET(pack), nullptr : &com::company::demo::FOLLOW_TARGET::meta;
					case 140:return pack ? channel->on_HIL_STATE(pack), nullptr : &com::company::demo::HIL_STATE::meta;
					case 35:return pack ? channel->on_MISSION_ITEM(pack), nullptr : &com::company::demo::MISSION_ITEM::meta;
					case 86:return pack ? channel->on_TERRAIN_REPORT(pack), nullptr : &com::company::demo::TERRAIN_REPORT::meta;
					case 92:return pack ? channel->on_TERRAIN_REQUEST(pack), nullptr : &com::company::demo::TERRAIN_REQUEST::meta;
					case 195:return pack ? channel->on_SCALED_IMU(pack), nullptr : &com::company::demo::SCALED_IMU::meta;
					case 79:return pack ? channel->on_SERVO_OUTPUT_RAW(pack), nullptr : &com::company::demo::SERVO_OUTPUT_RAW::meta;
					case 101:return pack ? channel->on_COMMAND_LONG(pack), nullptr : &com::company::demo::COMMAND_LONG::meta;
					case 72:return pack ? channel->on_LOG_REQUEST_DATA(pack), nullptr : &com::company::demo::LOG_REQUEST_DATA::meta;
					case 179:return pack ? channel->on_SAFETY_ALLOWED_AREA(pack), nullptr : &com::company::demo::SAFETY_ALLOWED_AREA::meta;
					case 98:return pack ? channel->on_REQUEST_DATA_STREAM(pack), nullptr : &com::company::demo::REQUEST_DATA_STREAM::meta;
					case 13:return pack ? channel->on_OPTICAL_FLOW(pack), nullptr : &com::company::demo::OPTICAL_FLOW::meta;
					case 38:return pack ? channel->on_ESTIMATOR_STATUS(pack), nullptr : &com::company::demo::ESTIMATOR_STATUS::meta;
					case 95:return pack ? channel->on_AUTH_KEY(pack), nullptr : &com::company::demo::AUTH_KEY::meta;
					case 110:return pack ? channel->on_GLOBAL_VISION_POSITION_ESTIMATE(pack), nullptr : &com::company::demo::GLOBAL_VISION_POSITION_ESTIMATE::meta;
					case 37:return pack ? channel->on_LOG_REQUEST_LIST(pack), nullptr : &com::company::demo::LOG_REQUEST_LIST::meta;
					case 162:return pack ? channel->on_GLOBAL_POSITION_INT(pack), nullptr : &com::company::demo::GLOBAL_POSITION_INT::meta;
					case 135:return pack ? channel->on_VICON_POSITION_ESTIMATE(pack), nullptr : &com::company::demo::VICON_POSITION_ESTIMATE::meta;
					case 28:return pack ? channel->on_SwitchModeCommand(), nullptr : &com::company::demo::SwitchModeCommand::meta;
					case 151:return pack ? channel->on_SCALED_PRESSURE2(pack), nullptr : &com::company::demo::SCALED_PRESSURE2::meta;
					case 172:return pack ? channel->on_LANDING_TARGET(pack), nullptr : &com::company::demo::LANDING_TARGET::meta;
					case 203:return pack ? channel->on_PLAY_TUNE(pack), nullptr : &com::company::demo::PLAY_TUNE::meta;
					case 47:return pack ? channel->on_PARAM_REQUEST_LIST(pack), nullptr : &com::company::demo::PARAM_REQUEST_LIST::meta;
					case 73:return pack ? channel->on_GPS_INPUT(pack), nullptr : &com::company::demo::GPS_INPUT::meta;
					case 88:return pack ? channel->on_GPS_RTCM_DATA(pack), nullptr : &com::company::demo::GPS_RTCM_DATA::meta;
					case 161:return pack ? channel->on_LOG_ENTRY(pack), nullptr : &com::company::demo::LOG_ENTRY::meta;
					case 168:return pack ? channel->on_HIL_GPS(pack), nullptr : &com::company::demo::HIL_GPS::meta;
					case 191:return pack ? channel->on_CAMERA_TRIGGER(pack), nullptr : &com::company::demo::CAMERA_TRIGGER::meta;
					case 207:return pack ? channel->on_CONTROL_SYSTEM_STATE(pack), nullptr : &com::company::demo::CONTROL_SYSTEM_STATE::meta;
					case 188:return pack ? channel->on_MISSION_REQUEST_INT(pack), nullptr : &com::company::demo::MISSION_REQUEST_INT::meta;
					case 94:return pack ? channel->on_SET_ACTUATOR_CONTROL_TARGET(pack), nullptr : &com::company::demo::SET_ACTUATOR_CONTROL_TARGET::meta;
					case 187:return pack ? channel->on_DEBUG_VECT(pack), nullptr : &com::company::demo::DEBUG_VECT::meta;
					case 204:return pack ? channel->on_LOG_DATA(pack), nullptr : &com::company::demo::LOG_DATA::meta;
					case 134:return pack ? channel->on_ATTITUDE(pack), nullptr : &com::company::demo::ATTITUDE::meta;
					case 10:return pack ? channel->on_CAMERA_IMAGE_CAPTURED(pack), nullptr : &com::company::demo::CAMERA_IMAGE_CAPTURED::meta;
					case 131:return pack ? channel->on_LOCAL_POSITION_NED(pack), nullptr : &com::company::demo::LOCAL_POSITION_NED::meta;
					case 89:return pack ? channel->on_GPS_RTK(pack), nullptr : &com::company::demo::GPS_RTK::meta;
					case 30:return pack ? channel->on_MEMORY_VECT(pack), nullptr : &com::company::demo::MEMORY_VECT::meta;
					case 42:return pack ? channel->on_VISION_SPEED_ESTIMATE(pack), nullptr : &com::company::demo::VISION_SPEED_ESTIMATE::meta;
					case 199:return pack ? channel->on_HIL_ACTUATOR_CONTROLS(pack), nullptr : &com::company::demo::HIL_ACTUATOR_CONTROLS::meta;
					case 125:return pack ? channel->on_HEARTBEAT(pack), nullptr : &com::company::demo::HEARTBEAT::meta;
					case 205:return pack ? channel->on_SETUP_SIGNING(pack), nullptr : &com::company::demo::SETUP_SIGNING::meta;
					case 21:return pack ? channel->on_NAMED_VALUE_INT(pack), nullptr : &com::company::demo::NAMED_VALUE_INT::meta;
					case 157:return pack ? channel->on_CAMERA_INFORMATION(pack), nullptr : &com::company::demo::CAMERA_INFORMATION::meta;
					case 122:return pack ? channel->on_PING(pack), nullptr : &com::company::demo::PING::meta;
					case 91:return pack ? channel->on_GPS2_RTK(pack), nullptr : &com::company::demo::GPS2_RTK::meta;
					case 81:return pack ? channel->on_MISSION_ITEM_REACHED(pack), nullptr : &com::company::demo::MISSION_ITEM_REACHED::meta;
					case 67:return pack ? channel->on_RESOURCE_REQUEST(pack), nullptr : &com::company::demo::RESOURCE_REQUEST::meta;
					case 9:return pack ? channel->on_SYSTEM_TIME(pack), nullptr : &com::company::demo::SYSTEM_TIME::meta;
					case 196:return pack ? channel->on_HIL_STATE_QUATERNION(pack), nullptr : &com::company::demo::HIL_STATE_QUATERNION::meta;
					case 123:return pack ? channel->on_PARAM_SET(pack), nullptr : &com::company::demo::PARAM_SET::meta;
					case 16:return pack ? channel->on_VISION_POSITION_ESTIMATE(pack), nullptr : &com::company::demo::VISION_POSITION_ESTIMATE::meta;
					case 185:return pack ? channel->on_GPS_GLOBAL_ORIGIN(pack), nullptr : &com::company::demo::GPS_GLOBAL_ORIGIN::meta;
					case 102:return pack ? channel->on_LOG_REQUEST_END(pack), nullptr : &com::company::demo::LOG_REQUEST_END::meta;
					case 99:return pack ? channel->on_SERIAL_CONTROL(pack), nullptr : &com::company::demo::SERIAL_CONTROL::meta;
					case 54:return pack ? channel->on_MANUAL_CONTROL(pack), nullptr : &com::company::demo::MANUAL_CONTROL::meta;
					case 166:return pack ? channel->on_PARAM_REQUEST_READ(pack), nullptr : &com::company::demo::PARAM_REQUEST_READ::meta;
					
				}
			}
			
			/*Push received packs bytes to the channel*/
			void bytes_into_packs(uint8_t *src, size_t src_bytes) { ::receive(src, src_bytes, &receiver); }
			
			bool send(FOLLOW_TARGET &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(ADSB_VEHICLE &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(MESSAGE_INTERVAL &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(EKF_STATUS_REPORT &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(ESTIMATOR_STATUS &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(HWSTATUS &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(TIMESYNC &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(PARAM_EXT_REQUEST_LIST &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(BUTTON_CHANGE &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(UAVCAN_NODE_STATUS &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(COLLISION &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(GIMBAL_TORQUE_CMD_REPORT &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(ALTITUDE &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(HIL_STATE_QUATERNION &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(SENSOR_OFFSETS &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(STORAGE_INFORMATION &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(CAMERA_INFORMATION &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(DEVICE_OP_WRITE_REPLY &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(TERRAIN_DATA &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(GIMBAL_CONTROL &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(VIDEO_STREAM_INFORMATION &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(AHRS &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(DEBUG &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(CAMERA_IMAGE_CAPTURED &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(LOG_ENTRY &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(ACTUATOR_CONTROL_TARGET &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(HIGH_LATENCY &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(HOME_POSITION &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(FENCE_STATUS &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(REMOTE_LOG_BLOCK_STATUS &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(OBSTACLE_DISTANCE &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(GPS2_RAW &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(MEMORY_VECT &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(PARAM_EXT_REQUEST_READ &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(HIL_SENSOR &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(SETUP_SIGNING &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(GPS_RTK &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(UAVIONIX_ADSB_OUT_CFG &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(LANDING_TARGET &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(SET_ACTUATOR_CONTROL_TARGET &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(CONTROL_SYSTEM_STATE &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(DATA32 &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(PING33 &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(RALLY_POINT &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(ADAP_TUNING &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(VIBRATION &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(PARAM_EXT_VALUE &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(BATTERY2 &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(LIMITS_STATUS &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(CAMERA_FEEDBACK &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(HIL_GPS &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(FENCE_FETCH_POINT &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(RADIO &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(AIRSPEED_AUTOCAL &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(ATT_POS_MOCAP &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(STATUSTEXT &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(GOPRO_GET_REQUEST &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(CAMERA_CAPTURE_STATUS &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(ENCAPSULATED_DATA &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(GPS_INPUT &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(COMPASSMOT_STATUS &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(LOG_REQUEST_DATA &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(CAMERA_STATUS &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(CAMERA_SETTINGS &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(DEVICE_OP_READ_REPLY &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(DIGICAM_CONTROL &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(NAMED_VALUE_FLOAT &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(GOPRO_HEARTBEAT &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(AHRS2 &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(LOG_ERASE &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(TERRAIN_REQUEST &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(MOUNT_STATUS &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(PID_TUNING &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(OPTICAL_FLOW_RAD &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(LOG_DATA &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(AHRS3 &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(VICON_POSITION_ESTIMATE &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(GPS2_RTK &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(MAG_CAL_REPORT &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(LOG_REQUEST_LIST &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(MOUNT_CONFIGURE &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(V2_EXTENSION &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(POWER_STATUS &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(REMOTE_LOG_DATA_BLOCK &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(LOGGING_DATA_ACKED &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(TERRAIN_CHECK &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(TERRAIN_REPORT &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(SET_HOME_POSITION &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send_SwitchModeCommand() { return CHANNEL::push_sending_pack(&transmitter, new_pack(&com::company::demo::SwitchModeCommand::meta)); }
			
			bool send(SCALED_IMU3 &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(MOUNT_CONTROL &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(LED_CONTROL &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(SIM_STATE &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(WIFI_CONFIG_AP &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(DATA96 &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(FLIGHT_INFORMATION &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(MEMINFO &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(LOGGING_ACK &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(VISION_SPEED_ESTIMATE &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(DEBUG_VECT &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(CAMERA_TRIGGER &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(LOG_REQUEST_END &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(GOPRO_SET_RESPONSE &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(PROTOCOL_VERSION &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(RALLY_FETCH_POINT &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(BATTERY_STATUS &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(MOUNT_ORIENTATION &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(SERIAL_CONTROL &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(PARAM_EXT_SET &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(AUTOPILOT_VERSION &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(SIMSTATE &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(SET_VIDEO_STREAM_SETTINGS &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(PLAY_TUNE &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(DIGICAM_CONFIGURE &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(SCALED_PRESSURE3 &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(PARAM_EXT_ACK &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(UAVCAN_NODE_INFO &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(DATA16 &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(SET_MAG_OFFSETS &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(SCALED_IMU2 &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(AP_ADC &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(WIND &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(AUTOPILOT_VERSION_REQUEST &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(DATA_TRANSMISSION_HANDSHAKE &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(DATA64 &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(GIMBAL_REPORT &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(DEVICE_OP_WRITE &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(DISTANCE_SENSOR &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(HIL_OPTICAL_FLOW &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(SCALED_PRESSURE2 &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(WIND_COV &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(GOPRO_SET_REQUEST &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(VISION_POSITION_DELTA &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(LOGGING_DATA &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(DEVICE_OP_READ &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(MAG_CAL_PROGRESS &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(HIGHRES_IMU &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(EXTENDED_SYS_STATE &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(UAVIONIX_ADSB_OUT_DYNAMIC &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(GOPRO_GET_RESPONSE &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(GPS_INJECT_DATA &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(NAMED_VALUE_INT &src) {
				return src.data_.base.pack && CHANNEL::push_sending_pack(&transmitter, src.data_.base.pack) ? src.data_.base.pack = nullptr, true : false;
			}
			
			bool send(RPM &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(GPS_RTCM_DATA &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(FILE_TRANSFER_PROTOCOL &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(RANGEFINDER &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(RADIO_STATUS &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(FENCE_POINT &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			bool send(RESOURCE_REQUEST &src) {
				return src.pack_ && CHANNEL::push_sending_pack(&transmitter, src.pack_) ? src.pack_ = nullptr, true : false;
			}
			
			struct NEW {
				/**
*current motion information from a designated system */
				static struct FOLLOW_TARGET FOLLOW_TARGET() {
					auto pack = new_pack(&com::company::demo::FOLLOW_TARGET::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*The location and information of an ADSB vehicle */
				static struct ADSB_VEHICLE ADSB_VEHICLE(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::ADSB_VEHICLE::meta), cur)};
				}
				
				/**
*This interface replaces DATA_STREAM */
				static struct MESSAGE_INTERVAL MESSAGE_INTERVAL() {
					auto pack = new_pack(&com::company::demo::MESSAGE_INTERVAL::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*EKF Status message including flags and variances */
				static struct EKF_STATUS_REPORT EKF_STATUS_REPORT(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::EKF_STATUS_REPORT::meta), cur)};
				}
				
				/**
*Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message
*				 is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS
*				 enum definition for further information. The innovaton test ratios show the magnitude of the sensor innovation
*				 divided by the innovation check threshold. Under normal operation the innovaton test ratios should be
*				 below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation
*				 and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation
*				 test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should
*				 be optional and controllable by the user */
				static struct ESTIMATOR_STATUS ESTIMATOR_STATUS(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::ESTIMATOR_STATUS::meta), cur)};
				}
				
				/**
*Status of key hardware */
				static struct HWSTATUS HWSTATUS() {
					auto pack = new_pack(&com::company::demo::HWSTATUS::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Time synchronization message. */
				static struct TIMESYNC TIMESYNC() {
					auto pack = new_pack(&com::company::demo::TIMESYNC::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Request all parameters of this component. After this request, all parameters are emitted. */
				static struct PARAM_EXT_REQUEST_LIST PARAM_EXT_REQUEST_LIST() {
					auto pack = new_pack(&com::company::demo::PARAM_EXT_REQUEST_LIST::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Report button state change */
				static struct BUTTON_CHANGE BUTTON_CHANGE() {
					auto pack = new_pack(&com::company::demo::BUTTON_CHANGE::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*General status information of an UAVCAN node. Please refer to the definition of the UAVCAN message "uavcan.protocol.NodeStatus"
*				 for the background information. The UAVCAN specification is available at http:uavcan.org */
				static struct UAVCAN_NODE_STATUS UAVCAN_NODE_STATUS(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::UAVCAN_NODE_STATUS::meta), cur)};
				}
				
				/**
*Information about a potential collision */
				static struct COLLISION COLLISION(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::COLLISION::meta), cur)};
				}
				
				/**
*100 Hz gimbal torque command telemetry */
				static struct GIMBAL_TORQUE_CMD_REPORT GIMBAL_TORQUE_CMD_REPORT() {
					auto pack = new_pack(&com::company::demo::GIMBAL_TORQUE_CMD_REPORT::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*The current system altitude. */
				static struct ALTITUDE ALTITUDE() {
					auto pack = new_pack(&com::company::demo::ALTITUDE::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful
*				 for high throughput applications such as hardware in the loop simulations */
				static struct HIL_STATE_QUATERNION HIL_STATE_QUATERNION() {
					auto pack = new_pack(&com::company::demo::HIL_STATE_QUATERNION::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Offsets and calibrations values for hardware sensors. This makes it easier to debug the calibration process */
				static struct SENSOR_OFFSETS SENSOR_OFFSETS() {
					auto pack = new_pack(&com::company::demo::SENSOR_OFFSETS::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*WIP: Information about a storage medium. */
				static struct STORAGE_INFORMATION STORAGE_INFORMATION() {
					auto pack = new_pack(&com::company::demo::STORAGE_INFORMATION::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*WIP: Information about a camera */
				static struct CAMERA_INFORMATION CAMERA_INFORMATION(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::CAMERA_INFORMATION::meta), cur)};
				}
				
				/**
*Write registers reply */
				static struct DEVICE_OP_WRITE_REPLY DEVICE_OP_WRITE_REPLY() {
					auto pack = new_pack(&com::company::demo::DEVICE_OP_WRITE_REPLY::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUES */
				static struct TERRAIN_DATA TERRAIN_DATA() {
					auto pack = new_pack(&com::company::demo::TERRAIN_DATA::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Control message for rate gimbal */
				static struct GIMBAL_CONTROL GIMBAL_CONTROL() {
					auto pack = new_pack(&com::company::demo::GIMBAL_CONTROL::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*WIP: Information about video stream */
				static struct VIDEO_STREAM_INFORMATION VIDEO_STREAM_INFORMATION(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::VIDEO_STREAM_INFORMATION::meta), cur)};
				}
				
				/**
*Status of DCM attitude estimator */
				static struct AHRS AHRS() {
					auto pack = new_pack(&com::company::demo::AHRS::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Send a debug value. The index is used to discriminate between values. These values show up in the plot
*				 of QGroundControl as DEBUG N */
				static struct DEBUG DEBUG() {
					auto pack = new_pack(&com::company::demo::DEBUG::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Information about a captured image */
				static struct CAMERA_IMAGE_CAPTURED CAMERA_IMAGE_CAPTURED(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::CAMERA_IMAGE_CAPTURED::meta), cur)};
				}
				
				/**
*Reply to LOG_REQUEST_LIST */
				static struct LOG_ENTRY LOG_ENTRY() {
					auto pack = new_pack(&com::company::demo::LOG_ENTRY::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Set the vehicle attitude and body angular rates. */
				static struct ACTUATOR_CONTROL_TARGET ACTUATOR_CONTROL_TARGET() {
					auto pack = new_pack(&com::company::demo::ACTUATOR_CONTROL_TARGET::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Message appropriate for high latency connections like Iridium */
				static struct HIGH_LATENCY HIGH_LATENCY(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::HIGH_LATENCY::meta), cur)};
				}
				
				/**
*This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system
*				 will return to and land on. The position is set automatically by the system during the takeoff in case
*				 it was not explicitely set by the operator before or after. The position the system will return to and
*				 land on. The global and local positions encode the position in the respective coordinate frames, while
*				 the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading
*				 and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes
*				 the point to which the system should fly in normal flight mode and then perform a landing sequence along
*				 the vector */
				static struct HOME_POSITION HOME_POSITION(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::HOME_POSITION::meta), cur)};
				}
				
				/**
*Status of geo-fencing. Sent in extended status stream when fencing enabled */
				static struct FENCE_STATUS FENCE_STATUS(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::FENCE_STATUS::meta), cur)};
				}
				
				/**
*Send Status of each log block that autopilot board might have sent */
				static struct REMOTE_LOG_BLOCK_STATUS REMOTE_LOG_BLOCK_STATUS(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::REMOTE_LOG_BLOCK_STATUS::meta), cur)};
				}
				
				/**
*Obstacle distances in front of the sensor, starting from the left in increment degrees to the right */
				static struct OBSTACLE_DISTANCE OBSTACLE_DISTANCE(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::OBSTACLE_DISTANCE::meta), cur)};
				}
				
				/**
*Second GPS data. Coordinate frame is right-handed, Z-axis up (GPS frame). */
				static struct GPS2_RAW GPS2_RAW(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::GPS2_RAW::meta), cur)};
				}
				
				/**
*Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient
*				 way for testing new messages and getting experimental debug output */
				static struct MEMORY_VECT MEMORY_VECT() {
					auto pack = new_pack(&com::company::demo::MEMORY_VECT::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Request to read the value of a parameter with the either the param_id string id or param_index. */
				static struct PARAM_EXT_REQUEST_READ PARAM_EXT_REQUEST_READ(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::PARAM_EXT_REQUEST_READ::meta), cur)};
				}
				
				/**
*The IMU readings in SI units in NED body frame */
				static struct HIL_SENSOR HIL_SENSOR() {
					auto pack = new_pack(&com::company::demo::HIL_SENSOR::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Setup a MAVLink2 signing key. If called with secret_key of all zero and zero initial_timestamp will disable
*				 signin */
				static struct SETUP_SIGNING SETUP_SIGNING() {
					auto pack = new_pack(&com::company::demo::SETUP_SIGNING::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */
				static struct GPS_RTK GPS_RTK() {
					auto pack = new_pack(&com::company::demo::GPS_RTK::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Static data to configure the ADS-B transponder (send within 10 sec of a POR and every 10 sec thereafter */
				static struct UAVIONIX_ADSB_OUT_CFG UAVIONIX_ADSB_OUT_CFG(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::UAVIONIX_ADSB_OUT_CFG::meta), cur)};
				}
				
				/**
*The location of a landing area captured from a downward facing camera */
				static struct LANDING_TARGET LANDING_TARGET(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::LANDING_TARGET::meta), cur)};
				}
				
				/**
*Set the vehicle attitude and body angular rates. */
				static struct SET_ACTUATOR_CONTROL_TARGET SET_ACTUATOR_CONTROL_TARGET() {
					auto pack = new_pack(&com::company::demo::SET_ACTUATOR_CONTROL_TARGET::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*The smoothed, monotonic system state used to feed the control loops of the system. */
				static struct CONTROL_SYSTEM_STATE CONTROL_SYSTEM_STATE() {
					auto pack = new_pack(&com::company::demo::CONTROL_SYSTEM_STATE::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Data packet, size 32 */
				static struct DATA32 DATA32() {
					auto pack = new_pack(&com::company::demo::DATA32::meta);
					return {pack, *pack->bytes};
				}
				
				static struct PING33 PING33(Cursor cur[])  //switch blink mode user command bytes
				
				{
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::PING33::meta), cur)};
				}
				
				/**
*GCS */
				static struct RALLY_POINT RALLY_POINT(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::RALLY_POINT::meta), cur)};
				}
				
				/**
*Adaptive Controller tuning information */
				static struct ADAP_TUNING ADAP_TUNING(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::ADAP_TUNING::meta), cur)};
				}
				
				/**
*Vibration levels and accelerometer clipping */
				static struct VIBRATION VIBRATION() {
					auto pack = new_pack(&com::company::demo::VIBRATION::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Emit the value of a parameter. The inclusion of param_count and param_index in the message allows the
*				 recipient to keep track of received parameters and allows them to re-request missing parameters after
*				 a loss or timeout */
				static struct PARAM_EXT_VALUE PARAM_EXT_VALUE(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::PARAM_EXT_VALUE::meta), cur)};
				}
				
				/**
*2nd Battery status */
				static struct BATTERY2 BATTERY2() {
					auto pack = new_pack(&com::company::demo::BATTERY2::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Status of AP_Limits. Sent in extended status stream when AP_Limits is enabled */
				static struct LIMITS_STATUS LIMITS_STATUS(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::LIMITS_STATUS::meta), cur)};
				}
				
				/**
*Camera Capture Feedback */
				static struct CAMERA_FEEDBACK CAMERA_FEEDBACK(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::CAMERA_FEEDBACK::meta), cur)};
				}
				
				/**
*The global position, as returned by the Global Positioning System (GPS). This is
*				 NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame). */
				static struct HIL_GPS HIL_GPS() {
					auto pack = new_pack(&com::company::demo::HIL_GPS::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Request a current fence point from MAV */
				static struct FENCE_FETCH_POINT FENCE_FETCH_POINT() {
					auto pack = new_pack(&com::company::demo::FENCE_FETCH_POINT::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Status generated by radio */
				static struct RADIO RADIO() {
					auto pack = new_pack(&com::company::demo::RADIO::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Airspeed auto-calibration */
				static struct AIRSPEED_AUTOCAL AIRSPEED_AUTOCAL() {
					auto pack = new_pack(&com::company::demo::AIRSPEED_AUTOCAL::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Motion capture attitude and position */
				static struct ATT_POS_MOCAP ATT_POS_MOCAP() {
					auto pack = new_pack(&com::company::demo::ATT_POS_MOCAP::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING:
*				 They consume quite some bandwidth, so use only for important status and error messages. If implemented
*				 wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz) */
				static struct STATUSTEXT STATUSTEXT(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::STATUSTEXT::meta), cur)};
				}
				
				/**
*Request a GOPRO_COMMAND response from the GoPro */
				static struct GOPRO_GET_REQUEST GOPRO_GET_REQUEST(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::GOPRO_GET_REQUEST::meta), cur)};
				}
				
				/**
*WIP: Information about the status of a capture */
				static struct CAMERA_CAPTURE_STATUS CAMERA_CAPTURE_STATUS() {
					auto pack = new_pack(&com::company::demo::CAMERA_CAPTURE_STATUS::meta);
					return {pack, *pack->bytes};
				}
				
				static struct ENCAPSULATED_DATA ENCAPSULATED_DATA() {
					auto pack = new_pack(&com::company::demo::ENCAPSULATED_DATA::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position
*				 estimate of the sytem */
				static struct GPS_INPUT GPS_INPUT(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::GPS_INPUT::meta), cur)};
				}
				
				/**
*Status of compassmot calibration */
				static struct COMPASSMOT_STATUS COMPASSMOT_STATUS() {
					auto pack = new_pack(&com::company::demo::COMPASSMOT_STATUS::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Request a chunk of a log */
				static struct LOG_REQUEST_DATA LOG_REQUEST_DATA() {
					auto pack = new_pack(&com::company::demo::LOG_REQUEST_DATA::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Camera Event */
				static struct CAMERA_STATUS CAMERA_STATUS(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::CAMERA_STATUS::meta), cur)};
				}
				
				/**
*WIP: Settings of a camera, can be requested using MAV_CMD_REQUEST_CAMERA_SETTINGS. */
				static struct CAMERA_SETTINGS CAMERA_SETTINGS(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::CAMERA_SETTINGS::meta), cur)};
				}
				
				/**
*Read registers reply */
				static struct DEVICE_OP_READ_REPLY DEVICE_OP_READ_REPLY() {
					auto pack = new_pack(&com::company::demo::DEVICE_OP_READ_REPLY::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Control on-board Camera Control System to take shots. */
				static struct DIGICAM_CONTROL DIGICAM_CONTROL() {
					auto pack = new_pack(&com::company::demo::DIGICAM_CONTROL::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite
*				 efficient way for testing new messages and getting experimental debug output */
				static struct NAMED_VALUE_FLOAT NAMED_VALUE_FLOAT(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::NAMED_VALUE_FLOAT::meta), cur)};
				}
				
				/**
*Heartbeat from a HeroBus attached GoPro */
				static struct GOPRO_HEARTBEAT GOPRO_HEARTBEAT(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::GOPRO_HEARTBEAT::meta), cur)};
				}
				
				/**
*Status of secondary AHRS filter if available */
				static struct AHRS2 AHRS2() {
					auto pack = new_pack(&com::company::demo::AHRS2::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Erase all logs */
				static struct LOG_ERASE LOG_ERASE() {
					auto pack = new_pack(&com::company::demo::LOG_ERASE::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Request for terrain data and terrain status */
				static struct TERRAIN_REQUEST TERRAIN_REQUEST() {
					auto pack = new_pack(&com::company::demo::TERRAIN_REQUEST::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Message with some status from APM to GCS about camera or antenna mount */
				static struct MOUNT_STATUS MOUNT_STATUS() {
					auto pack = new_pack(&com::company::demo::MOUNT_STATUS::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*PID tuning information */
				static struct PID_TUNING PID_TUNING(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::PID_TUNING::meta), cur)};
				}
				
				/**
*Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor) */
				static struct OPTICAL_FLOW_RAD OPTICAL_FLOW_RAD() {
					auto pack = new_pack(&com::company::demo::OPTICAL_FLOW_RAD::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Reply to LOG_REQUEST_DATA */
				static struct LOG_DATA LOG_DATA() {
					auto pack = new_pack(&com::company::demo::LOG_DATA::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Status of third AHRS filter if available. This is for ANU research group (Ali and Sean) */
				static struct AHRS3 AHRS3() {
					auto pack = new_pack(&com::company::demo::AHRS3::meta);
					return {pack, *pack->bytes};
				}
				
				static struct VICON_POSITION_ESTIMATE VICON_POSITION_ESTIMATE() {
					auto pack = new_pack(&com::company::demo::VICON_POSITION_ESTIMATE::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */
				static struct GPS2_RTK GPS2_RTK() {
					auto pack = new_pack(&com::company::demo::GPS2_RTK::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Reports results of completed compass calibration. Sent until MAG_CAL_ACK received. */
				static struct MAG_CAL_REPORT MAG_CAL_REPORT(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::MAG_CAL_REPORT::meta), cur)};
				}
				
				/**
*Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END
*				 is called */
				static struct LOG_REQUEST_LIST LOG_REQUEST_LIST() {
					auto pack = new_pack(&com::company::demo::LOG_REQUEST_LIST::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Message to configure a camera mount, directional antenna, etc. */
				static struct MOUNT_CONFIGURE MOUNT_CONFIGURE(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::MOUNT_CONFIGURE::meta), cur)};
				}
				
				/**
*Message implementing parts of the V2 payload specs in V1 frames for transitional support. */
				static struct V2_EXTENSION V2_EXTENSION() {
					auto pack = new_pack(&com::company::demo::V2_EXTENSION::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Power supply status */
				static struct POWER_STATUS POWER_STATUS(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::POWER_STATUS::meta), cur)};
				}
				
				/**
*Send a block of log data to remote location */
				static struct REMOTE_LOG_DATA_BLOCK REMOTE_LOG_DATA_BLOCK(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::REMOTE_LOG_DATA_BLOCK::meta), cur)};
				}
				
				/**
*A message containing logged data which requires a LOGGING_ACK to be sent back */
				static struct LOGGING_DATA_ACKED LOGGING_DATA_ACKED() {
					auto pack = new_pack(&com::company::demo::LOGGING_DATA_ACKED::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Request that the vehicle report terrain height at the given location. Used by GCS to check if vehicle
*				 has all terrain data needed for a mission */
				static struct TERRAIN_CHECK TERRAIN_CHECK() {
					auto pack = new_pack(&com::company::demo::TERRAIN_CHECK::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Response from a TERRAIN_CHECK request */
				static struct TERRAIN_REPORT TERRAIN_REPORT() {
					auto pack = new_pack(&com::company::demo::TERRAIN_REPORT::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*The position the system will return to and land on. The position is set automatically by the system during
*				 the takeoff in case it was not explicitely set by the operator before or after. The global and local
*				 positions encode the position in the respective coordinate frames, while the q parameter encodes the
*				 orientation of the surface. Under normal conditions it describes the heading and terrain slope, which
*				 can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which
*				 the system should fly in normal flight mode and then perform a landing sequence along the vector */
				static struct SET_HOME_POSITION SET_HOME_POSITION(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::SET_HOME_POSITION::meta), cur)};
				}
				
				/**
*The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described
*				 unit */
				static struct SCALED_IMU3 SCALED_IMU3() {
					auto pack = new_pack(&com::company::demo::SCALED_IMU3::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Message to control a camera mount, directional antenna, etc. */
				static struct MOUNT_CONTROL MOUNT_CONTROL() {
					auto pack = new_pack(&com::company::demo::MOUNT_CONTROL::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Control vehicle LEDs */
				static struct LED_CONTROL LED_CONTROL() {
					auto pack = new_pack(&com::company::demo::LED_CONTROL::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Status of simulation environment, if used */
				static struct SIM_STATE SIM_STATE() {
					auto pack = new_pack(&com::company::demo::SIM_STATE::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Configure AP SSID and Password. */
				static struct WIFI_CONFIG_AP WIFI_CONFIG_AP(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::WIFI_CONFIG_AP::meta), cur)};
				}
				
				/**
*Data packet, size 96 */
				static struct DATA96 DATA96() {
					auto pack = new_pack(&com::company::demo::DATA96::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*WIP: Information about flight since last arming */
				static struct FLIGHT_INFORMATION FLIGHT_INFORMATION() {
					auto pack = new_pack(&com::company::demo::FLIGHT_INFORMATION::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*state of APM memory */
				static struct MEMINFO MEMINFO(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::MEMINFO::meta), cur)};
				}
				
				/**
*An ack for a LOGGING_DATA_ACKED message */
				static struct LOGGING_ACK LOGGING_ACK() {
					auto pack = new_pack(&com::company::demo::LOGGING_ACK::meta);
					return {pack, *pack->bytes};
				}
				
				static struct VISION_SPEED_ESTIMATE VISION_SPEED_ESTIMATE() {
					auto pack = new_pack(&com::company::demo::VISION_SPEED_ESTIMATE::meta);
					return {pack, *pack->bytes};
				}
				
				static struct DEBUG_VECT DEBUG_VECT(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::DEBUG_VECT::meta), cur)};
				}
				
				/**
*Camera-IMU triggering and synchronisation message. */
				static struct CAMERA_TRIGGER CAMERA_TRIGGER() {
					auto pack = new_pack(&com::company::demo::CAMERA_TRIGGER::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Stop log transfer and resume normal logging */
				static struct LOG_REQUEST_END LOG_REQUEST_END() {
					auto pack = new_pack(&com::company::demo::LOG_REQUEST_END::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Response from a GOPRO_COMMAND set request */
				static struct GOPRO_SET_RESPONSE GOPRO_SET_RESPONSE(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::GOPRO_SET_RESPONSE::meta), cur)};
				}
				
				/**
*WIP: Version and capability of protocol version. This message is the response to REQUEST_PROTOCOL_VERSION
*				 and is used as part of the handshaking to establish which MAVLink version should be used on the network.
*				 Every node should respond to REQUEST_PROTOCOL_VERSION to enable the handshaking. Library implementers
*				 should consider adding this into the default decoding state machine to allow the protocol core to respond
*				 directly */
				static struct PROTOCOL_VERSION PROTOCOL_VERSION() {
					auto pack = new_pack(&com::company::demo::PROTOCOL_VERSION::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Request a current rally point from MAV. MAV should respond with a RALLY_POINT message. MAV should not
*				 respond if the request is invalid */
				static struct RALLY_FETCH_POINT RALLY_FETCH_POINT() {
					auto pack = new_pack(&com::company::demo::RALLY_FETCH_POINT::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Battery information */
				static struct BATTERY_STATUS BATTERY_STATUS(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::BATTERY_STATUS::meta), cur)};
				}
				
				static struct MOUNT_ORIENTATION MOUNT_ORIENTATION() {
					auto pack = new_pack(&com::company::demo::MOUNT_ORIENTATION::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or
*				 telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages
*				 or change the devices settings. A message with zero bytes can be used to change just the baudrate */
				static struct SERIAL_CONTROL SERIAL_CONTROL(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::SERIAL_CONTROL::meta), cur)};
				}
				
				/**
*Set a parameter value. In order to deal with message loss (and retransmission of PARAM_EXT_SET), when
*				 setting a parameter value and the new value is the same as the current value, you will immediately get
*				 a PARAM_ACK_ACCEPTED response. If the current state is PARAM_ACK_IN_PROGRESS, you will accordingly receive
*				 a PARAM_ACK_IN_PROGRESS in response */
				static struct PARAM_EXT_SET PARAM_EXT_SET(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::PARAM_EXT_SET::meta), cur)};
				}
				
				/**
*Version and capability of autopilot software */
				static struct AUTOPILOT_VERSION AUTOPILOT_VERSION(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::AUTOPILOT_VERSION::meta), cur)};
				}
				
				/**
*Status of simulation environment, if used */
				static struct SIMSTATE SIMSTATE() {
					auto pack = new_pack(&com::company::demo::SIMSTATE::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*WIP: Message that sets video stream settings */
				static struct SET_VIDEO_STREAM_SETTINGS SET_VIDEO_STREAM_SETTINGS(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::SET_VIDEO_STREAM_SETTINGS::meta), cur)};
				}
				
				/**
*Control vehicle tone generation (buzzer) */
				static struct PLAY_TUNE PLAY_TUNE(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::PLAY_TUNE::meta), cur)};
				}
				
				/**
*Configure on-board Camera Control System. */
				static struct DIGICAM_CONFIGURE DIGICAM_CONFIGURE() {
					auto pack = new_pack(&com::company::demo::DIGICAM_CONFIGURE::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Barometer readings for 3rd barometer */
				static struct SCALED_PRESSURE3 SCALED_PRESSURE3() {
					auto pack = new_pack(&com::company::demo::SCALED_PRESSURE3::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Response from a PARAM_EXT_SET message. */
				static struct PARAM_EXT_ACK PARAM_EXT_ACK(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::PARAM_EXT_ACK::meta), cur)};
				}
				
				/**
*General information describing a particular UAVCAN node. Please refer to the definition of the UAVCAN
*				 service "uavcan.protocol.GetNodeInfo" for the background information. This message should be emitted
*				 by the system whenever a new node appears online, or an existing node reboots. Additionally, it can be
*				 emitted upon request from the other end of the MAVLink channel (see MAV_CMD_UAVCAN_GET_NODE_INFO). It
*				 is also not prohibited to emit this message unconditionally at a low frequency. The UAVCAN specification
*				 is available at http:uavcan.org */
				static struct UAVCAN_NODE_INFO UAVCAN_NODE_INFO(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::UAVCAN_NODE_INFO::meta), cur)};
				}
				
				/**
*Data packet, size 16 */
				static struct DATA16 DATA16() {
					auto pack = new_pack(&com::company::demo::DATA16::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the magnetometer offsets */
				static struct SET_MAG_OFFSETS SET_MAG_OFFSETS() {
					auto pack = new_pack(&com::company::demo::SET_MAG_OFFSETS::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to
*				 the described unit */
				static struct SCALED_IMU2 SCALED_IMU2() {
					auto pack = new_pack(&com::company::demo::SCALED_IMU2::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*raw ADC output */
				static struct AP_ADC AP_ADC() {
					auto pack = new_pack(&com::company::demo::AP_ADC::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Wind estimation */
				static struct WIND WIND() {
					auto pack = new_pack(&com::company::demo::WIND::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Request the autopilot version from the system/component. */
				static struct AUTOPILOT_VERSION_REQUEST AUTOPILOT_VERSION_REQUEST() {
					auto pack = new_pack(&com::company::demo::AUTOPILOT_VERSION_REQUEST::meta);
					return {pack, *pack->bytes};
				}
				
				static struct DATA_TRANSMISSION_HANDSHAKE DATA_TRANSMISSION_HANDSHAKE() {
					auto pack = new_pack(&com::company::demo::DATA_TRANSMISSION_HANDSHAKE::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Data packet, size 64 */
				static struct DATA64 DATA64() {
					auto pack = new_pack(&com::company::demo::DATA64::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*3 axis gimbal mesuraments */
				static struct GIMBAL_REPORT GIMBAL_REPORT() {
					auto pack = new_pack(&com::company::demo::GIMBAL_REPORT::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Write registers for a device */
				static struct DEVICE_OP_WRITE DEVICE_OP_WRITE(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::DEVICE_OP_WRITE::meta), cur)};
				}
				
				static struct DISTANCE_SENSOR DISTANCE_SENSOR(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::DISTANCE_SENSOR::meta), cur)};
				}
				
				/**
*Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor) */
				static struct HIL_OPTICAL_FLOW HIL_OPTICAL_FLOW() {
					auto pack = new_pack(&com::company::demo::HIL_OPTICAL_FLOW::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Barometer readings for 2nd barometer */
				static struct SCALED_PRESSURE2 SCALED_PRESSURE2() {
					auto pack = new_pack(&com::company::demo::SCALED_PRESSURE2::meta);
					return {pack, *pack->bytes};
				}
				
				static struct WIND_COV WIND_COV() {
					auto pack = new_pack(&com::company::demo::WIND_COV::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Request to set a GOPRO_COMMAND with a desired */
				static struct GOPRO_SET_REQUEST GOPRO_SET_REQUEST(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::GOPRO_SET_REQUEST::meta), cur)};
				}
				
				/**
*camera vision based attitude and position deltas */
				static struct VISION_POSITION_DELTA VISION_POSITION_DELTA() {
					auto pack = new_pack(&com::company::demo::VISION_POSITION_DELTA::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*A message containing logged data (see also MAV_CMD_LOGGING_START) */
				static struct LOGGING_DATA LOGGING_DATA() {
					auto pack = new_pack(&com::company::demo::LOGGING_DATA::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Read registers for a device */
				static struct DEVICE_OP_READ DEVICE_OP_READ(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::DEVICE_OP_READ::meta), cur)};
				}
				
				/**
*Reports progress of compass calibration. */
				static struct MAG_CAL_PROGRESS MAG_CAL_PROGRESS(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::MAG_CAL_PROGRESS::meta), cur)};
				}
				
				/**
*The IMU readings in SI units in NED body frame */
				static struct HIGHRES_IMU HIGHRES_IMU() {
					auto pack = new_pack(&com::company::demo::HIGHRES_IMU::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Provides state for additional features */
				static struct EXTENDED_SYS_STATE EXTENDED_SYS_STATE(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::EXTENDED_SYS_STATE::meta), cur)};
				}
				
				/**
*Dynamic data used to generate ADS-B out transponder data (send at 5Hz) */
				static struct UAVIONIX_ADSB_OUT_DYNAMIC UAVIONIX_ADSB_OUT_DYNAMIC(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::UAVIONIX_ADSB_OUT_DYNAMIC::meta), cur)};
				}
				
				/**
*Response from a GOPRO_COMMAND get request */
				static struct GOPRO_GET_RESPONSE GOPRO_GET_RESPONSE(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::GOPRO_GET_RESPONSE::meta), cur)};
				}
				
				/**
*data for injecting into the onboard GPS (used for DGPS) */
				static struct GPS_INJECT_DATA GPS_INJECT_DATA() {
					auto pack = new_pack(&com::company::demo::GPS_INJECT_DATA::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Transceiver heartbeat with health report (updated every 10s) */
				static struct UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT::meta), cur)};
				}
				
				/**
*Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite
*				 efficient way for testing new messages and getting experimental debug output */
				static struct NAMED_VALUE_INT NAMED_VALUE_INT(Cursor cur[]) {
					return {*org::unirail::utils::wrap_pack(new_pack(&com::company::demo::NAMED_VALUE_INT::meta), cur)};
				}
				
				/**
*RPM sensor output */
				static struct RPM RPM() {
					auto pack = new_pack(&com::company::demo::RPM::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*RTCM message for injecting into the onboard GPS (used for DGPS) */
				static struct GPS_RTCM_DATA GPS_RTCM_DATA() {
					auto pack = new_pack(&com::company::demo::GPS_RTCM_DATA::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*File transfer message */
				static struct FILE_TRANSFER_PROTOCOL FILE_TRANSFER_PROTOCOL() {
					auto pack = new_pack(&com::company::demo::FILE_TRANSFER_PROTOCOL::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Rangefinder reporting */
				static struct RANGEFINDER RANGEFINDER() {
					auto pack = new_pack(&com::company::demo::RANGEFINDER::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*Status generated by radio and injected into MAVLink stream. */
				static struct RADIO_STATUS RADIO_STATUS() {
					auto pack = new_pack(&com::company::demo::RADIO_STATUS::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*GCS */
				static struct FENCE_POINT FENCE_POINT() {
					auto pack = new_pack(&com::company::demo::FENCE_POINT::meta);
					return {pack, *pack->bytes};
				}
				
				/**
*The autopilot is requesting a resource (file, binary, other type of data) */
				static struct RESOURCE_REQUEST RESOURCE_REQUEST() {
					auto pack = new_pack(&com::company::demo::RESOURCE_REQUEST::meta);
					return {pack, *pack->bytes};
				}
				
			} NEW;
			
		};
	
}}}
														
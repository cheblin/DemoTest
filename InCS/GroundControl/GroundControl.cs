
using System;
using System.Text;
using Cursor = org.unirail.AdHoc.Pack.Cursor;
using Field = org.unirail.AdHoc.Pack.Meta.Field;
using Pack = org.unirail.AdHoc.Pack;
using Lib  = org.unirail.AdHoc;
using System.IO;
using com.company.demo.GroundControl;
#pragma warning disable 1587




namespace  com.company.demo
{
    namespace GroundControl
    {



        public enum PID_TUNING_AXIS : sbyte
        {

            PID_TUNING_ROLL = 1,
            PID_TUNING_PITCH = 2,
            PID_TUNING_YAW = 3,
            PID_TUNING_ACCZ = 4,
            PID_TUNING_STEER = 5,
            PID_TUNING_LANDING = 6
        }

        public static class PID_TUNING_AXIS_
        {

            internal static PID_TUNING_AXIS from_bits(ulong bits) { return (PID_TUNING_AXIS)(1 + (sbyte)bits); }

            internal static ulong bits(this PID_TUNING_AXIS en) { return (ulong)(en  - 1);	}
        }

        /**
        *Flags in EKF_STATUS message */


        public enum ESTIMATOR_STATUS_FLAGS : int
        {

            ESTIMATOR_ATTITUDE = 1, //True if the attitude estimate is good
            ESTIMATOR_VELOCITY_HORIZ = 2, //True if the horizontal velocity estimate is good
            ESTIMATOR_VELOCITY_VERT = 4, //True if the  vertical velocity estimate is good
            ESTIMATOR_POS_HORIZ_REL = 8, //True if the horizontal position (relative) estimate is good
            ESTIMATOR_POS_HORIZ_ABS = 16, //True if the horizontal position (absolute) estimate is good
            ESTIMATOR_POS_VERT_ABS = 32, //True if the vertical position (absolute) estimate is good
            ESTIMATOR_POS_VERT_AGL = 64, //True if the vertical position (above ground) estimate is good
            /**
            *True if the EKF is in a constant position mode and is not using external measurements (eg GPS or optical
            *			 flow */
            ESTIMATOR_CONST_POS_MODE = 128,
            ESTIMATOR_PRED_POS_HORIZ_REL = 256, //True if the EKF has sufficient data to enter a mode that will provide a (relative) position estimat
            ESTIMATOR_PRED_POS_HORIZ_ABS = 512, //True if the EKF has sufficient data to enter a mode that will provide a (absolute) position estimat
            ESTIMATOR_GPS_GLITCH = 1024 //True if the EKF has detected a GPS glitch
        }

        public static class ESTIMATOR_STATUS_FLAGS_
        {

            internal static ESTIMATOR_STATUS_FLAGS from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_ATTITUDE;
                    case 1:
                        return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_VELOCITY_HORIZ;
                    case 2:
                        return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_VELOCITY_VERT;
                    case 3:
                        return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_HORIZ_REL;
                    case 4:
                        return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_HORIZ_ABS;
                    case 5:
                        return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_VERT_ABS;
                    case 6:
                        return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_VERT_AGL;
                    case 7:
                        return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_CONST_POS_MODE;
                    case 8:
                        return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_PRED_POS_HORIZ_REL;
                    case 9:
                        return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_PRED_POS_HORIZ_ABS;
                    case 10:
                        return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_GPS_GLITCH;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this ESTIMATOR_STATUS_FLAGS en)
            {
                switch(en)
                {
                    case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_ATTITUDE:
                        return 0;
                    case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_VELOCITY_HORIZ:
                        return 1;
                    case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_VELOCITY_VERT:
                        return 2;
                    case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_HORIZ_REL:
                        return 3;
                    case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_HORIZ_ABS:
                        return 4;
                    case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_VERT_ABS:
                        return 5;
                    case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_VERT_AGL:
                        return 6;
                    case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_CONST_POS_MODE:
                        return 7;
                    case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_PRED_POS_HORIZ_REL:
                        return 8;
                    case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_PRED_POS_HORIZ_ABS:
                        return 9;
                    case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_GPS_GLITCH:
                        return 10;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }



        public enum MAV_TYPE : sbyte
        {

            GENERIC = 0, //Generic micro air vehicle.
            FIXED_WING = 1, //Fixed wing aircraft.
            QUADROTOR = 2, //Quadrotor
            COAXIAL = 3, //Coaxial helicopter
            HELICOPTER = 4, //Normal helicopter with tail rotor.
            ANTENNA_TRACKER = 5, //Ground installation
            GCS = 6, //Operator control unit / ground control station
            AIRSHIP = 7, //Airship, controlled
            FREE_BALLOON = 8, //Free balloon, uncontrolled
            ROCKET = 9, //Rocket
            GROUND_ROVER = 10, //Ground rover
            SURFACE_BOAT = 11, //Surface vessel, boat, ship
            SUBMARINE = 12, //Submarine
            HEXAROTOR = 13, //Hexarotor
            OCTOROTOR = 14, //Octorotor
            TRICOPTER = 15, //Tricopter
            FLAPPING_WING = 16, //Flapping wing
            KITE = 17, //Kite
            ONBOARD_CONTROLLER = 18, //Onboard companion controller
            VTOL_DUOROTOR = 19, //Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter.
            VTOL_QUADROTOR = 20, //Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter.
            VTOL_TILTROTOR = 21, //Tiltrotor VTOL
            VTOL_RESERVED2 = 22, //VTOL reserved 2
            VTOL_RESERVED3 = 23, //VTOL reserved 3
            VTOL_RESERVED4 = 24, //VTOL reserved 4
            VTOL_RESERVED5 = 25, //VTOL reserved 5
            GIMBAL = 26, //Onboard gimbal
            ADSB = 27, //Onboard ADSB peripheral
            PARAFOIL = 28 //Steerable, nonrigid airfoil
        }

        public static class MAV_TYPE_
        {

            internal static MAV_TYPE from_bits(ulong bits) { return (MAV_TYPE)((sbyte)bits); }

            internal static ulong bits(this MAV_TYPE en) { return (ulong)(en);	}
        }



        public enum GOPRO_CAPTURE_MODE : int
        {

            GOPRO_CAPTURE_MODE_VIDEO = 0, //Video mode
            GOPRO_CAPTURE_MODE_PHOTO = 1, //Photo mode
            GOPRO_CAPTURE_MODE_BURST = 2, //Burst mode, hero 3+ only
            GOPRO_CAPTURE_MODE_TIME_LAPSE = 3, //Time lapse mode, hero 3+ only
            GOPRO_CAPTURE_MODE_MULTI_SHOT = 4, //Multi shot mode, hero 4 only
            GOPRO_CAPTURE_MODE_PLAYBACK = 5, //Playback mode, hero 4 only, silver only except when LCD or HDMI is connected to black
            GOPRO_CAPTURE_MODE_SETUP = 6, //Playback mode, hero 4 only
            GOPRO_CAPTURE_MODE_UNKNOWN = 255 //Mode not yet known
        }

        public static class GOPRO_CAPTURE_MODE_
        {

            internal static GOPRO_CAPTURE_MODE from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_VIDEO;
                    case 1:
                        return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_PHOTO;
                    case 2:
                        return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_BURST;
                    case 3:
                        return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_TIME_LAPSE;
                    case 4:
                        return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_MULTI_SHOT;
                    case 5:
                        return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_PLAYBACK;
                    case 6:
                        return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_SETUP;
                    case 7:
                        return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_UNKNOWN;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this GOPRO_CAPTURE_MODE en)
            {
                switch(en)
                {
                    case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_VIDEO:
                        return 0;
                    case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_PHOTO:
                        return 1;
                    case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_BURST:
                        return 2;
                    case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_TIME_LAPSE:
                        return 3;
                    case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_MULTI_SHOT:
                        return 4;
                    case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_PLAYBACK:
                        return 5;
                    case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_SETUP:
                        return 6;
                    case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_UNKNOWN:
                        return 7;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *Micro air vehicle / autopilot classes. This identifies the individual model. */


        public enum MAV_AUTOPILOT : sbyte
        {

            GENERIC = 0, //Generic autopilot, full support for everything
            RESERVED = 1, //Reserved for future use.
            SLUGS = 2, //SLUGS autopilot, http:slugsuav.soe.ucsc.edu
            ARDUPILOTMEGA = 3, //ArduPilotMega / ArduCopter, http:diydrones.com
            OPENPILOT = 4, //OpenPilot, http:openpilot.org
            GENERIC_WAYPOINTS_ONLY = 5, //Generic autopilot only supporting simple waypoints
            GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY = 6, //Generic autopilot supporting waypoints and other simple navigation commands
            GENERIC_MISSION_FULL = 7, //Generic autopilot supporting the full mission command set
            INVALID = 8, //No valid autopilot, e.g. a GCS or other MAVLink component
            PPZ = 9, //PPZ UAV - http:nongnu.org/paparazzi
            UDB = 10, //UAV Dev Board
            FP = 11, //FlexiPilot
            PX4 = 12, //PX4 Autopilot - http:pixhawk.ethz.ch/px4/
            SMACCMPILOT = 13, //SMACCMPilot - http:smaccmpilot.org
            AUTOQUAD = 14, //AutoQuad -- http:autoquad.org
            ARMAZILA = 15, //Armazila -- http:armazila.com
            AEROB = 16, //Aerob -- http:aerob.ru
            ASLUAV = 17, //ASLUAV autopilot -- http:www.asl.ethz.ch
            SMARTAP = 18 //SmartAP Autopilot - http:sky-drones.com
        }

        public static class MAV_AUTOPILOT_
        {

            internal static MAV_AUTOPILOT from_bits(ulong bits) { return (MAV_AUTOPILOT)((sbyte)bits); }

            internal static ulong bits(this MAV_AUTOPILOT en) { return (ulong)(en);	}
        }

        /**
        *Enumeration of battery functions */


        public enum MAV_BATTERY_FUNCTION : sbyte
        {

            MAV_BATTERY_FUNCTION_UNKNOWN = 0, //Battery function is unknown
            MAV_BATTERY_FUNCTION_ALL = 1, //Battery supports all flight systems
            MAV_BATTERY_FUNCTION_PROPULSION = 2, //Battery for the propulsion system
            MAV_BATTERY_FUNCTION_AVIONICS = 3, //Avionics battery
            MAV_BATTERY_TYPE_PAYLOAD = 4 //Payload battery
        }

        public static class MAV_BATTERY_FUNCTION_
        {

            internal static MAV_BATTERY_FUNCTION from_bits(ulong bits) { return (MAV_BATTERY_FUNCTION)((sbyte)bits); }

            internal static ulong bits(this MAV_BATTERY_FUNCTION en) { return (ulong)(en);	}
        }

        /**
        *Type of landing target */


        public enum LANDING_TARGET_TYPE : sbyte
        {

            LANDING_TARGET_TYPE_LIGHT_BEACON = 0, //Landing target signaled by light beacon (ex: IR-LOCK)
            LANDING_TARGET_TYPE_RADIO_BEACON = 1, //Landing target signaled by radio beacon (ex: ILS, NDB)
            LANDING_TARGET_TYPE_VISION_FIDUCIAL = 2, //Landing target represented by a fiducial marker (ex: ARTag)
            LANDING_TARGET_TYPE_VISION_OTHER = 3 //Landing target represented by a pre-defined visual shape/feature (ex: X-marker, H-marker, square)
        }

        public static class LANDING_TARGET_TYPE_
        {

            internal static LANDING_TARGET_TYPE from_bits(ulong bits) { return (LANDING_TARGET_TYPE)((sbyte)bits); }

            internal static ulong bits(this LANDING_TARGET_TYPE en) { return (ulong)(en);	}
        }



        public enum LIMIT_MODULE : int
        {

            LIMIT_GPSLOCK = 1, //pre-initialization
            LIMIT_GEOFENCE = 2, //disabled
            LIMIT_ALTITUDE = 4 //checking limits
        }

        public static class LIMIT_MODULE_
        {

            internal static LIMIT_MODULE from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return LIMIT_MODULE.LIMIT_GPSLOCK;
                    case 1:
                        return LIMIT_MODULE.LIMIT_GEOFENCE;
                    case 2:
                        return LIMIT_MODULE.LIMIT_ALTITUDE;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this LIMIT_MODULE en)
            {
                switch(en)
                {
                    case LIMIT_MODULE.LIMIT_GPSLOCK:
                        return 0;
                    case LIMIT_MODULE.LIMIT_GEOFENCE:
                        return 1;
                    case LIMIT_MODULE.LIMIT_ALTITUDE:
                        return 2;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *Enumeration of landed detector states */


        public enum MAV_LANDED_STATE : sbyte
        {

            MAV_LANDED_STATE_UNDEFINED = 0, //MAV landed state is unknown
            MAV_LANDED_STATE_ON_GROUND = 1, //MAV is landed (on ground)
            MAV_LANDED_STATE_IN_AIR = 2, //MAV is in air
            MAV_LANDED_STATE_TAKEOFF = 3, //MAV currently taking off
            MAV_LANDED_STATE_LANDING = 4 //MAV currently landing
        }

        public static class MAV_LANDED_STATE_
        {

            internal static MAV_LANDED_STATE from_bits(ulong bits) { return (MAV_LANDED_STATE)((sbyte)bits); }

            internal static ulong bits(this MAV_LANDED_STATE en) { return (ulong)(en);	}
        }

        /**
        *Specifies the datatype of a MAVLink parameter. */


        public enum MAV_PARAM_TYPE : sbyte
        {

            MAV_PARAM_TYPE_UINT8 = 1, //8-bit unsigned integer
            MAV_PARAM_TYPE_INT8 = 2, //8-bit signed integer
            MAV_PARAM_TYPE_UINT16 = 3, //16-bit unsigned integer
            MAV_PARAM_TYPE_INT16 = 4, //16-bit signed integer
            MAV_PARAM_TYPE_UINT32 = 5, //32-bit unsigned integer
            MAV_PARAM_TYPE_INT32 = 6, //32-bit signed integer
            MAV_PARAM_TYPE_UINT64 = 7, //64-bit unsigned integer
            MAV_PARAM_TYPE_INT64 = 8, //64-bit signed integer
            MAV_PARAM_TYPE_REAL32 = 9, //32-bit floating-point
            MAV_PARAM_TYPE_REAL64 = 10 //64-bit floating-point
        }

        public static class MAV_PARAM_TYPE_
        {

            internal static MAV_PARAM_TYPE from_bits(ulong bits) { return (MAV_PARAM_TYPE)(1 + (sbyte)bits); }

            internal static ulong bits(this MAV_PARAM_TYPE en) { return (ulong)(en  - 1);	}
        }

        /**
        *Emergency status encoding */


        public enum UAVIONIX_ADSB_EMERGENCY_STATUS : sbyte
        {

            UAVIONIX_ADSB_OUT_NO_EMERGENCY = 0,
            UAVIONIX_ADSB_OUT_GENERAL_EMERGENCY = 1,
            UAVIONIX_ADSB_OUT_LIFEGUARD_EMERGENCY = 2,
            UAVIONIX_ADSB_OUT_MINIMUM_FUEL_EMERGENCY = 3,
            UAVIONIX_ADSB_OUT_NO_COMM_EMERGENCY = 4,
            UAVIONIX_ADSB_OUT_UNLAWFUL_INTERFERANCE_EMERGENCY = 5,
            UAVIONIX_ADSB_OUT_DOWNED_AIRCRAFT_EMERGENCY = 6,
            UAVIONIX_ADSB_OUT_RESERVED = 7
        }

        public static class UAVIONIX_ADSB_EMERGENCY_STATUS_
        {

            internal static UAVIONIX_ADSB_EMERGENCY_STATUS from_bits(ulong bits) { return (UAVIONIX_ADSB_EMERGENCY_STATUS)((sbyte)bits); }

            internal static ulong bits(this UAVIONIX_ADSB_EMERGENCY_STATUS en) { return (ulong)(en);	}
        }

        /**
        *Indicates the severity level, generally used for status messages to indicate their relative urgency. Based
        *		 on RFC-5424 using expanded definitions at: http:www.kiwisyslog.com/kb/info:-syslog-message-levels/ */


        public enum MAV_SEVERITY : sbyte
        {

            MAV_SEVERITY_EMERGENCY = 0, //System is unusable. This is a "panic" condition.
            MAV_SEVERITY_ALERT = 1, //Action should be taken immediately. Indicates error in non-critical systems.
            MAV_SEVERITY_CRITICAL = 2, //Action must be taken immediately. Indicates failure in a primary system.
            MAV_SEVERITY_ERROR = 3, //Indicates an error in secondary/redundant systems.
            /**
            *Indicates about a possible future error if this is not resolved within a given timeframe. Example would
            *			 be a low battery warning */
            MAV_SEVERITY_WARNING = 4,
            /**
            *An unusual event has occured, though not an error condition. This should be investigated for the root
            *			 cause */
            MAV_SEVERITY_NOTICE = 5,
            MAV_SEVERITY_INFO = 6, //Normal operational messages. Useful for logging. No action is required for these messages.
            MAV_SEVERITY_DEBUG = 7 //Useful non-operational messages that can assist in debugging. These should not occur during normal operation
        }

        public static class MAV_SEVERITY_
        {

            internal static MAV_SEVERITY from_bits(ulong bits) { return (MAV_SEVERITY)((sbyte)bits); }

            internal static ulong bits(this MAV_SEVERITY en) { return (ulong)(en);	}
        }

        /**
        *These defines are predefined OR-combined mode flags. There is no need to use values from this enum, but it
        *		 simplifies the use of the mode flags. Note that manual input is enabled in all modes as a safety override. */


        public enum MAV_MODE : int
        {

            PREFLIGHT = 0, //System is not ready to fly, booting, calibrating, etc. No flag is set.
            MANUAL_DISARMED = 64, //System is allowed to be active, under manual (RC) control, no stabilization
            MAV_MODE_TEST_DISARMED = 66, //UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only
            STABILIZE_DISARMED = 80, //System is allowed to be active, under assisted RC control.
            GUIDED_DISARMED = 88, //System is allowed to be active, under autonomous control, manual setpoint
            /**
            *System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard
            *			 and not pre-programmed by waypoints */
            MAV_MODE_AUTO_DISARMED = 92,
            MANUAL_ARMED = 192, //System is allowed to be active, under manual (RC) control, no stabilization
            MAV_MODE_TEST_ARMED = 194, //UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only
            STABILIZE_ARMED = 208, //System is allowed to be active, under assisted RC control.
            GUIDED_ARMED = 216, //System is allowed to be active, under autonomous control, manual setpoint
            /**
            *System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard
            *			 and not pre-programmed by waypoints */
            MAV_MODE_AUTO_ARMED = 220
        }

        public static class MAV_MODE_
        {

            internal static MAV_MODE from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return MAV_MODE.PREFLIGHT;
                    case 1:
                        return MAV_MODE.MANUAL_DISARMED;
                    case 2:
                        return MAV_MODE.MAV_MODE_TEST_DISARMED;
                    case 3:
                        return MAV_MODE.STABILIZE_DISARMED;
                    case 4:
                        return MAV_MODE.GUIDED_DISARMED;
                    case 5:
                        return MAV_MODE.MAV_MODE_AUTO_DISARMED;
                    case 6:
                        return MAV_MODE.MANUAL_ARMED;
                    case 7:
                        return MAV_MODE.MAV_MODE_TEST_ARMED;
                    case 8:
                        return MAV_MODE.STABILIZE_ARMED;
                    case 9:
                        return MAV_MODE.GUIDED_ARMED;
                    case 10:
                        return MAV_MODE.MAV_MODE_AUTO_ARMED;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this MAV_MODE en)
            {
                switch(en)
                {
                    case MAV_MODE.PREFLIGHT:
                        return 0;
                    case MAV_MODE.MANUAL_DISARMED:
                        return 1;
                    case MAV_MODE.MAV_MODE_TEST_DISARMED:
                        return 2;
                    case MAV_MODE.STABILIZE_DISARMED:
                        return 3;
                    case MAV_MODE.GUIDED_DISARMED:
                        return 4;
                    case MAV_MODE.MAV_MODE_AUTO_DISARMED:
                        return 5;
                    case MAV_MODE.MANUAL_ARMED:
                        return 6;
                    case MAV_MODE.MAV_MODE_TEST_ARMED:
                        return 7;
                    case MAV_MODE.STABILIZE_ARMED:
                        return 8;
                    case MAV_MODE.GUIDED_ARMED:
                        return 9;
                    case MAV_MODE.MAV_MODE_AUTO_ARMED:
                        return 10;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *Enumeration of the ADSB altimeter types */


        public enum ADSB_ALTITUDE_TYPE : sbyte
        {

            ADSB_ALTITUDE_TYPE_PRESSURE_QNH = 0, //Altitude reported from a Baro source using QNH reference
            ADSB_ALTITUDE_TYPE_GEOMETRIC = 1 //Altitude reported from a GNSS source
        }

        public static class ADSB_ALTITUDE_TYPE_
        {

            internal static ADSB_ALTITUDE_TYPE from_bits(ulong bits) { return (ADSB_ALTITUDE_TYPE)((sbyte)bits); }

            internal static ulong bits(this ADSB_ALTITUDE_TYPE en) { return (ulong)(en);	}
        }

        /**
        *Type of mission items being requested/sent in mission protocol. */


        public enum MAV_MISSION_TYPE : int
        {

            MAV_MISSION_TYPE_MISSION = 0, //Items are mission commands for main mission.
            MAV_MISSION_TYPE_FENCE = 1, //Specifies GeoFence area(s). Items are MAV_CMD_FENCE_ GeoFence items.
            /**
            *Specifies the rally points for the vehicle. Rally points are alternative RTL points. Items are MAV_CMD_RALLY_POINT
            *			 rally point items */
            MAV_MISSION_TYPE_RALLY = 2,
            MAV_MISSION_TYPE_ALL = 255 //Only used in MISSION_CLEAR_ALL to clear all mission types.
        }

        public static class MAV_MISSION_TYPE_
        {

            internal static MAV_MISSION_TYPE from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return MAV_MISSION_TYPE.MAV_MISSION_TYPE_MISSION;
                    case 1:
                        return MAV_MISSION_TYPE.MAV_MISSION_TYPE_FENCE;
                    case 2:
                        return MAV_MISSION_TYPE.MAV_MISSION_TYPE_RALLY;
                    case 3:
                        return MAV_MISSION_TYPE.MAV_MISSION_TYPE_ALL;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this MAV_MISSION_TYPE en)
            {
                switch(en)
                {
                    case MAV_MISSION_TYPE.MAV_MISSION_TYPE_MISSION:
                        return 0;
                    case MAV_MISSION_TYPE.MAV_MISSION_TYPE_FENCE:
                        return 1;
                    case MAV_MISSION_TYPE.MAV_MISSION_TYPE_RALLY:
                        return 2;
                    case MAV_MISSION_TYPE.MAV_MISSION_TYPE_ALL:
                        return 3;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *Enumeration of distance sensor types */


        public enum MAV_DISTANCE_SENSOR : sbyte
        {

            MAV_DISTANCE_SENSOR_LASER = 0, //Laser rangefinder, e.g. LightWare SF02/F or PulsedLight units
            MAV_DISTANCE_SENSOR_ULTRASOUND = 1, //Ultrasound rangefinder, e.g. MaxBotix units
            MAV_DISTANCE_SENSOR_INFRARED = 2, //Infrared rangefinder, e.g. Sharp units
            MAV_DISTANCE_SENSOR_RADAR = 3, //Radar type, e.g. uLanding units
            MAV_DISTANCE_SENSOR_UNKNOWN = 4 //Broken or unknown type, e.g. analog units
        }

        public static class MAV_DISTANCE_SENSOR_
        {

            internal static MAV_DISTANCE_SENSOR from_bits(ulong bits) { return (MAV_DISTANCE_SENSOR)((sbyte)bits); }

            internal static ulong bits(this MAV_DISTANCE_SENSOR en) { return (ulong)(en);	}
        }

        /**
        *Enumeration of VTOL states */


        public enum MAV_VTOL_STATE : sbyte
        {

            MAV_VTOL_STATE_UNDEFINED = 0, //MAV is not configured as VTOL
            MAV_VTOL_STATE_TRANSITION_TO_FW = 1, //VTOL is in transition from multicopter to fixed-wing
            MAV_VTOL_STATE_TRANSITION_TO_MC = 2, //VTOL is in transition from fixed-wing to multicopter
            MAV_VTOL_STATE_MC = 3, //VTOL is in multicopter state
            MAV_VTOL_STATE_FW = 4 //VTOL is in fixed-wing state
        }

        public static class MAV_VTOL_STATE_
        {

            internal static MAV_VTOL_STATE from_bits(ulong bits) { return (MAV_VTOL_STATE)((sbyte)bits); }

            internal static ulong bits(this MAV_VTOL_STATE en) { return (ulong)(en);	}
        }

        /**
        *Type of GPS fix */


        public enum GPS_FIX_TYPE : sbyte
        {

            GPS_FIX_TYPE_NO_GPS = 0, //No GPS connected
            GPS_FIX_TYPE_NO_FIX = 1, //No position information, GPS is connected
            GPS_FIX_TYPE_2D_FIX = 2, //2D position
            GPS_FIX_TYPE_3D_FIX = 3, //3D position
            GPS_FIX_TYPE_DGPS = 4, //DGPS/SBAS aided 3D position
            GPS_FIX_TYPE_RTK_FLOAT = 5, //RTK float, 3D position
            GPS_FIX_TYPE_RTK_FIXED = 6, //RTK Fixed, 3D position
            GPS_FIX_TYPE_STATIC = 7, //Static fixed, typically used for base stations
            GPS_FIX_TYPE_PPP = 8 //PPP, 3D position.
        }

        public static class GPS_FIX_TYPE_
        {

            internal static GPS_FIX_TYPE from_bits(ulong bits) { return (GPS_FIX_TYPE)((sbyte)bits); }

            internal static ulong bits(this GPS_FIX_TYPE en) { return (ulong)(en);	}
        }

        /**
        *Specifies the datatype of a MAVLink extended parameter. */


        public enum MAV_PARAM_EXT_TYPE : sbyte
        {

            MAV_PARAM_EXT_TYPE_UINT8 = 1, //8-bit unsigned integer
            MAV_PARAM_EXT_TYPE_INT8 = 2, //8-bit signed integer
            MAV_PARAM_EXT_TYPE_UINT16 = 3, //16-bit unsigned integer
            MAV_PARAM_EXT_TYPE_INT16 = 4, //16-bit signed integer
            MAV_PARAM_EXT_TYPE_UINT32 = 5, //32-bit unsigned integer
            MAV_PARAM_EXT_TYPE_INT32 = 6, //32-bit signed integer
            MAV_PARAM_EXT_TYPE_UINT64 = 7, //64-bit unsigned integer
            MAV_PARAM_EXT_TYPE_INT64 = 8, //64-bit signed integer
            MAV_PARAM_EXT_TYPE_REAL32 = 9, //32-bit floating-point
            MAV_PARAM_EXT_TYPE_REAL64 = 10, //64-bit floating-point
            MAV_PARAM_EXT_TYPE_CUSTOM = 11 //Custom Type
        }

        public static class MAV_PARAM_EXT_TYPE_
        {

            internal static MAV_PARAM_EXT_TYPE from_bits(ulong bits) { return (MAV_PARAM_EXT_TYPE)(1 + (sbyte)bits); }

            internal static ulong bits(this MAV_PARAM_EXT_TYPE en) { return (ulong)(en  - 1);	}
        }

        /**
        *Enumeration of estimator types */


        public enum MAV_ESTIMATOR_TYPE : sbyte
        {

            MAV_ESTIMATOR_TYPE_NAIVE = 1, //This is a naive estimator without any real covariance feedback.
            MAV_ESTIMATOR_TYPE_VISION = 2, //Computer vision based estimate. Might be up to scale.
            MAV_ESTIMATOR_TYPE_VIO = 3, //Visual-inertial estimate.
            MAV_ESTIMATOR_TYPE_GPS = 4, //Plain GPS estimate.
            MAV_ESTIMATOR_TYPE_GPS_INS = 5 //Estimator integrating GPS and inertial sensing.
        }

        public static class MAV_ESTIMATOR_TYPE_
        {

            internal static MAV_ESTIMATOR_TYPE from_bits(ulong bits) { return (MAV_ESTIMATOR_TYPE)(1 + (sbyte)bits); }

            internal static ulong bits(this MAV_ESTIMATOR_TYPE en) { return (ulong)(en  - 1);	}
        }



        public enum CAMERA_FEEDBACK_FLAGS : sbyte
        {

            CAMERA_FEEDBACK_PHOTO = 0, //Shooting photos, not video
            CAMERA_FEEDBACK_VIDEO = 1, //Shooting video, not stills
            CAMERA_FEEDBACK_BADEXPOSURE = 2, //Unable to achieve requested exposure (e.g. shutter speed too low)
            CAMERA_FEEDBACK_CLOSEDLOOP = 3, //Closed loop feedback from camera, we know for sure it has successfully taken a picture
            /**
            *Open loop camera, an image trigger has been requested but we can't know for sure it has successfully taken
            *			 a pictur */
            CAMERA_FEEDBACK_OPENLOOP = 4
        }

        public static class CAMERA_FEEDBACK_FLAGS_
        {

            internal static CAMERA_FEEDBACK_FLAGS from_bits(ulong bits) { return (CAMERA_FEEDBACK_FLAGS)((sbyte)bits); }

            internal static ulong bits(this CAMERA_FEEDBACK_FLAGS en) { return (ulong)(en);	}
        }

        /**
        *Generalized UAVCAN node health */


        public enum UAVCAN_NODE_HEALTH : sbyte
        {

            UAVCAN_NODE_HEALTH_OK = 0, //The node is functioning properly.
            UAVCAN_NODE_HEALTH_WARNING = 1, //A critical parameter went out of range or the node has encountered a minor failure.
            UAVCAN_NODE_HEALTH_ERROR = 2, //The node has encountered a major failure.
            UAVCAN_NODE_HEALTH_CRITICAL = 3 //The node has suffered a fatal malfunction.
        }

        public static class UAVCAN_NODE_HEALTH_
        {

            internal static UAVCAN_NODE_HEALTH from_bits(ulong bits) { return (UAVCAN_NODE_HEALTH)((sbyte)bits); }

            internal static ulong bits(this UAVCAN_NODE_HEALTH en) { return (ulong)(en);	}
        }

        /**
        *Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script.
        *		 If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows:
        *		 Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what
        *		 ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data */


        public enum MAV_CMD : int
        {

            /**
            *Navigate to waypoint.
            *					 1	Hold time in decimal seconds. (ignored by fixed wing, time to stay at waypoint for rotary wing)
            *					 2	Acceptance radius in meters (if the sphere with this radius is hit, the waypoint counts as reached)
            *					 3	0 to pass through the WP, if 	>	0 radius in meters to pass by WP. Positive value for clockwise orbit, negative value for counter-clockwise orbit. Allows trajectory control.
            *					 4	Desired yaw angle at waypoint (rotary wing). NaN for unchanged.
            *					 5	Latitude
            *					 6	Longitude
            *					 7	Altitude */
            MAV_CMD_NAV_WAYPOINT = 16,
            /**
            *Loiter around this waypoint an unlimited amount of time
            *			 1	Empty
            *			 2	Empty
            *			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
            *			 4	Desired yaw angle.
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude */
            MAV_CMD_NAV_LOITER_UNLIM = 17,
            /**
            *Loiter around this waypoint for X turns
            *			 1	Turns
            *			 2	Empty
            *			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
            *			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude */
            MAV_CMD_NAV_LOITER_TURNS = 18,
            /**
            *Loiter around this waypoint for X seconds
            *			 1	Seconds (decimal)
            *			 2	Empty
            *			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
            *			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude */
            MAV_CMD_NAV_LOITER_TIME = 19,
            /**
            *Return to launch location
            *			 1	Empty
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_NAV_RETURN_TO_LAUNCH = 20,
            /**
            *Land at location
            *			 1	Abort Alt
            *			 2	Empty
            *			 3	Empty
            *			 4	Desired yaw angle. NaN for unchanged.
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude (ground level) */
            MAV_CMD_NAV_LAND = 21,
            /**
            *Takeoff from ground / hand
            *			 1	Minimum pitch (if airspeed sensor present), desired pitch without sensor
            *			 2	Empty
            *			 3	Empty
            *			 4	Yaw angle (if magnetometer present), ignored without magnetometer. NaN for unchanged.
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude */
            MAV_CMD_NAV_TAKEOFF = 22,
            /**
            *Land at local position (local frame only)
            *			 1	Landing target number (if available)
            *			 2	Maximum accepted offset from desired landing position [m] - computed magnitude from spherical coordinates: d = sqrt(x^2 + y^2 + z^2), which gives the maximum accepted distance between the desired landing position and the position where the vehicle is about to land
            *			 3	Landing descend rate [ms^-1]
            *			 4	Desired yaw angle [rad]
            *			 5	Y-axis position [m]
            *			 6	X-axis position [m]
            *			 7	Z-axis / ground level position [m] */
            MAV_CMD_NAV_LAND_LOCAL = 23,
            /**
            *Takeoff from local position (local frame only)
            *			 1	Minimum pitch (if airspeed sensor present), desired pitch without sensor [rad]
            *			 2	Empty
            *			 3	Takeoff ascend rate [ms^-1]
            *			 4	Yaw angle [rad] (if magnetometer or another yaw estimation source present), ignored without one of these
            *			 5	Y-axis position [m]
            *			 6	X-axis position [m]
            *			 7	Z-axis position [m] */
            MAV_CMD_NAV_TAKEOFF_LOCAL = 24,
            /**
            *Vehicle following, i.e. this waypoint represents the position of a moving vehicle
            *			 1	Following logic to use (e.g. loitering or sinusoidal following) - depends on specific autopilot implementation
            *			 2	Ground speed of vehicle to be followed
            *			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
            *			 4	Desired yaw angle.
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude */
            MAV_CMD_NAV_FOLLOW = 25,
            /**
            *Continue on the current course and climb/descend to specified altitude.  When the altitude is reached
            *			 continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached
            *			 1	Climb or Descend (0 = Neutral, command completes when within 5m of this command's altitude, 1 = Climbing, command completes when at or above this command's altitude, 2 = Descending, command completes when at or below this command's altitude.
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Desired altitude in meters */
            MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT = 30,
            /**
            *Begin loiter at the specified Latitude and Longitude.  If Lat=Lon=0, then loiter at the current position.
            *			 Don't consider the navigation command complete (don't leave loiter) until the altitude has been reached.
            *			 Additionally, if the Heading Required parameter is non-zero the  aircraft will not leave the loiter
            *			 until heading toward the next waypoint.
            *			 1	Heading Required (0 = False)
            *			 2	Radius in meters. If positive loiter clockwise, negative counter-clockwise, 0 means no change to standard loiter.
            *			 3	Empty
            *			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude */
            MAV_CMD_NAV_LOITER_TO_ALT = 31,
            /**
            *Being following a target
            *			 1	System ID (the system ID of the FOLLOW_TARGET beacon). Send 0 to disable follow-me and return to the default position hold mode
            *			 2	RESERVED
            *			 3	RESERVED
            *			 4	altitude flag: 0: Keep current altitude, 1: keep altitude difference to target, 2: go to a fixed altitude above home
            *			 5	altitude
            *			 6	RESERVED
            *			 7	TTL in seconds in which the MAV should go to the default position hold mode after a message rx timeout */
            MAV_CMD_DO_FOLLOW = 32,
            /**
            *Reposition the MAV after a follow target command has been sent
            *			 1	Camera q1 (where 0 is on the ray from the camera to the tracking device)
            *			 2	Camera q2
            *			 3	Camera q3
            *			 4	Camera q4
            *			 5	altitude offset from target (m)
            *			 6	X offset from target (m)
            *			 7	Y offset from target (m) */
            MAV_CMD_DO_FOLLOW_REPOSITION = 33,
            /**
            *Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the
            *			 vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras
            *			 1	Region of intereset mode. (see MAV_ROI enum)
            *			 2	Waypoint index/ target ID. (see MAV_ROI enum)
            *			 3	ROI index (allows a vehicle to manage multiple ROI's)
            *			 4	Empty
            *			 5	x the location of the fixed ROI (see MAV_FRAME)
            *			 6	y
            *			 7	z */
            MAV_CMD_NAV_ROI = 80,
            /**
            *Control autonomous path planning on the MAV.
            *			 1	0: Disable local obstacle avoidance / local path planning (without resetting map), 1: Enable local path planning, 2: Enable and reset local path planning
            *			 2	0: Disable full path planning (without resetting map), 1: Enable, 2: Enable and reset map/occupancy grid, 3: Enable and reset planned route, but not occupancy grid
            *			 3	Empty
            *			 4	Yaw angle at goal, in compass degrees, [0..360]
            *			 5	Latitude/X of goal
            *			 6	Longitude/Y of goal
            *			 7	Altitude/Z of goal */
            MAV_CMD_NAV_PATHPLANNING = 81,
            /**
            *Navigate to waypoint using a spline path.
            *			 1	Hold time in decimal seconds. (ignored by fixed wing, time to stay at waypoint for rotary wing)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Latitude/X of goal
            *			 6	Longitude/Y of goal
            *			 7	Altitude/Z of goal */
            MAV_CMD_NAV_SPLINE_WAYPOINT = 82,
            /**
            *Mission command to wait for an altitude or downwards vertical speed. This is meant for high altitude balloon
            *			 launches, allowing the aircraft to be idle until either an altitude is reached or a negative vertical
            *			 speed is reached (indicating early balloon burst). The wiggle time is how often to wiggle the control
            *			 surfaces to prevent them seizing up
            *			 1	altitude (m)
            *			 2	descent speed (m/s)
            *			 3	Wiggle Time (s)
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_NAV_ALTITUDE_WAIT = 83,
            /**
            *Takeoff from ground using VTOL mode
            *			 1	Empty
            *			 2	Front transition heading, see VTOL_TRANSITION_HEADING enum.
            *			 3	Empty
            *			 4	Yaw angle in degrees. NaN for unchanged.
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude */
            MAV_CMD_NAV_VTOL_TAKEOFF = 84,
            /**
            *Land using VTOL mode
            *			 1	Empty
            *			 2	Empty
            *			 3	Approach altitude (with the same reference as the Altitude field). NaN if unspecified.
            *			 4	Yaw angle in degrees. NaN for unchanged.
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude (ground level) */
            MAV_CMD_NAV_VTOL_LAND = 85,
            /**
            *hand control over to an external controller
            *			 1	On / Off (	>	0.5f on)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_NAV_GUIDED_ENABLE = 92,
            /**
            *Delay the next navigation command a number of seconds or until a specified time
            *			 1	Delay in seconds (decimal, -1 to enable time-of-day fields)
            *			 2	hour (24h format, UTC, -1 to ignore)
            *			 3	minute (24h format, UTC, -1 to ignore)
            *			 4	second (24h format, UTC)
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_NAV_DELAY = 93,
            /**
            *Descend and place payload.  Vehicle descends until it detects a hanging payload has reached the ground,
            *			 the gripper is opened to release the payloa
            *			 1	Maximum distance to descend (meters)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Latitude (deg * 1E7)
            *			 6	Longitude (deg * 1E7)
            *			 7	Altitude (meters) */
            MAV_CMD_NAV_PAYLOAD_PLACE = 94,
            /**
            *NOP - This command is only used to mark the upper limit of the NAV/ACTION commands in the enumeratio
            *			 1	Empty
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_NAV_LAST = 95,
            /**
            *Delay mission state machine.
            *			 1	Delay in seconds (decimal)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_CONDITION_DELAY = 112,
            /**
            *Ascend/descend at rate.  Delay mission state machine until desired altitude reached.
            *			 1	Descent / Ascend rate (m/s)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Finish Altitude */
            MAV_CMD_CONDITION_CHANGE_ALT = 113,
            /**
            *Delay mission state machine until within desired distance of next NAV point.
            *			 1	Distance (meters)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_CONDITION_DISTANCE = 114,
            /**
            *Reach a certain target angle.
            *			 1	target angle: [0-360], 0 is north
            *			 2	speed during yaw change:[deg per second]
            *			 3	direction: negative: counter clockwise, positive: clockwise [-1,1]
            *			 4	relative offset or absolute angle: [ 1,0]
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_CONDITION_YAW = 115,
            /**
            *NOP - This command is only used to mark the upper limit of the CONDITION commands in the enumeratio
            *			 1	Empty
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_CONDITION_LAST = 159,
            /**
            *Set system mode.
            *			 1	Mode, as defined by ENUM MAV_MODE
            *			 2	Custom mode - this is system specific, please refer to the individual autopilot specifications for details.
            *			 3	Custom sub mode - this is system specific, please refer to the individual autopilot specifications for details.
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_SET_MODE = 176,
            /**
            *Jump to the desired command in the mission list.  Repeat this action only the specified number of time
            *			 1	Sequence number
            *			 2	Repeat count
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_JUMP = 177,
            /**
            *Change speed and/or throttle set points.
            *			 1	Speed type (0=Airspeed, 1=Ground Speed)
            *			 2	Speed  (m/s, -1 indicates no change)
            *			 3	Throttle  ( Percent, -1 indicates no change)
            *			 4	absolute or relative [0,1]
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_CHANGE_SPEED = 178,
            /**
            *Changes the home location either to the current location or a specified location.
            *			 1	Use current (1=use current location, 0=use specified location)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude */
            MAV_CMD_DO_SET_HOME = 179,
            /**
            *Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value
            *			 of the parameter
            *			 1	Parameter number
            *			 2	Parameter value
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_SET_PARAMETER = 180,
            /**
            *Set a relay to a condition.
            *			 1	Relay number
            *			 2	Setting (1=on, 0=off, others possible depending on system hardware)
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_SET_RELAY = 181,
            /**
            *Cycle a relay on and off for a desired number of cyles with a desired period.
            *			 1	Relay number
            *			 2	Cycle count
            *			 3	Cycle time (seconds, decimal)
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_REPEAT_RELAY = 182,
            /**
            *Set a servo to a desired PWM value.
            *			 1	Servo number
            *			 2	PWM (microseconds, 1000 to 2000 typical)
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_SET_SERVO = 183,
            /**
            *Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period
            *			 1	Servo number
            *			 2	PWM (microseconds, 1000 to 2000 typical)
            *			 3	Cycle count
            *			 4	Cycle time (seconds)
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_REPEAT_SERVO = 184,
            /**
            *Terminate flight immediately
            *			 1	Flight termination activated if 	>	0.5
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_FLIGHTTERMINATION = 185,
            /**
            *Change altitude set point.
            *			 1	Altitude in meters
            *			 2	Mav frame of new altitude (see MAV_FRAME)
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_CHANGE_ALTITUDE = 186,
            /**
            *Mission command to perform a landing. This is used as a marker in a mission to tell the autopilot where
            *			 a sequence of mission items that represents a landing starts. It may also be sent via a COMMAND_LONG
            *			 to trigger a landing, in which case the nearest (geographically) landing sequence in the mission will
            *			 be used. The Latitude/Longitude is optional, and may be set to 0 if not needed. If specified then it
            *			 will be used to help find the closest landing sequence
            *			 1	Empty
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Empty */
            MAV_CMD_DO_LAND_START = 189,
            /**
            *Mission command to perform a landing from a rally point.
            *			 1	Break altitude (meters)
            *			 2	Landing speed (m/s)
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_RALLY_LAND = 190,
            /**
            *Mission command to safely abort an autonmous landing.
            *			 1	Altitude (meters)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_GO_AROUND = 191,
            /**
            *Reposition the vehicle to a specific WGS84 global position.
            *			 1	Ground speed, less than 0 (-1) for default
            *			 2	Bitmask of option flags, see the MAV_DO_REPOSITION_FLAGS enum.
            *			 3	Reserved
            *			 4	Yaw heading, NaN for unchanged. For planes indicates loiter direction (0: clockwise, 1: counter clockwise)
            *			 5	Latitude (deg * 1E7)
            *			 6	Longitude (deg * 1E7)
            *			 7	Altitude (meters) */
            MAV_CMD_DO_REPOSITION = 192,
            /**
            *If in a GPS controlled position mode, hold the current position or continue.
            *			 1	0: Pause current mission or reposition command, hold current position. 1: Continue mission. A VTOL capable vehicle should enter hover mode (multicopter and VTOL planes). A plane should loiter with the default loiter radius.
            *			 2	Reserved
            *			 3	Reserved
            *			 4	Reserved
            *			 5	Reserved
            *			 6	Reserved
            *			 7	Reserved */
            MAV_CMD_DO_PAUSE_CONTINUE = 193,
            /**
            *Set moving direction to forward or reverse.
            *			 1	Direction (0=Forward, 1=Reverse)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_SET_REVERSE = 194,
            /**
            *Control onboard camera system.
            *			 1	Camera ID (-1 for all)
            *			 2	Transmission: 0: disabled, 1: enabled compressed, 2: enabled raw
            *			 3	Transmission mode: 0: video stream, 	>	0: single images every n seconds (decimal)
            *			 4	Recording: 0: disabled, 1: enabled compressed, 2: enabled raw
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_CONTROL_VIDEO = 200,
            /**
            *Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the
            *			 vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras
            *			 1	Region of intereset mode. (see MAV_ROI enum)
            *			 2	Waypoint index/ target ID. (see MAV_ROI enum)
            *			 3	ROI index (allows a vehicle to manage multiple ROI's)
            *			 4	Empty
            *			 5	MAV_ROI_WPNEXT: pitch offset from next waypoint, MAV_ROI_LOCATION: latitude
            *			 6	MAV_ROI_WPNEXT: roll offset from next waypoint, MAV_ROI_LOCATION: longitude
            *			 7	MAV_ROI_WPNEXT: yaw offset from next waypoint, MAV_ROI_LOCATION: altitude */
            MAV_CMD_DO_SET_ROI = 201,
            /**
            *Mission command to configure an on-board camera controller system.
            *			 1	Modes: P, TV, AV, M, Etc
            *			 2	Shutter speed: Divisor number for one second
            *			 3	Aperture: F stop number
            *			 4	ISO number e.g. 80, 100, 200, Etc
            *			 5	Exposure type enumerator
            *			 6	Command Identity
            *			 7	Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off) */
            MAV_CMD_DO_DIGICAM_CONFIGURE = 202,
            /**
            *Mission command to control an on-board camera controller system.
            *			 1	Session control e.g. show/hide lens
            *			 2	Zoom's absolute position
            *			 3	Zooming step value to offset zoom from the current position
            *			 4	Focus Locking, Unlocking or Re-locking
            *			 5	Shooting Command
            *			 6	Command Identity
            *			 7	Test shot identifier. If set to 1, image will only be captured, but not counted towards internal frame count. */
            MAV_CMD_DO_DIGICAM_CONTROL = 203,
            /**
            *Mission command to configure a camera or antenna mount
            *			 1	Mount operation mode (see MAV_MOUNT_MODE enum)
            *			 2	stabilize roll? (1 = yes, 0 = no)
            *			 3	stabilize pitch? (1 = yes, 0 = no)
            *			 4	stabilize yaw? (1 = yes, 0 = no)
            *			 5	roll input (0 = angle, 1 = angular rate)
            *			 6	pitch input (0 = angle, 1 = angular rate)
            *			 7	yaw input (0 = angle, 1 = angular rate) */
            MAV_CMD_DO_MOUNT_CONFIGURE = 204,
            /**
            *Mission command to control a camera or antenna mount
            *			 1	pitch depending on mount mode (degrees or degrees/second depending on pitch input).
            *			 2	roll depending on mount mode (degrees or degrees/second depending on roll input).
            *			 3	yaw depending on mount mode (degrees or degrees/second depending on yaw input).
            *			 4	alt in meters depending on mount mode.
            *			 5	latitude in degrees * 1E7, set if appropriate mount mode.
            *			 6	longitude in degrees * 1E7, set if appropriate mount mode.
            *			 7	MAV_MOUNT_MODE enum value */
            MAV_CMD_DO_MOUNT_CONTROL = 205,
            /**
            *Mission command to set camera trigger distance for this flight. The camera is trigerred each time this
            *			 distance is exceeded. This command can also be used to set the shutter integration time for the camera
            *			 1	Camera trigger distance (meters). 0 to stop triggering.
            *			 2	Camera shutter integration time (milliseconds). -1 or 0 to ignore
            *			 3	Trigger camera once immediately. (0 = no trigger, 1 = trigger)
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_SET_CAM_TRIGG_DIST = 206,
            /**
            *Mission command to enable the geofence
            *			 1	enable? (0=disable, 1=enable, 2=disable_floor_only)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_FENCE_ENABLE = 207,
            /**
            *Mission command to trigger a parachute
            *			 1	action (0=disable, 1=enable, 2=release, for some systems see PARACHUTE_ACTION enum, not in general message set.)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_PARACHUTE = 208,
            /**
            *Mission command to perform motor test
            *			 1	motor sequence number (a number from 1 to max number of motors on the vehicle)
            *			 2	throttle type (0=throttle percentage, 1=PWM, 2=pilot throttle channel pass-through. See MOTOR_TEST_THROTTLE_TYPE enum)
            *			 3	throttle
            *			 4	timeout (in seconds)
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_MOTOR_TEST = 209,
            /**
            *Change to/from inverted flight
            *			 1	inverted (0=normal, 1=inverted)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_INVERTED_FLIGHT = 210,
            /**
            *Mission command to operate EPM gripper
            *			 1	gripper number (a number from 1 to max number of grippers on the vehicle)
            *			 2	gripper action (0=release, 1=grab. See GRIPPER_ACTIONS enum)
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_GRIPPER = 211,
            /**
            *Enable/disable autotune
            *			 1	enable (1: enable, 0:disable)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_AUTOTUNE_ENABLE = 212,
            /**
            *Sets a desired vehicle turn angle and speed change
            *			 1	yaw angle to adjust steering by in centidegress
            *			 2	speed - normalized to 0 .. 1
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_NAV_SET_YAW_SPEED = 213,
            /**
            *Mission command to set camera trigger interval for this flight. If triggering is enabled, the camera is
            *			 triggered each time this interval expires. This command can also be used to set the shutter integration
            *			 time for the camera
            *			 1	Camera trigger cycle time (milliseconds). -1 or 0 to ignore.
            *			 2	Camera shutter integration time (milliseconds). Should be less than trigger cycle time. -1 or 0 to ignore.
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL = 214,
            /**
            *Mission command to control a camera or antenna mount, using a quaternion as reference.
            *			 1	q1 - quaternion param #1, w (1 in null-rotation)
            *			 2	q2 - quaternion param #2, x (0 in null-rotation)
            *			 3	q3 - quaternion param #3, y (0 in null-rotation)
            *			 4	q4 - quaternion param #4, z (0 in null-rotation)
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_MOUNT_CONTROL_QUAT = 220,
            /**
            *set id of master controller
            *			 1	System ID
            *			 2	Component ID
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_GUIDED_MASTER = 221,
            /**
            *set limits for external control
            *			 1	timeout - maximum time (in seconds) that external controller will be allowed to control vehicle. 0 means no timeout
            *			 2	absolute altitude min (in meters, AMSL) - if vehicle moves below this alt, the command will be aborted and the mission will continue.  0 means no lower altitude limit
            *			 3	absolute altitude max (in meters)- if vehicle moves above this alt, the command will be aborted and the mission will continue.  0 means no upper altitude limit
            *			 4	horizontal move limit (in meters, AMSL) - if vehicle moves more than this distance from it's location at the moment the command was executed, the command will be aborted and the mission will continue. 0 means no horizontal altitude limit
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_GUIDED_LIMITS = 222,
            /**
            *Control vehicle engine. This is interpreted by the vehicles engine controller to change the target engine
            *			 state. It is intended for vehicles with internal combustion engine
            *			 1	0: Stop engine, 1:Start Engine
            *			 2	0: Warm start, 1:Cold start. Controls use of choke where applicable
            *			 3	Height delay (meters). This is for commanding engine start only after the vehicle has gained the specified height. Used in VTOL vehicles during takeoff to start engine after the aircraft is off the ground. Zero for no delay.
            *			 4	Empty
            *			 5	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_ENGINE_CONTROL = 223,
            /**
            *NOP - This command is only used to mark the upper limit of the DO commands in the enumeration
            *			 1	Empty
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_LAST = 240,
            /**
            *Trigger calibration. This command will be only accepted if in pre-flight mode. Except for Temperature
            *			 Calibration, only one sensor should be set in a single message and all others should be zero
            *			 1	1: gyro calibration, 3: gyro temperature calibration
            *			 2	1: magnetometer calibration
            *			 3	1: ground pressure calibration
            *			 4	1: radio RC calibration, 2: RC trim calibration
            *			 5	1: accelerometer calibration, 2: board level calibration, 3: accelerometer temperature calibration
            *			 6	1: APM: compass/motor interference calibration (PX4: airspeed calibration, deprecated), 2: airspeed calibration
            *			 7	1: ESC calibration, 3: barometer temperature calibration */
            MAV_CMD_PREFLIGHT_CALIBRATION = 241,
            /**
            *Set sensor offsets. This command will be only accepted if in pre-flight mode.
            *			 1	Sensor to adjust the offsets for: 0: gyros, 1: accelerometer, 2: magnetometer, 3: barometer, 4: optical flow, 5: second magnetometer, 6: third magnetometer
            *			 2	X axis offset (or generic dimension 1), in the sensor's raw units
            *			 3	Y axis offset (or generic dimension 2), in the sensor's raw units
            *			 4	Z axis offset (or generic dimension 3), in the sensor's raw units
            *			 5	Generic dimension 4, in the sensor's raw units
            *			 6	Generic dimension 5, in the sensor's raw units
            *			 7	Generic dimension 6, in the sensor's raw units */
            MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS = 242,
            /**
            *Trigger UAVCAN config. This command will be only accepted if in pre-flight mode.
            *			 1	1: Trigger actuator ID assignment and direction mapping.
            *			 2	Reserved
            *			 3	Reserved
            *			 4	Reserved
            *			 5	Reserved
            *			 6	Reserved
            *			 7	Reserved */
            MAV_CMD_PREFLIGHT_UAVCAN = 243,
            /**
            *Request storage of different parameter values and logs. This command will be only accepted if in pre-flight
            *			 mode
            *			 1	Parameter storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults
            *			 2	Mission storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults
            *			 3	Onboard logging: 0: Ignore, 1: Start default rate logging, -1: Stop logging, 	>	1: start logging with rate of param 3 in Hz (e.g. set to 1000 for 1000 Hz logging)
            *			 4	Reserved
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_PREFLIGHT_STORAGE = 245,
            /**
            *Request the reboot or shutdown of system components.
            *			 1	0: Do nothing for autopilot, 1: Reboot autopilot, 2: Shutdown autopilot, 3: Reboot autopilot and keep it in the bootloader until upgraded.
            *			 2	0: Do nothing for onboard computer, 1: Reboot onboard computer, 2: Shutdown onboard computer, 3: Reboot onboard computer and keep it in the bootloader until upgraded.
            *			 3	WIP: 0: Do nothing for camera, 1: Reboot onboard camera, 2: Shutdown onboard camera, 3: Reboot onboard camera and keep it in the bootloader until upgraded
            *			 4	WIP: 0: Do nothing for mount (e.g. gimbal), 1: Reboot mount, 2: Shutdown mount, 3: Reboot mount and keep it in the bootloader until upgraded
            *			 5	Reserved, send 0
            *			 6	Reserved, send 0
            *			 7	WIP: ID (e.g. camera ID -1 for all IDs) */
            MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN = 246,
            /**
            *Hold / continue the current action
            *			 1	MAV_GOTO_DO_HOLD: hold MAV_GOTO_DO_CONTINUE: continue with next item in mission plan
            *			 2	MAV_GOTO_HOLD_AT_CURRENT_POSITION: Hold at current position MAV_GOTO_HOLD_AT_SPECIFIED_POSITION: hold at specified position
            *			 3	MAV_FRAME coordinate frame of hold point
            *			 4	Desired yaw angle in degrees
            *			 5	Latitude / X position
            *			 6	Longitude / Y position
            *			 7	Altitude / Z position */
            MAV_CMD_OVERRIDE_GOTO = 252,
            /**
            *start running a mission
            *			 1	first_item: the first mission item to run
            *			 2	last_item:  the last mission item to run (after this item is run, the mission ends) */
            MAV_CMD_MISSION_START = 300,
            /**
            *Arms / Disarms a component
            *			 1	1 to arm, 0 to disarm */
            MAV_CMD_COMPONENT_ARM_DISARM = 400,
            /**
            *Request the home position from the vehicle.
            *			 1	Reserved
            *			 2	Reserved
            *			 3	Reserved
            *			 4	Reserved
            *			 5	Reserved
            *			 6	Reserved
            *			 7	Reserved */
            MAV_CMD_GET_HOME_POSITION = 410,
            /**
            *Starts receiver pairing
            *			 1	0:Spektrum
            *			 2	0:Spektrum DSM2, 1:Spektrum DSMX */
            MAV_CMD_START_RX_PAIR = 500,
            /**
            *Request the interval between messages for a particular MAVLink message ID
            *			 1	The MAVLink message ID */
            MAV_CMD_GET_MESSAGE_INTERVAL = 510,
            /**
            *Request the interval between messages for a particular MAVLink message ID. This interface replaces REQUEST_DATA_STREA
            *			 1	The MAVLink message ID
            *			 2	The interval between two messages, in microseconds. Set to -1 to disable and 0 to request default rate. */
            MAV_CMD_SET_MESSAGE_INTERVAL = 511,
            /**
            *Request MAVLink protocol version compatibility
            *			 1	1: Request supported protocol versions by all nodes on the network
            *			 2	Reserved (all remaining params) */
            MAV_CMD_REQUEST_PROTOCOL_VERSION = 519,
            /**
            *Request autopilot capabilities
            *			 1	1: Request autopilot version
            *			 2	Reserved (all remaining params) */
            MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES = 520,
            /**
            *WIP: Request camera information (CAMERA_INFORMATION).
            *			 1	0: No action 1: Request camera capabilities
            *			 2	Reserved (all remaining params) */
            MAV_CMD_REQUEST_CAMERA_INFORMATION = 521,
            /**
            *WIP: Request camera settings (CAMERA_SETTINGS).
            *			 1	0: No Action 1: Request camera settings
            *			 2	Reserved (all remaining params) */
            MAV_CMD_REQUEST_CAMERA_SETTINGS = 522,
            /**
            *WIP: Request storage information (STORAGE_INFORMATION). Use the command's target_component to target a
            *			 specific component's storage
            *			 1	Storage ID (0 for all, 1 for first, 2 for second, etc.)
            *			 2	0: No Action 1: Request storage information
            *			 3	Reserved (all remaining params) */
            MAV_CMD_REQUEST_STORAGE_INFORMATION = 525,
            /**
            *WIP: Format a storage medium. Once format is complete, a STORAGE_INFORMATION message is sent. Use the
            *			 command's target_component to target a specific component's storage
            *			 1	Storage ID (1 for first, 2 for second, etc.)
            *			 2	0: No action 1: Format storage
            *			 3	Reserved (all remaining params) */
            MAV_CMD_STORAGE_FORMAT = 526,
            /**
            *WIP: Request camera capture status (CAMERA_CAPTURE_STATUS)
            *			 1	0: No Action 1: Request camera capture status
            *			 2	Reserved (all remaining params) */
            MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS = 527,
            /**
            *WIP: Request flight information (FLIGHT_INFORMATION)
            *			 1	1: Request flight information
            *			 2	Reserved (all remaining params) */
            MAV_CMD_REQUEST_FLIGHT_INFORMATION = 528,
            /**
            *WIP: Reset all camera settings to Factory Default
            *			 1	0: No Action 1: Reset all settings
            *			 2	Reserved (all remaining params) */
            MAV_CMD_RESET_CAMERA_SETTINGS = 529,
            /**
            *Set camera running mode. Use NAN for reserved values.
            *			 1	Reserved (Set to 0)
            *			 2	Camera mode (see CAMERA_MODE enum)
            *			 3	Reserved (all remaining params) */
            MAV_CMD_SET_CAMERA_MODE = 530,
            /**
            *Start image capture sequence. Sends CAMERA_IMAGE_CAPTURED after each capture. Use NAN for reserved values
            *			 1	Reserved (Set to 0)
            *			 2	Duration between two consecutive pictures (in seconds)
            *			 3	Number of images to capture total - 0 for unlimited capture
            *			 4	Reserved (all remaining params) */
            MAV_CMD_IMAGE_START_CAPTURE = 2000,
            /**
            *Stop image capture sequence Use NAN for reserved values.
            *			 1	Reserved (Set to 0)
            *			 2	Reserved (all remaining params) */
            MAV_CMD_IMAGE_STOP_CAPTURE = 2001,
            /**
            *WIP: Re-request a CAMERA_IMAGE_CAPTURE packet. Use NAN for reserved values.
            *			 1	Sequence number for missing CAMERA_IMAGE_CAPTURE packet
            *			 2	Reserved (all remaining params) */
            MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE = 2002,
            /**
            *Enable or disable on-board camera triggering system.
            *			 1	Trigger enable/disable (0 for disable, 1 for start), -1 to ignore
            *			 2	1 to reset the trigger sequence, -1 or 0 to ignore
            *			 3	1 to pause triggering, but without switching the camera off or retracting it. -1 to ignore */
            MAV_CMD_DO_TRIGGER_CONTROL = 2003,
            /**
            *Starts video capture (recording). Use NAN for reserved values.
            *			 1	Reserved (Set to 0)
            *			 2	Frequency CAMERA_CAPTURE_STATUS messages should be sent while recording (0 for no messages, otherwise frequency in Hz)
            *			 3	Reserved (all remaining params) */
            MAV_CMD_VIDEO_START_CAPTURE = 2500,
            /**
            *Stop the current video capture (recording). Use NAN for reserved values.
            *			 1	Reserved (Set to 0)
            *			 2	Reserved (all remaining params) */
            MAV_CMD_VIDEO_STOP_CAPTURE = 2501,
            /**
            *WIP: Start video streaming
            *			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
            *			 2	Reserved */
            MAV_CMD_VIDEO_START_STREAMING = 2502,
            /**
            *WIP: Stop the current video streaming
            *			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
            *			 2	Reserved */
            MAV_CMD_VIDEO_STOP_STREAMING = 2503,
            /**
            *WIP: Request video stream information (VIDEO_STREAM_INFORMATION)
            *			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
            *			 2	0: No Action 1: Request video stream information
            *			 3	Reserved (all remaining params) */
            MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION = 2504,
            /**
            *Request to start streaming logging data over MAVLink (see also LOGGING_DATA message)
            *			 1	Format: 0: ULog
            *			 2	Reserved (set to 0)
            *			 3	Reserved (set to 0)
            *			 4	Reserved (set to 0)
            *			 5	Reserved (set to 0)
            *			 6	Reserved (set to 0)
            *			 7	Reserved (set to 0) */
            MAV_CMD_LOGGING_START = 2510,
            /**
            *Request to stop streaming log data over MAVLink
            *			 1	Reserved (set to 0)
            *			 2	Reserved (set to 0)
            *			 3	Reserved (set to 0)
            *			 4	Reserved (set to 0)
            *			 5	Reserved (set to 0)
            *			 6	Reserved (set to 0)
            *			 7	Reserved (set to 0) */
            MAV_CMD_LOGGING_STOP = 2511,
            /**
            *1	Landing gear ID (default: 0, -1 for all)
            *			 2	Landing gear position (Down: 0, Up: 1, NAN for no change)
            *			 3	Reserved, set to NAN
            *			 4	Reserved, set to NAN
            *			 5	Reserved, set to NAN
            *			 6	Reserved, set to NAN
            *			 7	Reserved, set to NAN */
            MAV_CMD_AIRFRAME_CONFIGURATION = 2520,
            /**
            *Create a panorama at the current position
            *			 1	Viewing angle horizontal of the panorama (in degrees, +- 0.5 the total angle)
            *			 2	Viewing angle vertical of panorama (in degrees)
            *			 3	Speed of the horizontal rotation (in degrees per second)
            *			 4	Speed of the vertical rotation (in degrees per second) */
            MAV_CMD_PANORAMA_CREATE = 2800,
            /**
            *Request VTOL transition
            *			 1	The target VTOL state, as defined by ENUM MAV_VTOL_STATE. Only MAV_VTOL_STATE_MC and MAV_VTOL_STATE_FW can be used. */
            MAV_CMD_DO_VTOL_TRANSITION = 3000,
            /**
            *Request authorization to arm the vehicle to a external entity, the arm authorizer is resposible to request all data that is needs from the vehicle before authorize or deny the request. If approved the progress of command_ack message should be set with period of time that this authorization is valid in seconds or in case it was denied it should be set with one of the reasons in ARM_AUTH_DENIED_REASON.
            *			 <p>
            *			 1	Vehicle system id, this way ground station can request arm authorization on behalf of any vehicle */
            MAV_CMD_ARM_AUTHORIZATION_REQUEST = 3001,
            /**
            *This command sets the submode to standard guided when vehicle is in guided mode. The vehicle holds position and altitude and the user can input the desired velocites along all three axes. */
            MAV_CMD_SET_GUIDED_SUBMODE_STANDARD = 4000,
            /**
            *This command sets submode circle when vehicle is in guided mode. Vehicle flies along a circle facing the center of the circle. The user can input the velocity along the circle and change the radius. If no input is given the vehicle will hold position.
            *			 <p>
            *			 1	Radius of desired circle in CIRCLE_MODE
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	Unscaled target latitude of center of circle in CIRCLE_MODE
            *			 6	Unscaled target longitude of center of circle in CIRCLE_MODE */
            MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE = 4001,
            /**
            *WIP: Delay mission state machine until gate has been reached.
            *			 1	Geometry: 0: orthogonal to path between previous and next waypoint.
            *			 2	Altitude: 0: ignore altitude
            *			 3	Empty
            *			 4	Empty
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude */
            MAV_CMD_CONDITION_GATE = 4501,
            /**
            *Fence return point. There can only be one fence return point.
            *			 <p>
            *			 1	Reserved
            *			 2	Reserved
            *			 3	Reserved
            *			 4	Reserved
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude */
            MAV_CMD_NAV_FENCE_RETURN_POINT = 5000,
            /**
            *Fence vertex for an inclusion polygon (the polygon must not be self-intersecting). The vehicle must stay within this area. Minimum of 3 vertices required.
            *			 <p>
            *			 1	Polygon vertex count
            *			 2	Reserved
            *			 3	Reserved
            *			 4	Reserved
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Reserved */
            MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION = 5001,
            /**
            *Fence vertex for an exclusion polygon (the polygon must not be self-intersecting). The vehicle must stay outside this area. Minimum of 3 vertices required.
            *			 <p>
            *			 1	Polygon vertex count
            *			 2	Reserved
            *			 3	Reserved
            *			 4	Reserved
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Reserved */
            MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION = 5002,
            /**
            *Circular fence area. The vehicle must stay inside this area.
            *			 <p>
            *			 1	radius in meters
            *			 2	Reserved
            *			 3	Reserved
            *			 4	Reserved
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Reserved */
            MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION = 5003,
            /**
            *Circular fence area. The vehicle must stay outside this area.
            *			 <p>
            *			 1	radius in meters
            *			 2	Reserved
            *			 3	Reserved
            *			 4	Reserved
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Reserved */
            MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION = 5004,
            /**
            *Rally point. You can have multiple rally points defined.
            *			 <p>
            *			 1	Reserved
            *			 2	Reserved
            *			 3	Reserved
            *			 4	Reserved
            *			 5	Latitude
            *			 6	Longitude
            *			 7	Altitude */
            MAV_CMD_NAV_RALLY_POINT = 5100,
            /**
            *Commands the vehicle to respond with a sequence of messages UAVCAN_NODE_INFO, one message per every UAVCAN
            *			 node that is online. Note that some of the response messages can be lost, which the receiver can detect
            *			 easily by checking whether every received UAVCAN_NODE_STATUS has a matching message UAVCAN_NODE_INFO
            *			 received earlier; if not, this command should be sent again in order to request re-transmission of the
            *			 node information messages
            *			 1	Reserved (set to 0)
            *			 2	Reserved (set to 0)
            *			 3	Reserved (set to 0)
            *			 4	Reserved (set to 0)
            *			 5	Reserved (set to 0)
            *			 6	Reserved (set to 0)
            *			 7	Reserved (set to 0) */
            MAV_CMD_UAVCAN_GET_NODE_INFO = 5200,
            /**
            *Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release
            *			 position and velocity
            *			 1	Operation mode. 0: prepare single payload deploy (overwriting previous requests), but do not execute it. 1: execute payload deploy immediately (rejecting further deploy commands during execution, but allowing abort). 2: add payload deploy to existing deployment list.
            *			 2	Desired approach vector in degrees compass heading (0..360). A negative value indicates the system can define the approach vector at will.
            *			 3	Desired ground speed at release time. This can be overriden by the airframe in case it needs to meet minimum airspeed. A negative value indicates the system can define the ground speed at will.
            *			 4	Minimum altitude clearance to the release position in meters. A negative value indicates the system can define the clearance at will.
            *			 5	Latitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT
            *			 6	Longitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT
            *			 7	Altitude, in meters AMSL */
            MAV_CMD_PAYLOAD_PREPARE_DEPLOY = 30001,
            /**
            *Control the payload deployment.
            *			 1	Operation mode. 0: Abort deployment, continue normal mission. 1: switch to payload deploment mode. 100: delete first payload deployment request. 101: delete all payload deployment requests.
            *			 2	Reserved
            *			 3	Reserved
            *			 4	Reserved
            *			 5	Reserved
            *			 6	Reserved
            *			 7	Reserved */
            MAV_CMD_PAYLOAD_CONTROL_DEPLOY = 30002,
            /**
            *User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	Latitude unscaled
            *			 6	Longitude unscaled
            *			 7	Altitude, in meters AMSL */
            MAV_CMD_WAYPOINT_USER_1 = 31000,
            /**
            *User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	Latitude unscaled
            *			 6	Longitude unscaled
            *			 7	Altitude, in meters AMSL */
            MAV_CMD_WAYPOINT_USER_2 = 31001,
            /**
            *User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	Latitude unscaled
            *			 6	Longitude unscaled
            *			 7	Altitude, in meters AMSL */
            MAV_CMD_WAYPOINT_USER_3 = 31002,
            /**
            *User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	Latitude unscaled
            *			 6	Longitude unscaled
            *			 7	Altitude, in meters AMSL */
            MAV_CMD_WAYPOINT_USER_4 = 31003,
            /**
            *User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	Latitude unscaled
            *			 6	Longitude unscaled
            *			 7	Altitude, in meters AMSL */
            MAV_CMD_WAYPOINT_USER_5 = 31004,
            /**
            *User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
            *			 ROI item
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	Latitude unscaled
            *			 6	Longitude unscaled
            *			 7	Altitude, in meters AMSL */
            MAV_CMD_SPATIAL_USER_1 = 31005,
            /**
            *User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
            *			 ROI item
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	Latitude unscaled
            *			 6	Longitude unscaled
            *			 7	Altitude, in meters AMSL */
            MAV_CMD_SPATIAL_USER_2 = 31006,
            /**
            *User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
            *			 ROI item
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	Latitude unscaled
            *			 6	Longitude unscaled
            *			 7	Altitude, in meters AMSL */
            MAV_CMD_SPATIAL_USER_3 = 31007,
            /**
            *User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
            *			 ROI item
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	Latitude unscaled
            *			 6	Longitude unscaled
            *			 7	Altitude, in meters AMSL */
            MAV_CMD_SPATIAL_USER_4 = 31008,
            /**
            *User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
            *			 ROI item
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	Latitude unscaled
            *			 6	Longitude unscaled
            *			 7	Altitude, in meters AMSL */
            MAV_CMD_SPATIAL_USER_5 = 31009,
            /**
            *User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
            *			 item
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	User defined
            *			 6	User defined
            *			 7	User defined */
            MAV_CMD_USER_1 = 31010,
            /**
            *User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
            *			 item
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	User defined
            *			 6	User defined
            *			 7	User defined */
            MAV_CMD_USER_2 = 31011,
            /**
            *User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
            *			 item
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	User defined
            *			 6	User defined
            *			 7	User defined */
            MAV_CMD_USER_3 = 31012,
            /**
            *User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
            *			 item
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	User defined
            *			 6	User defined
            *			 7	User defined */
            MAV_CMD_USER_4 = 31013,
            /**
            *User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
            *			 item
            *			 1	User defined
            *			 2	User defined
            *			 3	User defined
            *			 4	User defined
            *			 5	User defined
            *			 6	User defined
            *			 7	User defined */
            MAV_CMD_USER_5 = 31014,
            /**
            *A system wide power-off event has been initiated.
            *			 1	Empty
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_POWER_OFF_INITIATED = 42000,
            /**
            *FLY button has been clicked.
            *			 1	Empty
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_SOLO_BTN_FLY_CLICK = 42001,
            /**
            *FLY button has been held for 1.5 seconds.
            *			 1	Takeoff altitude
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_SOLO_BTN_FLY_HOLD = 42002,
            /**
            *PAUSE button has been clicked.
            *			 1	1 if Solo is in a shot mode, 0 otherwise
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_SOLO_BTN_PAUSE_CLICK = 42003,
            /**
            *Initiate a magnetometer calibration
            *			 1	uint8_t bitmask of magnetometers (0 means all)
            *			 2	Automatically retry on failure (0=no retry, 1=retry).
            *			 3	Save without user input (0=require input, 1=autosave).
            *			 4	Delay (seconds)
            *			 5	Autoreboot (0=user reboot, 1=autoreboot)
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_START_MAG_CAL = 42424,
            /**
            *Initiate a magnetometer calibration
            *			 1	uint8_t bitmask of magnetometers (0 means all)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_ACCEPT_MAG_CAL = 42425,
            /**
            *Cancel a running magnetometer calibration
            *			 1	uint8_t bitmask of magnetometers (0 means all)
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_CANCEL_MAG_CAL = 42426,
            /**
            *Command autopilot to get into factory test/diagnostic mode
            *			 1	0 means get out of test mode, 1 means get into test mode
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_SET_FACTORY_TEST_MODE = 42427,
            /**
            *Reply with the version banner
            *			 1	Empty
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_DO_SEND_BANNER = 42428,
            /**
            *Used when doing accelerometer calibration. When sent to the GCS tells it what position to put the vehicle
            *			 in. When sent to the vehicle says what position the vehicle is in
            *			 1	Position, one of the ACCELCAL_VEHICLE_POS enum values
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_ACCELCAL_VEHICLE_POS = 42429,
            /**
            *Causes the gimbal to reset and boot as if it was just powered on
            *			 1	Empty
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_GIMBAL_RESET = 42501,
            /**
            *Reports progress and success or failure of gimbal axis calibration procedure
            *			 1	Gimbal axis we're reporting calibration progress for
            *			 2	Current calibration progress for this axis, 0x64=100%
            *			 3	Status of the calibration
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS = 42502,
            /**
            *Starts commutation calibration on the gimbal
            *			 1	Empty
            *			 2	Empty
            *			 3	Empty
            *			 4	Empty
            *			 5	Empty
            *			 6	Empty
            *			 7	Empty */
            MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION = 42503,
            /**
            *Erases gimbal application and parameters
            *			 1	Magic number
            *			 2	Magic number
            *			 3	Magic number
            *			 4	Magic number
            *			 5	Magic number
            *			 6	Magic number
            *			 7	Magic number */
            MAV_CMD_GIMBAL_FULL_RESET = 42505
        }

        public static class MAV_CMD_
        {

            internal static MAV_CMD from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return MAV_CMD.MAV_CMD_NAV_WAYPOINT;
                    case 1:
                        return MAV_CMD.MAV_CMD_NAV_LOITER_UNLIM;
                    case 2:
                        return MAV_CMD.MAV_CMD_NAV_LOITER_TURNS;
                    case 3:
                        return MAV_CMD.MAV_CMD_NAV_LOITER_TIME;
                    case 4:
                        return MAV_CMD.MAV_CMD_NAV_RETURN_TO_LAUNCH;
                    case 5:
                        return MAV_CMD.MAV_CMD_NAV_LAND;
                    case 6:
                        return MAV_CMD.MAV_CMD_NAV_TAKEOFF;
                    case 7:
                        return MAV_CMD.MAV_CMD_NAV_LAND_LOCAL;
                    case 8:
                        return MAV_CMD.MAV_CMD_NAV_TAKEOFF_LOCAL;
                    case 9:
                        return MAV_CMD.MAV_CMD_NAV_FOLLOW;
                    case 10:
                        return MAV_CMD.MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT;
                    case 11:
                        return MAV_CMD.MAV_CMD_NAV_LOITER_TO_ALT;
                    case 12:
                        return MAV_CMD.MAV_CMD_DO_FOLLOW;
                    case 13:
                        return MAV_CMD.MAV_CMD_DO_FOLLOW_REPOSITION;
                    case 14:
                        return MAV_CMD.MAV_CMD_NAV_ROI;
                    case 15:
                        return MAV_CMD.MAV_CMD_NAV_PATHPLANNING;
                    case 16:
                        return MAV_CMD.MAV_CMD_NAV_SPLINE_WAYPOINT;
                    case 17:
                        return MAV_CMD.MAV_CMD_NAV_ALTITUDE_WAIT;
                    case 18:
                        return MAV_CMD.MAV_CMD_NAV_VTOL_TAKEOFF;
                    case 19:
                        return MAV_CMD.MAV_CMD_NAV_VTOL_LAND;
                    case 20:
                        return MAV_CMD.MAV_CMD_NAV_GUIDED_ENABLE;
                    case 21:
                        return MAV_CMD.MAV_CMD_NAV_DELAY;
                    case 22:
                        return MAV_CMD.MAV_CMD_NAV_PAYLOAD_PLACE;
                    case 23:
                        return MAV_CMD.MAV_CMD_NAV_LAST;
                    case 24:
                        return MAV_CMD.MAV_CMD_CONDITION_DELAY;
                    case 25:
                        return MAV_CMD.MAV_CMD_CONDITION_CHANGE_ALT;
                    case 26:
                        return MAV_CMD.MAV_CMD_CONDITION_DISTANCE;
                    case 27:
                        return MAV_CMD.MAV_CMD_CONDITION_YAW;
                    case 28:
                        return MAV_CMD.MAV_CMD_CONDITION_LAST;
                    case 29:
                        return MAV_CMD.MAV_CMD_DO_SET_MODE;
                    case 30:
                        return MAV_CMD.MAV_CMD_DO_JUMP;
                    case 31:
                        return MAV_CMD.MAV_CMD_DO_CHANGE_SPEED;
                    case 32:
                        return MAV_CMD.MAV_CMD_DO_SET_HOME;
                    case 33:
                        return MAV_CMD.MAV_CMD_DO_SET_PARAMETER;
                    case 34:
                        return MAV_CMD.MAV_CMD_DO_SET_RELAY;
                    case 35:
                        return MAV_CMD.MAV_CMD_DO_REPEAT_RELAY;
                    case 36:
                        return MAV_CMD.MAV_CMD_DO_SET_SERVO;
                    case 37:
                        return MAV_CMD.MAV_CMD_DO_REPEAT_SERVO;
                    case 38:
                        return MAV_CMD.MAV_CMD_DO_FLIGHTTERMINATION;
                    case 39:
                        return MAV_CMD.MAV_CMD_DO_CHANGE_ALTITUDE;
                    case 40:
                        return MAV_CMD.MAV_CMD_DO_LAND_START;
                    case 41:
                        return MAV_CMD.MAV_CMD_DO_RALLY_LAND;
                    case 42:
                        return MAV_CMD.MAV_CMD_DO_GO_AROUND;
                    case 43:
                        return MAV_CMD.MAV_CMD_DO_REPOSITION;
                    case 44:
                        return MAV_CMD.MAV_CMD_DO_PAUSE_CONTINUE;
                    case 45:
                        return MAV_CMD.MAV_CMD_DO_SET_REVERSE;
                    case 46:
                        return MAV_CMD.MAV_CMD_DO_CONTROL_VIDEO;
                    case 47:
                        return MAV_CMD.MAV_CMD_DO_SET_ROI;
                    case 48:
                        return MAV_CMD.MAV_CMD_DO_DIGICAM_CONFIGURE;
                    case 49:
                        return MAV_CMD.MAV_CMD_DO_DIGICAM_CONTROL;
                    case 50:
                        return MAV_CMD.MAV_CMD_DO_MOUNT_CONFIGURE;
                    case 51:
                        return MAV_CMD.MAV_CMD_DO_MOUNT_CONTROL;
                    case 52:
                        return MAV_CMD.MAV_CMD_DO_SET_CAM_TRIGG_DIST;
                    case 53:
                        return MAV_CMD.MAV_CMD_DO_FENCE_ENABLE;
                    case 54:
                        return MAV_CMD.MAV_CMD_DO_PARACHUTE;
                    case 55:
                        return MAV_CMD.MAV_CMD_DO_MOTOR_TEST;
                    case 56:
                        return MAV_CMD.MAV_CMD_DO_INVERTED_FLIGHT;
                    case 57:
                        return MAV_CMD.MAV_CMD_DO_GRIPPER;
                    case 58:
                        return MAV_CMD.MAV_CMD_DO_AUTOTUNE_ENABLE;
                    case 59:
                        return MAV_CMD.MAV_CMD_NAV_SET_YAW_SPEED;
                    case 60:
                        return MAV_CMD.MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL;
                    case 61:
                        return MAV_CMD.MAV_CMD_DO_MOUNT_CONTROL_QUAT;
                    case 62:
                        return MAV_CMD.MAV_CMD_DO_GUIDED_MASTER;
                    case 63:
                        return MAV_CMD.MAV_CMD_DO_GUIDED_LIMITS;
                    case 64:
                        return MAV_CMD.MAV_CMD_DO_ENGINE_CONTROL;
                    case 65:
                        return MAV_CMD.MAV_CMD_DO_LAST;
                    case 66:
                        return MAV_CMD.MAV_CMD_PREFLIGHT_CALIBRATION;
                    case 67:
                        return MAV_CMD.MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS;
                    case 68:
                        return MAV_CMD.MAV_CMD_PREFLIGHT_UAVCAN;
                    case 69:
                        return MAV_CMD.MAV_CMD_PREFLIGHT_STORAGE;
                    case 70:
                        return MAV_CMD.MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN;
                    case 71:
                        return MAV_CMD.MAV_CMD_OVERRIDE_GOTO;
                    case 72:
                        return MAV_CMD.MAV_CMD_MISSION_START;
                    case 73:
                        return MAV_CMD.MAV_CMD_COMPONENT_ARM_DISARM;
                    case 74:
                        return MAV_CMD.MAV_CMD_GET_HOME_POSITION;
                    case 75:
                        return MAV_CMD.MAV_CMD_START_RX_PAIR;
                    case 76:
                        return MAV_CMD.MAV_CMD_GET_MESSAGE_INTERVAL;
                    case 77:
                        return MAV_CMD.MAV_CMD_SET_MESSAGE_INTERVAL;
                    case 78:
                        return MAV_CMD.MAV_CMD_REQUEST_PROTOCOL_VERSION;
                    case 79:
                        return MAV_CMD.MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES;
                    case 80:
                        return MAV_CMD.MAV_CMD_REQUEST_CAMERA_INFORMATION;
                    case 81:
                        return MAV_CMD.MAV_CMD_REQUEST_CAMERA_SETTINGS;
                    case 82:
                        return MAV_CMD.MAV_CMD_REQUEST_STORAGE_INFORMATION;
                    case 83:
                        return MAV_CMD.MAV_CMD_STORAGE_FORMAT;
                    case 84:
                        return MAV_CMD.MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS;
                    case 85:
                        return MAV_CMD.MAV_CMD_REQUEST_FLIGHT_INFORMATION;
                    case 86:
                        return MAV_CMD.MAV_CMD_RESET_CAMERA_SETTINGS;
                    case 87:
                        return MAV_CMD.MAV_CMD_SET_CAMERA_MODE;
                    case 88:
                        return MAV_CMD.MAV_CMD_IMAGE_START_CAPTURE;
                    case 89:
                        return MAV_CMD.MAV_CMD_IMAGE_STOP_CAPTURE;
                    case 90:
                        return MAV_CMD.MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE;
                    case 91:
                        return MAV_CMD.MAV_CMD_DO_TRIGGER_CONTROL;
                    case 92:
                        return MAV_CMD.MAV_CMD_VIDEO_START_CAPTURE;
                    case 93:
                        return MAV_CMD.MAV_CMD_VIDEO_STOP_CAPTURE;
                    case 94:
                        return MAV_CMD.MAV_CMD_VIDEO_START_STREAMING;
                    case 95:
                        return MAV_CMD.MAV_CMD_VIDEO_STOP_STREAMING;
                    case 96:
                        return MAV_CMD.MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION;
                    case 97:
                        return MAV_CMD.MAV_CMD_LOGGING_START;
                    case 98:
                        return MAV_CMD.MAV_CMD_LOGGING_STOP;
                    case 99:
                        return MAV_CMD.MAV_CMD_AIRFRAME_CONFIGURATION;
                    case 100:
                        return MAV_CMD.MAV_CMD_PANORAMA_CREATE;
                    case 101:
                        return MAV_CMD.MAV_CMD_DO_VTOL_TRANSITION;
                    case 102:
                        return MAV_CMD.MAV_CMD_ARM_AUTHORIZATION_REQUEST;
                    case 103:
                        return MAV_CMD.MAV_CMD_SET_GUIDED_SUBMODE_STANDARD;
                    case 104:
                        return MAV_CMD.MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE;
                    case 105:
                        return MAV_CMD.MAV_CMD_CONDITION_GATE;
                    case 106:
                        return MAV_CMD.MAV_CMD_NAV_FENCE_RETURN_POINT;
                    case 107:
                        return MAV_CMD.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION;
                    case 108:
                        return MAV_CMD.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION;
                    case 109:
                        return MAV_CMD.MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION;
                    case 110:
                        return MAV_CMD.MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION;
                    case 111:
                        return MAV_CMD.MAV_CMD_NAV_RALLY_POINT;
                    case 112:
                        return MAV_CMD.MAV_CMD_UAVCAN_GET_NODE_INFO;
                    case 113:
                        return MAV_CMD.MAV_CMD_PAYLOAD_PREPARE_DEPLOY;
                    case 114:
                        return MAV_CMD.MAV_CMD_PAYLOAD_CONTROL_DEPLOY;
                    case 115:
                        return MAV_CMD.MAV_CMD_WAYPOINT_USER_1;
                    case 116:
                        return MAV_CMD.MAV_CMD_WAYPOINT_USER_2;
                    case 117:
                        return MAV_CMD.MAV_CMD_WAYPOINT_USER_3;
                    case 118:
                        return MAV_CMD.MAV_CMD_WAYPOINT_USER_4;
                    case 119:
                        return MAV_CMD.MAV_CMD_WAYPOINT_USER_5;
                    case 120:
                        return MAV_CMD.MAV_CMD_SPATIAL_USER_1;
                    case 121:
                        return MAV_CMD.MAV_CMD_SPATIAL_USER_2;
                    case 122:
                        return MAV_CMD.MAV_CMD_SPATIAL_USER_3;
                    case 123:
                        return MAV_CMD.MAV_CMD_SPATIAL_USER_4;
                    case 124:
                        return MAV_CMD.MAV_CMD_SPATIAL_USER_5;
                    case 125:
                        return MAV_CMD.MAV_CMD_USER_1;
                    case 126:
                        return MAV_CMD.MAV_CMD_USER_2;
                    case 127:
                        return MAV_CMD.MAV_CMD_USER_3;
                    case 128:
                        return MAV_CMD.MAV_CMD_USER_4;
                    case 129:
                        return MAV_CMD.MAV_CMD_USER_5;
                    case 130:
                        return MAV_CMD.MAV_CMD_POWER_OFF_INITIATED;
                    case 131:
                        return MAV_CMD.MAV_CMD_SOLO_BTN_FLY_CLICK;
                    case 132:
                        return MAV_CMD.MAV_CMD_SOLO_BTN_FLY_HOLD;
                    case 133:
                        return MAV_CMD.MAV_CMD_SOLO_BTN_PAUSE_CLICK;
                    case 134:
                        return MAV_CMD.MAV_CMD_DO_START_MAG_CAL;
                    case 135:
                        return MAV_CMD.MAV_CMD_DO_ACCEPT_MAG_CAL;
                    case 136:
                        return MAV_CMD.MAV_CMD_DO_CANCEL_MAG_CAL;
                    case 137:
                        return MAV_CMD.MAV_CMD_SET_FACTORY_TEST_MODE;
                    case 138:
                        return MAV_CMD.MAV_CMD_DO_SEND_BANNER;
                    case 139:
                        return MAV_CMD.MAV_CMD_ACCELCAL_VEHICLE_POS;
                    case 140:
                        return MAV_CMD.MAV_CMD_GIMBAL_RESET;
                    case 141:
                        return MAV_CMD.MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS;
                    case 142:
                        return MAV_CMD.MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION;
                    case 143:
                        return MAV_CMD.MAV_CMD_GIMBAL_FULL_RESET;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this MAV_CMD en)
            {
                switch(en)
                {
                    case MAV_CMD.MAV_CMD_NAV_WAYPOINT:
                        return 0;
                    case MAV_CMD.MAV_CMD_NAV_LOITER_UNLIM:
                        return 1;
                    case MAV_CMD.MAV_CMD_NAV_LOITER_TURNS:
                        return 2;
                    case MAV_CMD.MAV_CMD_NAV_LOITER_TIME:
                        return 3;
                    case MAV_CMD.MAV_CMD_NAV_RETURN_TO_LAUNCH:
                        return 4;
                    case MAV_CMD.MAV_CMD_NAV_LAND:
                        return 5;
                    case MAV_CMD.MAV_CMD_NAV_TAKEOFF:
                        return 6;
                    case MAV_CMD.MAV_CMD_NAV_LAND_LOCAL:
                        return 7;
                    case MAV_CMD.MAV_CMD_NAV_TAKEOFF_LOCAL:
                        return 8;
                    case MAV_CMD.MAV_CMD_NAV_FOLLOW:
                        return 9;
                    case MAV_CMD.MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT:
                        return 10;
                    case MAV_CMD.MAV_CMD_NAV_LOITER_TO_ALT:
                        return 11;
                    case MAV_CMD.MAV_CMD_DO_FOLLOW:
                        return 12;
                    case MAV_CMD.MAV_CMD_DO_FOLLOW_REPOSITION:
                        return 13;
                    case MAV_CMD.MAV_CMD_NAV_ROI:
                        return 14;
                    case MAV_CMD.MAV_CMD_NAV_PATHPLANNING:
                        return 15;
                    case MAV_CMD.MAV_CMD_NAV_SPLINE_WAYPOINT:
                        return 16;
                    case MAV_CMD.MAV_CMD_NAV_ALTITUDE_WAIT:
                        return 17;
                    case MAV_CMD.MAV_CMD_NAV_VTOL_TAKEOFF:
                        return 18;
                    case MAV_CMD.MAV_CMD_NAV_VTOL_LAND:
                        return 19;
                    case MAV_CMD.MAV_CMD_NAV_GUIDED_ENABLE:
                        return 20;
                    case MAV_CMD.MAV_CMD_NAV_DELAY:
                        return 21;
                    case MAV_CMD.MAV_CMD_NAV_PAYLOAD_PLACE:
                        return 22;
                    case MAV_CMD.MAV_CMD_NAV_LAST:
                        return 23;
                    case MAV_CMD.MAV_CMD_CONDITION_DELAY:
                        return 24;
                    case MAV_CMD.MAV_CMD_CONDITION_CHANGE_ALT:
                        return 25;
                    case MAV_CMD.MAV_CMD_CONDITION_DISTANCE:
                        return 26;
                    case MAV_CMD.MAV_CMD_CONDITION_YAW:
                        return 27;
                    case MAV_CMD.MAV_CMD_CONDITION_LAST:
                        return 28;
                    case MAV_CMD.MAV_CMD_DO_SET_MODE:
                        return 29;
                    case MAV_CMD.MAV_CMD_DO_JUMP:
                        return 30;
                    case MAV_CMD.MAV_CMD_DO_CHANGE_SPEED:
                        return 31;
                    case MAV_CMD.MAV_CMD_DO_SET_HOME:
                        return 32;
                    case MAV_CMD.MAV_CMD_DO_SET_PARAMETER:
                        return 33;
                    case MAV_CMD.MAV_CMD_DO_SET_RELAY:
                        return 34;
                    case MAV_CMD.MAV_CMD_DO_REPEAT_RELAY:
                        return 35;
                    case MAV_CMD.MAV_CMD_DO_SET_SERVO:
                        return 36;
                    case MAV_CMD.MAV_CMD_DO_REPEAT_SERVO:
                        return 37;
                    case MAV_CMD.MAV_CMD_DO_FLIGHTTERMINATION:
                        return 38;
                    case MAV_CMD.MAV_CMD_DO_CHANGE_ALTITUDE:
                        return 39;
                    case MAV_CMD.MAV_CMD_DO_LAND_START:
                        return 40;
                    case MAV_CMD.MAV_CMD_DO_RALLY_LAND:
                        return 41;
                    case MAV_CMD.MAV_CMD_DO_GO_AROUND:
                        return 42;
                    case MAV_CMD.MAV_CMD_DO_REPOSITION:
                        return 43;
                    case MAV_CMD.MAV_CMD_DO_PAUSE_CONTINUE:
                        return 44;
                    case MAV_CMD.MAV_CMD_DO_SET_REVERSE:
                        return 45;
                    case MAV_CMD.MAV_CMD_DO_CONTROL_VIDEO:
                        return 46;
                    case MAV_CMD.MAV_CMD_DO_SET_ROI:
                        return 47;
                    case MAV_CMD.MAV_CMD_DO_DIGICAM_CONFIGURE:
                        return 48;
                    case MAV_CMD.MAV_CMD_DO_DIGICAM_CONTROL:
                        return 49;
                    case MAV_CMD.MAV_CMD_DO_MOUNT_CONFIGURE:
                        return 50;
                    case MAV_CMD.MAV_CMD_DO_MOUNT_CONTROL:
                        return 51;
                    case MAV_CMD.MAV_CMD_DO_SET_CAM_TRIGG_DIST:
                        return 52;
                    case MAV_CMD.MAV_CMD_DO_FENCE_ENABLE:
                        return 53;
                    case MAV_CMD.MAV_CMD_DO_PARACHUTE:
                        return 54;
                    case MAV_CMD.MAV_CMD_DO_MOTOR_TEST:
                        return 55;
                    case MAV_CMD.MAV_CMD_DO_INVERTED_FLIGHT:
                        return 56;
                    case MAV_CMD.MAV_CMD_DO_GRIPPER:
                        return 57;
                    case MAV_CMD.MAV_CMD_DO_AUTOTUNE_ENABLE:
                        return 58;
                    case MAV_CMD.MAV_CMD_NAV_SET_YAW_SPEED:
                        return 59;
                    case MAV_CMD.MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL:
                        return 60;
                    case MAV_CMD.MAV_CMD_DO_MOUNT_CONTROL_QUAT:
                        return 61;
                    case MAV_CMD.MAV_CMD_DO_GUIDED_MASTER:
                        return 62;
                    case MAV_CMD.MAV_CMD_DO_GUIDED_LIMITS:
                        return 63;
                    case MAV_CMD.MAV_CMD_DO_ENGINE_CONTROL:
                        return 64;
                    case MAV_CMD.MAV_CMD_DO_LAST:
                        return 65;
                    case MAV_CMD.MAV_CMD_PREFLIGHT_CALIBRATION:
                        return 66;
                    case MAV_CMD.MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS:
                        return 67;
                    case MAV_CMD.MAV_CMD_PREFLIGHT_UAVCAN:
                        return 68;
                    case MAV_CMD.MAV_CMD_PREFLIGHT_STORAGE:
                        return 69;
                    case MAV_CMD.MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN:
                        return 70;
                    case MAV_CMD.MAV_CMD_OVERRIDE_GOTO:
                        return 71;
                    case MAV_CMD.MAV_CMD_MISSION_START:
                        return 72;
                    case MAV_CMD.MAV_CMD_COMPONENT_ARM_DISARM:
                        return 73;
                    case MAV_CMD.MAV_CMD_GET_HOME_POSITION:
                        return 74;
                    case MAV_CMD.MAV_CMD_START_RX_PAIR:
                        return 75;
                    case MAV_CMD.MAV_CMD_GET_MESSAGE_INTERVAL:
                        return 76;
                    case MAV_CMD.MAV_CMD_SET_MESSAGE_INTERVAL:
                        return 77;
                    case MAV_CMD.MAV_CMD_REQUEST_PROTOCOL_VERSION:
                        return 78;
                    case MAV_CMD.MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES:
                        return 79;
                    case MAV_CMD.MAV_CMD_REQUEST_CAMERA_INFORMATION:
                        return 80;
                    case MAV_CMD.MAV_CMD_REQUEST_CAMERA_SETTINGS:
                        return 81;
                    case MAV_CMD.MAV_CMD_REQUEST_STORAGE_INFORMATION:
                        return 82;
                    case MAV_CMD.MAV_CMD_STORAGE_FORMAT:
                        return 83;
                    case MAV_CMD.MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS:
                        return 84;
                    case MAV_CMD.MAV_CMD_REQUEST_FLIGHT_INFORMATION:
                        return 85;
                    case MAV_CMD.MAV_CMD_RESET_CAMERA_SETTINGS:
                        return 86;
                    case MAV_CMD.MAV_CMD_SET_CAMERA_MODE:
                        return 87;
                    case MAV_CMD.MAV_CMD_IMAGE_START_CAPTURE:
                        return 88;
                    case MAV_CMD.MAV_CMD_IMAGE_STOP_CAPTURE:
                        return 89;
                    case MAV_CMD.MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE:
                        return 90;
                    case MAV_CMD.MAV_CMD_DO_TRIGGER_CONTROL:
                        return 91;
                    case MAV_CMD.MAV_CMD_VIDEO_START_CAPTURE:
                        return 92;
                    case MAV_CMD.MAV_CMD_VIDEO_STOP_CAPTURE:
                        return 93;
                    case MAV_CMD.MAV_CMD_VIDEO_START_STREAMING:
                        return 94;
                    case MAV_CMD.MAV_CMD_VIDEO_STOP_STREAMING:
                        return 95;
                    case MAV_CMD.MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION:
                        return 96;
                    case MAV_CMD.MAV_CMD_LOGGING_START:
                        return 97;
                    case MAV_CMD.MAV_CMD_LOGGING_STOP:
                        return 98;
                    case MAV_CMD.MAV_CMD_AIRFRAME_CONFIGURATION:
                        return 99;
                    case MAV_CMD.MAV_CMD_PANORAMA_CREATE:
                        return 100;
                    case MAV_CMD.MAV_CMD_DO_VTOL_TRANSITION:
                        return 101;
                    case MAV_CMD.MAV_CMD_ARM_AUTHORIZATION_REQUEST:
                        return 102;
                    case MAV_CMD.MAV_CMD_SET_GUIDED_SUBMODE_STANDARD:
                        return 103;
                    case MAV_CMD.MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE:
                        return 104;
                    case MAV_CMD.MAV_CMD_CONDITION_GATE:
                        return 105;
                    case MAV_CMD.MAV_CMD_NAV_FENCE_RETURN_POINT:
                        return 106;
                    case MAV_CMD.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION:
                        return 107;
                    case MAV_CMD.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION:
                        return 108;
                    case MAV_CMD.MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION:
                        return 109;
                    case MAV_CMD.MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION:
                        return 110;
                    case MAV_CMD.MAV_CMD_NAV_RALLY_POINT:
                        return 111;
                    case MAV_CMD.MAV_CMD_UAVCAN_GET_NODE_INFO:
                        return 112;
                    case MAV_CMD.MAV_CMD_PAYLOAD_PREPARE_DEPLOY:
                        return 113;
                    case MAV_CMD.MAV_CMD_PAYLOAD_CONTROL_DEPLOY:
                        return 114;
                    case MAV_CMD.MAV_CMD_WAYPOINT_USER_1:
                        return 115;
                    case MAV_CMD.MAV_CMD_WAYPOINT_USER_2:
                        return 116;
                    case MAV_CMD.MAV_CMD_WAYPOINT_USER_3:
                        return 117;
                    case MAV_CMD.MAV_CMD_WAYPOINT_USER_4:
                        return 118;
                    case MAV_CMD.MAV_CMD_WAYPOINT_USER_5:
                        return 119;
                    case MAV_CMD.MAV_CMD_SPATIAL_USER_1:
                        return 120;
                    case MAV_CMD.MAV_CMD_SPATIAL_USER_2:
                        return 121;
                    case MAV_CMD.MAV_CMD_SPATIAL_USER_3:
                        return 122;
                    case MAV_CMD.MAV_CMD_SPATIAL_USER_4:
                        return 123;
                    case MAV_CMD.MAV_CMD_SPATIAL_USER_5:
                        return 124;
                    case MAV_CMD.MAV_CMD_USER_1:
                        return 125;
                    case MAV_CMD.MAV_CMD_USER_2:
                        return 126;
                    case MAV_CMD.MAV_CMD_USER_3:
                        return 127;
                    case MAV_CMD.MAV_CMD_USER_4:
                        return 128;
                    case MAV_CMD.MAV_CMD_USER_5:
                        return 129;
                    case MAV_CMD.MAV_CMD_POWER_OFF_INITIATED:
                        return 130;
                    case MAV_CMD.MAV_CMD_SOLO_BTN_FLY_CLICK:
                        return 131;
                    case MAV_CMD.MAV_CMD_SOLO_BTN_FLY_HOLD:
                        return 132;
                    case MAV_CMD.MAV_CMD_SOLO_BTN_PAUSE_CLICK:
                        return 133;
                    case MAV_CMD.MAV_CMD_DO_START_MAG_CAL:
                        return 134;
                    case MAV_CMD.MAV_CMD_DO_ACCEPT_MAG_CAL:
                        return 135;
                    case MAV_CMD.MAV_CMD_DO_CANCEL_MAG_CAL:
                        return 136;
                    case MAV_CMD.MAV_CMD_SET_FACTORY_TEST_MODE:
                        return 137;
                    case MAV_CMD.MAV_CMD_DO_SEND_BANNER:
                        return 138;
                    case MAV_CMD.MAV_CMD_ACCELCAL_VEHICLE_POS:
                        return 139;
                    case MAV_CMD.MAV_CMD_GIMBAL_RESET:
                        return 140;
                    case MAV_CMD.MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS:
                        return 141;
                    case MAV_CMD.MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION:
                        return 142;
                    case MAV_CMD.MAV_CMD_GIMBAL_FULL_RESET:
                        return 143;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *Camera Modes. */


        public enum CAMERA_MODE : sbyte
        {

            CAMERA_MODE_IMAGE = 0, //Camera is in image/photo capture mode.
            CAMERA_MODE_VIDEO = 1, //Camera is in video capture mode.
            CAMERA_MODE_IMAGE_SURVEY = 2 //Camera is in image survey capture mode. It allows for camera controller to do specific settings for surveys
        }

        public static class CAMERA_MODE_
        {

            internal static CAMERA_MODE from_bits(ulong bits) { return (CAMERA_MODE)((sbyte)bits); }

            internal static ulong bits(this CAMERA_MODE en) { return (ulong)(en);	}
        }

        /**
        *Source of information about this collision. */


        public enum MAV_COLLISION_SRC : sbyte
        {

            MAV_COLLISION_SRC_ADSB = 0, //ID field references ADSB_VEHICLE packets
            MAV_COLLISION_SRC_MAVLINK_GPS_GLOBAL_INT = 1 //ID field references MAVLink SRC ID
        }

        public static class MAV_COLLISION_SRC_
        {

            internal static MAV_COLLISION_SRC from_bits(ulong bits) { return (MAV_COLLISION_SRC)((sbyte)bits); }

            internal static ulong bits(this MAV_COLLISION_SRC en) { return (ulong)(en);	}
        }

        /**
        *Possible remote log data block statuses */


        public enum MAV_REMOTE_LOG_DATA_BLOCK_STATUSES : sbyte
        {

            MAV_REMOTE_LOG_DATA_BLOCK_NACK = 0, //This block has NOT been received
            MAV_REMOTE_LOG_DATA_BLOCK_ACK = 1 //This block has been received
        }

        public static class MAV_REMOTE_LOG_DATA_BLOCK_STATUSES_
        {

            internal static MAV_REMOTE_LOG_DATA_BLOCK_STATUSES from_bits(ulong bits) { return (MAV_REMOTE_LOG_DATA_BLOCK_STATUSES)((sbyte)bits); }

            internal static ulong bits(this MAV_REMOTE_LOG_DATA_BLOCK_STATUSES en) { return (ulong)(en);	}
        }

        /**
        *Status flags for ADS-B transponder dynamic output */


        public enum UAVIONIX_ADSB_RF_HEALTH : int
        {

            UAVIONIX_ADSB_RF_HEALTH_INITIALIZING = 0,
            UAVIONIX_ADSB_RF_HEALTH_OK = 1,
            UAVIONIX_ADSB_RF_HEALTH_FAIL_TX = 2,
            UAVIONIX_ADSB_RF_HEALTH_FAIL_RX = 16
        }

        public static class UAVIONIX_ADSB_RF_HEALTH_
        {

            internal static UAVIONIX_ADSB_RF_HEALTH from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_INITIALIZING;
                    case 1:
                        return UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_OK;
                    case 2:
                        return UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_FAIL_TX;
                    case 3:
                        return UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_FAIL_RX;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this UAVIONIX_ADSB_RF_HEALTH en)
            {
                switch(en)
                {
                    case UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_INITIALIZING:
                        return 0;
                    case UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_OK:
                        return 1;
                    case UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_FAIL_TX:
                        return 2;
                    case UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_FAIL_RX:
                        return 3;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *result from a mavlink command */


        public enum MAV_RESULT : sbyte
        {

            MAV_RESULT_ACCEPTED = 0, //Command ACCEPTED and EXECUTED
            MAV_RESULT_TEMPORARILY_REJECTED = 1, //Command TEMPORARY REJECTED/DENIED
            MAV_RESULT_DENIED = 2, //Command PERMANENTLY DENIED
            MAV_RESULT_UNSUPPORTED = 3, //Command UNKNOWN/UNSUPPORTED
            MAV_RESULT_FAILED = 4, //Command executed, but failed
            MAV_RESULT_IN_PROGRESS = 5 //WIP: Command being executed
        }

        public static class MAV_RESULT_
        {

            internal static MAV_RESULT from_bits(ulong bits) { return (MAV_RESULT)((sbyte)bits); }

            internal static ulong bits(this MAV_RESULT en) { return (ulong)(en);	}
        }

        /**
        *Special ACK block numbers control activation of dataflash log streaming */


        public enum MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS : uint
        {

            MAV_REMOTE_LOG_DATA_BLOCK_STOP = 2147483645U, //UAV to stop sending DataFlash blocks
            MAV_REMOTE_LOG_DATA_BLOCK_START = 2147483646U //UAV to start sending DataFlash blocks
        }

        public static class MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS_
        {

            internal static MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS from_bits(ulong bits) { return (MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS)(2147483645 + (uint)bits); }

            internal static ulong bits(this MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS en) { return (ulong)(en  - 2147483645);	}
        }

        /**
        *Status for ADS-B transponder dynamic input */


        public enum UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX : sbyte
        {

            UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_0 = 0,
            UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_1 = 1,
            UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_2D = 2,
            UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_3D = 3,
            UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_DGPS = 4,
            UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_RTK = 5
        }

        public static class UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_
        {

            internal static UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX from_bits(ulong bits) { return (UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX)((sbyte)bits); }

            internal static ulong bits(this UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX en) { return (ulong)(en);	}
        }



        public enum GOPRO_COMMAND : sbyte
        {

            GOPRO_COMMAND_POWER = 0, //(Get/Set)
            GOPRO_COMMAND_CAPTURE_MODE = 1, //(Get/Set)
            GOPRO_COMMAND_SHUTTER = 2, //(___/Set)
            GOPRO_COMMAND_BATTERY = 3, //(Get/___)
            GOPRO_COMMAND_MODEL = 4, //(Get/___)
            GOPRO_COMMAND_VIDEO_SETTINGS = 5, //(Get/Set)
            GOPRO_COMMAND_LOW_LIGHT = 6, //(Get/Set)
            GOPRO_COMMAND_PHOTO_RESOLUTION = 7, //(Get/Set)
            GOPRO_COMMAND_PHOTO_BURST_RATE = 8, //(Get/Set)
            GOPRO_COMMAND_PROTUNE = 9, //(Get/Set)
            GOPRO_COMMAND_PROTUNE_WHITE_BALANCE = 10, //(Get/Set) Hero 3+ Only
            GOPRO_COMMAND_PROTUNE_COLOUR = 11, //(Get/Set) Hero 3+ Only
            GOPRO_COMMAND_PROTUNE_GAIN = 12, //(Get/Set) Hero 3+ Only
            GOPRO_COMMAND_PROTUNE_SHARPNESS = 13, //(Get/Set) Hero 3+ Only
            GOPRO_COMMAND_PROTUNE_EXPOSURE = 14, //(Get/Set) Hero 3+ Only
            GOPRO_COMMAND_TIME = 15, //(Get/Set)
            GOPRO_COMMAND_CHARGING = 16 //(Get/Set)
        }

        public static class GOPRO_COMMAND_
        {

            internal static GOPRO_COMMAND from_bits(ulong bits) { return (GOPRO_COMMAND)((sbyte)bits); }

            internal static ulong bits(this GOPRO_COMMAND en) { return (ulong)(en);	}
        }



        public enum GOPRO_REQUEST_STATUS : sbyte
        {

            GOPRO_REQUEST_SUCCESS = 0, //The write message with ID indicated succeeded
            GOPRO_REQUEST_FAILED = 1 //The write message with ID indicated failed
        }

        public static class GOPRO_REQUEST_STATUS_
        {

            internal static GOPRO_REQUEST_STATUS from_bits(ulong bits) { return (GOPRO_REQUEST_STATUS)((sbyte)bits); }

            internal static ulong bits(this GOPRO_REQUEST_STATUS en) { return (ulong)(en);	}
        }

        /**
        *Definitions for aircraft size */


        public enum UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE : sbyte
        {

            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_NO_DATA = 0,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L15M_W23M = 1,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25M_W28P5M = 2,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25_34M = 3,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_33M = 4,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_38M = 5,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_39P5M = 6,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_45M = 7,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_45M = 8,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_52M = 9,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_59P5M = 10,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_67M = 11,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W72P5M = 12,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W80M = 13,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W80M = 14,
            UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W90M = 15
        }

        public static class UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_
        {

            internal static UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE from_bits(ulong bits) { return (UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE)((sbyte)bits); }

            internal static ulong bits(this UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE en) { return (ulong)(en);	}
        }



        public enum MAV_STATE : sbyte
        {

            UNINIT = 0, //Uninitialized system, state is unknown.
            ACTIVE = 1, //System is active and might be already airborne. Motors are engaged.
            BOOT = 2, //System is booting up.
            CALIBRATING = 3, //System is calibrating and not flight-ready.
            CRITICAL = 4, //System is in a non-normal flight mode. It can however still navigate.
            /**
            *System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in
            *			 mayday and going down */
            EMERGENCY = 5,
            FLIGHT_TERMINATION = 6, //System is terminating itself.
            POWEROFF = 7, //System just initialized its power-down sequence, will shut down now.
            STANDBY = 8 //System is grounded and on standby. It can be launched any time.
        }

        public static class MAV_STATE_
        {

            internal static MAV_STATE from_bits(ulong bits) { return (MAV_STATE)((sbyte)bits); }

            internal static ulong bits(this MAV_STATE en) { return (ulong)(en);	}
        }

        /**
        *SERIAL_CONTROL flags (bitmask) */


        public enum SERIAL_CONTROL_FLAG : int
        {

            SERIAL_CONTROL_FLAG_REPLY = 1, //Set if this is a reply
            SERIAL_CONTROL_FLAG_RESPOND = 2, //Set if the sender wants the receiver to send a response as another SERIAL_CONTROL message
            /**
            *Set if access to the serial port should be removed from whatever driver is currently using it, giving
            *			 exclusive access to the SERIAL_CONTROL protocol. The port can be handed back by sending a request without
            *			 this flag se */
            SERIAL_CONTROL_FLAG_EXCLUSIVE = 4,
            SERIAL_CONTROL_FLAG_BLOCKING = 8, //Block on writes to the serial port
            SERIAL_CONTROL_FLAG_MULTI = 16 //Send multiple replies until port is drained
        }

        public static class SERIAL_CONTROL_FLAG_
        {

            internal static SERIAL_CONTROL_FLAG from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_REPLY;
                    case 1:
                        return SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_RESPOND;
                    case 2:
                        return SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_EXCLUSIVE;
                    case 3:
                        return SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_BLOCKING;
                    case 4:
                        return SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_MULTI;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this SERIAL_CONTROL_FLAG en)
            {
                switch(en)
                {
                    case SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_REPLY:
                        return 0;
                    case SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_RESPOND:
                        return 1;
                    case SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_EXCLUSIVE:
                        return 2;
                    case SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_BLOCKING:
                        return 3;
                    case SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_MULTI:
                        return 4;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *Camera capability flags (Bitmap). */


        public enum CAMERA_CAP_FLAGS : int
        {

            CAMERA_CAP_FLAGS_CAPTURE_VIDEO = 1, //Camera is able to record video.
            CAMERA_CAP_FLAGS_CAPTURE_IMAGE = 2, //Camera is able to capture images.
            CAMERA_CAP_FLAGS_HAS_MODES = 4, //Camera has separate Video and Image/Photo modes (MAV_CMD_SET_CAMERA_MODE)
            CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE = 8, //Camera can capture images while in video mode
            CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE = 16, //Camera can capture videos while in Photo/Image mode
            CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE = 32 //Camera has image survey mode (MAV_CMD_SET_CAMERA_MODE)
        }

        public static class CAMERA_CAP_FLAGS_
        {

            internal static CAMERA_CAP_FLAGS from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAPTURE_VIDEO;
                    case 1:
                        return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAPTURE_IMAGE;
                    case 2:
                        return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_HAS_MODES;
                    case 3:
                        return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE;
                    case 4:
                        return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE;
                    case 5:
                        return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this CAMERA_CAP_FLAGS en)
            {
                switch(en)
                {
                    case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAPTURE_VIDEO:
                        return 0;
                    case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAPTURE_IMAGE:
                        return 1;
                    case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_HAS_MODES:
                        return 2;
                    case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE:
                        return 3;
                    case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE:
                        return 4;
                    case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE:
                        return 5;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }



        public enum GOPRO_HEARTBEAT_FLAGS : sbyte
        {

            GOPRO_FLAG_RECORDING = 1 //GoPro is currently recording
        }

        public static class GOPRO_HEARTBEAT_FLAGS_
        {

            internal static GOPRO_HEARTBEAT_FLAGS from_bits(ulong bits) { return (GOPRO_HEARTBEAT_FLAGS)(1 + (sbyte)bits); }

            internal static ulong bits(this GOPRO_HEARTBEAT_FLAGS en) { return (ulong)(en  - 1);	}
        }

        /**
        *Bitmask of (optional) autopilot capabilities (64 bit). If a bit is set, the autopilot supports this capability */


        public enum MAV_PROTOCOL_CAPABILITY : int
        {

            MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT = 1, //Autopilot supports MISSION float message type.
            MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT = 2, //Autopilot supports the new param float message type.
            MAV_PROTOCOL_CAPABILITY_MISSION_INT = 4, //Autopilot supports MISSION_INT scaled integer message type.
            MAV_PROTOCOL_CAPABILITY_COMMAND_INT = 8, //Autopilot supports COMMAND_INT scaled integer message type.
            MAV_PROTOCOL_CAPABILITY_PARAM_UNION = 16, //Autopilot supports the new param union message type.
            MAV_PROTOCOL_CAPABILITY_FTP = 32, //Autopilot supports the new FILE_TRANSFER_PROTOCOL message type.
            MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET = 64, //Autopilot supports commanding attitude offboard.
            MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED = 128, //Autopilot supports commanding position and velocity targets in local NED frame.
            MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT = 256, //Autopilot supports commanding position and velocity targets in global scaled integers.
            MAV_PROTOCOL_CAPABILITY_TERRAIN = 512, //Autopilot supports terrain protocol / data handling.
            MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET = 1024, //Autopilot supports direct actuator control.
            MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION = 2048, //Autopilot supports the flight termination command.
            MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION = 4096, //Autopilot supports onboard compass calibration.
            MAV_PROTOCOL_CAPABILITY_MAVLINK2 = 8192, //Autopilot supports mavlink version 2.
            MAV_PROTOCOL_CAPABILITY_MISSION_FENCE = 16384, //Autopilot supports mission fence protocol.
            MAV_PROTOCOL_CAPABILITY_MISSION_RALLY = 32768, //Autopilot supports mission rally point protocol.
            MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION = 65536 //Autopilot supports the flight information protocol.
        }

        public static class MAV_PROTOCOL_CAPABILITY_
        {

            internal static MAV_PROTOCOL_CAPABILITY from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT;
                    case 1:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT;
                    case 2:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_INT;
                    case 3:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_COMMAND_INT;
                    case 4:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_PARAM_UNION;
                    case 5:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FTP;
                    case 6:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET;
                    case 7:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED;
                    case 8:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT;
                    case 9:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_TERRAIN;
                    case 10:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET;
                    case 11:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION;
                    case 12:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION;
                    case 13:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MAVLINK2;
                    case 14:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_FENCE;
                    case 15:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_RALLY;
                    case 16:
                        return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this MAV_PROTOCOL_CAPABILITY en)
            {
                switch(en)
                {
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT:
                        return 0;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT:
                        return 1;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_INT:
                        return 2;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_COMMAND_INT:
                        return 3;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_PARAM_UNION:
                        return 4;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FTP:
                        return 5;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET:
                        return 6;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED:
                        return 7;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT:
                        return 8;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_TERRAIN:
                        return 9;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET:
                        return 10;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION:
                        return 11;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION:
                        return 12;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MAVLINK2:
                        return 13;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_FENCE:
                        return 14;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_RALLY:
                        return 15;
                    case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION:
                        return 16;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }



        public enum GOPRO_HEARTBEAT_STATUS : sbyte
        {

            GOPRO_HEARTBEAT_STATUS_DISCONNECTED = 0, //No GoPro connected
            GOPRO_HEARTBEAT_STATUS_INCOMPATIBLE = 1, //The detected GoPro is not HeroBus compatible
            GOPRO_HEARTBEAT_STATUS_CONNECTED = 2, //A HeroBus compatible GoPro is connected
            GOPRO_HEARTBEAT_STATUS_ERROR = 3 //An unrecoverable error was encountered with the connected GoPro, it may require a power cycle
        }

        public static class GOPRO_HEARTBEAT_STATUS_
        {

            internal static GOPRO_HEARTBEAT_STATUS from_bits(ulong bits) { return (GOPRO_HEARTBEAT_STATUS)((sbyte)bits); }

            internal static ulong bits(this GOPRO_HEARTBEAT_STATUS en) { return (ulong)(en);	}
        }



        public enum MAG_CAL_STATUS : sbyte
        {

            MAG_CAL_NOT_STARTED = 0,
            MAG_CAL_WAITING_TO_START = 1,
            MAG_CAL_RUNNING_STEP_ONE = 2,
            MAG_CAL_RUNNING_STEP_TWO = 3,
            MAG_CAL_SUCCESS = 4,
            MAG_CAL_FAILED = 5
        }

        public static class MAG_CAL_STATUS_
        {

            internal static MAG_CAL_STATUS from_bits(ulong bits) { return (MAG_CAL_STATUS)((sbyte)bits); }

            internal static ulong bits(this MAG_CAL_STATUS en) { return (ulong)(en);	}
        }



        public enum CAMERA_STATUS_TYPES : sbyte
        {

            CAMERA_STATUS_TYPE_HEARTBEAT = 0, //Camera heartbeat, announce camera component ID at 1hz
            CAMERA_STATUS_TYPE_TRIGGER = 1, //Camera image triggered
            CAMERA_STATUS_TYPE_DISCONNECT = 2, //Camera connection lost
            CAMERA_STATUS_TYPE_ERROR = 3, //Camera unknown error
            CAMERA_STATUS_TYPE_LOWBATT = 4, //Camera battery low. Parameter p1 shows reported voltage
            CAMERA_STATUS_TYPE_LOWSTORE = 5, //Camera storage low. Parameter p1 shows reported shots remaining
            CAMERA_STATUS_TYPE_LOWSTOREV = 6 //Camera storage low. Parameter p1 shows reported video minutes remaining
        }

        public static class CAMERA_STATUS_TYPES_
        {

            internal static CAMERA_STATUS_TYPES from_bits(ulong bits) { return (CAMERA_STATUS_TYPES)((sbyte)bits); }

            internal static ulong bits(this CAMERA_STATUS_TYPES en) { return (ulong)(en);	}
        }

        /**
        *SERIAL_CONTROL device types */


        public enum SERIAL_CONTROL_DEV : int
        {

            SERIAL_CONTROL_DEV_TELEM1 = 0, //First telemetry port
            SERIAL_CONTROL_DEV_TELEM2 = 1, //Second telemetry port
            SERIAL_CONTROL_DEV_GPS1 = 2, //First GPS port
            SERIAL_CONTROL_DEV_GPS2 = 3, //Second GPS port
            SERIAL_CONTROL_DEV_SHELL = 10 //system shell
        }

        public static class SERIAL_CONTROL_DEV_
        {

            internal static SERIAL_CONTROL_DEV from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_TELEM1;
                    case 1:
                        return SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_TELEM2;
                    case 2:
                        return SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_GPS1;
                    case 3:
                        return SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_GPS2;
                    case 4:
                        return SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_SHELL;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this SERIAL_CONTROL_DEV en)
            {
                switch(en)
                {
                    case SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_TELEM1:
                        return 0;
                    case SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_TELEM2:
                        return 1;
                    case SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_GPS1:
                        return 2;
                    case SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_GPS2:
                        return 3;
                    case SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_SHELL:
                        return 4;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *result in a mavlink mission ack */


        public enum MAV_MISSION_RESULT : sbyte
        {

            MAV_MISSION_ACCEPTED = 0, //mission accepted OK
            MAV_MISSION_ERROR = 1, //generic error / not accepting mission commands at all right now
            MAV_MISSION_UNSUPPORTED_FRAME = 2, //coordinate frame is not supported
            MAV_MISSION_UNSUPPORTED = 3, //command is not supported
            MAV_MISSION_NO_SPACE = 4, //mission item exceeds storage space
            MAV_MISSION_INVALID = 5, //one of the parameters has an invalid value
            MAV_MISSION_INVALID_PARAM1 = 6, //param1 has an invalid value
            MAV_MISSION_INVALID_PARAM2 = 7, //param2 has an invalid value
            MAV_MISSION_INVALID_PARAM3 = 8, //param3 has an invalid value
            MAV_MISSION_INVALID_PARAM4 = 9, //param4 has an invalid value
            MAV_MISSION_INVALID_PARAM5_X = 10, //x/param5 has an invalid value
            MAV_MISSION_INVALID_PARAM6_Y = 11, //y/param6 has an invalid value
            MAV_MISSION_INVALID_PARAM7 = 12, //param7 has an invalid value
            MAV_MISSION_INVALID_SEQUENCE = 13, //received waypoint out of sequence
            MAV_MISSION_DENIED = 14 //not accepting any mission commands from this communication partner
        }

        public static class MAV_MISSION_RESULT_
        {

            internal static MAV_MISSION_RESULT from_bits(ulong bits) { return (MAV_MISSION_RESULT)((sbyte)bits); }

            internal static ulong bits(this MAV_MISSION_RESULT en) { return (ulong)(en);	}
        }

        /**
        *Power supply status flags (bitmask) */


        public enum MAV_POWER_STATUS : int
        {

            MAV_POWER_STATUS_BRICK_VALID = 1, //main brick power supply valid
            MAV_POWER_STATUS_SERVO_VALID = 2, //main servo power supply valid for FMU
            MAV_POWER_STATUS_USB_CONNECTED = 4, //USB power is connected
            MAV_POWER_STATUS_PERIPH_OVERCURRENT = 8, //peripheral supply is in over-current state
            MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT = 16, //hi-power peripheral supply is in over-current state
            MAV_POWER_STATUS_CHANGED = 32 //Power status has changed since boot
        }

        public static class MAV_POWER_STATUS_
        {

            internal static MAV_POWER_STATUS from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return MAV_POWER_STATUS.MAV_POWER_STATUS_BRICK_VALID;
                    case 1:
                        return MAV_POWER_STATUS.MAV_POWER_STATUS_SERVO_VALID;
                    case 2:
                        return MAV_POWER_STATUS.MAV_POWER_STATUS_USB_CONNECTED;
                    case 3:
                        return MAV_POWER_STATUS.MAV_POWER_STATUS_PERIPH_OVERCURRENT;
                    case 4:
                        return MAV_POWER_STATUS.MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT;
                    case 5:
                        return MAV_POWER_STATUS.MAV_POWER_STATUS_CHANGED;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this MAV_POWER_STATUS en)
            {
                switch(en)
                {
                    case MAV_POWER_STATUS.MAV_POWER_STATUS_BRICK_VALID:
                        return 0;
                    case MAV_POWER_STATUS.MAV_POWER_STATUS_SERVO_VALID:
                        return 1;
                    case MAV_POWER_STATUS.MAV_POWER_STATUS_USB_CONNECTED:
                        return 2;
                    case MAV_POWER_STATUS.MAV_POWER_STATUS_PERIPH_OVERCURRENT:
                        return 3;
                    case MAV_POWER_STATUS.MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT:
                        return 4;
                    case MAV_POWER_STATUS.MAV_POWER_STATUS_CHANGED:
                        return 5;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *Generalized UAVCAN node mode */


        public enum UAVCAN_NODE_MODE : int
        {

            UAVCAN_NODE_MODE_OPERATIONAL = 0, //The node is performing its primary functions.
            UAVCAN_NODE_MODE_INITIALIZATION = 1, //The node is initializing; this mode is entered immediately after startup.
            UAVCAN_NODE_MODE_MAINTENANCE = 2, //The node is under maintenance.
            UAVCAN_NODE_MODE_SOFTWARE_UPDATE = 3, //The node is in the process of updating its software.
            UAVCAN_NODE_MODE_OFFLINE = 7 //The node is no longer available online.
        }

        public static class UAVCAN_NODE_MODE_
        {

            internal static UAVCAN_NODE_MODE from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_OPERATIONAL;
                    case 1:
                        return UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_INITIALIZATION;
                    case 2:
                        return UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_MAINTENANCE;
                    case 3:
                        return UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_SOFTWARE_UPDATE;
                    case 4:
                        return UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_OFFLINE;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this UAVCAN_NODE_MODE en)
            {
                switch(en)
                {
                    case UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_OPERATIONAL:
                        return 0;
                    case UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_INITIALIZATION:
                        return 1;
                    case UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_MAINTENANCE:
                        return 2;
                    case UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_SOFTWARE_UPDATE:
                        return 3;
                    case UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_OFFLINE:
                        return 4;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *These flags indicate status such as data validity of each data source. Set = data valid */


        public enum ADSB_FLAGS : int
        {

            ADSB_FLAGS_VALID_COORDS = 1,
            ADSB_FLAGS_VALID_ALTITUDE = 2,
            ADSB_FLAGS_VALID_HEADING = 4,
            ADSB_FLAGS_VALID_VELOCITY = 8,
            ADSB_FLAGS_VALID_CALLSIGN = 16,
            ADSB_FLAGS_VALID_SQUAWK = 32,
            ADSB_FLAGS_SIMULATED = 64
        }

        public static class ADSB_FLAGS_
        {

            internal static ADSB_FLAGS from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return ADSB_FLAGS.ADSB_FLAGS_VALID_COORDS;
                    case 1:
                        return ADSB_FLAGS.ADSB_FLAGS_VALID_ALTITUDE;
                    case 2:
                        return ADSB_FLAGS.ADSB_FLAGS_VALID_HEADING;
                    case 3:
                        return ADSB_FLAGS.ADSB_FLAGS_VALID_VELOCITY;
                    case 4:
                        return ADSB_FLAGS.ADSB_FLAGS_VALID_CALLSIGN;
                    case 5:
                        return ADSB_FLAGS.ADSB_FLAGS_VALID_SQUAWK;
                    case 6:
                        return ADSB_FLAGS.ADSB_FLAGS_SIMULATED;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this ADSB_FLAGS en)
            {
                switch(en)
                {
                    case ADSB_FLAGS.ADSB_FLAGS_VALID_COORDS:
                        return 0;
                    case ADSB_FLAGS.ADSB_FLAGS_VALID_ALTITUDE:
                        return 1;
                    case ADSB_FLAGS.ADSB_FLAGS_VALID_HEADING:
                        return 2;
                    case ADSB_FLAGS.ADSB_FLAGS_VALID_VELOCITY:
                        return 3;
                    case ADSB_FLAGS.ADSB_FLAGS_VALID_CALLSIGN:
                        return 4;
                    case ADSB_FLAGS.ADSB_FLAGS_VALID_SQUAWK:
                        return 5;
                    case ADSB_FLAGS.ADSB_FLAGS_SIMULATED:
                        return 6;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *Result from a PARAM_EXT_SET message. */


        public enum PARAM_ACK : sbyte
        {

            PARAM_ACK_ACCEPTED = 0, //Parameter value ACCEPTED and SET
            PARAM_ACK_VALUE_UNSUPPORTED = 1, //Parameter value UNKNOWN/UNSUPPORTED
            PARAM_ACK_FAILED = 2, //Parameter failed to set
            /**
            *Parameter value received but not yet validated or set. A subsequent PARAM_EXT_ACK will follow once operation
            *			 is completed with the actual result. These are for parameters that may take longer to set. Instead of
            *			 waiting for an ACK and potentially timing out, you will immediately receive this response to let you
            *			 know it was received */
            PARAM_ACK_IN_PROGRESS = 3
        }

        public static class PARAM_ACK_
        {

            internal static PARAM_ACK from_bits(ulong bits) { return (PARAM_ACK)((sbyte)bits); }

            internal static ulong bits(this PARAM_ACK en) { return (ulong)(en);	}
        }

        /**
        *Enumeration of possible mount operation modes */


        public enum MAV_MOUNT_MODE : sbyte
        {

            MAV_MOUNT_MODE_RETRACT = 0, //Load and keep safe position (Roll,Pitch,Yaw) from permant memory and stop stabilization
            MAV_MOUNT_MODE_NEUTRAL = 1, //Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory.
            MAV_MOUNT_MODE_MAVLINK_TARGETING = 2, //Load neutral position and start MAVLink Roll,Pitch,Yaw control with stabilization
            MAV_MOUNT_MODE_RC_TARGETING = 3, //Load neutral position and start RC Roll,Pitch,Yaw control with stabilization
            MAV_MOUNT_MODE_GPS_POINT = 4 //Load neutral position and start to point to Lat,Lon,Alt
        }

        public static class MAV_MOUNT_MODE_
        {

            internal static MAV_MOUNT_MODE from_bits(ulong bits) { return (MAV_MOUNT_MODE)((sbyte)bits); }

            internal static ulong bits(this MAV_MOUNT_MODE en) { return (ulong)(en);	}
        }

        /**
        *Enumeration of sensor orientation, according to its rotations */


        public enum MAV_SENSOR_ORIENTATION : sbyte
        {

            NONE = 0, //Roll: 0, Pitch: 0, Yaw: 0
            YAW_45 = 1, //Roll: 0, Pitch: 0, Yaw: 45
            YAW_90 = 2, //Roll: 0, Pitch: 0, Yaw: 90
            YAW_135 = 3, //Roll: 0, Pitch: 0, Yaw: 135
            YAW_180 = 4, //Roll: 0, Pitch: 0, Yaw: 180
            YAW_225 = 5, //Roll: 0, Pitch: 0, Yaw: 225
            YAW_270 = 6, //Roll: 0, Pitch: 0, Yaw: 270
            YAW_315 = 7, //Roll: 0, Pitch: 0, Yaw: 315
            ROLL_180 = 8, //Roll: 180, Pitch: 0, Yaw: 0
            ROLL_180_YAW_45 = 9, //Roll: 180, Pitch: 0, Yaw: 45
            ROLL_180_YAW_90 = 10, //Roll: 180, Pitch: 0, Yaw: 90
            ROLL_180_YAW_135 = 11, //Roll: 180, Pitch: 0, Yaw: 135
            PITCH_180 = 12, //Roll: 0, Pitch: 180, Yaw: 0
            ROLL_180_YAW_225 = 13, //Roll: 180, Pitch: 0, Yaw: 225
            ROLL_180_YAW_270 = 14, //Roll: 180, Pitch: 0, Yaw: 270
            ROLL_180_YAW_315 = 15, //Roll: 180, Pitch: 0, Yaw: 315
            ROLL_90 = 16, //Roll: 90, Pitch: 0, Yaw: 0
            ROLL_90_YAW_45 = 17, //Roll: 90, Pitch: 0, Yaw: 45
            ROLL_90_YAW_90 = 18, //Roll: 90, Pitch: 0, Yaw: 90
            ROLL_90_YAW_135 = 19, //Roll: 90, Pitch: 0, Yaw: 135
            ROLL_270 = 20, //Roll: 270, Pitch: 0, Yaw: 0
            ROLL_270_YAW_45 = 21, //Roll: 270, Pitch: 0, Yaw: 45
            ROLL_270_YAW_90 = 22, //Roll: 270, Pitch: 0, Yaw: 90
            ROLL_270_YAW_135 = 23, //Roll: 270, Pitch: 0, Yaw: 135
            PITCH_90 = 24, //Roll: 0, Pitch: 90, Yaw: 0
            PITCH_270 = 25, //Roll: 0, Pitch: 270, Yaw: 0
            PITCH_180_YAW_90 = 26, //Roll: 0, Pitch: 180, Yaw: 90
            PITCH_180_YAW_270 = 27, //Roll: 0, Pitch: 180, Yaw: 270
            ROLL_90_PITCH_90 = 28, //Roll: 90, Pitch: 90, Yaw: 0
            ROLL_180_PITCH_90 = 29, //Roll: 180, Pitch: 90, Yaw: 0
            ROLL_270_PITCH_90 = 30, //Roll: 270, Pitch: 90, Yaw: 0
            ROLL_90_PITCH_180 = 31, //Roll: 90, Pitch: 180, Yaw: 0
            ROLL_270_PITCH_180 = 32, //Roll: 270, Pitch: 180, Yaw: 0
            ROLL_90_PITCH_270 = 33, //Roll: 90, Pitch: 270, Yaw: 0
            ROLL_180_PITCH_270 = 34, //Roll: 180, Pitch: 270, Yaw: 0
            ROLL_270_PITCH_270 = 35, //Roll: 270, Pitch: 270, Yaw: 0
            ROLL_90_PITCH_180_YAW_90 = 36, //Roll: 90, Pitch: 180, Yaw: 90
            ROLL_90_YAW_270 = 37, //Roll: 90, Pitch: 0, Yaw: 270
            ROLL_315_PITCH_315_YAW_315 = 38 //Roll: 315, Pitch: 315, Yaw: 315
        }

        public static class MAV_SENSOR_ORIENTATION_
        {

            internal static MAV_SENSOR_ORIENTATION from_bits(ulong bits) { return (MAV_SENSOR_ORIENTATION)((sbyte)bits); }

            internal static ulong bits(this MAV_SENSOR_ORIENTATION en) { return (ulong)(en);	}
        }

        /**
        *State flags for ADS-B transponder dynamic report */


        public enum UAVIONIX_ADSB_OUT_DYNAMIC_STATE : int
        {

            UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE = 1,
            UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED = 2,
            UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED = 4,
            UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND = 8,
            UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT = 16
        }

        public static class UAVIONIX_ADSB_OUT_DYNAMIC_STATE_
        {

            internal static UAVIONIX_ADSB_OUT_DYNAMIC_STATE from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE;
                    case 1:
                        return UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED;
                    case 2:
                        return UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED;
                    case 3:
                        return UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND;
                    case 4:
                        return UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this UAVIONIX_ADSB_OUT_DYNAMIC_STATE en)
            {
                switch(en)
                {
                    case UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE:
                        return 0;
                    case UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED:
                        return 1;
                    case UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED:
                        return 2;
                    case UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND:
                        return 3;
                    case UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT:
                        return 4;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *Possible actions an aircraft can take to avoid a collision. */


        public enum MAV_COLLISION_ACTION : sbyte
        {

            MAV_COLLISION_ACTION_NONE = 0, //Ignore any potential collisions
            MAV_COLLISION_ACTION_REPORT = 1, //Report potential collision
            MAV_COLLISION_ACTION_ASCEND_OR_DESCEND = 2, //Ascend or Descend to avoid threat
            MAV_COLLISION_ACTION_MOVE_HORIZONTALLY = 3, //Move horizontally to avoid threat
            MAV_COLLISION_ACTION_MOVE_PERPENDICULAR = 4, //Aircraft to move perpendicular to the collision's velocity vector
            MAV_COLLISION_ACTION_RTL = 5, //Aircraft to fly directly back to its launch point
            MAV_COLLISION_ACTION_HOVER = 6 //Aircraft to stop in place
        }

        public static class MAV_COLLISION_ACTION_
        {

            internal static MAV_COLLISION_ACTION from_bits(ulong bits) { return (MAV_COLLISION_ACTION)((sbyte)bits); }

            internal static ulong bits(this MAV_COLLISION_ACTION en) { return (ulong)(en);	}
        }

        /**
        *Aircraft-rated danger from this threat. */


        public enum MAV_COLLISION_THREAT_LEVEL : sbyte
        {

            MAV_COLLISION_THREAT_LEVEL_NONE = 0, //Not a threat
            MAV_COLLISION_THREAT_LEVEL_LOW = 1, //Craft is mildly concerned about this threat
            MAV_COLLISION_THREAT_LEVEL_HIGH = 2 //Craft is panicing, and may take actions to avoid threat
        }

        public static class MAV_COLLISION_THREAT_LEVEL_
        {

            internal static MAV_COLLISION_THREAT_LEVEL from_bits(ulong bits) { return (MAV_COLLISION_THREAT_LEVEL)((sbyte)bits); }

            internal static ulong bits(this MAV_COLLISION_THREAT_LEVEL en) { return (ulong)(en);	}
        }



        public enum LIMITS_STATE : sbyte
        {

            LIMITS_INIT = 0, //pre-initialization
            LIMITS_DISABLED = 1, //disabled
            LIMITS_ENABLED = 2, //checking limits
            LIMITS_TRIGGERED = 3, //a limit has been breached
            LIMITS_RECOVERING = 4, //taking action eg. RTL
            LIMITS_RECOVERED = 5 //we're no longer in breach of a limit
        }

        public static class LIMITS_STATE_
        {

            internal static LIMITS_STATE from_bits(ulong bits) { return (LIMITS_STATE)((sbyte)bits); }

            internal static ulong bits(this LIMITS_STATE en) { return (ulong)(en);	}
        }

        /**
        *Transceiver RF control flags for ADS-B transponder dynamic reports */


        public enum UAVIONIX_ADSB_OUT_RF_SELECT : sbyte
        {

            UAVIONIX_ADSB_OUT_RF_SELECT_STANDBY = 0,
            UAVIONIX_ADSB_OUT_RF_SELECT_RX_ENABLED = 1,
            UAVIONIX_ADSB_OUT_RF_SELECT_TX_ENABLED = 2
        }

        public static class UAVIONIX_ADSB_OUT_RF_SELECT_
        {

            internal static UAVIONIX_ADSB_OUT_RF_SELECT from_bits(ulong bits) { return (UAVIONIX_ADSB_OUT_RF_SELECT)((sbyte)bits); }

            internal static ulong bits(this UAVIONIX_ADSB_OUT_RF_SELECT en) { return (ulong)(en);	}
        }

        /**
        *Enumeration of battery types */


        public enum MAV_BATTERY_TYPE : sbyte
        {

            UNKNOWN = 0, //Not specified.
            LIPO = 1, //Lithium polymer battery
            LIFE = 2, //Lithium-iron-phosphate battery
            LION = 3, //Lithium-ION battery
            NIMH = 4 //Nickel metal hydride battery
        }

        public static class MAV_BATTERY_TYPE_
        {

            internal static MAV_BATTERY_TYPE from_bits(ulong bits) { return (MAV_BATTERY_TYPE)((sbyte)bits); }

            internal static ulong bits(this MAV_BATTERY_TYPE en) { return (ulong)(en);	}
        }

        /**
        *Flags in EKF_STATUS message */


        public enum EKF_STATUS_FLAGS : int
        {

            EKF_ATTITUDE = 1, //set if EKF's attitude estimate is good
            EKF_VELOCITY_HORIZ = 2, //set if EKF's horizontal velocity estimate is good
            EKF_VELOCITY_VERT = 4, //set if EKF's vertical velocity estimate is good
            EKF_POS_HORIZ_REL = 8, //set if EKF's horizontal position (relative) estimate is good
            EKF_POS_HORIZ_ABS = 16, //set if EKF's horizontal position (absolute) estimate is good
            EKF_POS_VERT_ABS = 32, //set if EKF's vertical position (absolute) estimate is good
            EKF_POS_VERT_AGL = 64, //set if EKF's vertical position (above ground) estimate is good
            EKF_CONST_POS_MODE = 128, //EKF is in constant position mode and does not know it's absolute or relative position
            EKF_PRED_POS_HORIZ_REL = 256, //set if EKF's predicted horizontal position (relative) estimate is good
            EKF_PRED_POS_HORIZ_ABS = 512 //set if EKF's predicted horizontal position (absolute) estimate is good
        }

        public static class EKF_STATUS_FLAGS_
        {

            internal static EKF_STATUS_FLAGS from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return EKF_STATUS_FLAGS.EKF_ATTITUDE;
                    case 1:
                        return EKF_STATUS_FLAGS.EKF_VELOCITY_HORIZ;
                    case 2:
                        return EKF_STATUS_FLAGS.EKF_VELOCITY_VERT;
                    case 3:
                        return EKF_STATUS_FLAGS.EKF_POS_HORIZ_REL;
                    case 4:
                        return EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS;
                    case 5:
                        return EKF_STATUS_FLAGS.EKF_POS_VERT_ABS;
                    case 6:
                        return EKF_STATUS_FLAGS.EKF_POS_VERT_AGL;
                    case 7:
                        return EKF_STATUS_FLAGS.EKF_CONST_POS_MODE;
                    case 8:
                        return EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_REL;
                    case 9:
                        return EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_ABS;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this EKF_STATUS_FLAGS en)
            {
                switch(en)
                {
                    case EKF_STATUS_FLAGS.EKF_ATTITUDE:
                        return 0;
                    case EKF_STATUS_FLAGS.EKF_VELOCITY_HORIZ:
                        return 1;
                    case EKF_STATUS_FLAGS.EKF_VELOCITY_VERT:
                        return 2;
                    case EKF_STATUS_FLAGS.EKF_POS_HORIZ_REL:
                        return 3;
                    case EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS:
                        return 4;
                    case EKF_STATUS_FLAGS.EKF_POS_VERT_ABS:
                        return 5;
                    case EKF_STATUS_FLAGS.EKF_POS_VERT_AGL:
                        return 6;
                    case EKF_STATUS_FLAGS.EKF_CONST_POS_MODE:
                        return 7;
                    case EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_REL:
                        return 8;
                    case EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_ABS:
                        return 9;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *These encode the sensors whose status is sent as part of the SYS_STATUS message. */


        public enum MAV_SYS_STATUS_SENSOR : int
        {

            MAV_SYS_STATUS_SENSOR_3D_GYRO = 1, //0x01 3D gyro
            MAV_SYS_STATUS_SENSOR_3D_ACCEL = 2, //0x02 3D accelerometer
            MAV_SYS_STATUS_SENSOR_3D_MAG = 4, //0x04 3D magnetometer
            MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE = 8, //0x08 absolute pressure
            MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE = 16, //0x10 differential pressure
            MAV_SYS_STATUS_SENSOR_GPS = 32, //0x20 GPS
            MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW = 64, //0x40 optical flow
            MAV_SYS_STATUS_SENSOR_VISION_POSITION = 128, //0x80 computer vision position
            MAV_SYS_STATUS_SENSOR_LASER_POSITION = 256, //0x100 laser based position
            MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH = 512, //0x200 external ground truth (Vicon or Leica)
            MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL = 1024, //0x400 3D angular rate control
            MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION = 2048, //0x800 attitude stabilization
            MAV_SYS_STATUS_SENSOR_YAW_POSITION = 4096, //0x1000 yaw position
            MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL = 8192, //0x2000 z/altitude control
            MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL = 16384, //0x4000 x/y position control
            MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS = 32768, //0x8000 motor outputs / control
            MAV_SYS_STATUS_SENSOR_RC_RECEIVER = 65536, //0x10000 rc receiver
            MAV_SYS_STATUS_SENSOR_3D_GYRO2 = 131072, //0x20000 2nd 3D gyro
            MAV_SYS_STATUS_SENSOR_3D_ACCEL2 = 262144, //0x40000 2nd 3D accelerometer
            MAV_SYS_STATUS_SENSOR_3D_MAG2 = 524288, //0x80000 2nd 3D magnetometer
            MAV_SYS_STATUS_GEOFENCE = 1048576, //0x100000 geofence
            MAV_SYS_STATUS_AHRS = 2097152, //0x200000 AHRS subsystem health
            MAV_SYS_STATUS_TERRAIN = 4194304, //0x400000 Terrain subsystem health
            MAV_SYS_STATUS_REVERSE_MOTOR = 8388608, //0x800000 Motors are reversed
            MAV_SYS_STATUS_LOGGING = 16777216, //0x1000000 Logging
            MAV_SYS_STATUS_SENSOR_BATTERY = 33554432 //0x2000000 Battery
        }

        public static class MAV_SYS_STATUS_SENSOR_
        {

            internal static MAV_SYS_STATUS_SENSOR from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_GYRO;
                    case 1:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_ACCEL;
                    case 2:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_MAG;
                    case 3:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE;
                    case 4:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE;
                    case 5:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_GPS;
                    case 6:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW;
                    case 7:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_VISION_POSITION;
                    case 8:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_LASER_POSITION;
                    case 9:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH;
                    case 10:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL;
                    case 11:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION;
                    case 12:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_YAW_POSITION;
                    case 13:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL;
                    case 14:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL;
                    case 15:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS;
                    case 16:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_RC_RECEIVER;
                    case 17:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_GYRO2;
                    case 18:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_ACCEL2;
                    case 19:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_MAG2;
                    case 20:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_GEOFENCE;
                    case 21:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_AHRS;
                    case 22:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_TERRAIN;
                    case 23:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_REVERSE_MOTOR;
                    case 24:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_LOGGING;
                    case 25:
                        return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_BATTERY;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this MAV_SYS_STATUS_SENSOR en)
            {
                switch(en)
                {
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_GYRO:
                        return 0;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_ACCEL:
                        return 1;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_MAG:
                        return 2;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE:
                        return 3;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE:
                        return 4;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_GPS:
                        return 5;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW:
                        return 6;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_VISION_POSITION:
                        return 7;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_LASER_POSITION:
                        return 8;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH:
                        return 9;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL:
                        return 10;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION:
                        return 11;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_YAW_POSITION:
                        return 12;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL:
                        return 13;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL:
                        return 14;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS:
                        return 15;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_RC_RECEIVER:
                        return 16;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_GYRO2:
                        return 17;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_ACCEL2:
                        return 18;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_MAG2:
                        return 19;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_GEOFENCE:
                        return 20;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_AHRS:
                        return 21;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_TERRAIN:
                        return 22;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_REVERSE_MOTOR:
                        return 23;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_LOGGING:
                        return 24;
                    case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_BATTERY:
                        return 25;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }



        public enum MAV_FRAME : sbyte
        {

            /**
            *Global coordinate frame, WGS84 coordinate system. First value / x: latitude, second value / y: longitude,
            *					 third value / z: positive altitude over mean sea level (MSL */
            MAV_FRAME_GLOBAL = 0,
            MAV_FRAME_LOCAL_NED = 1, //Local coordinate frame, Z-up (x: north, y: east, z: down).
            MAV_FRAME_MISSION = 2, //NOT a coordinate frame, indicates a mission command.
            /**
            *Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home
            *			 position. First value / x: latitude, second value / y: longitude, third value / z: positive altitude
            *			 with 0 being at the altitude of the home location */
            MAV_FRAME_GLOBAL_RELATIVE_ALT = 3,
            MAV_FRAME_LOCAL_ENU = 4, //Local coordinate frame, Z-down (x: east, y: north, z: up)
            /**
            *Global coordinate frame, WGS84 coordinate system. First value / x: latitude in degrees*1.0e-7, second
            *			 value / y: longitude in degrees*1.0e-7, third value / z: positive altitude over mean sea level (MSL */
            MAV_FRAME_GLOBAL_INT = 5,
            /**
            *Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home
            *			 position. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third
            *			 value / z: positive altitude with 0 being at the altitude of the home location */
            MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6,
            /**
            *Offset to the current local frame. Anything expressed in this frame should be added to the current local
            *			 frame position */
            MAV_FRAME_LOCAL_OFFSET_NED = 7,
            /**
            *Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to
            *			 command 2 m/s^2 acceleration to the right */
            MAV_FRAME_BODY_NED = 8,
            /**
            *Offset in body NED frame. This makes sense if adding setpoints to the current flight path, to avoid an
            *			 obstacle - e.g. useful to command 2 m/s^2 acceleration to the east */
            MAV_FRAME_BODY_OFFSET_NED = 9,
            /**
            *Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude
            *			 over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees, second value
            *			 / y: longitude in degrees, third value / z: positive altitude in meters with 0 being at ground level
            *			 in terrain model */
            MAV_FRAME_GLOBAL_TERRAIN_ALT = 10,
            /**
            *Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude
            *			 over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees*10e-7, second
            *			 value / y: longitude in degrees*10e-7, third value / z: positive altitude in meters with 0 being at ground
            *			 level in terrain model */
            MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11
        }

        public static class MAV_FRAME_
        {

            internal static MAV_FRAME from_bits(ulong bits) { return (MAV_FRAME)((sbyte)bits); }

            internal static ulong bits(this MAV_FRAME en) { return (ulong)(en);	}
        }

        /**
        *ADSB classification for the type of vehicle emitting the transponder signal */


        public enum ADSB_EMITTER_TYPE : sbyte
        {

            ADSB_EMITTER_TYPE_NO_INFO = 0,
            ADSB_EMITTER_TYPE_LIGHT = 1,
            ADSB_EMITTER_TYPE_SMALL = 2,
            ADSB_EMITTER_TYPE_LARGE = 3,
            ADSB_EMITTER_TYPE_HIGH_VORTEX_LARGE = 4,
            ADSB_EMITTER_TYPE_HEAVY = 5,
            ADSB_EMITTER_TYPE_HIGHLY_MANUV = 6,
            ADSB_EMITTER_TYPE_ROTOCRAFT = 7,
            ADSB_EMITTER_TYPE_UNASSIGNED = 8,
            ADSB_EMITTER_TYPE_GLIDER = 9,
            ADSB_EMITTER_TYPE_LIGHTER_AIR = 10,
            ADSB_EMITTER_TYPE_PARACHUTE = 11,
            ADSB_EMITTER_TYPE_ULTRA_LIGHT = 12,
            ADSB_EMITTER_TYPE_UNASSIGNED2 = 13,
            ADSB_EMITTER_TYPE_UAV = 14,
            ADSB_EMITTER_TYPE_SPACE = 15,
            ADSB_EMITTER_TYPE_UNASSGINED3 = 16,
            ADSB_EMITTER_TYPE_EMERGENCY_SURFACE = 17,
            ADSB_EMITTER_TYPE_SERVICE_SURFACE = 18,
            ADSB_EMITTER_TYPE_POINT_OBSTACLE = 19
        }

        public static class ADSB_EMITTER_TYPE_
        {

            internal static ADSB_EMITTER_TYPE from_bits(ulong bits) { return (ADSB_EMITTER_TYPE)((sbyte)bits); }

            internal static ulong bits(this ADSB_EMITTER_TYPE en) { return (ulong)(en);	}
        }

        /**
        *GPS lataral offset encoding */


        public enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT : sbyte
        {

            NO_DATA = 0,
            LEFT_2M = 1,
            LEFT_4M = 2,
            LEFT_6M = 3,
            RIGHT_0M = 4,
            RIGHT_2M = 5,
            RIGHT_4M = 6,
            RIGHT_6M = 7
        }

        public static class UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_
        {

            internal static UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT from_bits(ulong bits) { return (UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT)((sbyte)bits); }

            internal static ulong bits(this UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT en) { return (ulong)(en);	}
        }

        /**
        *GPS longitudinal offset encoding */


        public enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON : sbyte
        {

            UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_NO_DATA = 0,
            UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_APPLIED_BY_SENSOR = 1
        }

        public static class UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_
        {

            internal static UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON from_bits(ulong bits) { return (UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON)((sbyte)bits); }

            internal static ulong bits(this UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON en) { return (ulong)(en);	}
        }



        public enum GPS_INPUT_IGNORE_FLAGS : int
        {

            GPS_INPUT_IGNORE_FLAG_ALT = 1, //ignore altitude field
            GPS_INPUT_IGNORE_FLAG_HDOP = 2, //ignore hdop field
            GPS_INPUT_IGNORE_FLAG_VDOP = 4, //ignore vdop field
            GPS_INPUT_IGNORE_FLAG_VEL_HORIZ = 8, //ignore horizontal velocity field (vn and ve)
            GPS_INPUT_IGNORE_FLAG_VEL_VERT = 16, //ignore vertical velocity field (vd)
            GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY = 32, //ignore speed accuracy field
            GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY = 64, //ignore horizontal accuracy field
            GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY = 128 //ignore vertical accuracy field
        }

        public static class GPS_INPUT_IGNORE_FLAGS_
        {

            internal static GPS_INPUT_IGNORE_FLAGS from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_ALT;
                    case 1:
                        return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_HDOP;
                    case 2:
                        return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VDOP;
                    case 3:
                        return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VEL_HORIZ;
                    case 4:
                        return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VEL_VERT;
                    case 5:
                        return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY;
                    case 6:
                        return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY;
                    case 7:
                        return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this GPS_INPUT_IGNORE_FLAGS en)
            {
                switch(en)
                {
                    case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_ALT:
                        return 0;
                    case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_HDOP:
                        return 1;
                    case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VDOP:
                        return 2;
                    case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VEL_HORIZ:
                        return 3;
                    case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VEL_VERT:
                        return 4;
                    case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY:
                        return 5;
                    case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY:
                        return 6;
                    case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY:
                        return 7;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *Flags in RALLY_POINT message */


        public enum RALLY_FLAGS : sbyte
        {

            FAVORABLE_WIND = 1, //Flag set when requiring favorable winds for landing.
            /**
            *Flag set when plane is to immediately descend to break altitude and land without GCS intervention. Flag
            *			 not set when plane is to loiter at Rally point until commanded to land */
            LAND_IMMEDIATELY = 2
        }

        public static class RALLY_FLAGS_
        {

            internal static RALLY_FLAGS from_bits(ulong bits) { return (RALLY_FLAGS)(1 + (sbyte)bits); }

            internal static ulong bits(this RALLY_FLAGS en) { return (ulong)(en  - 1);	}
        }



        public enum FENCE_BREACH : sbyte
        {

            FENCE_BREACH_NONE = 0, //No last fence breach
            FENCE_BREACH_MINALT = 1, //Breached minimum altitude
            FENCE_BREACH_MAXALT = 2, //Breached maximum altitude
            FENCE_BREACH_BOUNDARY = 3 //Breached fence boundary
        }

        public static class FENCE_BREACH_
        {

            internal static FENCE_BREACH from_bits(ulong bits) { return (FENCE_BREACH)((sbyte)bits); }

            internal static ulong bits(this FENCE_BREACH en) { return (ulong)(en);	}
        }

        /**
        *These flags encode the MAV mode. */


        public enum MAV_MODE_FLAG : int
        {

            MAV_MODE_FLAG_CUSTOM_MODE_ENABLED = 1, //0b00000001 Reserved for future use.
            /**
            *0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should
            *			 not be used for stable implementations */
            MAV_MODE_FLAG_TEST_ENABLED = 2,
            /**
            *0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not,
            *			 depends on the actual implementation */
            MAV_MODE_FLAG_AUTO_ENABLED = 4,
            MAV_MODE_FLAG_GUIDED_ENABLED = 8, //0b00001000 guided mode enabled, system flies waypoints / mission items.
            /**
            *0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further
            *			 control inputs to move around */
            MAV_MODE_FLAG_STABILIZE_ENABLED = 16,
            /**
            *0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software
            *			 is full operational */
            MAV_MODE_FLAG_HIL_ENABLED = 32,
            MAV_MODE_FLAG_MANUAL_INPUT_ENABLED = 64, //0b01000000 remote control input is enabled.
            /**
            *0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. Additional
            *					 note: this flag is to be ignore when sent in the command MAV_CMD_DO_SET_MODE and MAV_CMD_COMPONENT_ARM_DISARM
            *					 shall be used instead. The flag can still be used to report the armed state */
            MAV_MODE_FLAG_SAFETY_ARMED = 128
        }

        public static class MAV_MODE_FLAG_
        {

            internal static MAV_MODE_FLAG from_bits(ulong id)
            {
                switch(id)
                {
                    case 0:
                        return MAV_MODE_FLAG.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
                    case 1:
                        return MAV_MODE_FLAG.MAV_MODE_FLAG_TEST_ENABLED;
                    case 2:
                        return MAV_MODE_FLAG.MAV_MODE_FLAG_AUTO_ENABLED;
                    case 3:
                        return MAV_MODE_FLAG.MAV_MODE_FLAG_GUIDED_ENABLED;
                    case 4:
                        return MAV_MODE_FLAG.MAV_MODE_FLAG_STABILIZE_ENABLED;
                    case 5:
                        return MAV_MODE_FLAG.MAV_MODE_FLAG_HIL_ENABLED;
                    case 6:
                        return MAV_MODE_FLAG.MAV_MODE_FLAG_MANUAL_INPUT_ENABLED;
                    case 7:
                        return MAV_MODE_FLAG.MAV_MODE_FLAG_SAFETY_ARMED;
                }
                throw  new ArgumentException("Unknown enum ID ");
            }

            internal static ulong bits(this MAV_MODE_FLAG en)
            {
                switch(en)
                {
                    case MAV_MODE_FLAG.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED:
                        return 0;
                    case MAV_MODE_FLAG.MAV_MODE_FLAG_TEST_ENABLED:
                        return 1;
                    case MAV_MODE_FLAG.MAV_MODE_FLAG_AUTO_ENABLED:
                        return 2;
                    case MAV_MODE_FLAG.MAV_MODE_FLAG_GUIDED_ENABLED:
                        return 3;
                    case MAV_MODE_FLAG.MAV_MODE_FLAG_STABILIZE_ENABLED:
                        return 4;
                    case MAV_MODE_FLAG.MAV_MODE_FLAG_HIL_ENABLED:
                        return 5;
                    case MAV_MODE_FLAG.MAV_MODE_FLAG_MANUAL_INPUT_ENABLED:
                        return 6;
                    case MAV_MODE_FLAG.MAV_MODE_FLAG_SAFETY_ARMED:
                        return 7;
                    default:
                        throw  new ArgumentException("Unknown enum " + en);
                }
            }
        }

        /**
        *Bus types for device operations */


        public enum DEVICE_OP_BUSTYPE : sbyte
        {

            DEVICE_OP_BUSTYPE_I2C = 0, //I2C Device operation
            DEVICE_OP_BUSTYPE_SPI = 1 //SPI Device operation
        }

        public static class DEVICE_OP_BUSTYPE_
        {

            internal static DEVICE_OP_BUSTYPE from_bits(ulong bits) { return (DEVICE_OP_BUSTYPE)((sbyte)bits); }

            internal static ulong bits(this DEVICE_OP_BUSTYPE en) { return (ulong)(en);	}
        }




        /**
        *The heartbeat message shows that a system is present and responding. The type of the MAV and Autopilot
        *				 hardware allow the receiving system to treat further messages from this system appropriate (e.g. by laying
        *				 out the user interface based on the autopilot) */

        public struct HEARTBEAT
        {
            internal Pack.Cursor data_;
            internal HEARTBEAT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                typE = 42,
                autopilot = 43,
                base_mode = 44,
                system_status = 45
            }



            public int custom_mode() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public sbyte mavlink_version() { return (sbyte)(data_.bytes[data_.origin  + 4]); }



            public  MAV_TYPE? typE()
            {
                if(data_.field_bit !=  42 && !data_.set_field(42, -1))  return null;
                return (MAV_TYPE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 5)));;
            }





            public  MAV_AUTOPILOT? autopilot()
            {
                if(data_.field_bit !=  43 && !data_.set_field(43, -1))  return null;
                return (MAV_AUTOPILOT)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 5)));;
            }





            public  MAV_MODE_FLAG? base_mode()
            {
                if(data_.field_bit !=  44 && !data_.set_field(44, -1))  return null;
                return    MAV_MODE_FLAG_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 4));;
            }





            public  MAV_STATE? system_status()
            {
                if(data_.field_bit !=  45 && !data_.set_field(45, -1))  return null;
                return (MAV_STATE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }






            public interface DST_
            {
                void typE(com.company.demo.GroundControl. MAV_TYPE src);
                void autopilot(com.company.demo.GroundControl. MAV_AUTOPILOT src);
                void base_mode(com.company.demo.GroundControl. MAV_MODE_FLAG src);
                void custom_mode(int src);
                void system_status(com.company.demo.GroundControl. MAV_STATE src);
                void mavlink_version(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(125, 0, 1, 0, 6, 1, 42, 2, 0, 4);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = typE();
                    if(item.HasValue) dst.typE(item.Value);
                }
                {
                    var item = autopilot();
                    if(item.HasValue) dst.autopilot(item.Value);
                }
                {
                    var item = base_mode();
                    if(item.HasValue) dst.base_mode(item.Value);
                }
                dst.custom_mode(custom_mode()) ;
                {
                    var item = system_status();
                    if(item.HasValue) dst.system_status(item.Value);
                }
                dst.mavlink_version(mavlink_version()) ;
            }



        }
        /**
        *The general system state. If the system is following the MAVLink standard, the system state is mainly
        *				 defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and
        *				 locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position
        *				 setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined
        *				 the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents
        *				 the internal navigation state machine. The system status shows whether the system is currently active
        *				 or not and if an emergency occured. During the CRITICAL and EMERGENCY states the MAV is still considered
        *				 to be active, but should start emergency procedures autonomously. After a failure occured it should first
        *				 move from active to critical to allow manual intervention and then move to emergency after a certain
        *				 timeout */

        public struct SYS_STATUS
        {
            internal Pack.Cursor data_;
            internal SYS_STATUS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                onboard_control_sensors_present = 154,
                onboard_control_sensors_enabled = 155,
                onboard_control_sensors_health = 156
            }



            public short load() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public short voltage_battery() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }


            public short drop_rate_comm() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }


            public short errors_comm() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }


            public short errors_count1() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }


            public short errors_count2() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }


            public short errors_count3() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }


            public short errors_count4() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }


            public short current_battery() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 2)); }


            public sbyte battery_remaining() { return (sbyte)(data_.bytes[data_.origin  + 18]); }



            public  MAV_SYS_STATUS_SENSOR? onboard_control_sensors_present()
            {
                if(data_.field_bit !=  154 && !data_.set_field(154, -1))  return null;
                return    MAV_SYS_STATUS_SENSOR_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 5));;
            }





            public  MAV_SYS_STATUS_SENSOR? onboard_control_sensors_enabled()
            {
                if(data_.field_bit !=  155 && !data_.set_field(155, -1))  return null;
                return    MAV_SYS_STATUS_SENSOR_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 5));;
            }





            public  MAV_SYS_STATUS_SENSOR? onboard_control_sensors_health()
            {
                if(data_.field_bit !=  156 && !data_.set_field(156, -1))  return null;
                return    MAV_SYS_STATUS_SENSOR_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 5));;
            }






            public interface DST_
            {
                void onboard_control_sensors_present(com.company.demo.GroundControl. MAV_SYS_STATUS_SENSOR src);
                void onboard_control_sensors_enabled(com.company.demo.GroundControl. MAV_SYS_STATUS_SENSOR src);
                void onboard_control_sensors_health(com.company.demo.GroundControl. MAV_SYS_STATUS_SENSOR src);
                void load(short src);
                void voltage_battery(short src);
                void current_battery(short src);
                void battery_remaining(sbyte src);
                void drop_rate_comm(short src);
                void errors_comm(short src);
                void errors_count1(short src);
                void errors_count2(short src);
                void errors_count3(short src);
                void errors_count4(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(132, 8, 0, 0, 20, 1, 154, 2, 0, 3);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = onboard_control_sensors_present();
                    if(item.HasValue) dst.onboard_control_sensors_present(item.Value);
                }
                {
                    var item = onboard_control_sensors_enabled();
                    if(item.HasValue) dst.onboard_control_sensors_enabled(item.Value);
                }
                {
                    var item = onboard_control_sensors_health();
                    if(item.HasValue) dst.onboard_control_sensors_health(item.Value);
                }
                dst.load(load()) ;
                dst.voltage_battery(voltage_battery()) ;
                dst.current_battery(current_battery()) ;
                dst.battery_remaining(battery_remaining()) ;
                dst.drop_rate_comm(drop_rate_comm()) ;
                dst.errors_comm(errors_comm()) ;
                dst.errors_count1(errors_count1()) ;
                dst.errors_count2(errors_count2()) ;
                dst.errors_count3(errors_count3()) ;
                dst.errors_count4(errors_count4()) ;
            }



        }
        /**
        *The system time is the time of the master clock, typically the computer clock of the main onboard computer */

        public struct SYSTEM_TIME
        {
            internal Pack.Cursor data_;
            internal SYSTEM_TIME(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public long time_unix_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 8)); }




            public interface DST_
            {
                void time_unix_usec(long src);
                void time_boot_ms(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(9, 0, 1, 1, 12, 1, 96);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_unix_usec(time_unix_usec()) ;
                dst.time_boot_ms(time_boot_ms()) ;
            }



        }
        /**
        *A ping message either requesting or responding to a ping. This allows to measure the system latencies,
        *				 including serial port, radio modem and UDP connections */

        public struct PING
        {
            internal Pack.Cursor data_;
            internal PING(Pack.Cursor data) { this.data_ = data; }




            public int seq() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 8)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 12]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 13]); }




            public interface DST_
            {
                void time_usec(long src);
                void seq(int src);
                void target_system(sbyte src);
                void target_component(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(122, 0, 1, 1, 14, 1, 112);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.seq(seq()) ;
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
            }



        }
        /**
        *Request to control this MAV */

        public struct CHANGE_OPERATOR_CONTROL
        {
            internal Pack.Cursor data_;
            internal CHANGE_OPERATOR_CONTROL(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                passkey = 26
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte control_request() { return (sbyte)(data_.bytes[data_.origin  + 1]); }


            public sbyte version() { return (sbyte)(data_.bytes[data_.origin  + 2]); }



            public passkey_? passkey()
            {
                if(data_.field_bit !=  26 && !data_.set_field(26, -1))  return (passkey_?) null;
                return new passkey_(data_);
            }


            public struct passkey_
            {
                Pack.Cursor data_;
                public passkey_(Pack.Cursor data) {this.data_ = data;}


                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(passkey_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void target_system(sbyte src);
                void control_request(sbyte src);
                void version(sbyte src);
                void passkey(CHANGE_OPERATOR_CONTROL.passkey_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(154, 0, 0, 0, 4, 1, 26, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.control_request(control_request()) ;
                dst.version(version()) ;
                {
                    var item = passkey();
                    if(item.HasValue) dst.passkey(item.Value);
                }
            }



        }
        /**
        *Accept / deny control of this MAV */

        public struct CHANGE_OPERATOR_CONTROL_ACK
        {
            internal Pack.Cursor data_;
            internal CHANGE_OPERATOR_CONTROL_ACK(Pack.Cursor data) { this.data_ = data; }




            public sbyte gcs_system_id() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte control_request() { return (sbyte)(data_.bytes[data_.origin  + 1]); }


            public sbyte ack() { return (sbyte)(data_.bytes[data_.origin  + 2]); }




            public interface DST_
            {
                void gcs_system_id(sbyte src);
                void control_request(sbyte src);
                void ack(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(62, 0, 0, 0, 3, 1, 24);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.gcs_system_id(gcs_system_id()) ;
                dst.control_request(control_request()) ;
                dst.ack(ack()) ;
            }



        }
        /**
        *Emit an encrypted signature / key identifying this system. PLEASE NOTE: This protocol has been kept simple,
        *				 so transmitting the key requires an encrypted channel for true safety */

        public struct AUTH_KEY
        {
            internal Pack.Cursor data_;
            internal AUTH_KEY(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                key = 2
            }




            public key_? key()
            {
                if(data_.field_bit !=  2 && !data_.set_field(2, -1))  return (key_?) null;
                return new key_(data_);
            }


            public struct key_
            {
                Pack.Cursor data_;
                public key_(Pack.Cursor data) {this.data_ = data;}


                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(key_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void key(AUTH_KEY.key_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(95, 0, 0, 0, 1, 1, 2, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = key();
                    if(item.HasValue) dst.key(item.Value);
                }
            }



        }
        /**
        *THIS INTERFACE IS DEPRECATED. USE COMMAND_LONG with MAV_CMD_DO_SET_MODE INSTEAD. Set the system mode,
        *				 as defined by enum MAV_MODE. There is no target component id as the mode is by definition for the overall
        *				 aircraft, not only for one component */

        public struct SET_MODE
        {
            internal Pack.Cursor data_;
            internal SET_MODE(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                base_mode = 40
            }



            public int custom_mode() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 4]); }



            public  MAV_MODE? base_mode()
            {
                if(data_.field_bit !=  40 && !data_.set_field(40, -1))  return null;
                return    MAV_MODE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 4));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void base_mode(com.company.demo.GroundControl. MAV_MODE src);
                void custom_mode(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(7, 0, 1, 0, 6, 1, 40, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                {
                    var item = base_mode();
                    if(item.HasValue) dst.base_mode(item.Value);
                }
                dst.custom_mode(custom_mode()) ;
            }



        }
        /**
        *value[float]. This allows to send a parameter to any other component (such as the GCS) without the need
        *				 of previous knowledge of possible parameter names. Thus the same GCS can store different parameters for
        *				 different autopilots. See also http:qgroundcontrol.org/parameter_interface for a full documentation
        *				 of QGroundControl and IMU code */

        public struct PARAM_REQUEST_READ
        {
            internal Pack.Cursor data_;
            internal PARAM_REQUEST_READ(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                param_id = 34
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }


            public short param_index() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }



            public param_id_? param_id()
            {
                if(data_.field_bit !=  34 && !data_.set_field(34, -1))  return (param_id_?) null;
                return new param_id_(data_);
            }


            public struct param_id_
            {
                Pack.Cursor data_;
                public param_id_(Pack.Cursor data) {this.data_ = data;}


                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(param_id_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void param_id(PARAM_REQUEST_READ.param_id_ src);
                void param_index(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(166, 0, 0, 0, 5, 1, 34, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = param_id();
                    if(item.HasValue) dst.param_id(item.Value);
                }
                dst.param_index(param_index()) ;
            }



        }
        /**
        *Request all parameters of this component. After this request, all parameters are emitted. */

        public struct PARAM_REQUEST_LIST
        {
            internal Pack.Cursor data_;
            internal PARAM_REQUEST_LIST(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }




            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(47, 0, 0, 0, 2, 1, 16);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
            }



        }
        /**
        *Emit the value of a onboard parameter. The inclusion of param_count and param_index in the message allows
        *				 the recipient to keep track of received parameters and allows him to re-request missing parameters after
        *				 a loss or timeout */

        public struct PARAM_VALUE
        {
            internal Pack.Cursor data_;
            internal PARAM_VALUE(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                param_id = 66,
                param_type = 67
            }



            public short param_count() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public short param_index() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }


            public float param_value() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }



            public param_id_? param_id()
            {
                if(data_.field_bit !=  66 && !data_.set_field(66, -1))  return (param_id_?) null;
                return new param_id_(data_);
            }


            public struct param_id_
            {
                Pack.Cursor data_;
                public param_id_(Pack.Cursor data) {this.data_ = data;}


                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(param_id_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public  MAV_PARAM_TYPE? param_type()
            {
                if(data_.field_bit !=  67 && !data_.set_field(67, -1))  return null;
                return (MAV_PARAM_TYPE)((1 + (sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }






            public interface DST_
            {
                void param_id(PARAM_VALUE.param_id_ src);
                void param_value(float src);
                void param_type(com.company.demo.GroundControl. MAV_PARAM_TYPE src);
                void param_count(short src);
                void param_index(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(136, 2, 0, 0, 9, 1, 66, 2, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = param_id();
                    if(item.HasValue) dst.param_id(item.Value);
                }
                dst.param_value(param_value()) ;
                {
                    var item = param_type();
                    if(item.HasValue) dst.param_type(item.Value);
                }
                dst.param_count(param_count()) ;
                dst.param_index(param_index()) ;
            }



        }
        /**
        *Set a parameter value TEMPORARILY to RAM. It will be reset to default on system reboot. Send the ACTION
        *				 MAV_ACTION_STORAGE_WRITE to PERMANENTLY write the RAM contents to EEPROM. IMPORTANT: The receiving component
        *				 should acknowledge the new parameter value by sending a param_value message to all communication partners.
        *				 This will also ensure that multiple GCS all have an up-to-date list of all parameters. If the sending
        *				 GCS did not receive a PARAM_VALUE message within its timeout time, it should re-send the PARAM_SET message */

        public struct PARAM_SET
        {
            internal Pack.Cursor data_;
            internal PARAM_SET(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                param_id = 50,
                param_type = 51
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }


            public float param_value() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 2); }



            public param_id_? param_id()
            {
                if(data_.field_bit !=  50 && !data_.set_field(50, -1))  return (param_id_?) null;
                return new param_id_(data_);
            }


            public struct param_id_
            {
                Pack.Cursor data_;
                public param_id_(Pack.Cursor data) {this.data_ = data;}


                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(param_id_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public  MAV_PARAM_TYPE? param_type()
            {
                if(data_.field_bit !=  51 && !data_.set_field(51, -1))  return null;
                return (MAV_PARAM_TYPE)((1 + (sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void param_id(PARAM_SET.param_id_ src);
                void param_value(float src);
                void param_type(com.company.demo.GroundControl. MAV_PARAM_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(123, 0, 0, 0, 7, 1, 50, 2, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = param_id();
                    if(item.HasValue) dst.param_id(item.Value);
                }
                dst.param_value(param_value()) ;
                {
                    var item = param_type();
                    if(item.HasValue) dst.param_type(item.Value);
                }
            }



        }
        /**
        *The global position, as returned by the Global Positioning System (GPS). This is
        *				 NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame). */

        public struct GPS_RAW_INT
        {
            internal Pack.Cursor data_;
            internal GPS_RAW_INT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                fix_type = 234,
                alt_ellipsoid = 235,
                h_acc = 236,
                v_acc = 237,
                vel_acc = 238,
                hdg_acc = 239
            }



            public short eph() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public short epv() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }


            public short vel() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }


            public short cog() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }


            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 8)); }


            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 4)); }


            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 4)); }


            public int alt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 24, 4)); }


            public sbyte satellites_visible() { return (sbyte)(data_.bytes[data_.origin  + 28]); }



            public  GPS_FIX_TYPE? fix_type()
            {
                if(data_.field_bit !=  234 && !data_.set_field(234, -1))  return null;
                return (GPS_FIX_TYPE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }





            public int? alt_ellipsoid()
            {
                if(data_.field_bit !=  235 && !data_.set_field(235, -1))  return null;
                return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
            }





            public int? h_acc()
            {
                if(data_.field_bit !=  236 && !data_.set_field(236, -1))  return null;
                return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
            }





            public int? v_acc()
            {
                if(data_.field_bit !=  237 && !data_.set_field(237, -1))  return null;
                return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
            }





            public int? vel_acc()
            {
                if(data_.field_bit !=  238 && !data_.set_field(238, -1))  return null;
                return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
            }





            public int? hdg_acc()
            {
                if(data_.field_bit !=  239 && !data_.set_field(239, -1))  return null;
                return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
            }






            public interface DST_
            {
                void time_usec(long src);
                void fix_type(com.company.demo.GroundControl. GPS_FIX_TYPE src);
                void lat(int src);
                void lon(int src);
                void alt(int src);
                void eph(short src);
                void epv(short src);
                void vel(short src);
                void cog(short src);
                void satellites_visible(sbyte src);
                void alt_ellipsoid(int src);
                void h_acc(int src);
                void v_acc(int src);
                void vel_acc(int src);
                void hdg_acc(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(56, 4, 0, 1, 30, 1, 234, 2, 0, 6);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                {
                    var item = fix_type();
                    if(item.HasValue) dst.fix_type(item.Value);
                }
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.alt(alt()) ;
                dst.eph(eph()) ;
                dst.epv(epv()) ;
                dst.vel(vel()) ;
                dst.cog(cog()) ;
                dst.satellites_visible(satellites_visible()) ;
                {
                    var item = alt_ellipsoid();
                    if(item.HasValue) dst.alt_ellipsoid(item.Value);
                }
                {
                    var item = h_acc();
                    if(item.HasValue) dst.h_acc(item.Value);
                }
                {
                    var item = v_acc();
                    if(item.HasValue) dst.v_acc(item.Value);
                }
                {
                    var item = vel_acc();
                    if(item.HasValue) dst.vel_acc(item.Value);
                }
                {
                    var item = hdg_acc();
                    if(item.HasValue) dst.hdg_acc(item.Value);
                }
            }



        }
        /**
        *The positioning status, as reported by GPS. This message is intended to display status information about
        *				 each satellite visible to the receiver. See message GLOBAL_POSITION for the global position estimate.
        *				 This message can contain information for up to 20 satellites */

        public struct GPS_STATUS
        {
            internal Pack.Cursor data_;
            internal GPS_STATUS(Pack.Cursor data) { this.data_ = data; }




            public sbyte satellites_visible() { return (sbyte)(data_.bytes[data_.origin ]); }


            public satellite_prn_ satellite_prn()
            {
                return new  satellite_prn_(data_);
            }

            public struct satellite_prn_
            {
                internal Pack.Cursor data_;
                public satellite_prn_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return GPS_STATUS.satellite_prn_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 1 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != GPS_STATUS.satellite_prn_.item_len) return false;
                    for(int i = 0; i < GPS_STATUS.satellite_prn_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(satellite_prn_ other)
                {
                    if(other.len() != GPS_STATUS.satellite_prn_.item_len) return false;
                    for(int i = 0; i < GPS_STATUS.satellite_prn_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 20 ;


            }


            public satellite_used_ satellite_used()
            {
                return new  satellite_used_(data_);
            }

            public struct satellite_used_
            {
                internal Pack.Cursor data_;
                public satellite_used_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return GPS_STATUS.satellite_used_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 21 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != GPS_STATUS.satellite_used_.item_len) return false;
                    for(int i = 0; i < GPS_STATUS.satellite_used_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(satellite_used_ other)
                {
                    if(other.len() != GPS_STATUS.satellite_used_.item_len) return false;
                    for(int i = 0; i < GPS_STATUS.satellite_used_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 20 ;


            }


            public satellite_elevation_ satellite_elevation()
            {
                return new  satellite_elevation_(data_);
            }

            public struct satellite_elevation_
            {
                internal Pack.Cursor data_;
                public satellite_elevation_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return GPS_STATUS.satellite_elevation_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 41 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != GPS_STATUS.satellite_elevation_.item_len) return false;
                    for(int i = 0; i < GPS_STATUS.satellite_elevation_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(satellite_elevation_ other)
                {
                    if(other.len() != GPS_STATUS.satellite_elevation_.item_len) return false;
                    for(int i = 0; i < GPS_STATUS.satellite_elevation_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 20 ;


            }


            public satellite_azimuth_ satellite_azimuth()
            {
                return new  satellite_azimuth_(data_);
            }

            public struct satellite_azimuth_
            {
                internal Pack.Cursor data_;
                public satellite_azimuth_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return GPS_STATUS.satellite_azimuth_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 61 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != GPS_STATUS.satellite_azimuth_.item_len) return false;
                    for(int i = 0; i < GPS_STATUS.satellite_azimuth_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(satellite_azimuth_ other)
                {
                    if(other.len() != GPS_STATUS.satellite_azimuth_.item_len) return false;
                    for(int i = 0; i < GPS_STATUS.satellite_azimuth_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 20 ;


            }


            public satellite_snr_ satellite_snr()
            {
                return new  satellite_snr_(data_);
            }

            public struct satellite_snr_
            {
                internal Pack.Cursor data_;
                public satellite_snr_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return GPS_STATUS.satellite_snr_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 81 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != GPS_STATUS.satellite_snr_.item_len) return false;
                    for(int i = 0; i < GPS_STATUS.satellite_snr_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(satellite_snr_ other)
                {
                    if(other.len() != GPS_STATUS.satellite_snr_.item_len) return false;
                    for(int i = 0; i < GPS_STATUS.satellite_snr_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 20 ;


            }




            public interface DST_
            {
                void satellites_visible(sbyte src);
                void satellite_prn(GPS_STATUS.satellite_prn_ src);
                void satellite_used(GPS_STATUS.satellite_used_ src);
                void satellite_elevation(GPS_STATUS.satellite_elevation_ src);
                void satellite_azimuth(GPS_STATUS.satellite_azimuth_ src);
                void satellite_snr(GPS_STATUS.satellite_snr_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(48, 0, 0, 0, 101, 1, 808);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.satellites_visible(satellites_visible()) ;
                dst.satellite_prn(satellite_prn());
                dst.satellite_used(satellite_used());
                dst.satellite_elevation(satellite_elevation());
                dst.satellite_azimuth(satellite_azimuth());
                dst.satellite_snr(satellite_snr());
            }



        }
        /**
        *The RAW IMU readings for the usual 9DOF sensor setup. This message should contain the scaled values to
        *				 the described unit */

        public struct SCALED_IMU
        {
            internal Pack.Cursor data_;
            internal SCALED_IMU(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public short xacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }


            public short yacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }


            public short zacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }


            public short xgyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }


            public short ygyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }


            public short zgyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }


            public short xmag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 2)); }


            public short ymag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 18, 2)); }


            public short zmag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 2)); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void xacc(short src);
                void yacc(short src);
                void zacc(short src);
                void xgyro(short src);
                void ygyro(short src);
                void zgyro(short src);
                void xmag(short src);
                void ymag(short src);
                void zmag(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(195, 0, 1, 0, 22, 1, 176);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.xacc(xacc()) ;
                dst.yacc(yacc()) ;
                dst.zacc(zacc()) ;
                dst.xgyro(xgyro()) ;
                dst.ygyro(ygyro()) ;
                dst.zgyro(zgyro()) ;
                dst.xmag(xmag()) ;
                dst.ymag(ymag()) ;
                dst.zmag(zmag()) ;
            }



        }
        /**
        *The RAW IMU readings for the usual 9DOF sensor setup. This message should always contain the true raw
        *				 values without any scaling to allow data capture and system debugging */

        public struct RAW_IMU
        {
            internal Pack.Cursor data_;
            internal RAW_IMU(Pack.Cursor data) { this.data_ = data; }




            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }


            public short xacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }


            public short yacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }


            public short zacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }


            public short xgyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }


            public short ygyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 2)); }


            public short zgyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 18, 2)); }


            public short xmag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 2)); }


            public short ymag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 22, 2)); }


            public short zmag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 24, 2)); }




            public interface DST_
            {
                void time_usec(long src);
                void xacc(short src);
                void yacc(short src);
                void zacc(short src);
                void xgyro(short src);
                void ygyro(short src);
                void zgyro(short src);
                void xmag(short src);
                void ymag(short src);
                void zmag(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(163, 0, 0, 1, 26, 1, 208);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.xacc(xacc()) ;
                dst.yacc(yacc()) ;
                dst.zacc(zacc()) ;
                dst.xgyro(xgyro()) ;
                dst.ygyro(ygyro()) ;
                dst.zgyro(zgyro()) ;
                dst.xmag(xmag()) ;
                dst.ymag(ymag()) ;
                dst.zmag(zmag()) ;
            }



        }
        /**
        *The RAW pressure readings for the typical setup of one absolute pressure and one differential pressure
        *				 sensor. The sensor values should be the raw, UNSCALED ADC values */

        public struct RAW_PRESSURE
        {
            internal Pack.Cursor data_;
            internal RAW_PRESSURE(Pack.Cursor data) { this.data_ = data; }




            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }


            public short press_abs() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }


            public short press_diff1() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }


            public short press_diff2() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }


            public short temperature() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }




            public interface DST_
            {
                void time_usec(long src);
                void press_abs(short src);
                void press_diff1(short src);
                void press_diff2(short src);
                void temperature(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(19, 0, 0, 1, 16, 1, 128);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.press_abs(press_abs()) ;
                dst.press_diff1(press_diff1()) ;
                dst.press_diff2(press_diff2()) ;
                dst.temperature(temperature()) ;
            }



        }
        /**
        *The pressure readings for the typical setup of one absolute and differential pressure sensor. The units
        *				 are as specified in each field */

        public struct SCALED_PRESSURE
        {
            internal Pack.Cursor data_;
            internal SCALED_PRESSURE(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public float press_abs() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }


            public float press_diff() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public short temperature() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void press_abs(float src);
                void press_diff(float src);
                void temperature(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(18, 0, 1, 0, 14, 1, 112);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.press_abs(press_abs()) ;
                dst.press_diff(press_diff()) ;
                dst.temperature(temperature()) ;
            }



        }
        /**
        *The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right). */

        public struct ATTITUDE
        {
            internal Pack.Cursor data_;
            internal ATTITUDE(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }


            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float rollspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float pitchspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }


            public float yawspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void roll(float src);
                void pitch(float src);
                void yaw(float src);
                void rollspeed(float src);
                void pitchspeed(float src);
                void yawspeed(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(134, 0, 1, 0, 28, 1, 224);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
                dst.rollspeed(rollspeed()) ;
                dst.pitchspeed(pitchspeed()) ;
                dst.yawspeed(yawspeed()) ;
            }



        }
        /**
        *The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion.
        *				 Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0) */

        public struct ATTITUDE_QUATERNION
        {
            internal Pack.Cursor data_;
            internal ATTITUDE_QUATERNION(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public float q1() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }


            public float q2() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float q3() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float q4() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float rollspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }


            public float pitchspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }


            public float yawspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void q1(float src);
                void q2(float src);
                void q3(float src);
                void q4(float src);
                void rollspeed(float src);
                void pitchspeed(float src);
                void yawspeed(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(71, 0, 1, 0, 32, 1, 256);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.q1(q1()) ;
                dst.q2(q2()) ;
                dst.q3(q3()) ;
                dst.q4(q4()) ;
                dst.rollspeed(rollspeed()) ;
                dst.pitchspeed(pitchspeed()) ;
                dst.yawspeed(yawspeed()) ;
            }



        }
        /**
        *The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed,
        *				 Z-axis down (aeronautical frame, NED / north-east-down convention */

        public struct LOCAL_POSITION_NED
        {
            internal Pack.Cursor data_;
            internal LOCAL_POSITION_NED(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }


            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float vx() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float vy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }


            public float vz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void x(float src);
                void y(float src);
                void z(float src);
                void vx(float src);
                void vy(float src);
                void vz(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(131, 0, 1, 0, 28, 1, 224);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                dst.vx(vx()) ;
                dst.vy(vy()) ;
                dst.vz(vz()) ;
            }



        }
        /**
        *nt. */

        public struct GLOBAL_POSITION_INT
        {
            internal Pack.Cursor data_;
            internal GLOBAL_POSITION_INT(Pack.Cursor data) { this.data_ = data; }




            public short hdg() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }


            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }


            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }


            public int alt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 4)); }


            public int relative_alt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 18, 4)); }


            public short vx() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 22, 2)); }


            public short vy() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 24, 2)); }


            public short vz() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 26, 2)); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void lat(int src);
                void lon(int src);
                void alt(int src);
                void relative_alt(int src);
                void vx(short src);
                void vy(short src);
                void vz(short src);
                void hdg(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(162, 1, 1, 0, 28, 1, 224);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.alt(alt()) ;
                dst.relative_alt(relative_alt()) ;
                dst.vx(vx()) ;
                dst.vy(vy()) ;
                dst.vz(vz()) ;
                dst.hdg(hdg()) ;
            }



        }
        /**
        *The scaled values of the RC channels received. (-100%) -10000, (0%) 0, (100%) 10000. Channels that are
        *				 inactive should be set to UINT16_MAX */

        public struct RC_CHANNELS_SCALED
        {
            internal Pack.Cursor data_;
            internal RC_CHANNELS_SCALED(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public sbyte port() { return (sbyte)(data_.bytes[data_.origin  + 4]); }


            public short chan1_scaled() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 5, 2)); }


            public short chan2_scaled() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 7, 2)); }


            public short chan3_scaled() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 9, 2)); }


            public short chan4_scaled() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 11, 2)); }


            public short chan5_scaled() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 13, 2)); }


            public short chan6_scaled() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 15, 2)); }


            public short chan7_scaled() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 17, 2)); }


            public short chan8_scaled() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 19, 2)); }


            public sbyte rssi() { return (sbyte)(data_.bytes[data_.origin  + 21]); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void port(sbyte src);
                void chan1_scaled(short src);
                void chan2_scaled(short src);
                void chan3_scaled(short src);
                void chan4_scaled(short src);
                void chan5_scaled(short src);
                void chan6_scaled(short src);
                void chan7_scaled(short src);
                void chan8_scaled(short src);
                void rssi(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(120, 0, 1, 0, 22, 1, 176);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.port(port()) ;
                dst.chan1_scaled(chan1_scaled()) ;
                dst.chan2_scaled(chan2_scaled()) ;
                dst.chan3_scaled(chan3_scaled()) ;
                dst.chan4_scaled(chan4_scaled()) ;
                dst.chan5_scaled(chan5_scaled()) ;
                dst.chan6_scaled(chan6_scaled()) ;
                dst.chan7_scaled(chan7_scaled()) ;
                dst.chan8_scaled(chan8_scaled()) ;
                dst.rssi(rssi()) ;
            }



        }
        /**
        *The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds:
        *				 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification */

        public struct RC_CHANNELS_RAW
        {
            internal Pack.Cursor data_;
            internal RC_CHANNELS_RAW(Pack.Cursor data) { this.data_ = data; }




            public short chan1_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public short chan2_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }


            public short chan3_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }


            public short chan4_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }


            public short chan5_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }


            public short chan6_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }


            public short chan7_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }


            public short chan8_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }


            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 4)); }


            public sbyte port() { return (sbyte)(data_.bytes[data_.origin  + 20]); }


            public sbyte rssi() { return (sbyte)(data_.bytes[data_.origin  + 21]); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void port(sbyte src);
                void chan1_raw(short src);
                void chan2_raw(short src);
                void chan3_raw(short src);
                void chan4_raw(short src);
                void chan5_raw(short src);
                void chan6_raw(short src);
                void chan7_raw(short src);
                void chan8_raw(short src);
                void rssi(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(148, 8, 1, 0, 22, 1, 176);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.port(port()) ;
                dst.chan1_raw(chan1_raw()) ;
                dst.chan2_raw(chan2_raw()) ;
                dst.chan3_raw(chan3_raw()) ;
                dst.chan4_raw(chan4_raw()) ;
                dst.chan5_raw(chan5_raw()) ;
                dst.chan6_raw(chan6_raw()) ;
                dst.chan7_raw(chan7_raw()) ;
                dst.chan8_raw(chan8_raw()) ;
                dst.rssi(rssi()) ;
            }



        }
        /**
        *The RAW values of the servo outputs (for RC input from the remote, use the RC_CHANNELS messages). The
        *				 standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100% */

        public struct SERVO_OUTPUT_RAW
        {
            internal Pack.Cursor data_;
            internal SERVO_OUTPUT_RAW(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                servo9_raw = 168,
                servo10_raw = 169,
                servo11_raw = 170,
                servo12_raw = 171,
                servo13_raw = 172,
                servo14_raw = 173,
                servo15_raw = 174,
                servo16_raw = 175
            }



            public short servo1_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public short servo2_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }


            public short servo3_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }


            public short servo4_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }


            public short servo5_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }


            public short servo6_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }


            public short servo7_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }


            public short servo8_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }


            public int time_usec() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 4)); }


            public sbyte port() { return (sbyte)(data_.bytes[data_.origin  + 20]); }



            public short? servo9_raw()
            {
                if(data_.field_bit !=  168 && !data_.set_field(168, -1))  return null;
                return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.BYTE, 2));;
            }





            public short? servo10_raw()
            {
                if(data_.field_bit !=  169 && !data_.set_field(169, -1))  return null;
                return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.BYTE, 2));;
            }





            public short? servo11_raw()
            {
                if(data_.field_bit !=  170 && !data_.set_field(170, -1))  return null;
                return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.BYTE, 2));;
            }





            public short? servo12_raw()
            {
                if(data_.field_bit !=  171 && !data_.set_field(171, -1))  return null;
                return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.BYTE, 2));;
            }





            public short? servo13_raw()
            {
                if(data_.field_bit !=  172 && !data_.set_field(172, -1))  return null;
                return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.BYTE, 2));;
            }





            public short? servo14_raw()
            {
                if(data_.field_bit !=  173 && !data_.set_field(173, -1))  return null;
                return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.BYTE, 2));;
            }





            public short? servo15_raw()
            {
                if(data_.field_bit !=  174 && !data_.set_field(174, -1))  return null;
                return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.BYTE, 2));;
            }





            public short? servo16_raw()
            {
                if(data_.field_bit !=  175 && !data_.set_field(175, -1))  return null;
                return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.BYTE, 2));;
            }






            public interface DST_
            {
                void time_usec(int src);
                void port(sbyte src);
                void servo1_raw(short src);
                void servo2_raw(short src);
                void servo3_raw(short src);
                void servo4_raw(short src);
                void servo5_raw(short src);
                void servo6_raw(short src);
                void servo7_raw(short src);
                void servo8_raw(short src);
                void servo9_raw(short src);
                void servo10_raw(short src);
                void servo11_raw(short src);
                void servo12_raw(short src);
                void servo13_raw(short src);
                void servo14_raw(short src);
                void servo15_raw(short src);
                void servo16_raw(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(79, 8, 1, 0, 22, 1, 168, 0, 0, 8);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.port(port()) ;
                dst.servo1_raw(servo1_raw()) ;
                dst.servo2_raw(servo2_raw()) ;
                dst.servo3_raw(servo3_raw()) ;
                dst.servo4_raw(servo4_raw()) ;
                dst.servo5_raw(servo5_raw()) ;
                dst.servo6_raw(servo6_raw()) ;
                dst.servo7_raw(servo7_raw()) ;
                dst.servo8_raw(servo8_raw()) ;
                {
                    var item = servo9_raw();
                    if(item.HasValue) dst.servo9_raw(item.Value);
                }
                {
                    var item = servo10_raw();
                    if(item.HasValue) dst.servo10_raw(item.Value);
                }
                {
                    var item = servo11_raw();
                    if(item.HasValue) dst.servo11_raw(item.Value);
                }
                {
                    var item = servo12_raw();
                    if(item.HasValue) dst.servo12_raw(item.Value);
                }
                {
                    var item = servo13_raw();
                    if(item.HasValue) dst.servo13_raw(item.Value);
                }
                {
                    var item = servo14_raw();
                    if(item.HasValue) dst.servo14_raw(item.Value);
                }
                {
                    var item = servo15_raw();
                    if(item.HasValue) dst.servo15_raw(item.Value);
                }
                {
                    var item = servo16_raw();
                    if(item.HasValue) dst.servo16_raw(item.Value);
                }
            }



        }
        /**
        *Request a partial list of mission items from the system/component. http:qgroundcontrol.org/mavlink/waypoint_protocol.
        *				 If start and end index are the same, just send one waypoint */

        public struct MISSION_REQUEST_PARTIAL_LIST
        {
            internal Pack.Cursor data_;
            internal MISSION_REQUEST_PARTIAL_LIST(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                mission_type = 48
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }


            public short start_index() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }


            public short end_index() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }



            public  MAV_MISSION_TYPE? mission_type()
            {
                if(data_.field_bit !=  48 && !data_.set_field(48, -1))  return null;
                return    MAV_MISSION_TYPE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void start_index(short src);
                void end_index(short src);
                void mission_type(com.company.demo.GroundControl. MAV_MISSION_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(206, 0, 0, 0, 7, 1, 48, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.start_index(start_index()) ;
                dst.end_index(end_index()) ;
                {
                    var item = mission_type();
                    if(item.HasValue) dst.mission_type(item.Value);
                }
            }



        }
        /**
        *This message is sent to the MAV to write a partial list. If start index == end index, only one item will
        *				 be transmitted / updated. If the start index is NOT 0 and above the current list size, this request should
        *				 be REJECTED */

        public struct MISSION_WRITE_PARTIAL_LIST
        {
            internal Pack.Cursor data_;
            internal MISSION_WRITE_PARTIAL_LIST(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                mission_type = 48
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }


            public short start_index() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }


            public short end_index() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }



            public  MAV_MISSION_TYPE? mission_type()
            {
                if(data_.field_bit !=  48 && !data_.set_field(48, -1))  return null;
                return    MAV_MISSION_TYPE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void start_index(short src);
                void end_index(short src);
                void mission_type(com.company.demo.GroundControl. MAV_MISSION_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(145, 0, 0, 0, 7, 1, 48, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.start_index(start_index()) ;
                dst.end_index(end_index()) ;
                {
                    var item = mission_type();
                    if(item.HasValue) dst.mission_type(item.Value);
                }
            }



        }
        /**
        *Message encoding a mission item. This message is emitted to announce
        *				 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See also http:qgroundcontrol.org/mavlink/waypoint_protocol. */

        public struct MISSION_ITEM
        {
            internal Pack.Cursor data_;
            internal MISSION_ITEM(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                frame = 274,
                command = 275,
                mission_type = 276
            }



            public short seq() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }


            public sbyte current() { return (sbyte)(data_.bytes[data_.origin  + 4]); }


            public sbyte autocontinue() { return (sbyte)(data_.bytes[data_.origin  + 5]); }


            public float param1() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 6); }


            public float param2() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 10); }


            public float param3() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 14); }


            public float param4() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 18); }


            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 22); }


            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 26); }


            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 30); }



            public  MAV_FRAME? frame()
            {
                if(data_.field_bit !=  274 && !data_.set_field(274, -1))  return null;
                return (MAV_FRAME)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }





            public  MAV_CMD? command()
            {
                if(data_.field_bit !=  275 && !data_.set_field(275, -1))  return null;
                return    MAV_CMD_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 8));;
            }





            public  MAV_MISSION_TYPE? mission_type()
            {
                if(data_.field_bit !=  276 && !data_.set_field(276, -1))  return null;
                return    MAV_MISSION_TYPE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void seq(short src);
                void frame(com.company.demo.GroundControl. MAV_FRAME src);
                void command(com.company.demo.GroundControl. MAV_CMD src);
                void current(sbyte src);
                void autocontinue(sbyte src);
                void param1(float src);
                void param2(float src);
                void param3(float src);
                void param4(float src);
                void x(float src);
                void y(float src);
                void z(float src);
                void mission_type(com.company.demo.GroundControl. MAV_MISSION_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(35, 1, 0, 0, 35, 1, 274, 2, 0, 3);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.seq(seq()) ;
                {
                    var item = frame();
                    if(item.HasValue) dst.frame(item.Value);
                }
                {
                    var item = command();
                    if(item.HasValue) dst.command(item.Value);
                }
                dst.current(current()) ;
                dst.autocontinue(autocontinue()) ;
                dst.param1(param1()) ;
                dst.param2(param2()) ;
                dst.param3(param3()) ;
                dst.param4(param4()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                {
                    var item = mission_type();
                    if(item.HasValue) dst.mission_type(item.Value);
                }
            }



        }
        /**
        *Request the information of the mission item with the sequence number seq. The response of the system to
        *				 this message should be a MISSION_ITEM message. http:qgroundcontrol.org/mavlink/waypoint_protoco */

        public struct MISSION_REQUEST
        {
            internal Pack.Cursor data_;
            internal MISSION_REQUEST(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                mission_type = 32
            }



            public short seq() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }



            public  MAV_MISSION_TYPE? mission_type()
            {
                if(data_.field_bit !=  32 && !data_.set_field(32, -1))  return null;
                return    MAV_MISSION_TYPE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void seq(short src);
                void mission_type(com.company.demo.GroundControl. MAV_MISSION_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(147, 1, 0, 0, 5, 1, 32, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.seq(seq()) ;
                {
                    var item = mission_type();
                    if(item.HasValue) dst.mission_type(item.Value);
                }
            }



        }
        /**
        *Set the mission item with sequence number seq as current item. This means that the MAV will continue to
        *				 this mission item on the shortest path (not following the mission items in-between) */

        public struct MISSION_SET_CURRENT
        {
            internal Pack.Cursor data_;
            internal MISSION_SET_CURRENT(Pack.Cursor data) { this.data_ = data; }




            public short seq() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }




            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void seq(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(212, 1, 0, 0, 4, 1, 32);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.seq(seq()) ;
            }



        }
        /**
        *Message that announces the sequence number of the current active mission item. The MAV will fly towards
        *				 this mission item */

        public struct MISSION_CURRENT
        {
            internal Pack.Cursor data_;
            internal MISSION_CURRENT(Pack.Cursor data) { this.data_ = data; }




            public short seq() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }




            public interface DST_
            {
                void seq(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(189, 1, 0, 0, 2, 1, 16);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.seq(seq()) ;
            }



        }
        /**
        *Request the overall list of mission items from the system/component. */

        public struct MISSION_REQUEST_LIST
        {
            internal Pack.Cursor data_;
            internal MISSION_REQUEST_LIST(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                mission_type = 16
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }



            public  MAV_MISSION_TYPE? mission_type()
            {
                if(data_.field_bit !=  16 && !data_.set_field(16, -1))  return null;
                return    MAV_MISSION_TYPE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void mission_type(com.company.demo.GroundControl. MAV_MISSION_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(25, 0, 0, 0, 3, 1, 16, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = mission_type();
                    if(item.HasValue) dst.mission_type(item.Value);
                }
            }



        }
        /**
        *This message is emitted as response to MISSION_REQUEST_LIST by the MAV and to initiate a write transaction.
        *				 The GCS can then request the individual mission item based on the knowledge of the total number of waypoints */

        public struct MISSION_COUNT
        {
            internal Pack.Cursor data_;
            internal MISSION_COUNT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                mission_type = 32
            }



            public short count() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }



            public  MAV_MISSION_TYPE? mission_type()
            {
                if(data_.field_bit !=  32 && !data_.set_field(32, -1))  return null;
                return    MAV_MISSION_TYPE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void count(short src);
                void mission_type(com.company.demo.GroundControl. MAV_MISSION_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(50, 1, 0, 0, 5, 1, 32, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.count(count()) ;
                {
                    var item = mission_type();
                    if(item.HasValue) dst.mission_type(item.Value);
                }
            }



        }
        /**
        *Delete all mission items at once. */

        public struct MISSION_CLEAR_ALL
        {
            internal Pack.Cursor data_;
            internal MISSION_CLEAR_ALL(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                mission_type = 16
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }



            public  MAV_MISSION_TYPE? mission_type()
            {
                if(data_.field_bit !=  16 && !data_.set_field(16, -1))  return null;
                return    MAV_MISSION_TYPE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void mission_type(com.company.demo.GroundControl. MAV_MISSION_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(193, 0, 0, 0, 3, 1, 16, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = mission_type();
                    if(item.HasValue) dst.mission_type(item.Value);
                }
            }



        }
        /**
        *A certain mission item has been reached. The system will either hold this position (or circle on the orbit)
        *				 or (if the autocontinue on the WP was set) continue to the next waypoint */

        public struct MISSION_ITEM_REACHED
        {
            internal Pack.Cursor data_;
            internal MISSION_ITEM_REACHED(Pack.Cursor data) { this.data_ = data; }




            public short seq() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }




            public interface DST_
            {
                void seq(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(81, 1, 0, 0, 2, 1, 16);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.seq(seq()) ;
            }



        }
        /**
        *Ack message during waypoint handling. The type field states if this message is a positive ack (type=0)
        *				 or if an error happened (type=non-zero) */

        public struct MISSION_ACK
        {
            internal Pack.Cursor data_;
            internal MISSION_ACK(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                typE = 18,
                mission_type = 19
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }



            public  MAV_MISSION_RESULT? typE()
            {
                if(data_.field_bit !=  18 && !data_.set_field(18, -1))  return null;
                return (MAV_MISSION_RESULT)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }





            public  MAV_MISSION_TYPE? mission_type()
            {
                if(data_.field_bit !=  19 && !data_.set_field(19, -1))  return null;
                return    MAV_MISSION_TYPE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void typE(com.company.demo.GroundControl. MAV_MISSION_RESULT src);
                void mission_type(com.company.demo.GroundControl. MAV_MISSION_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(85, 0, 0, 0, 3, 1, 18, 2, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = typE();
                    if(item.HasValue) dst.typE(item.Value);
                }
                {
                    var item = mission_type();
                    if(item.HasValue) dst.mission_type(item.Value);
                }
            }



        }
        /**
        *As local waypoints exist, the global waypoint reference allows to transform between the local coordinate
        *				 frame and the global (GPS) coordinate frame. This can be necessary when e.g. in- and outdoor settings
        *				 are connected and the MAV should move from in- to outdoor */

        public struct SET_GPS_GLOBAL_ORIGIN
        {
            internal Pack.Cursor data_;
            internal SET_GPS_GLOBAL_ORIGIN(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                time_usec = 104
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public int latitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 1, 4)); }


            public int longitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 5, 4)); }


            public int altitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 9, 4)); }



            public long? time_usec()
            {
                if(data_.field_bit !=  104 && !data_.set_field(104, -1))  return null;
                return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.BYTE, 8));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void latitude(int src);
                void longitude(int src);
                void altitude(int src);
                void time_usec(long src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(53, 0, 0, 0, 14, 1, 104, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.latitude(latitude()) ;
                dst.longitude(longitude()) ;
                dst.altitude(altitude()) ;
                {
                    var item = time_usec();
                    if(item.HasValue) dst.time_usec(item.Value);
                }
            }



        }
        /**
        *Once the MAV sets a new GPS-Local correspondence, this message announces the origin (0,0,0) positio */

        public struct GPS_GLOBAL_ORIGIN
        {
            internal Pack.Cursor data_;
            internal GPS_GLOBAL_ORIGIN(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                time_usec = 96
            }



            public int latitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public int longitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }


            public int altitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 4)); }



            public long? time_usec()
            {
                if(data_.field_bit !=  96 && !data_.set_field(96, -1))  return null;
                return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.BYTE, 8));;
            }






            public interface DST_
            {
                void latitude(int src);
                void longitude(int src);
                void altitude(int src);
                void time_usec(long src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(185, 0, 0, 0, 13, 1, 96, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.latitude(latitude()) ;
                dst.longitude(longitude()) ;
                dst.altitude(altitude()) ;
                {
                    var item = time_usec();
                    if(item.HasValue) dst.time_usec(item.Value);
                }
            }



        }
        /**
        *Bind a RC channel to a parameter. The parameter should change accoding to the RC channel value. */

        public struct PARAM_MAP_RC
        {
            internal Pack.Cursor data_;
            internal PARAM_MAP_RC(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                param_id = 170
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }


            public short param_index() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }


            public sbyte parameter_rc_channel_index() { return (sbyte)(data_.bytes[data_.origin  + 4]); }


            public float param_value0() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 5); }


            public float scale() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 9); }


            public float param_value_min() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 13); }


            public float param_value_max() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 17); }



            public param_id_? param_id()
            {
                if(data_.field_bit !=  170 && !data_.set_field(170, -1))  return (param_id_?) null;
                return new param_id_(data_);
            }


            public struct param_id_
            {
                Pack.Cursor data_;
                public param_id_(Pack.Cursor data) {this.data_ = data;}


                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(param_id_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void param_id(PARAM_MAP_RC.param_id_ src);
                void param_index(short src);
                void parameter_rc_channel_index(sbyte src);
                void param_value0(float src);
                void scale(float src);
                void param_value_min(float src);
                void param_value_max(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(29, 0, 0, 0, 22, 1, 170, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = param_id();
                    if(item.HasValue) dst.param_id(item.Value);
                }
                dst.param_index(param_index()) ;
                dst.parameter_rc_channel_index(parameter_rc_channel_index()) ;
                dst.param_value0(param_value0()) ;
                dst.scale(scale()) ;
                dst.param_value_min(param_value_min()) ;
                dst.param_value_max(param_value_max()) ;
            }



        }
        /**
        *Request the information of the mission item with the sequence number seq. The response of the system to
        *				 this message should be a MISSION_ITEM_INT message. http:qgroundcontrol.org/mavlink/waypoint_protoco */

        public struct MISSION_REQUEST_INT
        {
            internal Pack.Cursor data_;
            internal MISSION_REQUEST_INT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                mission_type = 32
            }



            public short seq() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }



            public  MAV_MISSION_TYPE? mission_type()
            {
                if(data_.field_bit !=  32 && !data_.set_field(32, -1))  return null;
                return    MAV_MISSION_TYPE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void seq(short src);
                void mission_type(com.company.demo.GroundControl. MAV_MISSION_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(188, 1, 0, 0, 5, 1, 32, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.seq(seq()) ;
                {
                    var item = mission_type();
                    if(item.HasValue) dst.mission_type(item.Value);
                }
            }



        }
        /**
        *Set a safety zone (volume), which is defined by two corners of a cube. This message can be used to tell
        *				 the MAV which setpoints/waypoints to accept and which to reject. Safety areas are often enforced by national
        *				 or competition regulations */

        public struct SAFETY_SET_ALLOWED_AREA
        {
            internal Pack.Cursor data_;
            internal SAFETY_SET_ALLOWED_AREA(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                frame = 208
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }


            public float p1x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 2); }


            public float p1y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 6); }


            public float p1z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 10); }


            public float p2x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 14); }


            public float p2y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 18); }


            public float p2z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 22); }



            public  MAV_FRAME? frame()
            {
                if(data_.field_bit !=  208 && !data_.set_field(208, -1))  return null;
                return (MAV_FRAME)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void frame(com.company.demo.GroundControl. MAV_FRAME src);
                void p1x(float src);
                void p1y(float src);
                void p1z(float src);
                void p2x(float src);
                void p2y(float src);
                void p2z(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(24, 0, 0, 0, 27, 1, 208, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = frame();
                    if(item.HasValue) dst.frame(item.Value);
                }
                dst.p1x(p1x()) ;
                dst.p1y(p1y()) ;
                dst.p1z(p1z()) ;
                dst.p2x(p2x()) ;
                dst.p2y(p2y()) ;
                dst.p2z(p2z()) ;
            }



        }
        /**
        *Read out the safety zone the MAV currently assumes. */

        public struct SAFETY_ALLOWED_AREA
        {
            internal Pack.Cursor data_;
            internal SAFETY_ALLOWED_AREA(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                frame = 192
            }



            public float p1x() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }


            public float p1y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }


            public float p1z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float p2x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float p2y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float p2z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }



            public  MAV_FRAME? frame()
            {
                if(data_.field_bit !=  192 && !data_.set_field(192, -1))  return null;
                return (MAV_FRAME)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }






            public interface DST_
            {
                void frame(com.company.demo.GroundControl. MAV_FRAME src);
                void p1x(float src);
                void p1y(float src);
                void p1z(float src);
                void p2x(float src);
                void p2y(float src);
                void p2z(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(179, 0, 0, 0, 25, 1, 192, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = frame();
                    if(item.HasValue) dst.frame(item.Value);
                }
                dst.p1x(p1x()) ;
                dst.p1y(p1y()) ;
                dst.p1z(p1z()) ;
                dst.p2x(p2x()) ;
                dst.p2y(p2y()) ;
                dst.p2z(p2z()) ;
            }



        }
        /**
        *The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion.
        *				 Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0) */

        public struct ATTITUDE_QUATERNION_COV
        {
            internal Pack.Cursor data_;
            internal ATTITUDE_QUATERNION_COV(Pack.Cursor data) { this.data_ = data; }




            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }


            public q_ q()
            {
                return new  q_(data_);
            }

            public struct q_
            {
                internal Pack.Cursor data_;
                public q_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return ATTITUDE_QUATERNION_COV.q_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != ATTITUDE_QUATERNION_COV.q_.item_len) return false;
                    for(int i = 0; i < ATTITUDE_QUATERNION_COV.q_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(q_ other)
                {
                    if(other.len() != ATTITUDE_QUATERNION_COV.q_.item_len) return false;
                    for(int i = 0; i < ATTITUDE_QUATERNION_COV.q_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 4 ;


            }


            public float rollspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }


            public float pitchspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }


            public float yawspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }


            public covariance_ covariance()
            {
                return new  covariance_(data_);
            }

            public struct covariance_
            {
                internal Pack.Cursor data_;
                public covariance_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return ATTITUDE_QUATERNION_COV.covariance_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != ATTITUDE_QUATERNION_COV.covariance_.item_len) return false;
                    for(int i = 0; i < ATTITUDE_QUATERNION_COV.covariance_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(covariance_ other)
                {
                    if(other.len() != ATTITUDE_QUATERNION_COV.covariance_.item_len) return false;
                    for(int i = 0; i < ATTITUDE_QUATERNION_COV.covariance_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 9 ;


            }




            public interface DST_
            {
                void time_usec(long src);
                void q(ATTITUDE_QUATERNION_COV.q_ src);
                void rollspeed(float src);
                void pitchspeed(float src);
                void yawspeed(float src);
                void covariance(ATTITUDE_QUATERNION_COV.covariance_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(182, 0, 0, 1, 72, 1, 576);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.q(q());
                dst.rollspeed(rollspeed()) ;
                dst.pitchspeed(pitchspeed()) ;
                dst.yawspeed(yawspeed()) ;
                dst.covariance(covariance());
            }



        }
        /**
        *The state of the fixed wing navigation and position controller. */

        public struct NAV_CONTROLLER_OUTPUT
        {
            internal Pack.Cursor data_;
            internal NAV_CONTROLLER_OUTPUT(Pack.Cursor data) { this.data_ = data; }




            public short wp_dist() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public float nav_roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 2); }


            public float nav_pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 6); }


            public short nav_bearing() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }


            public short target_bearing() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }


            public float alt_error() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 14); }


            public float aspd_error() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 18); }


            public float xtrack_error() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 22); }




            public interface DST_
            {
                void nav_roll(float src);
                void nav_pitch(float src);
                void nav_bearing(short src);
                void target_bearing(short src);
                void wp_dist(short src);
                void alt_error(float src);
                void aspd_error(float src);
                void xtrack_error(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(201, 1, 0, 0, 26, 1, 208);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.nav_roll(nav_roll()) ;
                dst.nav_pitch(nav_pitch()) ;
                dst.nav_bearing(nav_bearing()) ;
                dst.target_bearing(target_bearing()) ;
                dst.wp_dist(wp_dist()) ;
                dst.alt_error(alt_error()) ;
                dst.aspd_error(aspd_error()) ;
                dst.xtrack_error(xtrack_error()) ;
            }



        }
        /**
        *The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed,
        *				 Z-up). It  is designed as scaled integer message since the resolution of float is not sufficient. NOTE:
        *				 This message is intended for onboard networks / companion computers and higher-bandwidth links and optimized
        *				 for accuracy and completeness. Please use the GLOBAL_POSITION_INT message for a minimal subset */

        public struct GLOBAL_POSITION_INT_COV
        {
            internal Pack.Cursor data_;
            internal GLOBAL_POSITION_INT_COV(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                estimator_type = 1440
            }



            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }


            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 4)); }


            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 4)); }


            public int alt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 4)); }


            public int relative_alt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 4)); }


            public float vx() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }


            public float vy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }


            public float vz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }


            public covariance_ covariance()
            {
                return new  covariance_(data_);
            }

            public struct covariance_
            {
                internal Pack.Cursor data_;
                public covariance_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return GLOBAL_POSITION_INT_COV.covariance_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != GLOBAL_POSITION_INT_COV.covariance_.item_len) return false;
                    for(int i = 0; i < GLOBAL_POSITION_INT_COV.covariance_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(covariance_ other)
                {
                    if(other.len() != GLOBAL_POSITION_INT_COV.covariance_.item_len) return false;
                    for(int i = 0; i < GLOBAL_POSITION_INT_COV.covariance_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 36 ;


            }



            public  MAV_ESTIMATOR_TYPE? estimator_type()
            {
                if(data_.field_bit !=  1440 && !data_.set_field(1440, -1))  return null;
                return (MAV_ESTIMATOR_TYPE)((1 + (sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }






            public interface DST_
            {
                void time_usec(long src);
                void estimator_type(com.company.demo.GroundControl. MAV_ESTIMATOR_TYPE src);
                void lat(int src);
                void lon(int src);
                void alt(int src);
                void relative_alt(int src);
                void vx(float src);
                void vy(float src);
                void vz(float src);
                void covariance(GLOBAL_POSITION_INT_COV.covariance_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(6, 0, 0, 1, 181, 1, 1440, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                {
                    var item = estimator_type();
                    if(item.HasValue) dst.estimator_type(item.Value);
                }
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.alt(alt()) ;
                dst.relative_alt(relative_alt()) ;
                dst.vx(vx()) ;
                dst.vy(vy()) ;
                dst.vz(vz()) ;
                dst.covariance(covariance());
            }



        }
        /**
        *The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed,
        *				 Z-axis down (aeronautical frame, NED / north-east-down convention */

        public struct LOCAL_POSITION_NED_COV
        {
            internal Pack.Cursor data_;
            internal LOCAL_POSITION_NED_COV(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                estimator_type = 1792
            }



            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }


            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float vx() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }


            public float vy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }


            public float vz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }


            public float ax() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }


            public float ay() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }


            public float az() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }


            public covariance_ covariance()
            {
                return new  covariance_(data_);
            }

            public struct covariance_
            {
                internal Pack.Cursor data_;
                public covariance_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return LOCAL_POSITION_NED_COV.covariance_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 44 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != LOCAL_POSITION_NED_COV.covariance_.item_len) return false;
                    for(int i = 0; i < LOCAL_POSITION_NED_COV.covariance_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(covariance_ other)
                {
                    if(other.len() != LOCAL_POSITION_NED_COV.covariance_.item_len) return false;
                    for(int i = 0; i < LOCAL_POSITION_NED_COV.covariance_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 45 ;


            }



            public  MAV_ESTIMATOR_TYPE? estimator_type()
            {
                if(data_.field_bit !=  1792 && !data_.set_field(1792, -1))  return null;
                return (MAV_ESTIMATOR_TYPE)((1 + (sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }






            public interface DST_
            {
                void time_usec(long src);
                void estimator_type(com.company.demo.GroundControl. MAV_ESTIMATOR_TYPE src);
                void x(float src);
                void y(float src);
                void z(float src);
                void vx(float src);
                void vy(float src);
                void vz(float src);
                void ax(float src);
                void ay(float src);
                void az(float src);
                void covariance(LOCAL_POSITION_NED_COV.covariance_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(180, 0, 0, 1, 225, 1, 1792, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                {
                    var item = estimator_type();
                    if(item.HasValue) dst.estimator_type(item.Value);
                }
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                dst.vx(vx()) ;
                dst.vy(vy()) ;
                dst.vz(vz()) ;
                dst.ax(ax()) ;
                dst.ay(ay()) ;
                dst.az(az()) ;
                dst.covariance(covariance());
            }



        }
        /**
        *The PPM values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds:
        *				 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification */

        public struct RC_CHANNELS
        {
            internal Pack.Cursor data_;
            internal RC_CHANNELS(Pack.Cursor data) { this.data_ = data; }




            public short chan1_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public short chan2_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }


            public short chan3_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }


            public short chan4_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }


            public short chan5_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }


            public short chan6_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }


            public short chan7_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }


            public short chan8_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }


            public short chan9_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 2)); }


            public short chan10_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 18, 2)); }


            public short chan11_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 2)); }


            public short chan12_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 22, 2)); }


            public short chan13_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 24, 2)); }


            public short chan14_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 26, 2)); }


            public short chan15_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 28, 2)); }


            public short chan16_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 30, 2)); }


            public short chan17_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 32, 2)); }


            public short chan18_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 34, 2)); }


            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 36, 4)); }


            public sbyte chancount() { return (sbyte)(data_.bytes[data_.origin  + 40]); }


            public sbyte rssi() { return (sbyte)(data_.bytes[data_.origin  + 41]); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void chancount(sbyte src);
                void chan1_raw(short src);
                void chan2_raw(short src);
                void chan3_raw(short src);
                void chan4_raw(short src);
                void chan5_raw(short src);
                void chan6_raw(short src);
                void chan7_raw(short src);
                void chan8_raw(short src);
                void chan9_raw(short src);
                void chan10_raw(short src);
                void chan11_raw(short src);
                void chan12_raw(short src);
                void chan13_raw(short src);
                void chan14_raw(short src);
                void chan15_raw(short src);
                void chan16_raw(short src);
                void chan17_raw(short src);
                void chan18_raw(short src);
                void rssi(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(23, 18, 1, 0, 42, 1, 336);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.chancount(chancount()) ;
                dst.chan1_raw(chan1_raw()) ;
                dst.chan2_raw(chan2_raw()) ;
                dst.chan3_raw(chan3_raw()) ;
                dst.chan4_raw(chan4_raw()) ;
                dst.chan5_raw(chan5_raw()) ;
                dst.chan6_raw(chan6_raw()) ;
                dst.chan7_raw(chan7_raw()) ;
                dst.chan8_raw(chan8_raw()) ;
                dst.chan9_raw(chan9_raw()) ;
                dst.chan10_raw(chan10_raw()) ;
                dst.chan11_raw(chan11_raw()) ;
                dst.chan12_raw(chan12_raw()) ;
                dst.chan13_raw(chan13_raw()) ;
                dst.chan14_raw(chan14_raw()) ;
                dst.chan15_raw(chan15_raw()) ;
                dst.chan16_raw(chan16_raw()) ;
                dst.chan17_raw(chan17_raw()) ;
                dst.chan18_raw(chan18_raw()) ;
                dst.rssi(rssi()) ;
            }



        }
        /**
        *THIS INTERFACE IS DEPRECATED. USE SET_MESSAGE_INTERVAL INSTEAD. */

        public struct REQUEST_DATA_STREAM
        {
            internal Pack.Cursor data_;
            internal REQUEST_DATA_STREAM(Pack.Cursor data) { this.data_ = data; }




            public short req_message_rate() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }


            public sbyte req_stream_id() { return (sbyte)(data_.bytes[data_.origin  + 4]); }


            public sbyte start_stop() { return (sbyte)(data_.bytes[data_.origin  + 5]); }




            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void req_stream_id(sbyte src);
                void req_message_rate(short src);
                void start_stop(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(98, 1, 0, 0, 6, 1, 48);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.req_stream_id(req_stream_id()) ;
                dst.req_message_rate(req_message_rate()) ;
                dst.start_stop(start_stop()) ;
            }



        }
        /**
        *THIS INTERFACE IS DEPRECATED. USE MESSAGE_INTERVAL INSTEAD. */

        public struct DATA_STREAM
        {
            internal Pack.Cursor data_;
            internal DATA_STREAM(Pack.Cursor data) { this.data_ = data; }




            public short message_rate() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public sbyte stream_id() { return (sbyte)(data_.bytes[data_.origin  + 2]); }


            public sbyte on_off() { return (sbyte)(data_.bytes[data_.origin  + 3]); }




            public interface DST_
            {
                void stream_id(sbyte src);
                void message_rate(short src);
                void on_off(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(31, 1, 0, 0, 4, 1, 32);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.stream_id(stream_id()) ;
                dst.message_rate(message_rate()) ;
                dst.on_off(on_off()) ;
            }



        }
        /**
        *This message provides an API for manually controlling the vehicle using standard joystick axes nomenclature,
        *				 along with a joystick-like input device. Unused axes can be disabled an buttons are also transmit as
        *				 boolean values of their */

        public struct MANUAL_CONTROL
        {
            internal Pack.Cursor data_;
            internal MANUAL_CONTROL(Pack.Cursor data) { this.data_ = data; }




            public short buttons() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public sbyte target() { return (sbyte)(data_.bytes[data_.origin  + 2]); }


            public short x() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 3, 2)); }


            public short y() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 5, 2)); }


            public short z() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 7, 2)); }


            public short r() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 9, 2)); }




            public interface DST_
            {
                void target(sbyte src);
                void x(short src);
                void y(short src);
                void z(short src);
                void r(short src);
                void buttons(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(54, 1, 0, 0, 11, 1, 88);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target(target()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                dst.r(r()) ;
                dst.buttons(buttons()) ;
            }



        }
        /**
        *The RAW values of the RC channels sent to the MAV to override info received from the RC radio. A value
        *				 of UINT16_MAX means no change to that channel. A value of 0 means control of that channel should be released
        *				 back to the RC radio. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds:
        *				 100%. Individual receivers/transmitters might violate this specification */

        public struct RC_CHANNELS_OVERRIDE
        {
            internal Pack.Cursor data_;
            internal RC_CHANNELS_OVERRIDE(Pack.Cursor data) { this.data_ = data; }




            public short chan1_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public short chan2_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }


            public short chan3_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }


            public short chan4_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }


            public short chan5_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }


            public short chan6_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }


            public short chan7_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }


            public short chan8_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 16]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 17]); }




            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void chan1_raw(short src);
                void chan2_raw(short src);
                void chan3_raw(short src);
                void chan4_raw(short src);
                void chan5_raw(short src);
                void chan6_raw(short src);
                void chan7_raw(short src);
                void chan8_raw(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(55, 8, 0, 0, 18, 1, 144);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.chan1_raw(chan1_raw()) ;
                dst.chan2_raw(chan2_raw()) ;
                dst.chan3_raw(chan3_raw()) ;
                dst.chan4_raw(chan4_raw()) ;
                dst.chan5_raw(chan5_raw()) ;
                dst.chan6_raw(chan6_raw()) ;
                dst.chan7_raw(chan7_raw()) ;
                dst.chan8_raw(chan8_raw()) ;
            }



        }
        /**
        *Message encoding a mission item. This message is emitted to announce
        *				 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See alsohttp:qgroundcontrol.org/mavlink/waypoint_protocol. */

        public struct MISSION_ITEM_INT
        {
            internal Pack.Cursor data_;
            internal MISSION_ITEM_INT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                frame = 274,
                command = 275,
                mission_type = 276
            }



            public short seq() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }


            public sbyte current() { return (sbyte)(data_.bytes[data_.origin  + 4]); }


            public sbyte autocontinue() { return (sbyte)(data_.bytes[data_.origin  + 5]); }


            public float param1() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 6); }


            public float param2() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 10); }


            public float param3() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 14); }


            public float param4() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 18); }


            public int x() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 22, 4)); }


            public int y() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 26, 4)); }


            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 30); }



            public  MAV_FRAME? frame()
            {
                if(data_.field_bit !=  274 && !data_.set_field(274, -1))  return null;
                return (MAV_FRAME)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }





            public  MAV_CMD? command()
            {
                if(data_.field_bit !=  275 && !data_.set_field(275, -1))  return null;
                return    MAV_CMD_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 8));;
            }





            public  MAV_MISSION_TYPE? mission_type()
            {
                if(data_.field_bit !=  276 && !data_.set_field(276, -1))  return null;
                return    MAV_MISSION_TYPE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void seq(short src);
                void frame(com.company.demo.GroundControl. MAV_FRAME src);
                void command(com.company.demo.GroundControl. MAV_CMD src);
                void current(sbyte src);
                void autocontinue(sbyte src);
                void param1(float src);
                void param2(float src);
                void param3(float src);
                void param4(float src);
                void x(int src);
                void y(int src);
                void z(float src);
                void mission_type(com.company.demo.GroundControl. MAV_MISSION_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(59, 1, 0, 0, 35, 1, 274, 2, 0, 3);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.seq(seq()) ;
                {
                    var item = frame();
                    if(item.HasValue) dst.frame(item.Value);
                }
                {
                    var item = command();
                    if(item.HasValue) dst.command(item.Value);
                }
                dst.current(current()) ;
                dst.autocontinue(autocontinue()) ;
                dst.param1(param1()) ;
                dst.param2(param2()) ;
                dst.param3(param3()) ;
                dst.param4(param4()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                {
                    var item = mission_type();
                    if(item.HasValue) dst.mission_type(item.Value);
                }
            }



        }
        /**
        *Metrics typically displayed on a HUD for fixed wing aircraft */

        public struct VFR_HUD
        {
            internal Pack.Cursor data_;
            internal VFR_HUD(Pack.Cursor data) { this.data_ = data; }




            public short throttle() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public float airspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 2); }


            public float groundspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 6); }


            public short heading() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }


            public float alt() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float climb() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }




            public interface DST_
            {
                void airspeed(float src);
                void groundspeed(float src);
                void heading(short src);
                void throttle(short src);
                void alt(float src);
                void climb(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(15, 1, 0, 0, 20, 1, 160);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.airspeed(airspeed()) ;
                dst.groundspeed(groundspeed()) ;
                dst.heading(heading()) ;
                dst.throttle(throttle()) ;
                dst.alt(alt()) ;
                dst.climb(climb()) ;
            }



        }
        /**
        *Message encoding a command with parameters as scaled integers. Scaling depends on the actual command value */

        public struct COMMAND_INT
        {
            internal Pack.Cursor data_;
            internal COMMAND_INT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                frame = 258,
                command = 259
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }


            public sbyte current() { return (sbyte)(data_.bytes[data_.origin  + 2]); }


            public sbyte autocontinue() { return (sbyte)(data_.bytes[data_.origin  + 3]); }


            public float param1() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }


            public float param2() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float param3() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float param4() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public int x() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 4)); }


            public int y() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 24, 4)); }


            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }



            public  MAV_FRAME? frame()
            {
                if(data_.field_bit !=  258 && !data_.set_field(258, -1))  return null;
                return (MAV_FRAME)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }





            public  MAV_CMD? command()
            {
                if(data_.field_bit !=  259 && !data_.set_field(259, -1))  return null;
                return    MAV_CMD_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 8));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void frame(com.company.demo.GroundControl. MAV_FRAME src);
                void command(com.company.demo.GroundControl. MAV_CMD src);
                void current(sbyte src);
                void autocontinue(sbyte src);
                void param1(float src);
                void param2(float src);
                void param3(float src);
                void param4(float src);
                void x(int src);
                void y(int src);
                void z(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(167, 0, 0, 0, 33, 1, 258, 2, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = frame();
                    if(item.HasValue) dst.frame(item.Value);
                }
                {
                    var item = command();
                    if(item.HasValue) dst.command(item.Value);
                }
                dst.current(current()) ;
                dst.autocontinue(autocontinue()) ;
                dst.param1(param1()) ;
                dst.param2(param2()) ;
                dst.param3(param3()) ;
                dst.param4(param4()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
            }



        }
        /**
        *Send a command with up to seven parameters to the MAV */

        public struct COMMAND_LONG
        {
            internal Pack.Cursor data_;
            internal COMMAND_LONG(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                command = 250
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }


            public sbyte confirmation() { return (sbyte)(data_.bytes[data_.origin  + 2]); }


            public float param1() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 3); }


            public float param2() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 7); }


            public float param3() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 11); }


            public float param4() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 15); }


            public float param5() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 19); }


            public float param6() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 23); }


            public float param7() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 27); }



            public  MAV_CMD? command()
            {
                if(data_.field_bit !=  250 && !data_.set_field(250, -1))  return null;
                return    MAV_CMD_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 8));;
            }






            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void command(com.company.demo.GroundControl. MAV_CMD src);
                void confirmation(sbyte src);
                void param1(float src);
                void param2(float src);
                void param3(float src);
                void param4(float src);
                void param5(float src);
                void param6(float src);
                void param7(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(101, 0, 0, 0, 32, 1, 250, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = command();
                    if(item.HasValue) dst.command(item.Value);
                }
                dst.confirmation(confirmation()) ;
                dst.param1(param1()) ;
                dst.param2(param2()) ;
                dst.param3(param3()) ;
                dst.param4(param4()) ;
                dst.param5(param5()) ;
                dst.param6(param6()) ;
                dst.param7(param7()) ;
            }



        }
        /**
        *Report status of a command. Includes feedback whether the command was executed. */

        public struct COMMAND_ACK
        {
            internal Pack.Cursor data_;
            internal COMMAND_ACK(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                command = 2,
                result = 3,
                progress = 4,
                result_param2 = 5,
                target_system = 6,
                target_component = 7
            }




            public  MAV_CMD? command()
            {
                if(data_.field_bit !=  2 && !data_.set_field(2, -1))  return null;
                return    MAV_CMD_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 8));;
            }





            public  MAV_RESULT? result()
            {
                if(data_.field_bit !=  3 && !data_.set_field(3, -1))  return null;
                return (MAV_RESULT)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }





            public sbyte? progress()
            {
                if(data_.field_bit !=  4 && !data_.set_field(4, -1))  return null;
                return (sbyte)(data_.bytes[data_.BYTE]);;
            }





            public int? result_param2()
            {
                if(data_.field_bit !=  5 && !data_.set_field(5, -1))  return null;
                return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
            }





            public sbyte? target_system()
            {
                if(data_.field_bit !=  6 && !data_.set_field(6, -1))  return null;
                return (sbyte)(data_.bytes[data_.BYTE]);;
            }





            public sbyte? target_component()
            {
                if(data_.field_bit !=  7 && !data_.set_field(7, -1))  return null;
                return (sbyte)(data_.bytes[data_.BYTE]);;
            }






            public interface DST_
            {
                void command(com.company.demo.GroundControl. MAV_CMD src);
                void result(com.company.demo.GroundControl. MAV_RESULT src);
                void progress(sbyte src);
                void result_param2(int src);
                void target_system(sbyte src);
                void target_component(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(121, 0, 0, 0, 1, 1, 2, 2, 0, 6);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = command();
                    if(item.HasValue) dst.command(item.Value);
                }
                {
                    var item = result();
                    if(item.HasValue) dst.result(item.Value);
                }
                {
                    var item = progress();
                    if(item.HasValue) dst.progress(item.Value);
                }
                {
                    var item = result_param2();
                    if(item.HasValue) dst.result_param2(item.Value);
                }
                {
                    var item = target_system();
                    if(item.HasValue) dst.target_system(item.Value);
                }
                {
                    var item = target_component();
                    if(item.HasValue) dst.target_component(item.Value);
                }
            }



        }
        /**
        *Setpoint in roll, pitch, yaw and thrust from the operator */

        public struct MANUAL_SETPOINT
        {
            internal Pack.Cursor data_;
            internal MANUAL_SETPOINT(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }


            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float thrust() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public sbyte mode_switch() { return (sbyte)(data_.bytes[data_.origin  + 20]); }


            public sbyte manual_override_switch() { return (sbyte)(data_.bytes[data_.origin  + 21]); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void roll(float src);
                void pitch(float src);
                void yaw(float src);
                void thrust(float src);
                void mode_switch(sbyte src);
                void manual_override_switch(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(219, 0, 1, 0, 22, 1, 176);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
                dst.thrust(thrust()) ;
                dst.mode_switch(mode_switch()) ;
                dst.manual_override_switch(manual_override_switch()) ;
            }



        }
        /**
        *Sets a desired vehicle attitude. Used by an external controller to command the vehicle (manual controller
        *				 or other system) */

        public struct SET_ATTITUDE_TARGET
        {
            internal Pack.Cursor data_;
            internal SET_ATTITUDE_TARGET(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 4]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 5]); }


            public sbyte type_mask() { return (sbyte)(data_.bytes[data_.origin  + 6]); }


            public q_ q()
            {
                return new  q_(data_);
            }

            public struct q_
            {
                internal Pack.Cursor data_;
                public q_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return SET_ATTITUDE_TARGET.q_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 7 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != SET_ATTITUDE_TARGET.q_.item_len) return false;
                    for(int i = 0; i < SET_ATTITUDE_TARGET.q_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(q_ other)
                {
                    if(other.len() != SET_ATTITUDE_TARGET.q_.item_len) return false;
                    for(int i = 0; i < SET_ATTITUDE_TARGET.q_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 4 ;


            }


            public float body_roll_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 23); }


            public float body_pitch_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 27); }


            public float body_yaw_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 31); }


            public float thrust() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 35); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void target_system(sbyte src);
                void target_component(sbyte src);
                void type_mask(sbyte src);
                void q(SET_ATTITUDE_TARGET.q_ src);
                void body_roll_rate(float src);
                void body_pitch_rate(float src);
                void body_yaw_rate(float src);
                void thrust(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(74, 0, 1, 0, 39, 1, 312);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.type_mask(type_mask()) ;
                dst.q(q());
                dst.body_roll_rate(body_roll_rate()) ;
                dst.body_pitch_rate(body_pitch_rate()) ;
                dst.body_yaw_rate(body_yaw_rate()) ;
                dst.thrust(thrust()) ;
            }



        }
        /**
        *Reports the current commanded attitude of the vehicle as specified by the autopilot. This should match
        *				 the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way */

        public struct ATTITUDE_TARGET
        {
            internal Pack.Cursor data_;
            internal ATTITUDE_TARGET(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public sbyte type_mask() { return (sbyte)(data_.bytes[data_.origin  + 4]); }


            public q_ q()
            {
                return new  q_(data_);
            }

            public struct q_
            {
                internal Pack.Cursor data_;
                public q_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return ATTITUDE_TARGET.q_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 5 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != ATTITUDE_TARGET.q_.item_len) return false;
                    for(int i = 0; i < ATTITUDE_TARGET.q_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(q_ other)
                {
                    if(other.len() != ATTITUDE_TARGET.q_.item_len) return false;
                    for(int i = 0; i < ATTITUDE_TARGET.q_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 4 ;


            }


            public float body_roll_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 21); }


            public float body_pitch_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 25); }


            public float body_yaw_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 29); }


            public float thrust() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 33); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void type_mask(sbyte src);
                void q(ATTITUDE_TARGET.q_ src);
                void body_roll_rate(float src);
                void body_pitch_rate(float src);
                void body_yaw_rate(float src);
                void thrust(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(106, 0, 1, 0, 37, 1, 296);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.type_mask(type_mask()) ;
                dst.q(q());
                dst.body_roll_rate(body_roll_rate()) ;
                dst.body_pitch_rate(body_pitch_rate()) ;
                dst.body_yaw_rate(body_yaw_rate()) ;
                dst.thrust(thrust()) ;
            }



        }
        /**
        *Sets a desired vehicle position in a local north-east-down coordinate frame. Used by an external controller
        *				 to command the vehicle (manual controller or other system) */

        public struct SET_POSITION_TARGET_LOCAL_NED
        {
            internal Pack.Cursor data_;
            internal SET_POSITION_TARGET_LOCAL_NED(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                coordinate_frame = 416
            }



            public short type_mask() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 6]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 7]); }


            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float vx() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }


            public float vy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }


            public float vz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }


            public float afx() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }


            public float afy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }


            public float afz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }


            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 44); }


            public float yaw_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 48); }



            public  MAV_FRAME? coordinate_frame()
            {
                if(data_.field_bit !=  416 && !data_.set_field(416, -1))  return null;
                return (MAV_FRAME)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }






            public interface DST_
            {
                void time_boot_ms(int src);
                void target_system(sbyte src);
                void target_component(sbyte src);
                void coordinate_frame(com.company.demo.GroundControl. MAV_FRAME src);
                void type_mask(short src);
                void x(float src);
                void y(float src);
                void z(float src);
                void vx(float src);
                void vy(float src);
                void vz(float src);
                void afx(float src);
                void afy(float src);
                void afz(float src);
                void yaw(float src);
                void yaw_rate(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(209, 1, 1, 0, 53, 1, 416, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = coordinate_frame();
                    if(item.HasValue) dst.coordinate_frame(item.Value);
                }
                dst.type_mask(type_mask()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                dst.vx(vx()) ;
                dst.vy(vy()) ;
                dst.vz(vz()) ;
                dst.afx(afx()) ;
                dst.afy(afy()) ;
                dst.afz(afz()) ;
                dst.yaw(yaw()) ;
                dst.yaw_rate(yaw_rate()) ;
            }



        }
        /**
        *Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot.
        *				 This should match the commands sent in SET_POSITION_TARGET_LOCAL_NED if the vehicle is being controlled
        *				 this way */

        public struct POSITION_TARGET_LOCAL_NED
        {
            internal Pack.Cursor data_;
            internal POSITION_TARGET_LOCAL_NED(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                coordinate_frame = 400
            }



            public short type_mask() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }


            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 6); }


            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 10); }


            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 14); }


            public float vx() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 18); }


            public float vy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 22); }


            public float vz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 26); }


            public float afx() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 30); }


            public float afy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 34); }


            public float afz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 38); }


            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 42); }


            public float yaw_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 46); }



            public  MAV_FRAME? coordinate_frame()
            {
                if(data_.field_bit !=  400 && !data_.set_field(400, -1))  return null;
                return (MAV_FRAME)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }






            public interface DST_
            {
                void time_boot_ms(int src);
                void coordinate_frame(com.company.demo.GroundControl. MAV_FRAME src);
                void type_mask(short src);
                void x(float src);
                void y(float src);
                void z(float src);
                void vx(float src);
                void vy(float src);
                void vz(float src);
                void afx(float src);
                void afy(float src);
                void afz(float src);
                void yaw(float src);
                void yaw_rate(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(129, 1, 1, 0, 51, 1, 400, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                {
                    var item = coordinate_frame();
                    if(item.HasValue) dst.coordinate_frame(item.Value);
                }
                dst.type_mask(type_mask()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                dst.vx(vx()) ;
                dst.vy(vy()) ;
                dst.vz(vz()) ;
                dst.afx(afx()) ;
                dst.afy(afy()) ;
                dst.afz(afz()) ;
                dst.yaw(yaw()) ;
                dst.yaw_rate(yaw_rate()) ;
            }



        }
        /**
        *Sets a desired vehicle position, velocity, and/or acceleration in a global coordinate system (WGS84).
        *				 Used by an external controller to command the vehicle (manual controller or other system) */

        public struct SET_POSITION_TARGET_GLOBAL_INT
        {
            internal Pack.Cursor data_;
            internal SET_POSITION_TARGET_GLOBAL_INT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                coordinate_frame = 416
            }



            public short type_mask() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }


            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 6]); }


            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 7]); }


            public int lat_int() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 4)); }


            public int lon_int() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 4)); }


            public float alt() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float vx() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }


            public float vy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }


            public float vz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }


            public float afx() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }


            public float afy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }


            public float afz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }


            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 44); }


            public float yaw_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 48); }



            public  MAV_FRAME? coordinate_frame()
            {
                if(data_.field_bit !=  416 && !data_.set_field(416, -1))  return null;
                return (MAV_FRAME)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }






            public interface DST_
            {
                void time_boot_ms(int src);
                void target_system(sbyte src);
                void target_component(sbyte src);
                void coordinate_frame(com.company.demo.GroundControl. MAV_FRAME src);
                void type_mask(short src);
                void lat_int(int src);
                void lon_int(int src);
                void alt(float src);
                void vx(float src);
                void vy(float src);
                void vz(float src);
                void afx(float src);
                void afy(float src);
                void afz(float src);
                void yaw(float src);
                void yaw_rate(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(218, 1, 1, 0, 53, 1, 416, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = coordinate_frame();
                    if(item.HasValue) dst.coordinate_frame(item.Value);
                }
                dst.type_mask(type_mask()) ;
                dst.lat_int(lat_int()) ;
                dst.lon_int(lon_int()) ;
                dst.alt(alt()) ;
                dst.vx(vx()) ;
                dst.vy(vy()) ;
                dst.vz(vz()) ;
                dst.afx(afx()) ;
                dst.afy(afy()) ;
                dst.afz(afz()) ;
                dst.yaw(yaw()) ;
                dst.yaw_rate(yaw_rate()) ;
            }



        }
        /**
        *Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot.
        *				 This should match the commands sent in SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being controlled
        *				 this way */

        public struct POSITION_TARGET_GLOBAL_INT
        {
            internal Pack.Cursor data_;
            internal POSITION_TARGET_GLOBAL_INT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                coordinate_frame = 400
            }



            public short type_mask() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }


            public int lat_int() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }


            public int lon_int() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }


            public float alt() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 14); }


            public float vx() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 18); }


            public float vy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 22); }


            public float vz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 26); }


            public float afx() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 30); }


            public float afy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 34); }


            public float afz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 38); }


            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 42); }


            public float yaw_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 46); }



            public  MAV_FRAME? coordinate_frame()
            {
                if(data_.field_bit !=  400 && !data_.set_field(400, -1))  return null;
                return (MAV_FRAME)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }






            public interface DST_
            {
                void time_boot_ms(int src);
                void coordinate_frame(com.company.demo.GroundControl. MAV_FRAME src);
                void type_mask(short src);
                void lat_int(int src);
                void lon_int(int src);
                void alt(float src);
                void vx(float src);
                void vy(float src);
                void vz(float src);
                void afx(float src);
                void afy(float src);
                void afz(float src);
                void yaw(float src);
                void yaw_rate(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(133, 1, 1, 0, 51, 1, 400, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                {
                    var item = coordinate_frame();
                    if(item.HasValue) dst.coordinate_frame(item.Value);
                }
                dst.type_mask(type_mask()) ;
                dst.lat_int(lat_int()) ;
                dst.lon_int(lon_int()) ;
                dst.alt(alt()) ;
                dst.vx(vx()) ;
                dst.vy(vy()) ;
                dst.vz(vz()) ;
                dst.afx(afx()) ;
                dst.afy(afy()) ;
                dst.afz(afz()) ;
                dst.yaw(yaw()) ;
                dst.yaw_rate(yaw_rate()) ;
            }



        }
        /**
        *The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages of MAV X and the global coordinate
        *				 frame in NED coordinates. Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down
        *				 convention */

        public struct LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET
        {
            internal Pack.Cursor data_;
            internal LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }


            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }


            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }


            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }




            public interface DST_
            {
                void time_boot_ms(int src);
                void x(float src);
                void y(float src);
                void z(float src);
                void roll(float src);
                void pitch(float src);
                void yaw(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(158, 0, 1, 0, 28, 1, 224);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
            }



        }
        /**
        *DEPRECATED PACKET! Suffers from missing airspeed fields and singularities due to Euler angles. Please
        *				 use HIL_STATE_QUATERNION instead. Sent from simulation to autopilot. This packet is useful for high throughput
        *				 applications such as hardware in the loop simulations */

        public struct HIL_STATE
        {
            internal Pack.Cursor data_;
            internal HIL_STATE(Pack.Cursor data) { this.data_ = data; }




            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }


            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float rollspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }


            public float pitchspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }


            public float yawspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }


            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 32, 4)); }


            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 36, 4)); }


            public int alt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 40, 4)); }


            public short vx() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 44, 2)); }


            public short vy() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 46, 2)); }


            public short vz() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 48, 2)); }


            public short xacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 50, 2)); }


            public short yacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 52, 2)); }


            public short zacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 54, 2)); }




            public interface DST_
            {
                void time_usec(long src);
                void roll(float src);
                void pitch(float src);
                void yaw(float src);
                void rollspeed(float src);
                void pitchspeed(float src);
                void yawspeed(float src);
                void lat(int src);
                void lon(int src);
                void alt(int src);
                void vx(short src);
                void vy(short src);
                void vz(short src);
                void xacc(short src);
                void yacc(short src);
                void zacc(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(140, 0, 0, 1, 56, 1, 448);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
                dst.rollspeed(rollspeed()) ;
                dst.pitchspeed(pitchspeed()) ;
                dst.yawspeed(yawspeed()) ;
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.alt(alt()) ;
                dst.vx(vx()) ;
                dst.vy(vy()) ;
                dst.vz(vz()) ;
                dst.xacc(xacc()) ;
                dst.yacc(yacc()) ;
                dst.zacc(zacc()) ;
            }



        }
        /**
        *Sent from autopilot to simulation. Hardware in the loop control outputs */

        public struct HIL_CONTROLS
        {
            internal Pack.Cursor data_;
            internal HIL_CONTROLS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                mode = 328
            }



            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }


            public float roll_ailerons() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float pitch_elevator() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float yaw_rudder() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float throttle() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }


            public float aux1() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }


            public float aux2() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }


            public float aux3() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }


            public float aux4() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }


            public sbyte nav_mode() { return (sbyte)(data_.bytes[data_.origin  + 40]); }



            public  MAV_MODE? mode()
            {
                if(data_.field_bit !=  328 && !data_.set_field(328, -1))  return null;
                return    MAV_MODE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 4));;
            }






            public interface DST_
            {
                void time_usec(long src);
                void roll_ailerons(float src);
                void pitch_elevator(float src);
                void yaw_rudder(float src);
                void throttle(float src);
                void aux1(float src);
                void aux2(float src);
                void aux3(float src);
                void aux4(float src);
                void mode(com.company.demo.GroundControl. MAV_MODE src);
                void nav_mode(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(82, 0, 0, 1, 42, 1, 328, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.roll_ailerons(roll_ailerons()) ;
                dst.pitch_elevator(pitch_elevator()) ;
                dst.yaw_rudder(yaw_rudder()) ;
                dst.throttle(throttle()) ;
                dst.aux1(aux1()) ;
                dst.aux2(aux2()) ;
                dst.aux3(aux3()) ;
                dst.aux4(aux4()) ;
                {
                    var item = mode();
                    if(item.HasValue) dst.mode(item.Value);
                }
                dst.nav_mode(nav_mode()) ;
            }



        }
        /**
        *Sent from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation
        *				 is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might
        *				 violate this specification */

        public struct HIL_RC_INPUTS_RAW
        {
            internal Pack.Cursor data_;
            internal HIL_RC_INPUTS_RAW(Pack.Cursor data) { this.data_ = data; }




            public short chan1_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }


            public short chan2_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }


            public short chan3_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }


            public short chan4_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }


            public short chan5_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }


            public short chan6_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }


            public short chan7_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }


            public short chan8_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }


            public short chan9_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 2)); }


            public short chan10_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 18, 2)); }


            public short chan11_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 2)); }


            public short chan12_raw() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 22, 2)); }


            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 24, 8)); }


            public sbyte rssi() { return (sbyte)(data_.bytes[data_.origin  + 32]); }




            public interface DST_
            {
                void time_usec(long src);
                void chan1_raw(short src);
                void chan2_raw(short src);
                void chan3_raw(short src);
                void chan4_raw(short src);
                void chan5_raw(short src);
                void chan6_raw(short src);
                void chan7_raw(short src);
                void chan8_raw(short src);
                void chan9_raw(short src);
                void chan10_raw(short src);
                void chan11_raw(short src);
                void chan12_raw(short src);
                void rssi(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(184, 12, 0, 1, 33, 1, 264);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.chan1_raw(chan1_raw()) ;
                dst.chan2_raw(chan2_raw()) ;
                dst.chan3_raw(chan3_raw()) ;
                dst.chan4_raw(chan4_raw()) ;
                dst.chan5_raw(chan5_raw()) ;
                dst.chan6_raw(chan6_raw()) ;
                dst.chan7_raw(chan7_raw()) ;
                dst.chan8_raw(chan8_raw()) ;
                dst.chan9_raw(chan9_raw()) ;
                dst.chan10_raw(chan10_raw()) ;
                dst.chan11_raw(chan11_raw()) ;
                dst.chan12_raw(chan12_raw()) ;
                dst.rssi(rssi()) ;
            }



        }
        /**
        *Sent from autopilot to simulation. Hardware in the loop control outputs (replacement for HIL_CONTROLS */

        public struct HIL_ACTUATOR_CONTROLS
        {
            internal Pack.Cursor data_;
            internal HIL_ACTUATOR_CONTROLS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                mode = 640
            }



            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }


            public long flags() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 8)); }


            public controls_ controls()
            {
                return new  controls_(data_);
            }

            public struct controls_
            {
                internal Pack.Cursor data_;
                public controls_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return HIL_ACTUATOR_CONTROLS.controls_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != HIL_ACTUATOR_CONTROLS.controls_.item_len) return false;
                    for(int i = 0; i < HIL_ACTUATOR_CONTROLS.controls_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(controls_ other)
                {
                    if(other.len() != HIL_ACTUATOR_CONTROLS.controls_.item_len) return false;
                    for(int i = 0; i < HIL_ACTUATOR_CONTROLS.controls_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }



                public const int item_len = 16 ;


            }



            public  MAV_MODE? mode()
            {
                if(data_.field_bit !=  640 && !data_.set_field(640, -1))  return null;
                return    MAV_MODE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 4));;
            }






            public interface DST_
            {
                void time_usec(long src);
                void controls(HIL_ACTUATOR_CONTROLS.controls_ src);
                void mode(com.company.demo.GroundControl. MAV_MODE src);
                void flags(long src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(199, 0, 0, 2, 81, 1, 640, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.controls(controls());
                {
                    var item = mode();
                    if(item.HasValue) dst.mode(item.Value);
                }
                dst.flags(flags()) ;
            }



        }
        /**
        *Optical flow from a flow sensor (e.g. optical mouse sensor) */

        public struct OPTICAL_FLOW
        {
            internal Pack.Cursor data_;
            internal OPTICAL_FLOW(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                flow_rate_x = 208,
                flow_rate_y = 209
            }



            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }


            public sbyte sensor_id() { return (sbyte)(data_.bytes[data_.origin  + 8]); }


            public short flow_x() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 9, 2)); }


            public short flow_y() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 11, 2)); }


            public float flow_comp_m_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 13); }


            public float flow_comp_m_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 17); }


            public sbyte quality() { return (sbyte)(data_.bytes[data_.origin  + 21]); }


            public float ground_distance() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 22); }



            public float? flow_rate_x()
            {
                if(data_.field_bit !=  208 && !data_.set_field(208, -1))  return null;
                return   BitConverter.ToSingle(data_.bytes, data_.BYTE);;
            }





            public float? flow_rate_y()
            {
                if(data_.field_bit !=  209 && !data_.set_field(209, -1))  return null;
                return   BitConverter.ToSingle(data_.bytes, data_.BYTE);;
            }






            public interface DST_
            {
                void time_usec(long src);
                void sensor_id(sbyte src);
                void flow_x(short src);
                void flow_y(short src);
                void flow_comp_m_x(float src);
                void flow_comp_m_y(float src);
                void quality(sbyte src);
                void ground_distance(float src);
                void flow_rate_x(float src);
                void flow_rate_y(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(13, 0, 0, 1, 27, 1, 208, 0, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.sensor_id(sensor_id()) ;
                dst.flow_x(flow_x()) ;
                dst.flow_y(flow_y()) ;
                dst.flow_comp_m_x(flow_comp_m_x()) ;
                dst.flow_comp_m_y(flow_comp_m_y()) ;
                dst.quality(quality()) ;
                dst.ground_distance(ground_distance()) ;
                {
                    var item = flow_rate_x();
                    if(item.HasValue) dst.flow_rate_x(item.Value);
                }
                {
                    var item = flow_rate_y();
                    if(item.HasValue) dst.flow_rate_y(item.Value);
                }
            }



        }

        public struct GLOBAL_VISION_POSITION_ESTIMATE
        {
            internal Pack.Cursor data_;
            internal GLOBAL_VISION_POSITION_ESTIMATE(Pack.Cursor data) { this.data_ = data; }




            public long usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }


            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }


            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }


            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }




            public interface DST_
            {
                void usec(long src);
                void x(float src);
                void y(float src);
                void z(float src);
                void roll(float src);
                void pitch(float src);
                void yaw(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(110, 0, 0, 1, 32, 1, 256);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.usec(usec()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
            }



        }

        public struct VISION_POSITION_ESTIMATE
        {
            internal Pack.Cursor data_;
            internal VISION_POSITION_ESTIMATE(Pack.Cursor data) { this.data_ = data; }




            public long usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }


            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }


            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }


            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }


            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }


            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }


            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }




            public interface DST_
            {
                void usec(long src);
                void x(float src);
                void y(float src);
                void z(float src);
                void roll(float src);
                void pitch(float src);
                void yaw(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(16, 0, 0, 1, 32, 1, 256);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.usec(usec()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
            }



        }

        public struct SwitchModeCommand
        {
            internal static readonly Pack pack_ = new Pack(new Pack.Meta(28));
        }

        public struct PING33
        {
            internal Pack.Cursor data_;
            internal PING33(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                testBOOL = 1234,
                seq = 1235,
                field1 = 1236,
                field12 = 1237,
                field13 = 1238,
                WWWWWWWW = 1239,
                bit_field2 = 1240,
                Field_Bits = 1241,
                SparseFixAllBits = 1242,
                FixAllBits = 1243,
                VarAllBits = 1244,
                SparseVarAllBits = 1245,
                VarEachBits = 1246,
                SparsVarEachBits = 1247,
                testBOOLX = 1248,
                testBOOL2X = 1249,
                testBOOL3X = 1250,
                MMMMMM = 1251,
                field44 = 1252,
                field634 = 1253,
                field33344 = 1254,
                field333634 = 1255,
                field__ = 1256,
                field63 = 1257,
                uid2 = 1258,
                field2 = 1259,
                field4 = 1260,
                stringtest1 = 1261,
                stringtest2 = 1262,
                stringtest3 = 1263,
                stringtest4 = 1264
            }



            public int TTTT(int d0, int d1, int d2) { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4)); }
            public void TTTT(int src, int d0, int d1, int d2) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + (d0 + d1 * 3 + d2 * 3 * 2)    * 4);  }
            public struct TTTT_
            {
                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2 = 3 ;


                public static void enumerate(PING33 pack, Action< int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                {
                    for(int d0 = 0; d0 < PING33.TTTT_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.TTTT_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.TTTT_.d2; d2++)
                                dst((int)((int)(int)Lib.get_bytes(pack.data_.bytes,  pack.data_.origin  + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4)), d0, d1, d2);
                }

            }

            public long field() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 72, 8)); }
            public void field(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 72);  }

            public sbyte bit_field() { return (sbyte)(4 +  data_.bytes[data_.origin  + 80]); }
            public void bit_field(sbyte src) {    data_.bytes[data_.origin  + 80] = (byte)(-4 +    src);  }
            public struct bit_field_
            {

                public const sbyte min_value = (sbyte)4;
                public const sbyte max_value = (sbyte)45;


            }

            public int field6(int d0, int d1, int d2) { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 81 + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4)); }
            public void field6(int src, int d0, int d1, int d2) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 81 + (d0 + d1 * 3 + d2 * 3 * 2)    * 4);  }
            public struct field6_
            {
                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2 = 3 ;


                public static void enumerate(PING33 pack, Action< int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                {
                    for(int d0 = 0; d0 < PING33.field6_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field6_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field6_.d2; d2++)
                                dst((int)((int)(int)Lib.get_bytes(pack.data_.bytes,  pack.data_.origin  + 81 + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4)), d0, d1, d2);
                }

            }

            public bool testBOOL2() { return (data_.bytes[(data_.origin * 8  + 1224) >> 3] & 1 << ((int)data_.origin * 8  + 1224 & 7)) != 0; }
            public void testBOOL2(bool src)
            {
                if(src) data_.bytes[(data_.origin * 8  + 1224) >> 3] |= (byte)(1 << ((int)data_.origin * 8  + 1224 & 7));
                else data_.bytes[(data_.origin * 8  + 1224) >> 3] &= (byte)(~(1 << ((int)data_.origin * 8  + 1224 & 7)) & 0xFF);
            }

            public bool testBOOL3() { return (data_.bytes[(data_.origin * 8  + 1225) >> 3] & 1 << ((int)data_.origin * 8  + 1225 & 7)) != 0; }
            public void testBOOL3(bool src)
            {
                if(src) data_.bytes[(data_.origin * 8  + 1225) >> 3] |= (byte)(1 << ((int)data_.origin * 8  + 1225 & 7));
                else data_.bytes[(data_.origin * 8  + 1225) >> 3] &= (byte)(~(1 << ((int)data_.origin * 8  + 1225 & 7)) & 0xFF);
            }


            public bool? testBOOL()
            {
                if(data_.field_bit !=  1234 && !data_.set_field(1234, -1))  return null;
                return (data_.bytes[(data_.BIT) >> 3] & 1 << ((int)data_.BIT & 7)) != 0;;
            }


            public void testBOOL(bool src)
            {
                if(data_.field_bit !=  1234) data_.set_field(1234, 0);
                ;
                if(src) data_.bytes[(data_.BIT) >> 3] |= (byte)(1 << ((int)data_.BIT & 7));
                else data_.bytes[(data_.BIT) >> 3] &= (byte)(~(1 << ((int)data_.BIT & 7)) & 0xFF);
                ;
            }




            public long? seq()
            {
                if(data_.field_bit !=  1235 && !data_.set_field(1235, -1))  return null;
                return (long)(-14 + (long)(uint)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
            }


            public void seq(long src)
            {
                if(data_.field_bit !=  1235) data_.set_field(1235, 0);
                ;
                Lib.set_bytes((ulong)(14 +    src), 4, data_.bytes,  data_.BYTE);;
            }




            public field1_ field1() {return new  field1_(data_); }

            public struct field1_
            {
                Pack.Cursor data_;
                public field1_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1236 || data_.set_field(1236, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1236 || data_.set_field(1236, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d0) { return (data_.set_field(1236,  0, d0)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d0() {return data_.var_dims[0];}


                    public int get(int d0, int d1, int d2)
                    {
                        return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 2)    * 4, 4));;
                    }


                    public void set(int src, int d0, int d1, int d2)
                    {
                        Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 2)    * 4);;
                    }


                    public void enumerate(Action<int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < this.d0(); d0++)
                            for(int d1 = 0; d1 < PING33.field1_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.field1_.d2; d2++)
                                    dst((int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 2)    * 4, 4)), d0, d1, d2);
                    }

                }

                public const int d0_max = 7 ;
                public const int d1 = 2 ;
                public const int d2 = 3 ;

            }




            public void field12(int src, int d0, int d1, int d2)
            {
                if(data_.field_bit !=  1237) data_.set_field(1237, 0);
                Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4);;
            }


            public field12_ ? field12() { return (data_.field_bit ==  1237 || data_.set_field(1237, -1)) ? new field12_(data_) : (field12_ ?)null ;}

            public struct field12_
            {
                internal Pack.Cursor data_;
                internal field12_(Pack.Cursor data) { this.data_ = data; }


                public void enumerate(Action<int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                {
                    for(int d0 = 0; d0 < PING33.field12_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field12_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field12_.d2; d2++)
                                dst((int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4)), d0, d1, d2);
                }


                public int get(int d0, int d1, int d2)
                {
                    return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4));;
                }



                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2 = 3 ;

            }



            public void field13(int src, int d0, int d1, int d2)
            {
                if(data_.field_bit !=  1238) data_.set_field(1238, 0);
                data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0) ;
                Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE);;
            }


            public field13_ ? field13() { return (data_.field_bit ==  1238 || data_.set_field(1238, -1)) ? new field13_(data_) : (field13_ ?)null ;}

            public struct field13_
            {
                internal Pack.Cursor data_;
                internal field13_(Pack.Cursor data) { this.data_ = data; }


                public void enumerate(Action<int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                {
                    for(int d0 = 0; d0 < PING33.field13_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field13_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field13_.d2; d2++)
                                if(data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst((int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4)), d0, d1, d2);
                }


                public int? get(int d0, int d1, int d2)
                {
                    if(!data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1))  return null;
                    return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
                }



                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2 = 3 ;

            }


            public int? WWWWWWWW()
            {
                if(data_.field_bit !=  1239 && !data_.set_field(1239, -1))  return null;
                return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
            }


            public void WWWWWWWW(int src)
            {
                if(data_.field_bit !=  1239) data_.set_field(1239, 0);
                ;
                Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE);;
            }




            public sbyte? bit_field2()
            {
                if(data_.field_bit !=  1240 && !data_.set_field(1240, -1))  return null;
                return (sbyte)(45 -  data_.bytes[data_.BYTE]);;
            }


            public void bit_field2(sbyte src)
            {
                if(data_.field_bit !=  1240) data_.set_field(1240, 0);
                ;
                data_.bytes[data_.BYTE] = (byte)(45 -    src);;
            }

            public struct bit_field2_
            {
                public const sbyte min_value = (sbyte)4;
                public const sbyte max_value = (sbyte)45;
            }



            public void Field_Bits(sbyte src, int d0, int d1, int d2)
            {
                if(data_.field_bit !=  1241) data_.set_field(1241, 0);
                Lib.set_bits((ulong)(-4 +    src), 6, data_.bytes,  data_.BIT + (d0 + d1 * 3 + d2 * 3 * 3)    * 6) ;;
            }


            public Field_Bits_ ? Field_Bits() { return (data_.field_bit ==  1241 || data_.set_field(1241, -1)) ? new Field_Bits_(data_) : (Field_Bits_ ?)null ;}

            public struct Field_Bits_
            {
                internal Pack.Cursor data_;
                internal Field_Bits_(Pack.Cursor data) { this.data_ = data; }


                public void enumerate(Action<sbyte /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                {
                    for(int d0 = 0; d0 < PING33.Field_Bits_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.Field_Bits_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.Field_Bits_.d2; d2++)
                                dst((sbyte)(4 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT + (d0 + d1 * 3 + d2 * 3 * 3)    * 6, 6)), d0, d1, d2);
                }


                public sbyte get(int d0, int d1, int d2)
                {
                    return (sbyte)(4 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT + (d0 + d1 * 3 + d2 * 3 * 3)    * 6, 6));;
                }




                public const sbyte min_value = (sbyte)4;
                public const sbyte max_value = (sbyte)45;
                public const int d0 = 3 ;
                public const int d1 = 3 ;
                public const int d2 = 3 ;

            }


            public SparseFixAllBits_ SparseFixAllBits() {return new  SparseFixAllBits_(data_); }

            public struct SparseFixAllBits_
            {
                Pack.Cursor data_;
                public SparseFixAllBits_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1242 || data_.set_field(1242, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1242 || data_.set_field(1242, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d0) { return (data_.set_field(1242,  0, d0)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d0() {return data_.var_dims[0];}


                    public sbyte? get(int d0, int d1, int d2)
                    {
                        if(!data_.set_item(d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, -1))  return null;
                        return (sbyte)(4 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT, 6));;
                    }


                    public void set(sbyte src, int d0, int d1, int d2)
                    {
                        data_.set_item(d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, 0) ;
                        Lib.set_bits((ulong)(-4 +    src), 6, data_.bytes,  data_.BIT) ;;
                    }


                    public void enumerate(Action<sbyte /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < this.d0(); d0++)
                            for(int d1 = 0; d1 < PING33.SparseFixAllBits_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.SparseFixAllBits_.d2; d2++)
                                    if(data_.set_item(d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, -1)) dst((sbyte)(4 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT, 6)), d0, d1, d2);
                    }

                }


                public const sbyte min_value = (sbyte)4;
                public const sbyte max_value = (sbyte)45;
                public const int d0_max = 3 ;
                public const int d1 = 3 ;
                public const int d2 = 3 ;

            }



            public FixAllBits_ FixAllBits() {return new  FixAllBits_(data_); }

            public struct FixAllBits_
            {
                Pack.Cursor data_;
                public FixAllBits_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1243 || data_.set_field(1243, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1243 || data_.set_field(1243, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d0) { return (data_.set_field(1243,  0, d0)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d0() {return data_.var_dims[0];}


                    public sbyte get(int d0, int d1, int d2)
                    {
                        return (sbyte)(14 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3)    * 5, 5));;
                    }


                    public void set(sbyte src, int d0, int d1, int d2)
                    {
                        Lib.set_bits((ulong)(-14 +    src), 5, data_.bytes,  data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3)    * 5) ;;
                    }


                    public void enumerate(Action<sbyte /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < this.d0(); d0++)
                            for(int d1 = 0; d1 < PING33.FixAllBits_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.FixAllBits_.d2; d2++)
                                    dst((sbyte)(14 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3)    * 5, 5)), d0, d1, d2);
                    }

                }


                public const sbyte min_value = (sbyte)14;
                public const sbyte max_value = (sbyte)45;
                public const int d0_max = 3 ;
                public const int d1 = 3 ;
                public const int d2 = 3 ;

            }



            public VarAllBits_ VarAllBits() {return new  VarAllBits_(data_); }

            public struct VarAllBits_
            {
                Pack.Cursor data_;
                public VarAllBits_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1244 || data_.set_field(1244, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1244 || data_.set_field(1244, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d0, int d2) { return (data_.set_field(1244,  0, d0, d2)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d0() {return data_.var_dims[0];}
                    public int d2() {return data_.var_dims[1];}


                    public sbyte get(int d0, int d1, int d2)
                    {
                        return (sbyte)(14 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3)    * 5, 5));;
                    }


                    public void set(sbyte src, int d0, int d1, int d2)
                    {
                        Lib.set_bits((ulong)(-14 +    src), 5, data_.bytes,  data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3)    * 5) ;;
                    }


                    public void enumerate(Action<sbyte /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < this.d0(); d0++)
                            for(int d1 = 0; d1 < PING33.VarAllBits_.d1; d1++)
                                for(int d2 = 0; d2 < this.d2(); d2++)
                                    dst((sbyte)(14 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3)    * 5, 5)), d0, d1, d2);
                    }

                }


                public const sbyte min_value = (sbyte)14;
                public const sbyte max_value = (sbyte)45;
                public const int d0_max = 3 ;
                public const int d1 = 3 ;
                public const int d2_max = 3 ;

            }



            public SparseVarAllBits_ SparseVarAllBits() {return new  SparseVarAllBits_(data_); }

            public struct SparseVarAllBits_
            {
                Pack.Cursor data_;
                public SparseVarAllBits_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1245 || data_.set_field(1245, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1245 || data_.set_field(1245, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d0, int d2) { return (data_.set_field(1245,  0, d0, d2)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d0() {return data_.var_dims[0];}
                    public int d2() {return data_.var_dims[1];}


                    public sbyte? get(int d0, int d1, int d2)
                    {
                        if(!data_.set_item(d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, -1))  return null;
                        return (sbyte)(14 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT, 5));;
                    }


                    public void set(sbyte src, int d0, int d1, int d2)
                    {
                        data_.set_item(d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, 0) ;
                        Lib.set_bits((ulong)(-14 +    src), 5, data_.bytes,  data_.BIT) ;;
                    }


                    public void enumerate(Action<sbyte /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < this.d0(); d0++)
                            for(int d1 = 0; d1 < PING33.SparseVarAllBits_.d1; d1++)
                                for(int d2 = 0; d2 < this.d2(); d2++)
                                    if(data_.set_item(d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, -1)) dst((sbyte)(14 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT, 5)), d0, d1, d2);
                    }

                }


                public const sbyte min_value = (sbyte)14;
                public const sbyte max_value = (sbyte)45;
                public const int d0_max = 3 ;
                public const int d1 = 3 ;
                public const int d2_max = 3 ;

            }



            public VarEachBits_ VarEachBits() {return new  VarEachBits_(data_); }

            public struct VarEachBits_
            {
                Pack.Cursor data_;
                public VarEachBits_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1246 || data_.set_field(1246, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1246 || data_.set_field(1246, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d0) { return (data_.set_field(1246,  0, d0)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d0() {return data_.var_dims[0];}


                    public sbyte get(int d0, int d1, int d2)
                    {
                        return (sbyte)(-14 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3)    * 6, 6));;
                    }


                    public void set(sbyte src, int d0, int d1, int d2)
                    {
                        Lib.set_bits((ulong)(14 +    src), 6, data_.bytes,  data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3)    * 6) ;;
                    }


                    public void enumerate(Action<sbyte /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < this.d0(); d0++)
                            for(int d1 = 0; d1 < PING33.VarEachBits_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.VarEachBits_.d2; d2++)
                                    dst((sbyte)(-14 + (sbyte)(sbyte)Lib.get_bits(data_.bytes,  data_.BIT + (d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3)    * 6, 6)), d0, d1, d2);
                    }

                }


                public const sbyte min_value = (sbyte) - 14;
                public const sbyte max_value = (sbyte)45;
                public const int d0_max = 3 ;
                public const int d1 = 3 ;
                public const int d2 = 3 ;

            }



            public SparsVarEachBits_ SparsVarEachBits() {return new  SparsVarEachBits_(data_); }

            public struct SparsVarEachBits_
            {
                Pack.Cursor data_;
                public SparsVarEachBits_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1247 || data_.set_field(1247, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1247 || data_.set_field(1247, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d0) { return (data_.set_field(1247,  0, d0)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d0() {return data_.var_dims[0];}


                    public short? get(int d0, int d1, int d2)
                    {
                        if(!data_.set_item(d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, -1))  return null;
                        return (short)(-14 + (short)(ushort)Lib.get_bits(data_.bytes,  data_.BIT, 9));;
                    }


                    public void set(short src, int d0, int d1, int d2)
                    {
                        data_.set_item(d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, 0) ;
                        Lib.set_bits((ulong)(14 +    src), 9, data_.bytes,  data_.BIT) ;;
                    }


                    public void enumerate(Action<short /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < this.d0(); d0++)
                            for(int d1 = 0; d1 < PING33.SparsVarEachBits_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.SparsVarEachBits_.d2; d2++)
                                    if(data_.set_item(d0 + d1 * data_.var_dims[0] + d2 * data_.var_dims[0] * 3, -1)) dst((short)(-14 + (short)(ushort)Lib.get_bits(data_.bytes,  data_.BIT, 9)), d0, d1, d2);
                    }

                }


                public const short min_value = (short) -14;
                public const short max_value = (short)450;
                public const int d0_max = 3 ;
                public const int d1 = 3 ;
                public const int d2 = 3 ;

            }



            public bool? testBOOLX()
            {
                if(data_.field_bit !=  1248 && !data_.set_field(1248, -1))  return null;
                return (data_.bytes[(data_.BIT) >> 3] & 1 << ((int)data_.BIT & 7)) != 0;;
            }


            public void testBOOLX(bool src)
            {
                if(data_.field_bit !=  1248) data_.set_field(1248, 0);
                ;
                if(src) data_.bytes[(data_.BIT) >> 3] |= (byte)(1 << ((int)data_.BIT & 7));
                else data_.bytes[(data_.BIT) >> 3] &= (byte)(~(1 << ((int)data_.BIT & 7)) & 0xFF);
                ;
            }




            public bool? testBOOL2X()
            {
                if(data_.field_bit !=  1249 && !data_.set_field(1249, -1))  return null;
                return (data_.bytes[(data_.BIT) >> 3] & 1 << ((int)data_.BIT & 7)) != 0;;
            }


            public void testBOOL2X(bool src)
            {
                if(data_.field_bit !=  1249) data_.set_field(1249, 0);
                ;
                if(src) data_.bytes[(data_.BIT) >> 3] |= (byte)(1 << ((int)data_.BIT & 7));
                else data_.bytes[(data_.BIT) >> 3] &= (byte)(~(1 << ((int)data_.BIT & 7)) & 0xFF);
                ;
            }




            public bool? testBOOL3X()
            {
                if(data_.field_bit !=  1250 && !data_.set_field(1250, -1))  return null;
                return (data_.bytes[(data_.BIT) >> 3] & 1 << ((int)data_.BIT & 7)) != 0;;
            }


            public void testBOOL3X(bool src)
            {
                if(data_.field_bit !=  1250) data_.set_field(1250, 0);
                ;
                if(src) data_.bytes[(data_.BIT) >> 3] |= (byte)(1 << ((int)data_.BIT & 7));
                else data_.bytes[(data_.BIT) >> 3] &= (byte)(~(1 << ((int)data_.BIT & 7)) & 0xFF);
                ;
            }




            public  MAV_MODE? MMMMMM()
            {
                if(data_.field_bit !=  1251 && !data_.set_field(1251, -1))  return null;
                return    MAV_MODE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 4));;
            }


            public void MMMMMM(MAV_MODE src)
            {
                if(data_.field_bit !=  1251) data_.set_field(1251, 0);
                ;
                Lib.set_bits(MAV_MODE_.bits(src), 4, data_.bytes, data_.BIT) ;;
            }




            public field44_ field44() {return new  field44_(data_); }

            public struct field44_
            {
                Pack.Cursor data_;
                public field44_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1252 || data_.set_field(1252, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1252 || data_.set_field(1252, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d2) { return (data_.set_field(1252,  0, d2)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d2() {return data_.var_dims[0];}


                    public int get(int d0, int d1, int d2)
                    {
                        return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4));;
                    }


                    public void set(int src, int d0, int d1, int d2)
                    {
                        Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4);;
                    }


                    public void enumerate(Action<int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < PING33.field44_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field44_.d1; d1++)
                                for(int d2 = 0; d2 < this.d2(); d2++)
                                    dst((int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4)), d0, d1, d2);
                    }

                }

                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2_max = 3 ;

            }



            public field634_ field634() {return new  field634_(data_); }

            public struct field634_
            {
                Pack.Cursor data_;
                public field634_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1253 || data_.set_field(1253, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1253 || data_.set_field(1253, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d2) { return (data_.set_field(1253,  0, d2)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d2() {return data_.var_dims[0];}


                    public int get(int d0, int d1, int d2)
                    {
                        return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4));;
                    }


                    public void set(int src, int d0, int d1, int d2)
                    {
                        Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4);;
                    }


                    public void enumerate(Action<int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < PING33.field634_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field634_.d1; d1++)
                                for(int d2 = 0; d2 < this.d2(); d2++)
                                    dst((int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4)), d0, d1, d2);
                    }

                }

                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2_max = 3 ;

            }



            public field33344_ field33344() {return new  field33344_(data_); }

            public struct field33344_
            {
                Pack.Cursor data_;
                public field33344_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1254 || data_.set_field(1254, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1254 || data_.set_field(1254, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d2) { return (data_.set_field(1254,  0, d2)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d2() {return data_.var_dims[0];}


                    public int? get(int d0, int d1, int d2)
                    {
                        if(!data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1))  return null;
                        return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
                    }


                    public void set(int src, int d0, int d1, int d2)
                    {
                        data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0) ;
                        Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE);;
                    }


                    public void enumerate(Action<int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < PING33.field33344_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field33344_.d1; d1++)
                                for(int d2 = 0; d2 < this.d2(); d2++)
                                    if(data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst((int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4)), d0, d1, d2);
                    }

                }

                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2_max = 3 ;

            }



            public field333634_ field333634() {return new  field333634_(data_); }

            public struct field333634_
            {
                Pack.Cursor data_;
                public field333634_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1255 || data_.set_field(1255, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1255 || data_.set_field(1255, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d2) { return (data_.set_field(1255,  0, d2)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d2() {return data_.var_dims[0];}


                    public int? get(int d0, int d1, int d2)
                    {
                        if(!data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1))  return null;
                        return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
                    }


                    public void set(int src, int d0, int d1, int d2)
                    {
                        data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0) ;
                        Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE);;
                    }


                    public void enumerate(Action<int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < PING33.field333634_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field333634_.d1; d1++)
                                for(int d2 = 0; d2 < this.d2(); d2++)
                                    if(data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst((int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4)), d0, d1, d2);
                    }

                }

                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2_max = 3 ;

            }




            public void field__(int src, int d0, int d1, int d2)
            {
                if(data_.field_bit !=  1256) data_.set_field(1256, 0);
                data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0) ;
                Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE);;
            }


            public field___ ? field__() { return (data_.field_bit ==  1256 || data_.set_field(1256, -1)) ? new field___(data_) : (field___ ?)null ;}

            public struct field___
            {
                internal Pack.Cursor data_;
                internal field___(Pack.Cursor data) { this.data_ = data; }


                public void enumerate(Action<int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                {
                    for(int d0 = 0; d0 < PING33.field___.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field___.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field___.d2; d2++)
                                if(data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst((int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4)), d0, d1, d2);
                }


                public int? get(int d0, int d1, int d2)
                {
                    if(!data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1))  return null;
                    return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
                }



                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2 = 3 ;

            }


            public field63_ field63() {return new  field63_(data_); }

            public struct field63_
            {
                Pack.Cursor data_;
                public field63_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1257 || data_.set_field(1257, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1257 || data_.set_field(1257, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d2) { return (data_.set_field(1257,  0, d2)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d2() {return data_.var_dims[0];}


                    public int get(int d0, int d1, int d2)
                    {
                        return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4));;
                    }


                    public void set(int src, int d0, int d1, int d2)
                    {
                        Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4);;
                    }


                    public void enumerate(Action<int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < PING33.field63_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field63_.d1; d1++)
                                for(int d2 = 0; d2 < this.d2(); d2++)
                                    dst((int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2)    * 4, 4)), d0, d1, d2);
                    }

                }

                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2_max = 3 ;

            }




            public void uid2(sbyte src, int d0)
            {
                if(data_.field_bit !=  1258) data_.set_field(1258, 0);
                data_.set_item(d0, 0) ;
                data_.bytes[data_.BYTE] = (byte)(src);;
            }


            public uid2_ ? uid2() { return (data_.field_bit ==  1258 || data_.set_field(1258, -1)) ? new uid2_(data_) : (uid2_ ?)null ;}

            public struct uid2_
            {
                internal Pack.Cursor data_;
                internal uid2_(Pack.Cursor data) { this.data_ = data; }


                public void enumerate(Action<sbyte /*item*/, int /*d0*/> dst)
                {
                    for(int d0 = 0; d0 < PING33.uid2_.d0; d0++)
                        if(data_.set_item(d0, -1)) dst((sbyte)(data_.bytes[data_.BYTE]), d0);
                }


                public sbyte? get(int d0)
                {
                    if(!data_.set_item(d0, -1))  return null;
                    return (sbyte)(data_.bytes[data_.BYTE]);;
                }



                public const int d0 = 18 ;

            }



            public void field2(int src, int d0, int d1, int d2)
            {
                if(data_.field_bit !=  1259) data_.set_field(1259, 0);
                data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0) ;
                Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE);;
            }


            public field2_ ? field2() { return (data_.field_bit ==  1259 || data_.set_field(1259, -1)) ? new field2_(data_) : (field2_ ?)null ;}

            public struct field2_
            {
                internal Pack.Cursor data_;
                internal field2_(Pack.Cursor data) { this.data_ = data; }


                public void enumerate(Action<int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                {
                    for(int d0 = 0; d0 < PING33.field2_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field2_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field2_.d2; d2++)
                                if(data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst((int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4)), d0, d1, d2);
                }


                public int? get(int d0, int d1, int d2)
                {
                    if(!data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1))  return null;
                    return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
                }



                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2 = 3 ;

            }



            public void field4(int src, int d0, int d1, int d2)
            {
                if(data_.field_bit !=  1260) data_.set_field(1260, 0);
                data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0) ;
                Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE);;
            }


            public field4_ ? field4() { return (data_.field_bit ==  1260 || data_.set_field(1260, -1)) ? new field4_(data_) : (field4_ ?)null ;}

            public struct field4_
            {
                internal Pack.Cursor data_;
                internal field4_(Pack.Cursor data) { this.data_ = data; }


                public void enumerate(Action<int /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                {
                    for(int d0 = 0; d0 < PING33.field4_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field4_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field4_.d2; d2++)
                                if(data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst((int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4)), d0, d1, d2);
                }


                public int? get(int d0, int d1, int d2)
                {
                    if(!data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1))  return null;
                    return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
                }



                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2 = 3 ;

            }


            public stringtest1_? stringtest1()
            {
                if(data_.field_bit !=  1261 && !data_.set_field(1261, -1))  return (stringtest1_?) null;
                return new stringtest1_(data_);
            }



            public char[] stringtest1(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  1261) data_.set_field(1261, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PING33.stringtest1_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void stringtest1(byte[] src)
            {
                var len = Math.Min(src.Length, PING33.stringtest1_.item_len_max);
                if(data_.field_bit !=  1261) data_.set_field(1261, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public stringtest1_ stringtest1(int len)
            {
                if(data_.field_bit !=  1261) data_.set_field(1261, Math.Min(len, PING33.stringtest1_.item_len_max));
                return new stringtest1_(data_);
            }

            public struct stringtest1_
            {
                Pack.Cursor data_;
                public stringtest1_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(stringtest1_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public stringtest2_ stringtest2() {return new  stringtest2_(data_); }

            public struct stringtest2_
            {
                Pack.Cursor data_;
                public stringtest2_(Pack.Cursor data) { this.data_ = data; }
                public Initializer_ ? Initializer() {return (data_.field_bit ==  1262 || data_.set_field(1262, -1)) ? (Initializer_ ?) null : new Initializer_(data_) ;}
                public Field_ ?  Field() { return (data_.field_bit ==  1262 || data_.set_field(1262, -1)) ? new Field_(data_) : (Field_?)null ;}

                public struct Initializer_
                {
                    Pack.Cursor data_;
                    public Initializer_(Pack.Cursor data) { this.data_ = data; }
                    public Field_ ? init(int d2) { return (data_.set_field(1262,  0, d2)) ? new Field_(data_) : (Field_?) null ;}
                }

                public struct Field_
                {
                    Pack.Cursor data_;
                    public Field_(Pack.Cursor data) { this.data_ = data; }
                    public int d2() {return data_.var_dims[0];}


                    public stringtest2_.Item? get(int d0, int d1, int d2)
                    {
                        if(!data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1))  return (stringtest2_.Item?) null;
                        return new stringtest2_.Item(data_);
                    }



                    public char[] set(string src, int d0, int d1, int d2, char[] reuse)
                    {
                        var len = src.Length;
                        if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                        else src.CopyTo(0, reuse, 0, len);
                        data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PING33.stringtest2_.item_len_max));
                        Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                        return reuse;
                    }


                    public void set(byte[] src, int d0, int d1, int d2)
                    {
                        var len = Math.Min(src.Length, PING33.stringtest2_.item_len_max);
                        data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, len);
                        for(int index = 0; index < len; index++)
                            data_.bytes[data_.BYTE + index] = src[index];;
                    }

                    public stringtest2_.Item set(int len, int d0, int d1, int d2)
                    {
                        data_.set_item(d0 + d1 * 3 + d2 * 3 * 2,  Math.Min(len, PING33.stringtest2_.item_len_max));
                        return new stringtest2_.Item(data_);
                    }


                    public void enumerate(Action< stringtest2_.Item /*item*/, int /*d0*/, int /*d1*/, int /*d2*/> dst)
                    {
                        for(int d0 = 0; d0 < PING33.stringtest2_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.stringtest2_.d1; d1++)
                                for(int d2 = 0; d2 < this.d2(); d2++)
                                {
                                    var fld = get(d0, d1, d2);
                                    if(fld.HasValue)  dst(fld.Value, d0, d1, d2);
                                }
                    }

                }
                public struct Item
                {
                    Pack.Cursor data_;
                    public Item(Pack.Cursor data) {this.data_ = data;}

                    public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                    public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                    public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                    public bool same(byte [] other)
                    {
                        if(other.Length != len()) return false;
                        for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                        return true;
                    }

                    public bool same(stringtest2_.Item other)
                    {
                        if(other.len() != len()) return false;
                        for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                        return true;
                    }
                    public int len() { return data_.item_len;  }

                }

                public const int d0 = 3 ;
                public const int d1 = 2 ;
                public const int d2_max = 3 ;
                public const int item_len_max = 255 ;

            }



            public stringtest3_? stringtest3()
            {
                if(data_.field_bit !=  1263 && !data_.set_field(1263, -1))  return (stringtest3_?) null;
                return new stringtest3_(data_);
            }



            public char[] stringtest3(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  1263) data_.set_field(1263, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PING33.stringtest3_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void stringtest3(byte[] src)
            {
                var len = Math.Min(src.Length, PING33.stringtest3_.item_len_max);
                if(data_.field_bit !=  1263) data_.set_field(1263, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public stringtest3_ stringtest3(int len)
            {
                if(data_.field_bit !=  1263) data_.set_field(1263, Math.Min(len, PING33.stringtest3_.item_len_max));
                return new stringtest3_(data_);
            }

            public struct stringtest3_
            {
                Pack.Cursor data_;
                public stringtest3_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(stringtest3_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public stringtest4_? stringtest4()
            {
                if(data_.field_bit !=  1264 && !data_.set_field(1264, -1))  return (stringtest4_?) null;
                return new stringtest4_(data_);
            }



            public char[] stringtest4(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  1264) data_.set_field(1264, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PING33.stringtest4_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void stringtest4(byte[] src)
            {
                var len = Math.Min(src.Length, PING33.stringtest4_.item_len_max);
                if(data_.field_bit !=  1264) data_.set_field(1264, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public stringtest4_ stringtest4(int len)
            {
                if(data_.field_bit !=  1264) data_.set_field(1264, Math.Min(len, PING33.stringtest4_.item_len_max));
                return new stringtest4_(data_);
            }

            public struct stringtest4_
            {
                Pack.Cursor data_;
                public stringtest4_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(stringtest4_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void testBOOL(bool src);
                void seq(long src);
                void field(long src);
                void field1_init(int d0) ;
                void field1(int src, int d0, int d1, int d2);
                void field12(int src, int d0, int d1, int d2);
                void field13(int src, int d0, int d1, int d2);
                void TTTT(int src, int d0, int d1, int d2);
                void WWWWWWWW(int src);
                void testBOOL2(bool src);
                void testBOOL3(bool src);
                void bit_field(sbyte src);
                void bit_field2(sbyte src);
                void Field_Bits(sbyte src, int d0, int d1, int d2);
                void SparseFixAllBits_init(int d0) ;
                void SparseFixAllBits(sbyte src, int d0, int d1, int d2);
                void FixAllBits_init(int d0) ;
                void FixAllBits(sbyte src, int d0, int d1, int d2);
                void VarAllBits_init(int d0, int d2) ;
                void VarAllBits(sbyte src, int d0, int d1, int d2);
                void SparseVarAllBits_init(int d0, int d2) ;
                void SparseVarAllBits(sbyte src, int d0, int d1, int d2);
                void VarEachBits_init(int d0) ;
                void VarEachBits(sbyte src, int d0, int d1, int d2);
                void SparsVarEachBits_init(int d0) ;
                void SparsVarEachBits(short src, int d0, int d1, int d2);
                void testBOOLX(bool src);
                void testBOOL2X(bool src);
                void testBOOL3X(bool src);
                void MMMMMM(com.company.demo.GroundControl. MAV_MODE src);
                void field44_init(int d2) ;
                void field44(int src, int d0, int d1, int d2);
                void field634_init(int d2) ;
                void field634(int src, int d0, int d1, int d2);
                void field33344_init(int d2) ;
                void field33344(int src, int d0, int d1, int d2);
                void field333634_init(int d2) ;
                void field333634(int src, int d0, int d1, int d2);
                void field__(int src, int d0, int d1, int d2);
                void field6(int src, int d0, int d1, int d2);
                void field63_init(int d2) ;
                void field63(int src, int d0, int d1, int d2);
                void uid2(sbyte src, int d0);
                void field2(int src, int d0, int d1, int d2);
                void field4(int src, int d0, int d1, int d2);
                void stringtest1(PING33.stringtest1_ src);
                void stringtest2_init(int d2) ;
                void stringtest2(PING33.stringtest2_.Item src, int d0, int d1, int d2);
                void stringtest3(PING33.stringtest3_ src);
                void stringtest4(PING33.stringtest4_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(139, 0, 18, 0, 155, 1, 1234, 8, 0, 31);
            const  int const3 = (int) 56;  //56
            const  int stati_cconst1 = (int) 1;  //1
            const  float stati_cconst1D = (float) 1.456;  //(float)1.456
            const  float const3D = (float) 56.555;  //(float)56.555

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = testBOOL();
                    if(item.HasValue) dst.testBOOL(item.Value);
                }
                {
                    var item = seq();
                    if(item.HasValue) dst.seq(item.Value);
                }
                dst.field(field()) ;
                {
                    var _fld = field1().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.field1_init(fld.d0());
                        for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                            for(int d1 = 0; d1 < PING33.field1_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.field1_.d2; d2++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    dst.field1(item, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = field12();
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        for(int d0 = 0; d0 < PING33.field12_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field12_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.field12_.d2; d2++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    dst.field12(item, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = field13();
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        for(int d0 = 0; d0 < PING33.field13_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field13_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.field13_.d2; d2++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    if(item.HasValue) dst.field13(item.Value, d0, d1, d2);
                                }
                    }
                }
                {
                    for(int d0 = 0; d0 < PING33.TTTT_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.TTTT_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.TTTT_.d2; d2++)
                                dst.TTTT(TTTT(d0, d1, d2), d0, d1, d2) ;
                }
                {
                    var item = WWWWWWWW();
                    if(item.HasValue) dst.WWWWWWWW(item.Value);
                }
                dst.testBOOL2(testBOOL2()) ;
                dst.testBOOL3(testBOOL3()) ;
                dst.bit_field(bit_field()) ;
                {
                    var item = bit_field2();
                    if(item.HasValue) dst.bit_field2(item.Value);
                }
                {
                    var _fld = Field_Bits();
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        for(int d0 = 0; d0 < PING33.Field_Bits_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.Field_Bits_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.Field_Bits_.d2; d2++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    dst.Field_Bits(item, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = SparseFixAllBits().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.SparseFixAllBits_init(fld.d0());
                        for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                            for(int d1 = 0; d1 < PING33.SparseFixAllBits_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.SparseFixAllBits_.d2; d2++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    if(item.HasValue) dst.SparseFixAllBits(item.Value, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = FixAllBits().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.FixAllBits_init(fld.d0());
                        for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                            for(int d1 = 0; d1 < PING33.FixAllBits_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.FixAllBits_.d2; d2++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    dst.FixAllBits(item, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = VarAllBits().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.VarAllBits_init(fld.d0(), fld.d2());
                        for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                            for(int d1 = 0; d1 < PING33.VarAllBits_.d1; d1++)
                                for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    dst.VarAllBits(item, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = SparseVarAllBits().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.SparseVarAllBits_init(fld.d0(), fld.d2());
                        for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                            for(int d1 = 0; d1 < PING33.SparseVarAllBits_.d1; d1++)
                                for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    if(item.HasValue) dst.SparseVarAllBits(item.Value, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = VarEachBits().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.VarEachBits_init(fld.d0());
                        for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                            for(int d1 = 0; d1 < PING33.VarEachBits_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.VarEachBits_.d2; d2++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    dst.VarEachBits(item, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = SparsVarEachBits().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.SparsVarEachBits_init(fld.d0());
                        for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                            for(int d1 = 0; d1 < PING33.SparsVarEachBits_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.SparsVarEachBits_.d2; d2++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    if(item.HasValue) dst.SparsVarEachBits(item.Value, d0, d1, d2);
                                }
                    }
                }
                {
                    var item = testBOOLX();
                    if(item.HasValue) dst.testBOOLX(item.Value);
                }
                {
                    var item = testBOOL2X();
                    if(item.HasValue) dst.testBOOL2X(item.Value);
                }
                {
                    var item = testBOOL3X();
                    if(item.HasValue) dst.testBOOL3X(item.Value);
                }
                {
                    var item = MMMMMM();
                    if(item.HasValue) dst.MMMMMM(item.Value);
                }
                {
                    var _fld = field44().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.field44_init(fld.d2());
                        for(int d0 = 0; d0 < PING33.field44_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field44_.d1; d1++)
                                for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    dst.field44(item, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = field634().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.field634_init(fld.d2());
                        for(int d0 = 0; d0 < PING33.field634_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field634_.d1; d1++)
                                for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    dst.field634(item, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = field33344().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.field33344_init(fld.d2());
                        for(int d0 = 0; d0 < PING33.field33344_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field33344_.d1; d1++)
                                for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    if(item.HasValue) dst.field33344(item.Value, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = field333634().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.field333634_init(fld.d2());
                        for(int d0 = 0; d0 < PING33.field333634_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field333634_.d1; d1++)
                                for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    if(item.HasValue) dst.field333634(item.Value, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = field__();
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        for(int d0 = 0; d0 < PING33.field___.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field___.d1; d1++)
                                for(int d2 = 0; d2 < PING33.field___.d2; d2++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    if(item.HasValue) dst.field__(item.Value, d0, d1, d2);
                                }
                    }
                }
                {
                    for(int d0 = 0; d0 < PING33.field6_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field6_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field6_.d2; d2++)
                                dst.field6(field6(d0, d1, d2), d0, d1, d2) ;
                }
                {
                    var _fld = field63().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.field63_init(fld.d2());
                        for(int d0 = 0; d0 < PING33.field63_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field63_.d1; d1++)
                                for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    dst.field63(item, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = uid2();
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        for(int d0 = 0; d0 < PING33.uid2_.d0; d0++)
                        {
                            var item = fld.get(d0);
                            if(item.HasValue) dst.uid2(item.Value, d0);
                        }
                    }
                }
                {
                    var _fld = field2();
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        for(int d0 = 0; d0 < PING33.field2_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field2_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.field2_.d2; d2++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    if(item.HasValue) dst.field2(item.Value, d0, d1, d2);
                                }
                    }
                }
                {
                    var _fld = field4();
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        for(int d0 = 0; d0 < PING33.field4_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.field4_.d1; d1++)
                                for(int d2 = 0; d2 < PING33.field4_.d2; d2++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    if(item.HasValue) dst.field4(item.Value, d0, d1, d2);
                                }
                    }
                }
                {
                    var item = stringtest1();
                    if(item.HasValue) dst.stringtest1(item.Value);
                }
                {
                    var _fld = stringtest2().Field() ;
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        dst.stringtest2_init(fld.d2());
                        for(int d0 = 0; d0 < PING33.stringtest2_.d0; d0++)
                            for(int d1 = 0; d1 < PING33.stringtest2_.d1; d1++)
                                for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                {
                                    var item = fld.get(d0, d1, d2);
                                    if(item.HasValue) dst.stringtest2(item.Value, d0, d1, d2);
                                }
                    }
                }
                {
                    var item = stringtest3();
                    if(item.HasValue) dst.stringtest3(item.Value);
                }
                {
                    var item = stringtest4();
                    if(item.HasValue) dst.stringtest4(item.Value);
                }
            }

            public interface SRC_
            {
                bool?  testBOOL();
                long?  seq();
                long field();
                void field1_init(PING33.field1_.Initializer_ init_field) ;
                int field1(int d0, int d1, int d2) ;
                bool field12_exist();
                int field12(int d0, int d1, int d2) ;
                bool field13_exist();
                int?  field13(int d0, int d1, int d2);
                int TTTT(int d0, int d1, int d2);
                int?  WWWWWWWW();
                bool testBOOL2();
                bool testBOOL3();
                sbyte bit_field();
                sbyte?  bit_field2();
                bool Field_Bits_exist();
                sbyte Field_Bits(int d0, int d1, int d2) ;
                void SparseFixAllBits_init(PING33.SparseFixAllBits_.Initializer_ init_field) ;
                sbyte?  SparseFixAllBits(int d0, int d1, int d2);
                void FixAllBits_init(PING33.FixAllBits_.Initializer_ init_field) ;
                sbyte FixAllBits(int d0, int d1, int d2) ;
                void VarAllBits_init(PING33.VarAllBits_.Initializer_ init_field) ;
                sbyte VarAllBits(int d0, int d1, int d2) ;
                void SparseVarAllBits_init(PING33.SparseVarAllBits_.Initializer_ init_field) ;
                sbyte?  SparseVarAllBits(int d0, int d1, int d2);
                void VarEachBits_init(PING33.VarEachBits_.Initializer_ init_field) ;
                sbyte VarEachBits(int d0, int d1, int d2) ;
                void SparsVarEachBits_init(PING33.SparsVarEachBits_.Initializer_ init_field) ;
                short?  SparsVarEachBits(int d0, int d1, int d2);
                bool?  testBOOLX();
                bool?  testBOOL2X();
                bool?  testBOOL3X();
                com.company.demo.GroundControl. MAV_MODE?  MMMMMM();
                void field44_init(PING33.field44_.Initializer_ init_field) ;
                int field44(int d0, int d1, int d2) ;
                void field634_init(PING33.field634_.Initializer_ init_field) ;
                int field634(int d0, int d1, int d2) ;
                void field33344_init(PING33.field33344_.Initializer_ init_field) ;
                int?  field33344(int d0, int d1, int d2);
                void field333634_init(PING33.field333634_.Initializer_ init_field) ;
                int?  field333634(int d0, int d1, int d2);
                bool field___exist();
                int?  field__(int d0, int d1, int d2);
                int field6(int d0, int d1, int d2);
                void field63_init(PING33.field63_.Initializer_ init_field) ;
                int field63(int d0, int d1, int d2) ;
                bool uid2_exist();
                sbyte?  uid2(int d0);
                bool field2_exist();
                int?  field2(int d0, int d1, int d2);
                bool field4_exist();
                int?  field4(int d0, int d1, int d2);
                int stringtest1_exist() ;
                void stringtest1(PING33.stringtest1_ dst) ;
                void stringtest2_init(PING33.stringtest2_.Initializer_ init_field) ;
                int stringtest2_item_exist(int d0, int d1, int d2) ;
                void stringtest2(PING33.stringtest2_.Item dst, int d0, int d1, int d2) ;
                int stringtest3_exist() ;
                void stringtest3(PING33.stringtest3_ dst) ;
                int stringtest4_exist() ;
                void stringtest4(PING33.stringtest4_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.testBOOL();
                    if(item.HasValue)     testBOOL(item.Value);
                }
                {
                    var item = src.seq();
                    if(item.HasValue)     seq(item.Value);
                }
                field(src.field());
                {
                    var init = field1().Initializer();
                    if(init.HasValue)
                    {
                        src.field1_init(init.Value);
                        var _fld = field1().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                                for(int d1 = 0; d1 < PING33.field1_.d1; d1++)
                                    for(int d2 = 0; d2 < PING33.field1_.d2; d2++)
                                    {
                                        fld.set(src.field1(d0, d1, d2), d0, d1, d2);
                                    }
                        }
                    }
                }
                if(src.field12_exist())
                    for(int d0 = 0; d0 < PING33.field12_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field12_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field12_.d2; d2++)
                                field12(src.field12(d0, d1, d2), d0, d1, d2);
                if(src.field13_exist())
                    for(int d0 = 0; d0 < PING33.field13_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field13_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field13_.d2; d2++)
                            {
                                var item = src.field13(d0, d1, d2);
                                if(item.HasValue) field13(item.Value, d0, d1, d2);
                            }
                for(int d0 = 0; d0 < PING33.TTTT_.d0; d0++)
                    for(int d1 = 0; d1 < PING33.TTTT_.d1; d1++)
                        for(int d2 = 0; d2 < PING33.TTTT_.d2; d2++)
                        {
                            TTTT(src.TTTT(d0, d1, d2), d0, d1, d2);
                        }
                {
                    var item = src.WWWWWWWW();
                    if(item.HasValue)     WWWWWWWW(item.Value);
                }
                testBOOL2(src.testBOOL2());
                testBOOL3(src.testBOOL3());
                bit_field(src.bit_field());
                {
                    var item = src.bit_field2();
                    if(item.HasValue)     bit_field2(item.Value);
                }
                if(src.Field_Bits_exist())
                    for(int d0 = 0; d0 < PING33.Field_Bits_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.Field_Bits_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.Field_Bits_.d2; d2++)
                                Field_Bits(src.Field_Bits(d0, d1, d2), d0, d1, d2);
                {
                    var init = SparseFixAllBits().Initializer();
                    if(init.HasValue)
                    {
                        src.SparseFixAllBits_init(init.Value);
                        var _fld = SparseFixAllBits().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                                for(int d1 = 0; d1 < PING33.SparseFixAllBits_.d1; d1++)
                                    for(int d2 = 0; d2 < PING33.SparseFixAllBits_.d2; d2++)
                                    {
                                        {
                                            var item = src.SparseFixAllBits(d0, d1, d2);
                                            if(item.HasValue) fld.set(item.Value, d0, d1, d2);
                                        }
                                    }
                        }
                    }
                }
                {
                    var init = FixAllBits().Initializer();
                    if(init.HasValue)
                    {
                        src.FixAllBits_init(init.Value);
                        var _fld = FixAllBits().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                                for(int d1 = 0; d1 < PING33.FixAllBits_.d1; d1++)
                                    for(int d2 = 0; d2 < PING33.FixAllBits_.d2; d2++)
                                    {
                                        fld.set(src.FixAllBits(d0, d1, d2), d0, d1, d2);
                                    }
                        }
                    }
                }
                {
                    var init = VarAllBits().Initializer();
                    if(init.HasValue)
                    {
                        src.VarAllBits_init(init.Value);
                        var _fld = VarAllBits().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                                for(int d1 = 0; d1 < PING33.VarAllBits_.d1; d1++)
                                    for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                    {
                                        fld.set(src.VarAllBits(d0, d1, d2), d0, d1, d2);
                                    }
                        }
                    }
                }
                {
                    var init = SparseVarAllBits().Initializer();
                    if(init.HasValue)
                    {
                        src.SparseVarAllBits_init(init.Value);
                        var _fld = SparseVarAllBits().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                                for(int d1 = 0; d1 < PING33.SparseVarAllBits_.d1; d1++)
                                    for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                    {
                                        {
                                            var item = src.SparseVarAllBits(d0, d1, d2);
                                            if(item.HasValue) fld.set(item.Value, d0, d1, d2);
                                        }
                                    }
                        }
                    }
                }
                {
                    var init = VarEachBits().Initializer();
                    if(init.HasValue)
                    {
                        src.VarEachBits_init(init.Value);
                        var _fld = VarEachBits().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                                for(int d1 = 0; d1 < PING33.VarEachBits_.d1; d1++)
                                    for(int d2 = 0; d2 < PING33.VarEachBits_.d2; d2++)
                                    {
                                        fld.set(src.VarEachBits(d0, d1, d2), d0, d1, d2);
                                    }
                        }
                    }
                }
                {
                    var init = SparsVarEachBits().Initializer();
                    if(init.HasValue)
                    {
                        src.SparsVarEachBits_init(init.Value);
                        var _fld = SparsVarEachBits().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0 ; d0 < fld.d0(); d0 ++)
                                for(int d1 = 0; d1 < PING33.SparsVarEachBits_.d1; d1++)
                                    for(int d2 = 0; d2 < PING33.SparsVarEachBits_.d2; d2++)
                                    {
                                        {
                                            var item = src.SparsVarEachBits(d0, d1, d2);
                                            if(item.HasValue) fld.set(item.Value, d0, d1, d2);
                                        }
                                    }
                        }
                    }
                }
                {
                    var item = src.testBOOLX();
                    if(item.HasValue)     testBOOLX(item.Value);
                }
                {
                    var item = src.testBOOL2X();
                    if(item.HasValue)     testBOOL2X(item.Value);
                }
                {
                    var item = src.testBOOL3X();
                    if(item.HasValue)     testBOOL3X(item.Value);
                }
                {
                    var item = src.MMMMMM();
                    if(item.HasValue)     MMMMMM(item.Value);
                }
                {
                    var init = field44().Initializer();
                    if(init.HasValue)
                    {
                        src.field44_init(init.Value);
                        var _fld = field44().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0; d0 < PING33.field44_.d0; d0++)
                                for(int d1 = 0; d1 < PING33.field44_.d1; d1++)
                                    for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                    {
                                        fld.set(src.field44(d0, d1, d2), d0, d1, d2);
                                    }
                        }
                    }
                }
                {
                    var init = field634().Initializer();
                    if(init.HasValue)
                    {
                        src.field634_init(init.Value);
                        var _fld = field634().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0; d0 < PING33.field634_.d0; d0++)
                                for(int d1 = 0; d1 < PING33.field634_.d1; d1++)
                                    for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                    {
                                        fld.set(src.field634(d0, d1, d2), d0, d1, d2);
                                    }
                        }
                    }
                }
                {
                    var init = field33344().Initializer();
                    if(init.HasValue)
                    {
                        src.field33344_init(init.Value);
                        var _fld = field33344().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0; d0 < PING33.field33344_.d0; d0++)
                                for(int d1 = 0; d1 < PING33.field33344_.d1; d1++)
                                    for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                    {
                                        {
                                            var item = src.field33344(d0, d1, d2);
                                            if(item.HasValue) fld.set(item.Value, d0, d1, d2);
                                        }
                                    }
                        }
                    }
                }
                {
                    var init = field333634().Initializer();
                    if(init.HasValue)
                    {
                        src.field333634_init(init.Value);
                        var _fld = field333634().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0; d0 < PING33.field333634_.d0; d0++)
                                for(int d1 = 0; d1 < PING33.field333634_.d1; d1++)
                                    for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                    {
                                        {
                                            var item = src.field333634(d0, d1, d2);
                                            if(item.HasValue) fld.set(item.Value, d0, d1, d2);
                                        }
                                    }
                        }
                    }
                }
                if(src.field___exist())
                    for(int d0 = 0; d0 < PING33.field___.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field___.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field___.d2; d2++)
                            {
                                var item = src.field__(d0, d1, d2);
                                if(item.HasValue) field__(item.Value, d0, d1, d2);
                            }
                for(int d0 = 0; d0 < PING33.field6_.d0; d0++)
                    for(int d1 = 0; d1 < PING33.field6_.d1; d1++)
                        for(int d2 = 0; d2 < PING33.field6_.d2; d2++)
                        {
                            field6(src.field6(d0, d1, d2), d0, d1, d2);
                        }
                {
                    var init = field63().Initializer();
                    if(init.HasValue)
                    {
                        src.field63_init(init.Value);
                        var _fld = field63().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0; d0 < PING33.field63_.d0; d0++)
                                for(int d1 = 0; d1 < PING33.field63_.d1; d1++)
                                    for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                    {
                                        fld.set(src.field63(d0, d1, d2), d0, d1, d2);
                                    }
                        }
                    }
                }
                if(src.uid2_exist())
                    for(int d0 = 0; d0 < PING33.uid2_.d0; d0++)
                    {
                        var item = src.uid2(d0);
                        if(item.HasValue) uid2(item.Value, d0);
                    }
                if(src.field2_exist())
                    for(int d0 = 0; d0 < PING33.field2_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field2_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field2_.d2; d2++)
                            {
                                var item = src.field2(d0, d1, d2);
                                if(item.HasValue) field2(item.Value, d0, d1, d2);
                            }
                if(src.field4_exist())
                    for(int d0 = 0; d0 < PING33.field4_.d0; d0++)
                        for(int d1 = 0; d1 < PING33.field4_.d1; d1++)
                            for(int d2 = 0; d2 < PING33.field4_.d2; d2++)
                            {
                                var item = src.field4(d0, d1, d2);
                                if(item.HasValue) field4(item.Value, d0, d1, d2);
                            }
                {
                    var len = src.stringtest1_exist();
                    if(0 < len)
                        src.stringtest1(stringtest1(len));
                }
                {
                    var init = stringtest2().Initializer();
                    if(init.HasValue)
                    {
                        src.stringtest2_init(init.Value);
                        var _fld = stringtest2().Field();
                        if(_fld.HasValue)
                        {
                            var fld = _fld.Value;
                            for(int d0 = 0; d0 < PING33.stringtest2_.d0; d0++)
                                for(int d1 = 0; d1 < PING33.stringtest2_.d1; d1++)
                                    for(int d2 = 0 ; d2 < fld.d2(); d2 ++)
                                    {
                                        {
                                            var len = src.stringtest2_item_exist(d0, d1, d2);
                                            if(0 < len)
                                                src.stringtest2(fld.set(len, d0, d1, d2), d0, d1, d2);
                                        }
                                    }
                        }
                    }
                }
                {
                    var len = src.stringtest3_exist();
                    if(0 < len)
                        src.stringtest3(stringtest3(len));
                }
                {
                    var len = src.stringtest4_exist();
                    if(0 < len)
                        src.stringtest4(stringtest4(len));
                }
            }



        }

        public struct VISION_SPEED_ESTIMATE
        {
            internal Pack.Cursor data_;
            internal VISION_SPEED_ESTIMATE(Pack.Cursor data) { this.data_ = data; }




            public long usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }



            public interface DST_
            {
                void usec(long src);
                void x(float src);
                void y(float src);
                void z(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(42, 0, 0, 1, 20, 1, 160);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.usec(usec()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
            }

            public interface SRC_
            {
                long usec();
                float x();
                float y();
                float z();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                usec(src.usec());
                x(src.x());
                y(src.y());
                z(src.z());
            }



        }

        public struct VICON_POSITION_ESTIMATE
        {
            internal Pack.Cursor data_;
            internal VICON_POSITION_ESTIMATE(Pack.Cursor data) { this.data_ = data; }




            public long usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void roll(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void pitch(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void yaw(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }



            public interface DST_
            {
                void usec(long src);
                void x(float src);
                void y(float src);
                void z(float src);
                void roll(float src);
                void pitch(float src);
                void yaw(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(135, 0, 0, 1, 32, 1, 256);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.usec(usec()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
            }

            public interface SRC_
            {
                long usec();
                float x();
                float y();
                float z();
                float roll();
                float pitch();
                float yaw();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                usec(src.usec());
                x(src.x());
                y(src.y());
                z(src.z());
                roll(src.roll());
                pitch(src.pitch());
                yaw(src.yaw());
            }



        }
        /**
        *The IMU readings in SI units in NED body frame */

        public struct HIGHRES_IMU
        {
            internal Pack.Cursor data_;
            internal HIGHRES_IMU(Pack.Cursor data) { this.data_ = data; }




            public short fields_updated() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void fields_updated(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 2);  }

            public float xacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 10); }
            public void xacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 10, 4);  }

            public float yacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 14); }
            public void yacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 14, 4);  }

            public float zacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 18); }
            public void zacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 18, 4);  }

            public float xgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 22); }
            public void xgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 22, 4);  }

            public float ygyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 26); }
            public void ygyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 26, 4);  }

            public float zgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 30); }
            public void zgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 30, 4);  }

            public float xmag() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 34); }
            public void xmag(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 34, 4);  }

            public float ymag() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 38); }
            public void ymag(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 38, 4);  }

            public float zmag() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 42); }
            public void zmag(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 42, 4);  }

            public float abs_pressure() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 46); }
            public void abs_pressure(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 46, 4);  }

            public float diff_pressure() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 50); }
            public void diff_pressure(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 50, 4);  }

            public float pressure_alt() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 54); }
            public void pressure_alt(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 54, 4);  }

            public float temperature() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 58); }
            public void temperature(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 58, 4);  }



            public interface DST_
            {
                void time_usec(long src);
                void xacc(float src);
                void yacc(float src);
                void zacc(float src);
                void xgyro(float src);
                void ygyro(float src);
                void zgyro(float src);
                void xmag(float src);
                void ymag(float src);
                void zmag(float src);
                void abs_pressure(float src);
                void diff_pressure(float src);
                void pressure_alt(float src);
                void temperature(float src);
                void fields_updated(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(137, 1, 0, 1, 62, 1, 496);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.xacc(xacc()) ;
                dst.yacc(yacc()) ;
                dst.zacc(zacc()) ;
                dst.xgyro(xgyro()) ;
                dst.ygyro(ygyro()) ;
                dst.zgyro(zgyro()) ;
                dst.xmag(xmag()) ;
                dst.ymag(ymag()) ;
                dst.zmag(zmag()) ;
                dst.abs_pressure(abs_pressure()) ;
                dst.diff_pressure(diff_pressure()) ;
                dst.pressure_alt(pressure_alt()) ;
                dst.temperature(temperature()) ;
                dst.fields_updated(fields_updated()) ;
            }

            public interface SRC_
            {
                long time_usec();
                float xacc();
                float yacc();
                float zacc();
                float xgyro();
                float ygyro();
                float zgyro();
                float xmag();
                float ymag();
                float zmag();
                float abs_pressure();
                float diff_pressure();
                float pressure_alt();
                float temperature();
                short fields_updated();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                xacc(src.xacc());
                yacc(src.yacc());
                zacc(src.zacc());
                xgyro(src.xgyro());
                ygyro(src.ygyro());
                zgyro(src.zgyro());
                xmag(src.xmag());
                ymag(src.ymag());
                zmag(src.zmag());
                abs_pressure(src.abs_pressure());
                diff_pressure(src.diff_pressure());
                pressure_alt(src.pressure_alt());
                temperature(src.temperature());
                fields_updated(src.fields_updated());
            }



        }
        /**
        *Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor) */

        public struct OPTICAL_FLOW_RAD
        {
            internal Pack.Cursor data_;
            internal OPTICAL_FLOW_RAD(Pack.Cursor data) { this.data_ = data; }




            public int integration_time_us() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void integration_time_us(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public int time_delta_distance_us() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }
            public void time_delta_distance_us(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 4);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 8);  }

            public sbyte sensor_id() { return (sbyte)(data_.bytes[data_.origin  + 16]); }
            public void sensor_id(sbyte src) {    data_.bytes[data_.origin  + 16] = (byte)(src);  }

            public float integrated_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 17); }
            public void integrated_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 17, 4);  }

            public float integrated_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 21); }
            public void integrated_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 21, 4);  }

            public float integrated_xgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 25); }
            public void integrated_xgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 25, 4);  }

            public float integrated_ygyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 29); }
            public void integrated_ygyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 29, 4);  }

            public float integrated_zgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 33); }
            public void integrated_zgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 33, 4);  }

            public short temperature() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 37, 2)); }
            public void temperature(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 37);  }

            public sbyte quality() { return (sbyte)(data_.bytes[data_.origin  + 39]); }
            public void quality(sbyte src) {    data_.bytes[data_.origin  + 39] = (byte)(src);  }

            public float distance() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }
            public void distance(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 40, 4);  }



            public interface DST_
            {
                void time_usec(long src);
                void sensor_id(sbyte src);
                void integration_time_us(int src);
                void integrated_x(float src);
                void integrated_y(float src);
                void integrated_xgyro(float src);
                void integrated_ygyro(float src);
                void integrated_zgyro(float src);
                void temperature(short src);
                void quality(sbyte src);
                void time_delta_distance_us(int src);
                void distance(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(202, 0, 2, 1, 44, 1, 352);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.sensor_id(sensor_id()) ;
                dst.integration_time_us(integration_time_us()) ;
                dst.integrated_x(integrated_x()) ;
                dst.integrated_y(integrated_y()) ;
                dst.integrated_xgyro(integrated_xgyro()) ;
                dst.integrated_ygyro(integrated_ygyro()) ;
                dst.integrated_zgyro(integrated_zgyro()) ;
                dst.temperature(temperature()) ;
                dst.quality(quality()) ;
                dst.time_delta_distance_us(time_delta_distance_us()) ;
                dst.distance(distance()) ;
            }

            public interface SRC_
            {
                long time_usec();
                sbyte sensor_id();
                int integration_time_us();
                float integrated_x();
                float integrated_y();
                float integrated_xgyro();
                float integrated_ygyro();
                float integrated_zgyro();
                short temperature();
                sbyte quality();
                int time_delta_distance_us();
                float distance();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                sensor_id(src.sensor_id());
                integration_time_us(src.integration_time_us());
                integrated_x(src.integrated_x());
                integrated_y(src.integrated_y());
                integrated_xgyro(src.integrated_xgyro());
                integrated_ygyro(src.integrated_ygyro());
                integrated_zgyro(src.integrated_zgyro());
                temperature(src.temperature());
                quality(src.quality());
                time_delta_distance_us(src.time_delta_distance_us());
                distance(src.distance());
            }



        }
        /**
        *The IMU readings in SI units in NED body frame */

        public struct HIL_SENSOR
        {
            internal Pack.Cursor data_;
            internal HIL_SENSOR(Pack.Cursor data) { this.data_ = data; }




            public int fields_updated() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void fields_updated(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 4);  }

            public float xacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void xacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float yacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void yacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float zacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void zacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float xgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void xgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float ygyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void ygyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float zgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void zgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public float xmag() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }
            public void xmag(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 36, 4);  }

            public float ymag() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }
            public void ymag(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 40, 4);  }

            public float zmag() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 44); }
            public void zmag(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 44, 4);  }

            public float abs_pressure() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 48); }
            public void abs_pressure(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 48, 4);  }

            public float diff_pressure() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 52); }
            public void diff_pressure(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 52, 4);  }

            public float pressure_alt() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 56); }
            public void pressure_alt(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 56, 4);  }

            public float temperature() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 60); }
            public void temperature(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 60, 4);  }



            public interface DST_
            {
                void time_usec(long src);
                void xacc(float src);
                void yacc(float src);
                void zacc(float src);
                void xgyro(float src);
                void ygyro(float src);
                void zgyro(float src);
                void xmag(float src);
                void ymag(float src);
                void zmag(float src);
                void abs_pressure(float src);
                void diff_pressure(float src);
                void pressure_alt(float src);
                void temperature(float src);
                void fields_updated(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(169, 0, 1, 1, 64, 1, 512);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.xacc(xacc()) ;
                dst.yacc(yacc()) ;
                dst.zacc(zacc()) ;
                dst.xgyro(xgyro()) ;
                dst.ygyro(ygyro()) ;
                dst.zgyro(zgyro()) ;
                dst.xmag(xmag()) ;
                dst.ymag(ymag()) ;
                dst.zmag(zmag()) ;
                dst.abs_pressure(abs_pressure()) ;
                dst.diff_pressure(diff_pressure()) ;
                dst.pressure_alt(pressure_alt()) ;
                dst.temperature(temperature()) ;
                dst.fields_updated(fields_updated()) ;
            }

            public interface SRC_
            {
                long time_usec();
                float xacc();
                float yacc();
                float zacc();
                float xgyro();
                float ygyro();
                float zgyro();
                float xmag();
                float ymag();
                float zmag();
                float abs_pressure();
                float diff_pressure();
                float pressure_alt();
                float temperature();
                int fields_updated();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                xacc(src.xacc());
                yacc(src.yacc());
                zacc(src.zacc());
                xgyro(src.xgyro());
                ygyro(src.ygyro());
                zgyro(src.zgyro());
                xmag(src.xmag());
                ymag(src.ymag());
                zmag(src.zmag());
                abs_pressure(src.abs_pressure());
                diff_pressure(src.diff_pressure());
                pressure_alt(src.pressure_alt());
                temperature(src.temperature());
                fields_updated(src.fields_updated());
            }



        }
        /**
        *Status of simulation environment, if used */

        public struct SIM_STATE
        {
            internal Pack.Cursor data_;
            internal SIM_STATE(Pack.Cursor data) { this.data_ = data; }




            public float q1() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void q1(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float q2() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void q2(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float q3() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void q3(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float q4() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void q4(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void roll(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void pitch(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void yaw(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float xacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void xacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float yacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void yacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public float zacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }
            public void zacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 36, 4);  }

            public float xgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }
            public void xgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 40, 4);  }

            public float ygyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 44); }
            public void ygyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 44, 4);  }

            public float zgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 48); }
            public void zgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 48, 4);  }

            public float lat() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 52); }
            public void lat(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 52, 4);  }

            public float lon() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 56); }
            public void lon(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 56, 4);  }

            public float alt() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 60); }
            public void alt(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 60, 4);  }

            public float std_dev_horz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 64); }
            public void std_dev_horz(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 64, 4);  }

            public float std_dev_vert() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 68); }
            public void std_dev_vert(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 68, 4);  }

            public float vn() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 72); }
            public void vn(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 72, 4);  }

            public float ve() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 76); }
            public void ve(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 76, 4);  }

            public float vd() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 80); }
            public void vd(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 80, 4);  }



            public interface DST_
            {
                void q1(float src);
                void q2(float src);
                void q3(float src);
                void q4(float src);
                void roll(float src);
                void pitch(float src);
                void yaw(float src);
                void xacc(float src);
                void yacc(float src);
                void zacc(float src);
                void xgyro(float src);
                void ygyro(float src);
                void zgyro(float src);
                void lat(float src);
                void lon(float src);
                void alt(float src);
                void std_dev_horz(float src);
                void std_dev_vert(float src);
                void vn(float src);
                void ve(float src);
                void vd(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(108, 0, 0, 0, 84, 1, 672);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.q1(q1()) ;
                dst.q2(q2()) ;
                dst.q3(q3()) ;
                dst.q4(q4()) ;
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
                dst.xacc(xacc()) ;
                dst.yacc(yacc()) ;
                dst.zacc(zacc()) ;
                dst.xgyro(xgyro()) ;
                dst.ygyro(ygyro()) ;
                dst.zgyro(zgyro()) ;
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.alt(alt()) ;
                dst.std_dev_horz(std_dev_horz()) ;
                dst.std_dev_vert(std_dev_vert()) ;
                dst.vn(vn()) ;
                dst.ve(ve()) ;
                dst.vd(vd()) ;
            }

            public interface SRC_
            {
                float q1();
                float q2();
                float q3();
                float q4();
                float roll();
                float pitch();
                float yaw();
                float xacc();
                float yacc();
                float zacc();
                float xgyro();
                float ygyro();
                float zgyro();
                float lat();
                float lon();
                float alt();
                float std_dev_horz();
                float std_dev_vert();
                float vn();
                float ve();
                float vd();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                q1(src.q1());
                q2(src.q2());
                q3(src.q3());
                q4(src.q4());
                roll(src.roll());
                pitch(src.pitch());
                yaw(src.yaw());
                xacc(src.xacc());
                yacc(src.yacc());
                zacc(src.zacc());
                xgyro(src.xgyro());
                ygyro(src.ygyro());
                zgyro(src.zgyro());
                lat(src.lat());
                lon(src.lon());
                alt(src.alt());
                std_dev_horz(src.std_dev_horz());
                std_dev_vert(src.std_dev_vert());
                vn(src.vn());
                ve(src.ve());
                vd(src.vd());
            }



        }
        /**
        *Status generated by radio and injected into MAVLink stream. */

        public struct RADIO_STATUS
        {
            internal Pack.Cursor data_;
            internal RADIO_STATUS(Pack.Cursor data) { this.data_ = data; }




            public short rxerrors() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void rxerrors(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short fixeD() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void fixeD(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public sbyte rssi() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void rssi(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte remrssi() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void remrssi(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }

            public sbyte txbuf() { return (sbyte)(data_.bytes[data_.origin  + 6]); }
            public void txbuf(sbyte src) {    data_.bytes[data_.origin  + 6] = (byte)(src);  }

            public sbyte noise() { return (sbyte)(data_.bytes[data_.origin  + 7]); }
            public void noise(sbyte src) {    data_.bytes[data_.origin  + 7] = (byte)(src);  }

            public sbyte remnoise() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void remnoise(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }



            public interface DST_
            {
                void rssi(sbyte src);
                void remrssi(sbyte src);
                void txbuf(sbyte src);
                void noise(sbyte src);
                void remnoise(sbyte src);
                void rxerrors(short src);
                void fixeD(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(107, 2, 0, 0, 9, 1, 72);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.rssi(rssi()) ;
                dst.remrssi(remrssi()) ;
                dst.txbuf(txbuf()) ;
                dst.noise(noise()) ;
                dst.remnoise(remnoise()) ;
                dst.rxerrors(rxerrors()) ;
                dst.fixeD(fixeD()) ;
            }

            public interface SRC_
            {
                sbyte rssi();
                sbyte remrssi();
                sbyte txbuf();
                sbyte noise();
                sbyte remnoise();
                short rxerrors();
                short fixeD();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                rssi(src.rssi());
                remrssi(src.remrssi());
                txbuf(src.txbuf());
                noise(src.noise());
                remnoise(src.remnoise());
                rxerrors(src.rxerrors());
                fixeD(src.fixeD());
            }



        }
        /**
        *File transfer message */

        public struct FILE_TRANSFER_PROTOCOL
        {
            internal Pack.Cursor data_;
            internal FILE_TRANSFER_PROTOCOL(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_network() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_network(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public payload_ payload()
            {
                return new  payload_(data_);
            }

            public struct payload_
            {
                internal Pack.Cursor data_;
                public payload_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return FILE_TRANSFER_PROTOCOL.payload_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 3 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != FILE_TRANSFER_PROTOCOL.payload_.item_len) return false;
                    for(int i = 0; i < FILE_TRANSFER_PROTOCOL.payload_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(payload_ other)
                {
                    if(other.len() != FILE_TRANSFER_PROTOCOL.payload_.item_len) return false;
                    for(int i = 0; i < FILE_TRANSFER_PROTOCOL.payload_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 3 + index] = (byte)(src); }

                public const int item_len = 251 ;


            }

            public void payload(sbyte[] src)
            {
                var len =  Math.Min(src.Length, FILE_TRANSFER_PROTOCOL.payload_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 3 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void target_network(sbyte src);
                void target_system(sbyte src);
                void target_component(sbyte src);
                void payload(FILE_TRANSFER_PROTOCOL.payload_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(27, 0, 0, 0, 254, 1, 2032);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_network(target_network()) ;
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.payload(payload());
            }

            public interface SRC_
            {
                sbyte target_network();
                sbyte target_system();
                sbyte target_component();
                void payload(FILE_TRANSFER_PROTOCOL.payload_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_network(src.target_network());
                target_system(src.target_system());
                target_component(src.target_component());
                src.payload(payload());
            }



        }
        /**
        *Time synchronization message. */

        public struct TIMESYNC
        {
            internal Pack.Cursor data_;
            internal TIMESYNC(Pack.Cursor data) { this.data_ = data; }




            public long tc1() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void tc1(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public long ts1() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 8)); }
            public void ts1(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 8);  }



            public interface DST_
            {
                void tc1(long src);
                void ts1(long src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(46, 0, 0, 0, 16, 1, 128);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.tc1(tc1()) ;
                dst.ts1(ts1()) ;
            }

            public interface SRC_
            {
                long tc1();
                long ts1();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                tc1(src.tc1());
                ts1(src.ts1());
            }



        }
        /**
        *Camera-IMU triggering and synchronisation message. */

        public struct CAMERA_TRIGGER
        {
            internal Pack.Cursor data_;
            internal CAMERA_TRIGGER(Pack.Cursor data) { this.data_ = data; }




            public int seq() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void seq(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 4);  }



            public interface DST_
            {
                void time_usec(long src);
                void seq(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(191, 0, 1, 1, 12, 1, 96);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.seq(seq()) ;
            }

            public interface SRC_
            {
                long time_usec();
                int seq();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                seq(src.seq());
            }



        }
        /**
        *The global position, as returned by the Global Positioning System (GPS). This is
        *				 NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame). */

        public struct HIL_GPS
        {
            internal Pack.Cursor data_;
            internal HIL_GPS(Pack.Cursor data) { this.data_ = data; }




            public short eph() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void eph(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short epv() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void epv(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short vel() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void vel(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public short cog() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }
            public void cog(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 6);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 8);  }

            public sbyte fix_type() { return (sbyte)(data_.bytes[data_.origin  + 16]); }
            public void fix_type(sbyte src) {    data_.bytes[data_.origin  + 16] = (byte)(src);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 17, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 17);  }

            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 21, 4)); }
            public void lon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 21);  }

            public int alt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 25, 4)); }
            public void alt(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 25);  }

            public short vn() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 29, 2)); }
            public void vn(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 29);  }

            public short ve() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 31, 2)); }
            public void ve(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 31);  }

            public short vd() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 33, 2)); }
            public void vd(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 33);  }

            public sbyte satellites_visible() { return (sbyte)(data_.bytes[data_.origin  + 35]); }
            public void satellites_visible(sbyte src) {    data_.bytes[data_.origin  + 35] = (byte)(src);  }



            public interface DST_
            {
                void time_usec(long src);
                void fix_type(sbyte src);
                void lat(int src);
                void lon(int src);
                void alt(int src);
                void eph(short src);
                void epv(short src);
                void vel(short src);
                void vn(short src);
                void ve(short src);
                void vd(short src);
                void cog(short src);
                void satellites_visible(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(168, 4, 0, 1, 36, 1, 288);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.fix_type(fix_type()) ;
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.alt(alt()) ;
                dst.eph(eph()) ;
                dst.epv(epv()) ;
                dst.vel(vel()) ;
                dst.vn(vn()) ;
                dst.ve(ve()) ;
                dst.vd(vd()) ;
                dst.cog(cog()) ;
                dst.satellites_visible(satellites_visible()) ;
            }

            public interface SRC_
            {
                long time_usec();
                sbyte fix_type();
                int lat();
                int lon();
                int alt();
                short eph();
                short epv();
                short vel();
                short vn();
                short ve();
                short vd();
                short cog();
                sbyte satellites_visible();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                fix_type(src.fix_type());
                lat(src.lat());
                lon(src.lon());
                alt(src.alt());
                eph(src.eph());
                epv(src.epv());
                vel(src.vel());
                vn(src.vn());
                ve(src.ve());
                vd(src.vd());
                cog(src.cog());
                satellites_visible(src.satellites_visible());
            }



        }
        /**
        *Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor) */

        public struct HIL_OPTICAL_FLOW
        {
            internal Pack.Cursor data_;
            internal HIL_OPTICAL_FLOW(Pack.Cursor data) { this.data_ = data; }




            public int integration_time_us() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void integration_time_us(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public int time_delta_distance_us() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }
            public void time_delta_distance_us(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 4);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 8);  }

            public sbyte sensor_id() { return (sbyte)(data_.bytes[data_.origin  + 16]); }
            public void sensor_id(sbyte src) {    data_.bytes[data_.origin  + 16] = (byte)(src);  }

            public float integrated_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 17); }
            public void integrated_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 17, 4);  }

            public float integrated_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 21); }
            public void integrated_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 21, 4);  }

            public float integrated_xgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 25); }
            public void integrated_xgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 25, 4);  }

            public float integrated_ygyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 29); }
            public void integrated_ygyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 29, 4);  }

            public float integrated_zgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 33); }
            public void integrated_zgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 33, 4);  }

            public short temperature() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 37, 2)); }
            public void temperature(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 37);  }

            public sbyte quality() { return (sbyte)(data_.bytes[data_.origin  + 39]); }
            public void quality(sbyte src) {    data_.bytes[data_.origin  + 39] = (byte)(src);  }

            public float distance() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }
            public void distance(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 40, 4);  }



            public interface DST_
            {
                void time_usec(long src);
                void sensor_id(sbyte src);
                void integration_time_us(int src);
                void integrated_x(float src);
                void integrated_y(float src);
                void integrated_xgyro(float src);
                void integrated_ygyro(float src);
                void integrated_zgyro(float src);
                void temperature(short src);
                void quality(sbyte src);
                void time_delta_distance_us(int src);
                void distance(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(116, 0, 2, 1, 44, 1, 352);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.sensor_id(sensor_id()) ;
                dst.integration_time_us(integration_time_us()) ;
                dst.integrated_x(integrated_x()) ;
                dst.integrated_y(integrated_y()) ;
                dst.integrated_xgyro(integrated_xgyro()) ;
                dst.integrated_ygyro(integrated_ygyro()) ;
                dst.integrated_zgyro(integrated_zgyro()) ;
                dst.temperature(temperature()) ;
                dst.quality(quality()) ;
                dst.time_delta_distance_us(time_delta_distance_us()) ;
                dst.distance(distance()) ;
            }

            public interface SRC_
            {
                long time_usec();
                sbyte sensor_id();
                int integration_time_us();
                float integrated_x();
                float integrated_y();
                float integrated_xgyro();
                float integrated_ygyro();
                float integrated_zgyro();
                short temperature();
                sbyte quality();
                int time_delta_distance_us();
                float distance();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                sensor_id(src.sensor_id());
                integration_time_us(src.integration_time_us());
                integrated_x(src.integrated_x());
                integrated_y(src.integrated_y());
                integrated_xgyro(src.integrated_xgyro());
                integrated_ygyro(src.integrated_ygyro());
                integrated_zgyro(src.integrated_zgyro());
                temperature(src.temperature());
                quality(src.quality());
                time_delta_distance_us(src.time_delta_distance_us());
                distance(src.distance());
            }



        }
        /**
        *Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful
        *				 for high throughput applications such as hardware in the loop simulations */

        public struct HIL_STATE_QUATERNION
        {
            internal Pack.Cursor data_;
            internal HIL_STATE_QUATERNION(Pack.Cursor data) { this.data_ = data; }




            public short ind_airspeed() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void ind_airspeed(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short true_airspeed() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void true_airspeed(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 4);  }

            public attitude_quaternion_ attitude_quaternion()
            {
                return new  attitude_quaternion_(data_);
            }

            public struct attitude_quaternion_
            {
                internal Pack.Cursor data_;
                public attitude_quaternion_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return HIL_STATE_QUATERNION.attitude_quaternion_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != HIL_STATE_QUATERNION.attitude_quaternion_.item_len) return false;
                    for(int i = 0; i < HIL_STATE_QUATERNION.attitude_quaternion_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(attitude_quaternion_ other)
                {
                    if(other.len() != HIL_STATE_QUATERNION.attitude_quaternion_.item_len) return false;
                    for(int i = 0; i < HIL_STATE_QUATERNION.attitude_quaternion_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12 + index * 4, 4); }

                public const int item_len = 4 ;


            }

            public void attitude_quaternion(float[] src)
            {
                var len =  Math.Min(src.Length, HIL_STATE_QUATERNION.attitude_quaternion_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 12 + index * 4, 4);
            }

            public float rollspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void rollspeed(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float pitchspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void pitchspeed(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public float yawspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }
            public void yawspeed(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 36, 4);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 40, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 40);  }

            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 44, 4)); }
            public void lon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 44);  }

            public int alt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 48, 4)); }
            public void alt(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 48);  }

            public short vx() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 52, 2)); }
            public void vx(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 52);  }

            public short vy() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 54, 2)); }
            public void vy(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 54);  }

            public short vz() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 56, 2)); }
            public void vz(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 56);  }

            public short xacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 58, 2)); }
            public void xacc(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 58);  }

            public short yacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 60, 2)); }
            public void yacc(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 60);  }

            public short zacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 62, 2)); }
            public void zacc(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 62);  }



            public interface DST_
            {
                void time_usec(long src);
                void attitude_quaternion(HIL_STATE_QUATERNION.attitude_quaternion_ src);
                void rollspeed(float src);
                void pitchspeed(float src);
                void yawspeed(float src);
                void lat(int src);
                void lon(int src);
                void alt(int src);
                void vx(short src);
                void vy(short src);
                void vz(short src);
                void ind_airspeed(short src);
                void true_airspeed(short src);
                void xacc(short src);
                void yacc(short src);
                void zacc(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(196, 2, 0, 1, 64, 1, 512);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.attitude_quaternion(attitude_quaternion());
                dst.rollspeed(rollspeed()) ;
                dst.pitchspeed(pitchspeed()) ;
                dst.yawspeed(yawspeed()) ;
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.alt(alt()) ;
                dst.vx(vx()) ;
                dst.vy(vy()) ;
                dst.vz(vz()) ;
                dst.ind_airspeed(ind_airspeed()) ;
                dst.true_airspeed(true_airspeed()) ;
                dst.xacc(xacc()) ;
                dst.yacc(yacc()) ;
                dst.zacc(zacc()) ;
            }

            public interface SRC_
            {
                long time_usec();
                void attitude_quaternion(HIL_STATE_QUATERNION.attitude_quaternion_ dst) ;
                float rollspeed();
                float pitchspeed();
                float yawspeed();
                int lat();
                int lon();
                int alt();
                short vx();
                short vy();
                short vz();
                short ind_airspeed();
                short true_airspeed();
                short xacc();
                short yacc();
                short zacc();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                src.attitude_quaternion(attitude_quaternion());
                rollspeed(src.rollspeed());
                pitchspeed(src.pitchspeed());
                yawspeed(src.yawspeed());
                lat(src.lat());
                lon(src.lon());
                alt(src.alt());
                vx(src.vx());
                vy(src.vy());
                vz(src.vz());
                ind_airspeed(src.ind_airspeed());
                true_airspeed(src.true_airspeed());
                xacc(src.xacc());
                yacc(src.yacc());
                zacc(src.zacc());
            }



        }
        /**
        *The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to
        *				 the described unit */

        public struct SCALED_IMU2
        {
            internal Pack.Cursor data_;
            internal SCALED_IMU2(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public short xacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void xacc(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public short yacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }
            public void yacc(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 6);  }

            public short zacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }
            public void zacc(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 8);  }

            public short xgyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }
            public void xgyro(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 10);  }

            public short ygyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }
            public void ygyro(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 12);  }

            public short zgyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }
            public void zgyro(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 14);  }

            public short xmag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 2)); }
            public void xmag(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 16);  }

            public short ymag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 18, 2)); }
            public void ymag(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 18);  }

            public short zmag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 2)); }
            public void zmag(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 20);  }



            public interface DST_
            {
                void time_boot_ms(int src);
                void xacc(short src);
                void yacc(short src);
                void zacc(short src);
                void xgyro(short src);
                void ygyro(short src);
                void zgyro(short src);
                void xmag(short src);
                void ymag(short src);
                void zmag(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(178, 0, 1, 0, 22, 1, 176);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.xacc(xacc()) ;
                dst.yacc(yacc()) ;
                dst.zacc(zacc()) ;
                dst.xgyro(xgyro()) ;
                dst.ygyro(ygyro()) ;
                dst.zgyro(zgyro()) ;
                dst.xmag(xmag()) ;
                dst.ymag(ymag()) ;
                dst.zmag(zmag()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                short xacc();
                short yacc();
                short zacc();
                short xgyro();
                short ygyro();
                short zgyro();
                short xmag();
                short ymag();
                short zmag();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                xacc(src.xacc());
                yacc(src.yacc());
                zacc(src.zacc());
                xgyro(src.xgyro());
                ygyro(src.ygyro());
                zgyro(src.zgyro());
                xmag(src.xmag());
                ymag(src.ymag());
                zmag(src.zmag());
            }



        }
        /**
        *Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END
        *				 is called */

        public struct LOG_REQUEST_LIST
        {
            internal Pack.Cursor data_;
            internal LOG_REQUEST_LIST(Pack.Cursor data) { this.data_ = data; }




            public short start() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void start(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short end() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void end(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void start(short src);
                void end(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(37, 2, 0, 0, 6, 1, 48);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.start(start()) ;
                dst.end(end()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                short start();
                short end();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                start(src.start());
                end(src.end());
            }



        }
        /**
        *Reply to LOG_REQUEST_LIST */

        public struct LOG_ENTRY
        {
            internal Pack.Cursor data_;
            internal LOG_ENTRY(Pack.Cursor data) { this.data_ = data; }




            public short id() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void id(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short num_logs() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void num_logs(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short last_log_num() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void last_log_num(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public int time_utc() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void time_utc(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public int size() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void size(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }



            public interface DST_
            {
                void id(short src);
                void num_logs(short src);
                void last_log_num(short src);
                void time_utc(int src);
                void size(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(161, 3, 2, 0, 14, 1, 112);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.id(id()) ;
                dst.num_logs(num_logs()) ;
                dst.last_log_num(last_log_num()) ;
                dst.time_utc(time_utc()) ;
                dst.size(size()) ;
            }

            public interface SRC_
            {
                short id();
                short num_logs();
                short last_log_num();
                int time_utc();
                int size();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                id(src.id());
                num_logs(src.num_logs());
                last_log_num(src.last_log_num());
                time_utc(src.time_utc());
                size(src.size());
            }



        }
        /**
        *Request a chunk of a log */

        public struct LOG_REQUEST_DATA
        {
            internal Pack.Cursor data_;
            internal LOG_REQUEST_DATA(Pack.Cursor data) { this.data_ = data; }




            public short id() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void id(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int ofs() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void ofs(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public int count() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void count(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 10]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 10] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 11]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 11] = (byte)(src);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void id(short src);
                void ofs(int src);
                void count(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(72, 1, 2, 0, 12, 1, 96);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.id(id()) ;
                dst.ofs(ofs()) ;
                dst.count(count()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                short id();
                int ofs();
                int count();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                id(src.id());
                ofs(src.ofs());
                count(src.count());
            }



        }
        /**
        *Reply to LOG_REQUEST_DATA */

        public struct LOG_DATA
        {
            internal Pack.Cursor data_;
            internal LOG_DATA(Pack.Cursor data) { this.data_ = data; }




            public short id() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void id(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int ofs() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void ofs(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public sbyte count() { return (sbyte)(data_.bytes[data_.origin  + 6]); }
            public void count(sbyte src) {    data_.bytes[data_.origin  + 6] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return LOG_DATA.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 7 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != LOG_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < LOG_DATA.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != LOG_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < LOG_DATA.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 7 + index] = (byte)(src); }

                public const int item_len = 90 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, LOG_DATA.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 7 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void id(short src);
                void ofs(int src);
                void count(sbyte src);
                void daTa(LOG_DATA.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(204, 1, 1, 0, 97, 1, 776);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.id(id()) ;
                dst.ofs(ofs()) ;
                dst.count(count()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                short id();
                int ofs();
                sbyte count();
                void daTa(LOG_DATA.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                id(src.id());
                ofs(src.ofs());
                count(src.count());
                src.daTa(daTa());
            }



        }
        /**
        *Erase all logs */

        public struct LOG_ERASE
        {
            internal Pack.Cursor data_;
            internal LOG_ERASE(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(4, 0, 0, 0, 2, 1, 16);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
            }



        }
        /**
        *Stop log transfer and resume normal logging */

        public struct LOG_REQUEST_END
        {
            internal Pack.Cursor data_;
            internal LOG_REQUEST_END(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(102, 0, 0, 0, 2, 1, 16);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
            }



        }
        /**
        *data for injecting into the onboard GPS (used for DGPS) */

        public struct GPS_INJECT_DATA
        {
            internal Pack.Cursor data_;
            internal GPS_INJECT_DATA(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public sbyte len() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void len(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return GPS_INJECT_DATA.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 3 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != GPS_INJECT_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < GPS_INJECT_DATA.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != GPS_INJECT_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < GPS_INJECT_DATA.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 3 + index] = (byte)(src); }

                public const int item_len = 110 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, GPS_INJECT_DATA.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 3 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void len(sbyte src);
                void daTa(GPS_INJECT_DATA.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(52, 0, 0, 0, 113, 1, 904);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.len(len()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                sbyte len();
                void daTa(GPS_INJECT_DATA.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                len(src.len());
                src.daTa(daTa());
            }



        }
        /**
        *Second GPS data. Coordinate frame is right-handed, Z-axis up (GPS frame). */

        public struct GPS2_RAW
        {
            internal Pack.Cursor data_;
            internal GPS2_RAW(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                fix_type = 272
            }



            public short eph() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void eph(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short epv() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void epv(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short vel() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void vel(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public short cog() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }
            public void cog(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 6);  }

            public int dgps_age() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 4)); }
            public void dgps_age(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 8);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 12);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 20);  }

            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 24, 4)); }
            public void lon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 24);  }

            public int alt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 28, 4)); }
            public void alt(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 28);  }

            public sbyte satellites_visible() { return (sbyte)(data_.bytes[data_.origin  + 32]); }
            public void satellites_visible(sbyte src) {    data_.bytes[data_.origin  + 32] = (byte)(src);  }

            public sbyte dgps_numch() { return (sbyte)(data_.bytes[data_.origin  + 33]); }
            public void dgps_numch(sbyte src) {    data_.bytes[data_.origin  + 33] = (byte)(src);  }


            public  GPS_FIX_TYPE? fix_type()
            {
                if(data_.field_bit !=  272 && !data_.set_field(272, -1))  return null;
                return (GPS_FIX_TYPE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }


            public void fix_type(GPS_FIX_TYPE src)
            {
                if(data_.field_bit !=  272) data_.set_field(272, 0);
                ;
                Lib.set_bits((ulong)(src), 4, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void time_usec(long src);
                void fix_type(com.company.demo.GroundControl. GPS_FIX_TYPE src);
                void lat(int src);
                void lon(int src);
                void alt(int src);
                void eph(short src);
                void epv(short src);
                void vel(short src);
                void cog(short src);
                void satellites_visible(sbyte src);
                void dgps_numch(sbyte src);
                void dgps_age(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(213, 4, 1, 1, 35, 1, 272, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                {
                    var item = fix_type();
                    if(item.HasValue) dst.fix_type(item.Value);
                }
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.alt(alt()) ;
                dst.eph(eph()) ;
                dst.epv(epv()) ;
                dst.vel(vel()) ;
                dst.cog(cog()) ;
                dst.satellites_visible(satellites_visible()) ;
                dst.dgps_numch(dgps_numch()) ;
                dst.dgps_age(dgps_age()) ;
            }

            public interface SRC_
            {
                long time_usec();
                com.company.demo.GroundControl. GPS_FIX_TYPE?  fix_type();
                int lat();
                int lon();
                int alt();
                short eph();
                short epv();
                short vel();
                short cog();
                sbyte satellites_visible();
                sbyte dgps_numch();
                int dgps_age();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                {
                    var item = src.fix_type();
                    if(item.HasValue)     fix_type(item.Value);
                }
                lat(src.lat());
                lon(src.lon());
                alt(src.alt());
                eph(src.eph());
                epv(src.epv());
                vel(src.vel());
                cog(src.cog());
                satellites_visible(src.satellites_visible());
                dgps_numch(src.dgps_numch());
                dgps_age(src.dgps_age());
            }



        }
        /**
        *Power supply status */

        public struct POWER_STATUS
        {
            internal Pack.Cursor data_;
            internal POWER_STATUS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                flags = 32
            }



            public short Vcc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void Vcc(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short Vservo() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void Vservo(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }


            public  MAV_POWER_STATUS? flags()
            {
                if(data_.field_bit !=  32 && !data_.set_field(32, -1))  return null;
                return    MAV_POWER_STATUS_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }


            public void flags(MAV_POWER_STATUS src)
            {
                if(data_.field_bit !=  32) data_.set_field(32, 0);
                ;
                Lib.set_bits(MAV_POWER_STATUS_.bits(src), 3, data_.bytes, data_.BIT) ;;
            }





            public interface DST_
            {
                void Vcc(short src);
                void Vservo(short src);
                void flags(com.company.demo.GroundControl. MAV_POWER_STATUS src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(156, 2, 0, 0, 5, 1, 32, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.Vcc(Vcc()) ;
                dst.Vservo(Vservo()) ;
                {
                    var item = flags();
                    if(item.HasValue) dst.flags(item.Value);
                }
            }

            public interface SRC_
            {
                short Vcc();
                short Vservo();
                com.company.demo.GroundControl. MAV_POWER_STATUS?  flags();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                Vcc(src.Vcc());
                Vservo(src.Vservo());
                {
                    var item = src.flags();
                    if(item.HasValue)     flags(item.Value);
                }
            }



        }
        /**
        *Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or
        *				 telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages
        *				 or change the devices settings. A message with zero bytes can be used to change just the baudrate */

        public struct SERIAL_CONTROL
        {
            internal Pack.Cursor data_;
            internal SERIAL_CONTROL(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                device = 616,
                flags = 617
            }



            public short timeout() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void timeout(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int baudrate() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void baudrate(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public sbyte count() { return (sbyte)(data_.bytes[data_.origin  + 6]); }
            public void count(sbyte src) {    data_.bytes[data_.origin  + 6] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return SERIAL_CONTROL.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 7 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != SERIAL_CONTROL.daTa_.item_len) return false;
                    for(int i = 0; i < SERIAL_CONTROL.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != SERIAL_CONTROL.daTa_.item_len) return false;
                    for(int i = 0; i < SERIAL_CONTROL.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 7 + index] = (byte)(src); }

                public const int item_len = 70 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, SERIAL_CONTROL.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 7 + index] = (byte)(src[index]);
            }


            public  SERIAL_CONTROL_DEV? device()
            {
                if(data_.field_bit !=  616 && !data_.set_field(616, -1))  return null;
                return    SERIAL_CONTROL_DEV_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }


            public void device(SERIAL_CONTROL_DEV src)
            {
                if(data_.field_bit !=  616) data_.set_field(616, 0);
                ;
                Lib.set_bits(SERIAL_CONTROL_DEV_.bits(src), 3, data_.bytes, data_.BIT) ;;
            }




            public  SERIAL_CONTROL_FLAG? flags()
            {
                if(data_.field_bit !=  617 && !data_.set_field(617, -1))  return null;
                return    SERIAL_CONTROL_FLAG_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }


            public void flags(SERIAL_CONTROL_FLAG src)
            {
                if(data_.field_bit !=  617) data_.set_field(617, 0);
                ;
                Lib.set_bits(SERIAL_CONTROL_FLAG_.bits(src), 3, data_.bytes, data_.BIT) ;;
            }





            public interface DST_
            {
                void device(com.company.demo.GroundControl. SERIAL_CONTROL_DEV src);
                void flags(com.company.demo.GroundControl. SERIAL_CONTROL_FLAG src);
                void timeout(short src);
                void baudrate(int src);
                void count(sbyte src);
                void daTa(SERIAL_CONTROL.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(99, 1, 1, 0, 78, 1, 616, 0, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = device();
                    if(item.HasValue) dst.device(item.Value);
                }
                {
                    var item = flags();
                    if(item.HasValue) dst.flags(item.Value);
                }
                dst.timeout(timeout()) ;
                dst.baudrate(baudrate()) ;
                dst.count(count()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. SERIAL_CONTROL_DEV?  device();
                com.company.demo.GroundControl. SERIAL_CONTROL_FLAG?  flags();
                short timeout();
                int baudrate();
                sbyte count();
                void daTa(SERIAL_CONTROL.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.device();
                    if(item.HasValue)     device(item.Value);
                }
                {
                    var item = src.flags();
                    if(item.HasValue)     flags(item.Value);
                }
                timeout(src.timeout());
                baudrate(src.baudrate());
                count(src.count());
                src.daTa(daTa());
            }



        }
        /**
        *RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */

        public struct GPS_RTK
        {
            internal Pack.Cursor data_;
            internal GPS_RTK(Pack.Cursor data) { this.data_ = data; }




            public short wn() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void wn(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int time_last_baseline_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void time_last_baseline_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public int tow() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void tow(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public int accuracy() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void accuracy(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }

            public sbyte rtk_receiver_id() { return (sbyte)(data_.bytes[data_.origin  + 14]); }
            public void rtk_receiver_id(sbyte src) {    data_.bytes[data_.origin  + 14] = (byte)(src);  }

            public sbyte rtk_health() { return (sbyte)(data_.bytes[data_.origin  + 15]); }
            public void rtk_health(sbyte src) {    data_.bytes[data_.origin  + 15] = (byte)(src);  }

            public sbyte rtk_rate() { return (sbyte)(data_.bytes[data_.origin  + 16]); }
            public void rtk_rate(sbyte src) {    data_.bytes[data_.origin  + 16] = (byte)(src);  }

            public sbyte nsats() { return (sbyte)(data_.bytes[data_.origin  + 17]); }
            public void nsats(sbyte src) {    data_.bytes[data_.origin  + 17] = (byte)(src);  }

            public sbyte baseline_coords_type() { return (sbyte)(data_.bytes[data_.origin  + 18]); }
            public void baseline_coords_type(sbyte src) {    data_.bytes[data_.origin  + 18] = (byte)(src);  }

            public int baseline_a_mm() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 19, 4)); }
            public void baseline_a_mm(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 19);  }

            public int baseline_b_mm() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 23, 4)); }
            public void baseline_b_mm(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 23);  }

            public int baseline_c_mm() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 27, 4)); }
            public void baseline_c_mm(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 27);  }

            public int iar_num_hypotheses() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 31, 4)); }
            public void iar_num_hypotheses(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 31);  }



            public interface DST_
            {
                void time_last_baseline_ms(int src);
                void rtk_receiver_id(sbyte src);
                void wn(short src);
                void tow(int src);
                void rtk_health(sbyte src);
                void rtk_rate(sbyte src);
                void nsats(sbyte src);
                void baseline_coords_type(sbyte src);
                void baseline_a_mm(int src);
                void baseline_b_mm(int src);
                void baseline_c_mm(int src);
                void accuracy(int src);
                void iar_num_hypotheses(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(89, 1, 3, 0, 35, 1, 280);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_last_baseline_ms(time_last_baseline_ms()) ;
                dst.rtk_receiver_id(rtk_receiver_id()) ;
                dst.wn(wn()) ;
                dst.tow(tow()) ;
                dst.rtk_health(rtk_health()) ;
                dst.rtk_rate(rtk_rate()) ;
                dst.nsats(nsats()) ;
                dst.baseline_coords_type(baseline_coords_type()) ;
                dst.baseline_a_mm(baseline_a_mm()) ;
                dst.baseline_b_mm(baseline_b_mm()) ;
                dst.baseline_c_mm(baseline_c_mm()) ;
                dst.accuracy(accuracy()) ;
                dst.iar_num_hypotheses(iar_num_hypotheses()) ;
            }

            public interface SRC_
            {
                int time_last_baseline_ms();
                sbyte rtk_receiver_id();
                short wn();
                int tow();
                sbyte rtk_health();
                sbyte rtk_rate();
                sbyte nsats();
                sbyte baseline_coords_type();
                int baseline_a_mm();
                int baseline_b_mm();
                int baseline_c_mm();
                int accuracy();
                int iar_num_hypotheses();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_last_baseline_ms(src.time_last_baseline_ms());
                rtk_receiver_id(src.rtk_receiver_id());
                wn(src.wn());
                tow(src.tow());
                rtk_health(src.rtk_health());
                rtk_rate(src.rtk_rate());
                nsats(src.nsats());
                baseline_coords_type(src.baseline_coords_type());
                baseline_a_mm(src.baseline_a_mm());
                baseline_b_mm(src.baseline_b_mm());
                baseline_c_mm(src.baseline_c_mm());
                accuracy(src.accuracy());
                iar_num_hypotheses(src.iar_num_hypotheses());
            }



        }
        /**
        *RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */

        public struct GPS2_RTK
        {
            internal Pack.Cursor data_;
            internal GPS2_RTK(Pack.Cursor data) { this.data_ = data; }




            public short wn() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void wn(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int time_last_baseline_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void time_last_baseline_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public int tow() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void tow(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public int accuracy() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void accuracy(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }

            public sbyte rtk_receiver_id() { return (sbyte)(data_.bytes[data_.origin  + 14]); }
            public void rtk_receiver_id(sbyte src) {    data_.bytes[data_.origin  + 14] = (byte)(src);  }

            public sbyte rtk_health() { return (sbyte)(data_.bytes[data_.origin  + 15]); }
            public void rtk_health(sbyte src) {    data_.bytes[data_.origin  + 15] = (byte)(src);  }

            public sbyte rtk_rate() { return (sbyte)(data_.bytes[data_.origin  + 16]); }
            public void rtk_rate(sbyte src) {    data_.bytes[data_.origin  + 16] = (byte)(src);  }

            public sbyte nsats() { return (sbyte)(data_.bytes[data_.origin  + 17]); }
            public void nsats(sbyte src) {    data_.bytes[data_.origin  + 17] = (byte)(src);  }

            public sbyte baseline_coords_type() { return (sbyte)(data_.bytes[data_.origin  + 18]); }
            public void baseline_coords_type(sbyte src) {    data_.bytes[data_.origin  + 18] = (byte)(src);  }

            public int baseline_a_mm() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 19, 4)); }
            public void baseline_a_mm(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 19);  }

            public int baseline_b_mm() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 23, 4)); }
            public void baseline_b_mm(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 23);  }

            public int baseline_c_mm() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 27, 4)); }
            public void baseline_c_mm(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 27);  }

            public int iar_num_hypotheses() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 31, 4)); }
            public void iar_num_hypotheses(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 31);  }



            public interface DST_
            {
                void time_last_baseline_ms(int src);
                void rtk_receiver_id(sbyte src);
                void wn(short src);
                void tow(int src);
                void rtk_health(sbyte src);
                void rtk_rate(sbyte src);
                void nsats(sbyte src);
                void baseline_coords_type(sbyte src);
                void baseline_a_mm(int src);
                void baseline_b_mm(int src);
                void baseline_c_mm(int src);
                void accuracy(int src);
                void iar_num_hypotheses(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(91, 1, 3, 0, 35, 1, 280);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_last_baseline_ms(time_last_baseline_ms()) ;
                dst.rtk_receiver_id(rtk_receiver_id()) ;
                dst.wn(wn()) ;
                dst.tow(tow()) ;
                dst.rtk_health(rtk_health()) ;
                dst.rtk_rate(rtk_rate()) ;
                dst.nsats(nsats()) ;
                dst.baseline_coords_type(baseline_coords_type()) ;
                dst.baseline_a_mm(baseline_a_mm()) ;
                dst.baseline_b_mm(baseline_b_mm()) ;
                dst.baseline_c_mm(baseline_c_mm()) ;
                dst.accuracy(accuracy()) ;
                dst.iar_num_hypotheses(iar_num_hypotheses()) ;
            }

            public interface SRC_
            {
                int time_last_baseline_ms();
                sbyte rtk_receiver_id();
                short wn();
                int tow();
                sbyte rtk_health();
                sbyte rtk_rate();
                sbyte nsats();
                sbyte baseline_coords_type();
                int baseline_a_mm();
                int baseline_b_mm();
                int baseline_c_mm();
                int accuracy();
                int iar_num_hypotheses();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_last_baseline_ms(src.time_last_baseline_ms());
                rtk_receiver_id(src.rtk_receiver_id());
                wn(src.wn());
                tow(src.tow());
                rtk_health(src.rtk_health());
                rtk_rate(src.rtk_rate());
                nsats(src.nsats());
                baseline_coords_type(src.baseline_coords_type());
                baseline_a_mm(src.baseline_a_mm());
                baseline_b_mm(src.baseline_b_mm());
                baseline_c_mm(src.baseline_c_mm());
                accuracy(src.accuracy());
                iar_num_hypotheses(src.iar_num_hypotheses());
            }



        }
        /**
        *The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described
        *				 unit */

        public struct SCALED_IMU3
        {
            internal Pack.Cursor data_;
            internal SCALED_IMU3(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public short xacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void xacc(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public short yacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }
            public void yacc(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 6);  }

            public short zacc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }
            public void zacc(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 8);  }

            public short xgyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }
            public void xgyro(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 10);  }

            public short ygyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }
            public void ygyro(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 12);  }

            public short zgyro() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }
            public void zgyro(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 14);  }

            public short xmag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 2)); }
            public void xmag(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 16);  }

            public short ymag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 18, 2)); }
            public void ymag(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 18);  }

            public short zmag() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 2)); }
            public void zmag(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 20);  }



            public interface DST_
            {
                void time_boot_ms(int src);
                void xacc(short src);
                void yacc(short src);
                void zacc(short src);
                void xgyro(short src);
                void ygyro(short src);
                void zgyro(short src);
                void xmag(short src);
                void ymag(short src);
                void zmag(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(2, 0, 1, 0, 22, 1, 176);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.xacc(xacc()) ;
                dst.yacc(yacc()) ;
                dst.zacc(zacc()) ;
                dst.xgyro(xgyro()) ;
                dst.ygyro(ygyro()) ;
                dst.zgyro(zgyro()) ;
                dst.xmag(xmag()) ;
                dst.ymag(ymag()) ;
                dst.zmag(zmag()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                short xacc();
                short yacc();
                short zacc();
                short xgyro();
                short ygyro();
                short zgyro();
                short xmag();
                short ymag();
                short zmag();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                xacc(src.xacc());
                yacc(src.yacc());
                zacc(src.zacc());
                xgyro(src.xgyro());
                ygyro(src.ygyro());
                zgyro(src.zgyro());
                xmag(src.xmag());
                ymag(src.ymag());
                zmag(src.zmag());
            }



        }

        public struct DATA_TRANSMISSION_HANDSHAKE
        {
            internal Pack.Cursor data_;
            internal DATA_TRANSMISSION_HANDSHAKE(Pack.Cursor data) { this.data_ = data; }




            public short width() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void width(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short height() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void height(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short packets() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void packets(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public int size() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void size(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public sbyte typE() { return (sbyte)(data_.bytes[data_.origin  + 10]); }
            public void typE(sbyte src) {    data_.bytes[data_.origin  + 10] = (byte)(src);  }

            public sbyte payload() { return (sbyte)(data_.bytes[data_.origin  + 11]); }
            public void payload(sbyte src) {    data_.bytes[data_.origin  + 11] = (byte)(src);  }

            public sbyte jpg_quality() { return (sbyte)(data_.bytes[data_.origin  + 12]); }
            public void jpg_quality(sbyte src) {    data_.bytes[data_.origin  + 12] = (byte)(src);  }



            public interface DST_
            {
                void typE(sbyte src);
                void size(int src);
                void width(short src);
                void height(short src);
                void packets(short src);
                void payload(sbyte src);
                void jpg_quality(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(149, 3, 1, 0, 13, 1, 104);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.typE(typE()) ;
                dst.size(size()) ;
                dst.width(width()) ;
                dst.height(height()) ;
                dst.packets(packets()) ;
                dst.payload(payload()) ;
                dst.jpg_quality(jpg_quality()) ;
            }

            public interface SRC_
            {
                sbyte typE();
                int size();
                short width();
                short height();
                short packets();
                sbyte payload();
                sbyte jpg_quality();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                typE(src.typE());
                size(src.size());
                width(src.width());
                height(src.height());
                packets(src.packets());
                payload(src.payload());
                jpg_quality(src.jpg_quality());
            }



        }

        public struct ENCAPSULATED_DATA
        {
            internal Pack.Cursor data_;
            internal ENCAPSULATED_DATA(Pack.Cursor data) { this.data_ = data; }




            public short seqnr() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void seqnr(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return ENCAPSULATED_DATA.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 2 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != ENCAPSULATED_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < ENCAPSULATED_DATA.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != ENCAPSULATED_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < ENCAPSULATED_DATA.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 2 + index] = (byte)(src); }

                public const int item_len = 253 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, ENCAPSULATED_DATA.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 2 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void seqnr(short src);
                void daTa(ENCAPSULATED_DATA.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(170, 1, 0, 0, 255, 1, 2040);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.seqnr(seqnr()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                short seqnr();
                void daTa(ENCAPSULATED_DATA.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                seqnr(src.seqnr());
                src.daTa(daTa());
            }



        }

        public struct DISTANCE_SENSOR
        {
            internal Pack.Cursor data_;
            internal DISTANCE_SENSOR(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                typE = 98,
                orientation = 99
            }



            public short min_distance() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void min_distance(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short max_distance() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void max_distance(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short current_distance() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void current_distance(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public sbyte id() { return (sbyte)(data_.bytes[data_.origin  + 10]); }
            public void id(sbyte src) {    data_.bytes[data_.origin  + 10] = (byte)(src);  }

            public sbyte covariance() { return (sbyte)(data_.bytes[data_.origin  + 11]); }
            public void covariance(sbyte src) {    data_.bytes[data_.origin  + 11] = (byte)(src);  }


            public  MAV_DISTANCE_SENSOR? typE()
            {
                if(data_.field_bit !=  98 && !data_.set_field(98, -1))  return null;
                return (MAV_DISTANCE_SENSOR)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void typE(MAV_DISTANCE_SENSOR src)
            {
                if(data_.field_bit !=  98) data_.set_field(98, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }




            public  MAV_SENSOR_ORIENTATION? orientation()
            {
                if(data_.field_bit !=  99 && !data_.set_field(99, -1))  return null;
                return (MAV_SENSOR_ORIENTATION)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 6)));;
            }


            public void orientation(MAV_SENSOR_ORIENTATION src)
            {
                if(data_.field_bit !=  99) data_.set_field(99, 0);
                ;
                Lib.set_bits((ulong)(src), 6, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void time_boot_ms(int src);
                void min_distance(short src);
                void max_distance(short src);
                void current_distance(short src);
                void typE(com.company.demo.GroundControl. MAV_DISTANCE_SENSOR src);
                void id(sbyte src);
                void orientation(com.company.demo.GroundControl. MAV_SENSOR_ORIENTATION src);
                void covariance(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(61, 3, 1, 0, 13, 1, 98, 2, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.min_distance(min_distance()) ;
                dst.max_distance(max_distance()) ;
                dst.current_distance(current_distance()) ;
                {
                    var item = typE();
                    if(item.HasValue) dst.typE(item.Value);
                }
                dst.id(id()) ;
                {
                    var item = orientation();
                    if(item.HasValue) dst.orientation(item.Value);
                }
                dst.covariance(covariance()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                short min_distance();
                short max_distance();
                short current_distance();
                com.company.demo.GroundControl. MAV_DISTANCE_SENSOR?  typE();
                sbyte id();
                com.company.demo.GroundControl. MAV_SENSOR_ORIENTATION?  orientation();
                sbyte covariance();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                min_distance(src.min_distance());
                max_distance(src.max_distance());
                current_distance(src.current_distance());
                {
                    var item = src.typE();
                    if(item.HasValue)     typE(item.Value);
                }
                id(src.id());
                {
                    var item = src.orientation();
                    if(item.HasValue)     orientation(item.Value);
                }
                covariance(src.covariance());
            }



        }
        /**
        *Request for terrain data and terrain status */

        public struct TERRAIN_REQUEST
        {
            internal Pack.Cursor data_;
            internal TERRAIN_REQUEST(Pack.Cursor data) { this.data_ = data; }




            public short grid_spacing() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void grid_spacing(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public long mask() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 8)); }
            public void mask(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 2);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }

            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 4)); }
            public void lon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 14);  }



            public interface DST_
            {
                void lat(int src);
                void lon(int src);
                void grid_spacing(short src);
                void mask(long src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(92, 1, 0, 1, 18, 1, 144);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.grid_spacing(grid_spacing()) ;
                dst.mask(mask()) ;
            }

            public interface SRC_
            {
                int lat();
                int lon();
                short grid_spacing();
                long mask();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                lat(src.lat());
                lon(src.lon());
                grid_spacing(src.grid_spacing());
                mask(src.mask());
            }



        }
        /**
        *Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUES */

        public struct TERRAIN_DATA
        {
            internal Pack.Cursor data_;
            internal TERRAIN_DATA(Pack.Cursor data) { this.data_ = data; }




            public short grid_spacing() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void grid_spacing(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void lon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public sbyte gridbit() { return (sbyte)(data_.bytes[data_.origin  + 10]); }
            public void gridbit(sbyte src) {    data_.bytes[data_.origin  + 10] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return TERRAIN_DATA.daTa_.item_len  ;}
                public short get(int index) { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 11 + index * 2, 2)); }

                public bool same(short[] other)
                {
                    if(other.Length != TERRAIN_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < TERRAIN_DATA.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != TERRAIN_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < TERRAIN_DATA.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(short src, int index) { Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 11 + index * 2); }

                public const int item_len = 16 ;


            }

            public void daTa(short[] src)
            {
                var len =  Math.Min(src.Length, TERRAIN_DATA.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    Lib.set_bytes((ulong)(src[index]), 2, data_.bytes,  data_.origin  + 11 + index * 2);
            }



            public interface DST_
            {
                void lat(int src);
                void lon(int src);
                void grid_spacing(short src);
                void gridbit(sbyte src);
                void daTa(TERRAIN_DATA.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(173, 1, 0, 0, 43, 1, 344);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.grid_spacing(grid_spacing()) ;
                dst.gridbit(gridbit()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                int lat();
                int lon();
                short grid_spacing();
                sbyte gridbit();
                void daTa(TERRAIN_DATA.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                lat(src.lat());
                lon(src.lon());
                grid_spacing(src.grid_spacing());
                gridbit(src.gridbit());
                src.daTa(daTa());
            }



        }
        /**
        *Request that the vehicle report terrain height at the given location. Used by GCS to check if vehicle
        *				 has all terrain data needed for a mission */

        public struct TERRAIN_CHECK
        {
            internal Pack.Cursor data_;
            internal TERRAIN_CHECK(Pack.Cursor data) { this.data_ = data; }




            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }
            public void lon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 4);  }



            public interface DST_
            {
                void lat(int src);
                void lon(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(152, 0, 0, 0, 8, 1, 64);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.lat(lat()) ;
                dst.lon(lon()) ;
            }

            public interface SRC_
            {
                int lat();
                int lon();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                lat(src.lat());
                lon(src.lon());
            }



        }
        /**
        *Response from a TERRAIN_CHECK request */

        public struct TERRAIN_REPORT
        {
            internal Pack.Cursor data_;
            internal TERRAIN_REPORT(Pack.Cursor data) { this.data_ = data; }




            public short spacing() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void spacing(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short pending() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void pending(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short loaded() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void loaded(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void lon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }

            public float terrain_height() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 14); }
            public void terrain_height(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 14, 4);  }

            public float current_height() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 18); }
            public void current_height(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 18, 4);  }



            public interface DST_
            {
                void lat(int src);
                void lon(int src);
                void spacing(short src);
                void terrain_height(float src);
                void current_height(float src);
                void pending(short src);
                void loaded(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(86, 3, 0, 0, 22, 1, 176);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.spacing(spacing()) ;
                dst.terrain_height(terrain_height()) ;
                dst.current_height(current_height()) ;
                dst.pending(pending()) ;
                dst.loaded(loaded()) ;
            }

            public interface SRC_
            {
                int lat();
                int lon();
                short spacing();
                float terrain_height();
                float current_height();
                short pending();
                short loaded();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                lat(src.lat());
                lon(src.lon());
                spacing(src.spacing());
                terrain_height(src.terrain_height());
                current_height(src.current_height());
                pending(src.pending());
                loaded(src.loaded());
            }



        }
        /**
        *Barometer readings for 2nd barometer */

        public struct SCALED_PRESSURE2
        {
            internal Pack.Cursor data_;
            internal SCALED_PRESSURE2(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public float press_abs() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void press_abs(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float press_diff() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void press_diff(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public short temperature() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }
            public void temperature(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 12);  }



            public interface DST_
            {
                void time_boot_ms(int src);
                void press_abs(float src);
                void press_diff(float src);
                void temperature(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(151, 0, 1, 0, 14, 1, 112);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.press_abs(press_abs()) ;
                dst.press_diff(press_diff()) ;
                dst.temperature(temperature()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                float press_abs();
                float press_diff();
                short temperature();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                press_abs(src.press_abs());
                press_diff(src.press_diff());
                temperature(src.temperature());
            }



        }
        /**
        *Motion capture attitude and position */

        public struct ATT_POS_MOCAP
        {
            internal Pack.Cursor data_;
            internal ATT_POS_MOCAP(Pack.Cursor data) { this.data_ = data; }




            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public q_ q()
            {
                return new  q_(data_);
            }

            public struct q_
            {
                internal Pack.Cursor data_;
                public q_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return ATT_POS_MOCAP.q_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != ATT_POS_MOCAP.q_.item_len) return false;
                    for(int i = 0; i < ATT_POS_MOCAP.q_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(q_ other)
                {
                    if(other.len() != ATT_POS_MOCAP.q_.item_len) return false;
                    for(int i = 0; i < ATT_POS_MOCAP.q_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8 + index * 4, 4); }

                public const int item_len = 4 ;


            }

            public void q(float[] src)
            {
                var len =  Math.Min(src.Length, ATT_POS_MOCAP.q_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 8 + index * 4, 4);
            }

            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }



            public interface DST_
            {
                void time_usec(long src);
                void q(ATT_POS_MOCAP.q_ src);
                void x(float src);
                void y(float src);
                void z(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(200, 0, 0, 1, 36, 1, 288);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.q(q());
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
            }

            public interface SRC_
            {
                long time_usec();
                void q(ATT_POS_MOCAP.q_ dst) ;
                float x();
                float y();
                float z();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                src.q(q());
                x(src.x());
                y(src.y());
                z(src.z());
            }



        }
        /**
        *Set the vehicle attitude and body angular rates. */

        public struct SET_ACTUATOR_CONTROL_TARGET
        {
            internal Pack.Cursor data_;
            internal SET_ACTUATOR_CONTROL_TARGET(Pack.Cursor data) { this.data_ = data; }




            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public sbyte group_mlx() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void group_mlx(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 9]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 9] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 10]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 10] = (byte)(src);  }

            public controls_ controls()
            {
                return new  controls_(data_);
            }

            public struct controls_
            {
                internal Pack.Cursor data_;
                public controls_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return SET_ACTUATOR_CONTROL_TARGET.controls_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 11 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != SET_ACTUATOR_CONTROL_TARGET.controls_.item_len) return false;
                    for(int i = 0; i < SET_ACTUATOR_CONTROL_TARGET.controls_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(controls_ other)
                {
                    if(other.len() != SET_ACTUATOR_CONTROL_TARGET.controls_.item_len) return false;
                    for(int i = 0; i < SET_ACTUATOR_CONTROL_TARGET.controls_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 11 + index * 4, 4); }

                public const int item_len = 8 ;


            }

            public void controls(float[] src)
            {
                var len =  Math.Min(src.Length, SET_ACTUATOR_CONTROL_TARGET.controls_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 11 + index * 4, 4);
            }



            public interface DST_
            {
                void time_usec(long src);
                void group_mlx(sbyte src);
                void target_system(sbyte src);
                void target_component(sbyte src);
                void controls(SET_ACTUATOR_CONTROL_TARGET.controls_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(94, 0, 0, 1, 43, 1, 344);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.group_mlx(group_mlx()) ;
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.controls(controls());
            }

            public interface SRC_
            {
                long time_usec();
                sbyte group_mlx();
                sbyte target_system();
                sbyte target_component();
                void controls(SET_ACTUATOR_CONTROL_TARGET.controls_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                group_mlx(src.group_mlx());
                target_system(src.target_system());
                target_component(src.target_component());
                src.controls(controls());
            }



        }
        /**
        *Set the vehicle attitude and body angular rates. */

        public struct ACTUATOR_CONTROL_TARGET
        {
            internal Pack.Cursor data_;
            internal ACTUATOR_CONTROL_TARGET(Pack.Cursor data) { this.data_ = data; }




            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public sbyte group_mlx() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void group_mlx(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }

            public controls_ controls()
            {
                return new  controls_(data_);
            }

            public struct controls_
            {
                internal Pack.Cursor data_;
                public controls_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return ACTUATOR_CONTROL_TARGET.controls_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 9 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != ACTUATOR_CONTROL_TARGET.controls_.item_len) return false;
                    for(int i = 0; i < ACTUATOR_CONTROL_TARGET.controls_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(controls_ other)
                {
                    if(other.len() != ACTUATOR_CONTROL_TARGET.controls_.item_len) return false;
                    for(int i = 0; i < ACTUATOR_CONTROL_TARGET.controls_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 9 + index * 4, 4); }

                public const int item_len = 8 ;


            }

            public void controls(float[] src)
            {
                var len =  Math.Min(src.Length, ACTUATOR_CONTROL_TARGET.controls_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 9 + index * 4, 4);
            }



            public interface DST_
            {
                void time_usec(long src);
                void group_mlx(sbyte src);
                void controls(ACTUATOR_CONTROL_TARGET.controls_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(3, 0, 0, 1, 41, 1, 328);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.group_mlx(group_mlx()) ;
                dst.controls(controls());
            }

            public interface SRC_
            {
                long time_usec();
                sbyte group_mlx();
                void controls(ACTUATOR_CONTROL_TARGET.controls_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                group_mlx(src.group_mlx());
                src.controls(controls());
            }



        }
        /**
        *The current system altitude. */

        public struct ALTITUDE
        {
            internal Pack.Cursor data_;
            internal ALTITUDE(Pack.Cursor data) { this.data_ = data; }




            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public float altitude_monotonic() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void altitude_monotonic(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float altitude_amsl() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void altitude_amsl(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float altitude_local() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void altitude_local(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float altitude_relative() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void altitude_relative(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float altitude_terrain() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void altitude_terrain(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float bottom_clearance() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void bottom_clearance(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }



            public interface DST_
            {
                void time_usec(long src);
                void altitude_monotonic(float src);
                void altitude_amsl(float src);
                void altitude_local(float src);
                void altitude_relative(float src);
                void altitude_terrain(float src);
                void bottom_clearance(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(34, 0, 0, 1, 32, 1, 256);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.altitude_monotonic(altitude_monotonic()) ;
                dst.altitude_amsl(altitude_amsl()) ;
                dst.altitude_local(altitude_local()) ;
                dst.altitude_relative(altitude_relative()) ;
                dst.altitude_terrain(altitude_terrain()) ;
                dst.bottom_clearance(bottom_clearance()) ;
            }

            public interface SRC_
            {
                long time_usec();
                float altitude_monotonic();
                float altitude_amsl();
                float altitude_local();
                float altitude_relative();
                float altitude_terrain();
                float bottom_clearance();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                altitude_monotonic(src.altitude_monotonic());
                altitude_amsl(src.altitude_amsl());
                altitude_local(src.altitude_local());
                altitude_relative(src.altitude_relative());
                altitude_terrain(src.altitude_terrain());
                bottom_clearance(src.bottom_clearance());
            }



        }
        /**
        *The autopilot is requesting a resource (file, binary, other type of data) */

        public struct RESOURCE_REQUEST
        {
            internal Pack.Cursor data_;
            internal RESOURCE_REQUEST(Pack.Cursor data) { this.data_ = data; }




            public sbyte request_id() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void request_id(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte uri_type() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void uri_type(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public uri_ uri()
            {
                return new  uri_(data_);
            }

            public struct uri_
            {
                internal Pack.Cursor data_;
                public uri_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return RESOURCE_REQUEST.uri_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 2 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != RESOURCE_REQUEST.uri_.item_len) return false;
                    for(int i = 0; i < RESOURCE_REQUEST.uri_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(uri_ other)
                {
                    if(other.len() != RESOURCE_REQUEST.uri_.item_len) return false;
                    for(int i = 0; i < RESOURCE_REQUEST.uri_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 2 + index] = (byte)(src); }

                public const int item_len = 120 ;


            }

            public void uri(sbyte[] src)
            {
                var len =  Math.Min(src.Length, RESOURCE_REQUEST.uri_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 2 + index] = (byte)(src[index]);
            }

            public sbyte transfer_type() { return (sbyte)(data_.bytes[data_.origin  + 122]); }
            public void transfer_type(sbyte src) {    data_.bytes[data_.origin  + 122] = (byte)(src);  }

            public storage_ storage()
            {
                return new  storage_(data_);
            }

            public struct storage_
            {
                internal Pack.Cursor data_;
                public storage_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return RESOURCE_REQUEST.storage_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 123 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != RESOURCE_REQUEST.storage_.item_len) return false;
                    for(int i = 0; i < RESOURCE_REQUEST.storage_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(storage_ other)
                {
                    if(other.len() != RESOURCE_REQUEST.storage_.item_len) return false;
                    for(int i = 0; i < RESOURCE_REQUEST.storage_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 123 + index] = (byte)(src); }

                public const int item_len = 120 ;


            }

            public void storage(sbyte[] src)
            {
                var len =  Math.Min(src.Length, RESOURCE_REQUEST.storage_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 123 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void request_id(sbyte src);
                void uri_type(sbyte src);
                void uri(RESOURCE_REQUEST.uri_ src);
                void transfer_type(sbyte src);
                void storage(RESOURCE_REQUEST.storage_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(67, 0, 0, 0, 243, 1, 1944);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.request_id(request_id()) ;
                dst.uri_type(uri_type()) ;
                dst.uri(uri());
                dst.transfer_type(transfer_type()) ;
                dst.storage(storage());
            }

            public interface SRC_
            {
                sbyte request_id();
                sbyte uri_type();
                void uri(RESOURCE_REQUEST.uri_ dst) ;
                sbyte transfer_type();
                void storage(RESOURCE_REQUEST.storage_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                request_id(src.request_id());
                uri_type(src.uri_type());
                src.uri(uri());
                transfer_type(src.transfer_type());
                src.storage(storage());
            }



        }
        /**
        *Barometer readings for 3rd barometer */

        public struct SCALED_PRESSURE3
        {
            internal Pack.Cursor data_;
            internal SCALED_PRESSURE3(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public float press_abs() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void press_abs(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float press_diff() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void press_diff(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public short temperature() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 2)); }
            public void temperature(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 12);  }



            public interface DST_
            {
                void time_boot_ms(int src);
                void press_abs(float src);
                void press_diff(float src);
                void temperature(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(130, 0, 1, 0, 14, 1, 112);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.press_abs(press_abs()) ;
                dst.press_diff(press_diff()) ;
                dst.temperature(temperature()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                float press_abs();
                float press_diff();
                short temperature();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                press_abs(src.press_abs());
                press_diff(src.press_diff());
                temperature(src.temperature());
            }



        }
        /**
        *current motion information from a designated system */

        public struct FOLLOW_TARGET
        {
            internal Pack.Cursor data_;
            internal FOLLOW_TARGET(Pack.Cursor data) { this.data_ = data; }




            public long timestamp() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void timestamp(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public long custom_state() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 8)); }
            public void custom_state(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 8);  }

            public sbyte est_capabilities() { return (sbyte)(data_.bytes[data_.origin  + 16]); }
            public void est_capabilities(sbyte src) {    data_.bytes[data_.origin  + 16] = (byte)(src);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 17, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 17);  }

            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 21, 4)); }
            public void lon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 21);  }

            public float alt() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 25); }
            public void alt(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 25, 4);  }

            public vel_ vel()
            {
                return new  vel_(data_);
            }

            public struct vel_
            {
                internal Pack.Cursor data_;
                public vel_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return FOLLOW_TARGET.vel_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 29 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != FOLLOW_TARGET.vel_.item_len) return false;
                    for(int i = 0; i < FOLLOW_TARGET.vel_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(vel_ other)
                {
                    if(other.len() != FOLLOW_TARGET.vel_.item_len) return false;
                    for(int i = 0; i < FOLLOW_TARGET.vel_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 29 + index * 4, 4); }

                public const int item_len = 3 ;


            }

            public void vel(float[] src)
            {
                var len =  Math.Min(src.Length, FOLLOW_TARGET.vel_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 29 + index * 4, 4);
            }

            public acc_ acc()
            {
                return new  acc_(data_);
            }

            public struct acc_
            {
                internal Pack.Cursor data_;
                public acc_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return FOLLOW_TARGET.acc_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 41 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != FOLLOW_TARGET.acc_.item_len) return false;
                    for(int i = 0; i < FOLLOW_TARGET.acc_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(acc_ other)
                {
                    if(other.len() != FOLLOW_TARGET.acc_.item_len) return false;
                    for(int i = 0; i < FOLLOW_TARGET.acc_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 41 + index * 4, 4); }

                public const int item_len = 3 ;


            }

            public void acc(float[] src)
            {
                var len =  Math.Min(src.Length, FOLLOW_TARGET.acc_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 41 + index * 4, 4);
            }

            public attitude_q_ attitude_q()
            {
                return new  attitude_q_(data_);
            }

            public struct attitude_q_
            {
                internal Pack.Cursor data_;
                public attitude_q_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return FOLLOW_TARGET.attitude_q_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 53 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != FOLLOW_TARGET.attitude_q_.item_len) return false;
                    for(int i = 0; i < FOLLOW_TARGET.attitude_q_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(attitude_q_ other)
                {
                    if(other.len() != FOLLOW_TARGET.attitude_q_.item_len) return false;
                    for(int i = 0; i < FOLLOW_TARGET.attitude_q_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 53 + index * 4, 4); }

                public const int item_len = 4 ;


            }

            public void attitude_q(float[] src)
            {
                var len =  Math.Min(src.Length, FOLLOW_TARGET.attitude_q_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 53 + index * 4, 4);
            }

            public rates_ rates()
            {
                return new  rates_(data_);
            }

            public struct rates_
            {
                internal Pack.Cursor data_;
                public rates_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return FOLLOW_TARGET.rates_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 69 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != FOLLOW_TARGET.rates_.item_len) return false;
                    for(int i = 0; i < FOLLOW_TARGET.rates_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(rates_ other)
                {
                    if(other.len() != FOLLOW_TARGET.rates_.item_len) return false;
                    for(int i = 0; i < FOLLOW_TARGET.rates_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 69 + index * 4, 4); }

                public const int item_len = 3 ;


            }

            public void rates(float[] src)
            {
                var len =  Math.Min(src.Length, FOLLOW_TARGET.rates_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 69 + index * 4, 4);
            }

            public position_cov_ position_cov()
            {
                return new  position_cov_(data_);
            }

            public struct position_cov_
            {
                internal Pack.Cursor data_;
                public position_cov_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return FOLLOW_TARGET.position_cov_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 81 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != FOLLOW_TARGET.position_cov_.item_len) return false;
                    for(int i = 0; i < FOLLOW_TARGET.position_cov_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(position_cov_ other)
                {
                    if(other.len() != FOLLOW_TARGET.position_cov_.item_len) return false;
                    for(int i = 0; i < FOLLOW_TARGET.position_cov_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 81 + index * 4, 4); }

                public const int item_len = 3 ;


            }

            public void position_cov(float[] src)
            {
                var len =  Math.Min(src.Length, FOLLOW_TARGET.position_cov_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 81 + index * 4, 4);
            }



            public interface DST_
            {
                void timestamp(long src);
                void est_capabilities(sbyte src);
                void lat(int src);
                void lon(int src);
                void alt(float src);
                void vel(FOLLOW_TARGET.vel_ src);
                void acc(FOLLOW_TARGET.acc_ src);
                void attitude_q(FOLLOW_TARGET.attitude_q_ src);
                void rates(FOLLOW_TARGET.rates_ src);
                void position_cov(FOLLOW_TARGET.position_cov_ src);
                void custom_state(long src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(39, 0, 0, 2, 93, 1, 744);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.timestamp(timestamp()) ;
                dst.est_capabilities(est_capabilities()) ;
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.alt(alt()) ;
                dst.vel(vel());
                dst.acc(acc());
                dst.attitude_q(attitude_q());
                dst.rates(rates());
                dst.position_cov(position_cov());
                dst.custom_state(custom_state()) ;
            }

            public interface SRC_
            {
                long timestamp();
                sbyte est_capabilities();
                int lat();
                int lon();
                float alt();
                void vel(FOLLOW_TARGET.vel_ dst) ;
                void acc(FOLLOW_TARGET.acc_ dst) ;
                void attitude_q(FOLLOW_TARGET.attitude_q_ dst) ;
                void rates(FOLLOW_TARGET.rates_ dst) ;
                void position_cov(FOLLOW_TARGET.position_cov_ dst) ;
                long custom_state();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                timestamp(src.timestamp());
                est_capabilities(src.est_capabilities());
                lat(src.lat());
                lon(src.lon());
                alt(src.alt());
                src.vel(vel());
                src.acc(acc());
                src.attitude_q(attitude_q());
                src.rates(rates());
                src.position_cov(position_cov());
                custom_state(src.custom_state());
            }



        }
        /**
        *The smoothed, monotonic system state used to feed the control loops of the system. */

        public struct CONTROL_SYSTEM_STATE
        {
            internal Pack.Cursor data_;
            internal CONTROL_SYSTEM_STATE(Pack.Cursor data) { this.data_ = data; }




            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public float x_acc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void x_acc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float y_acc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void y_acc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float z_acc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void z_acc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float x_vel() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void x_vel(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float y_vel() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void y_vel(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float z_vel() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void z_vel(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float x_pos() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void x_pos(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public float y_pos() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }
            public void y_pos(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 36, 4);  }

            public float z_pos() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }
            public void z_pos(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 40, 4);  }

            public float airspeed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 44); }
            public void airspeed(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 44, 4);  }

            public vel_variance_ vel_variance()
            {
                return new  vel_variance_(data_);
            }

            public struct vel_variance_
            {
                internal Pack.Cursor data_;
                public vel_variance_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return CONTROL_SYSTEM_STATE.vel_variance_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 48 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != CONTROL_SYSTEM_STATE.vel_variance_.item_len) return false;
                    for(int i = 0; i < CONTROL_SYSTEM_STATE.vel_variance_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(vel_variance_ other)
                {
                    if(other.len() != CONTROL_SYSTEM_STATE.vel_variance_.item_len) return false;
                    for(int i = 0; i < CONTROL_SYSTEM_STATE.vel_variance_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 48 + index * 4, 4); }

                public const int item_len = 3 ;


            }

            public void vel_variance(float[] src)
            {
                var len =  Math.Min(src.Length, CONTROL_SYSTEM_STATE.vel_variance_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 48 + index * 4, 4);
            }

            public pos_variance_ pos_variance()
            {
                return new  pos_variance_(data_);
            }

            public struct pos_variance_
            {
                internal Pack.Cursor data_;
                public pos_variance_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return CONTROL_SYSTEM_STATE.pos_variance_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 60 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != CONTROL_SYSTEM_STATE.pos_variance_.item_len) return false;
                    for(int i = 0; i < CONTROL_SYSTEM_STATE.pos_variance_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(pos_variance_ other)
                {
                    if(other.len() != CONTROL_SYSTEM_STATE.pos_variance_.item_len) return false;
                    for(int i = 0; i < CONTROL_SYSTEM_STATE.pos_variance_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 60 + index * 4, 4); }

                public const int item_len = 3 ;


            }

            public void pos_variance(float[] src)
            {
                var len =  Math.Min(src.Length, CONTROL_SYSTEM_STATE.pos_variance_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 60 + index * 4, 4);
            }

            public q_ q()
            {
                return new  q_(data_);
            }

            public struct q_
            {
                internal Pack.Cursor data_;
                public q_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return CONTROL_SYSTEM_STATE.q_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 72 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != CONTROL_SYSTEM_STATE.q_.item_len) return false;
                    for(int i = 0; i < CONTROL_SYSTEM_STATE.q_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(q_ other)
                {
                    if(other.len() != CONTROL_SYSTEM_STATE.q_.item_len) return false;
                    for(int i = 0; i < CONTROL_SYSTEM_STATE.q_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 72 + index * 4, 4); }

                public const int item_len = 4 ;


            }

            public void q(float[] src)
            {
                var len =  Math.Min(src.Length, CONTROL_SYSTEM_STATE.q_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 72 + index * 4, 4);
            }

            public float roll_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 88); }
            public void roll_rate(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 88, 4);  }

            public float pitch_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 92); }
            public void pitch_rate(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 92, 4);  }

            public float yaw_rate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 96); }
            public void yaw_rate(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 96, 4);  }



            public interface DST_
            {
                void time_usec(long src);
                void x_acc(float src);
                void y_acc(float src);
                void z_acc(float src);
                void x_vel(float src);
                void y_vel(float src);
                void z_vel(float src);
                void x_pos(float src);
                void y_pos(float src);
                void z_pos(float src);
                void airspeed(float src);
                void vel_variance(CONTROL_SYSTEM_STATE.vel_variance_ src);
                void pos_variance(CONTROL_SYSTEM_STATE.pos_variance_ src);
                void q(CONTROL_SYSTEM_STATE.q_ src);
                void roll_rate(float src);
                void pitch_rate(float src);
                void yaw_rate(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(207, 0, 0, 1, 100, 1, 800);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.x_acc(x_acc()) ;
                dst.y_acc(y_acc()) ;
                dst.z_acc(z_acc()) ;
                dst.x_vel(x_vel()) ;
                dst.y_vel(y_vel()) ;
                dst.z_vel(z_vel()) ;
                dst.x_pos(x_pos()) ;
                dst.y_pos(y_pos()) ;
                dst.z_pos(z_pos()) ;
                dst.airspeed(airspeed()) ;
                dst.vel_variance(vel_variance());
                dst.pos_variance(pos_variance());
                dst.q(q());
                dst.roll_rate(roll_rate()) ;
                dst.pitch_rate(pitch_rate()) ;
                dst.yaw_rate(yaw_rate()) ;
            }

            public interface SRC_
            {
                long time_usec();
                float x_acc();
                float y_acc();
                float z_acc();
                float x_vel();
                float y_vel();
                float z_vel();
                float x_pos();
                float y_pos();
                float z_pos();
                float airspeed();
                void vel_variance(CONTROL_SYSTEM_STATE.vel_variance_ dst) ;
                void pos_variance(CONTROL_SYSTEM_STATE.pos_variance_ dst) ;
                void q(CONTROL_SYSTEM_STATE.q_ dst) ;
                float roll_rate();
                float pitch_rate();
                float yaw_rate();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                x_acc(src.x_acc());
                y_acc(src.y_acc());
                z_acc(src.z_acc());
                x_vel(src.x_vel());
                y_vel(src.y_vel());
                z_vel(src.z_vel());
                x_pos(src.x_pos());
                y_pos(src.y_pos());
                z_pos(src.z_pos());
                airspeed(src.airspeed());
                src.vel_variance(vel_variance());
                src.pos_variance(pos_variance());
                src.q(q());
                roll_rate(src.roll_rate());
                pitch_rate(src.pitch_rate());
                yaw_rate(src.yaw_rate());
            }



        }
        /**
        *Battery information */

        public struct BATTERY_STATUS
        {
            internal Pack.Cursor data_;
            internal BATTERY_STATUS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                battery_function = 272,
                typE = 273
            }



            public voltages_ voltages()
            {
                return new  voltages_(data_);
            }

            public struct voltages_
            {
                internal Pack.Cursor data_;
                public voltages_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return BATTERY_STATUS.voltages_.item_len  ;}
                public short get(int index) { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + index * 2, 2)); }

                public bool same(short[] other)
                {
                    if(other.Length != BATTERY_STATUS.voltages_.item_len) return false;
                    for(int i = 0; i < BATTERY_STATUS.voltages_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(voltages_ other)
                {
                    if(other.len() != BATTERY_STATUS.voltages_.item_len) return false;
                    for(int i = 0; i < BATTERY_STATUS.voltages_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(short src, int index) { Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + index * 2); }

                public const int item_len = 10 ;


            }

            public void voltages(short[] src)
            {
                var len =  Math.Min(src.Length, BATTERY_STATUS.voltages_.item_len);
                for(int index = 0; index < len; index++)
                    Lib.set_bytes((ulong)(src[index]), 2, data_.bytes,  data_.origin  + index * 2);
            }

            public sbyte id() { return (sbyte)(data_.bytes[data_.origin  + 20]); }
            public void id(sbyte src) {    data_.bytes[data_.origin  + 20] = (byte)(src);  }

            public short temperature() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 21, 2)); }
            public void temperature(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 21);  }

            public short current_battery() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 23, 2)); }
            public void current_battery(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 23);  }

            public int current_consumed() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 25, 4)); }
            public void current_consumed(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 25);  }

            public int energy_consumed() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 29, 4)); }
            public void energy_consumed(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 29);  }

            public sbyte battery_remaining() { return (sbyte)(data_.bytes[data_.origin  + 33]); }
            public void battery_remaining(sbyte src) {    data_.bytes[data_.origin  + 33] = (byte)(src);  }


            public  MAV_BATTERY_FUNCTION? battery_function()
            {
                if(data_.field_bit !=  272 && !data_.set_field(272, -1))  return null;
                return (MAV_BATTERY_FUNCTION)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void battery_function(MAV_BATTERY_FUNCTION src)
            {
                if(data_.field_bit !=  272) data_.set_field(272, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }




            public  MAV_BATTERY_TYPE? typE()
            {
                if(data_.field_bit !=  273 && !data_.set_field(273, -1))  return null;
                return (MAV_BATTERY_TYPE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void typE(MAV_BATTERY_TYPE src)
            {
                if(data_.field_bit !=  273) data_.set_field(273, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void id(sbyte src);
                void battery_function(com.company.demo.GroundControl. MAV_BATTERY_FUNCTION src);
                void typE(com.company.demo.GroundControl. MAV_BATTERY_TYPE src);
                void temperature(short src);
                void voltages(BATTERY_STATUS.voltages_ src);
                void current_battery(short src);
                void current_consumed(int src);
                void energy_consumed(int src);
                void battery_remaining(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(111, 10, 0, 0, 35, 1, 272, 0, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.id(id()) ;
                {
                    var item = battery_function();
                    if(item.HasValue) dst.battery_function(item.Value);
                }
                {
                    var item = typE();
                    if(item.HasValue) dst.typE(item.Value);
                }
                dst.temperature(temperature()) ;
                dst.voltages(voltages());
                dst.current_battery(current_battery()) ;
                dst.current_consumed(current_consumed()) ;
                dst.energy_consumed(energy_consumed()) ;
                dst.battery_remaining(battery_remaining()) ;
            }

            public interface SRC_
            {
                sbyte id();
                com.company.demo.GroundControl. MAV_BATTERY_FUNCTION?  battery_function();
                com.company.demo.GroundControl. MAV_BATTERY_TYPE?  typE();
                short temperature();
                void voltages(BATTERY_STATUS.voltages_ dst) ;
                short current_battery();
                int current_consumed();
                int energy_consumed();
                sbyte battery_remaining();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                id(src.id());
                {
                    var item = src.battery_function();
                    if(item.HasValue)     battery_function(item.Value);
                }
                {
                    var item = src.typE();
                    if(item.HasValue)     typE(item.Value);
                }
                temperature(src.temperature());
                src.voltages(voltages());
                current_battery(src.current_battery());
                current_consumed(src.current_consumed());
                energy_consumed(src.energy_consumed());
                battery_remaining(src.battery_remaining());
            }



        }
        /**
        *Version and capability of autopilot software */

        public struct AUTOPILOT_VERSION
        {
            internal Pack.Cursor data_;
            internal AUTOPILOT_VERSION(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                capabilities = 419,
                uid2 = 420
            }



            public short vendor_id() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void vendor_id(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short product_id() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void product_id(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public int flight_sw_version() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }
            public void flight_sw_version(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 4);  }

            public int middleware_sw_version() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 4)); }
            public void middleware_sw_version(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 8);  }

            public int os_sw_version() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 4)); }
            public void os_sw_version(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 12);  }

            public int board_version() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 4)); }
            public void board_version(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 16);  }

            public long uid() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 8)); }
            public void uid(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 20);  }

            public flight_custom_version_ flight_custom_version()
            {
                return new  flight_custom_version_(data_);
            }

            public struct flight_custom_version_
            {
                internal Pack.Cursor data_;
                public flight_custom_version_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return AUTOPILOT_VERSION.flight_custom_version_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 28 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != AUTOPILOT_VERSION.flight_custom_version_.item_len) return false;
                    for(int i = 0; i < AUTOPILOT_VERSION.flight_custom_version_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(flight_custom_version_ other)
                {
                    if(other.len() != AUTOPILOT_VERSION.flight_custom_version_.item_len) return false;
                    for(int i = 0; i < AUTOPILOT_VERSION.flight_custom_version_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 28 + index] = (byte)(src); }

                public const int item_len = 8 ;


            }

            public void flight_custom_version(sbyte[] src)
            {
                var len =  Math.Min(src.Length, AUTOPILOT_VERSION.flight_custom_version_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 28 + index] = (byte)(src[index]);
            }

            public middleware_custom_version_ middleware_custom_version()
            {
                return new  middleware_custom_version_(data_);
            }

            public struct middleware_custom_version_
            {
                internal Pack.Cursor data_;
                public middleware_custom_version_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return AUTOPILOT_VERSION.middleware_custom_version_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 36 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != AUTOPILOT_VERSION.middleware_custom_version_.item_len) return false;
                    for(int i = 0; i < AUTOPILOT_VERSION.middleware_custom_version_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(middleware_custom_version_ other)
                {
                    if(other.len() != AUTOPILOT_VERSION.middleware_custom_version_.item_len) return false;
                    for(int i = 0; i < AUTOPILOT_VERSION.middleware_custom_version_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 36 + index] = (byte)(src); }

                public const int item_len = 8 ;


            }

            public void middleware_custom_version(sbyte[] src)
            {
                var len =  Math.Min(src.Length, AUTOPILOT_VERSION.middleware_custom_version_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 36 + index] = (byte)(src[index]);
            }

            public os_custom_version_ os_custom_version()
            {
                return new  os_custom_version_(data_);
            }

            public struct os_custom_version_
            {
                internal Pack.Cursor data_;
                public os_custom_version_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return AUTOPILOT_VERSION.os_custom_version_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 44 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != AUTOPILOT_VERSION.os_custom_version_.item_len) return false;
                    for(int i = 0; i < AUTOPILOT_VERSION.os_custom_version_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(os_custom_version_ other)
                {
                    if(other.len() != AUTOPILOT_VERSION.os_custom_version_.item_len) return false;
                    for(int i = 0; i < AUTOPILOT_VERSION.os_custom_version_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 44 + index] = (byte)(src); }

                public const int item_len = 8 ;


            }

            public void os_custom_version(sbyte[] src)
            {
                var len =  Math.Min(src.Length, AUTOPILOT_VERSION.os_custom_version_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 44 + index] = (byte)(src[index]);
            }


            public  MAV_PROTOCOL_CAPABILITY? capabilities()
            {
                if(data_.field_bit !=  419 && !data_.set_field(419, -1))  return null;
                return    MAV_PROTOCOL_CAPABILITY_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 5));;
            }


            public void capabilities(MAV_PROTOCOL_CAPABILITY src)
            {
                if(data_.field_bit !=  419) data_.set_field(419, 0);
                ;
                Lib.set_bits(MAV_PROTOCOL_CAPABILITY_.bits(src), 5, data_.bytes, data_.BIT) ;;
            }





            public void uid2(sbyte src, int d0)
            {
                if(data_.field_bit !=  420) data_.set_field(420, 0);
                data_.set_item(d0, 0) ;
                data_.bytes[data_.BYTE] = (byte)(src);;
            }


            public uid2_ ? uid2() { return (data_.field_bit ==  420 || data_.set_field(420, -1)) ? new uid2_(data_) : (uid2_ ?)null ;}

            public struct uid2_
            {
                internal Pack.Cursor data_;
                internal uid2_(Pack.Cursor data) { this.data_ = data; }


                public void enumerate(Action<sbyte /*item*/, int /*d0*/> dst)
                {
                    for(int d0 = 0; d0 < AUTOPILOT_VERSION.uid2_.d0; d0++)
                        if(data_.set_item(d0, -1)) dst((sbyte)(data_.bytes[data_.BYTE]), d0);
                }


                public sbyte? get(int d0)
                {
                    if(!data_.set_item(d0, -1))  return null;
                    return (sbyte)(data_.bytes[data_.BYTE]);;
                }



                public const int d0 = 18 ;

            }



            public interface DST_
            {
                void capabilities(com.company.demo.GroundControl. MAV_PROTOCOL_CAPABILITY src);
                void flight_sw_version(int src);
                void middleware_sw_version(int src);
                void os_sw_version(int src);
                void board_version(int src);
                void flight_custom_version(AUTOPILOT_VERSION.flight_custom_version_ src);
                void middleware_custom_version(AUTOPILOT_VERSION.middleware_custom_version_ src);
                void os_custom_version(AUTOPILOT_VERSION.os_custom_version_ src);
                void vendor_id(short src);
                void product_id(short src);
                void uid(long src);
                void uid2(sbyte src, int d0);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(60, 2, 4, 1, 53, 1, 419, 3, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = capabilities();
                    if(item.HasValue) dst.capabilities(item.Value);
                }
                dst.flight_sw_version(flight_sw_version()) ;
                dst.middleware_sw_version(middleware_sw_version()) ;
                dst.os_sw_version(os_sw_version()) ;
                dst.board_version(board_version()) ;
                dst.flight_custom_version(flight_custom_version());
                dst.middleware_custom_version(middleware_custom_version());
                dst.os_custom_version(os_custom_version());
                dst.vendor_id(vendor_id()) ;
                dst.product_id(product_id()) ;
                dst.uid(uid()) ;
                {
                    var _fld = uid2();
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        for(int d0 = 0; d0 < AUTOPILOT_VERSION.uid2_.d0; d0++)
                        {
                            var item = fld.get(d0);
                            if(item.HasValue) dst.uid2(item.Value, d0);
                        }
                    }
                }
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. MAV_PROTOCOL_CAPABILITY?  capabilities();
                int flight_sw_version();
                int middleware_sw_version();
                int os_sw_version();
                int board_version();
                void flight_custom_version(AUTOPILOT_VERSION.flight_custom_version_ dst) ;
                void middleware_custom_version(AUTOPILOT_VERSION.middleware_custom_version_ dst) ;
                void os_custom_version(AUTOPILOT_VERSION.os_custom_version_ dst) ;
                short vendor_id();
                short product_id();
                long uid();
                bool uid2_exist();
                sbyte?  uid2(int d0);

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.capabilities();
                    if(item.HasValue)     capabilities(item.Value);
                }
                flight_sw_version(src.flight_sw_version());
                middleware_sw_version(src.middleware_sw_version());
                os_sw_version(src.os_sw_version());
                board_version(src.board_version());
                src.flight_custom_version(flight_custom_version());
                src.middleware_custom_version(middleware_custom_version());
                src.os_custom_version(os_custom_version());
                vendor_id(src.vendor_id());
                product_id(src.product_id());
                uid(src.uid());
                if(src.uid2_exist())
                    for(int d0 = 0; d0 < AUTOPILOT_VERSION.uid2_.d0; d0++)
                    {
                        var item = src.uid2(d0);
                        if(item.HasValue) uid2(item.Value, d0);
                    }
            }



        }
        /**
        *The location of a landing area captured from a downward facing camera */

        public struct LANDING_TARGET
        {
            internal Pack.Cursor data_;
            internal LANDING_TARGET(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                frame = 235,
                x = 236,
                y = 237,
                z = 238,
                q = 239,
                typE = 240,
                position_valid = 241
            }



            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public sbyte target_num() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void target_num(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }

            public float angle_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 9); }
            public void angle_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 9, 4);  }

            public float angle_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 13); }
            public void angle_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 13, 4);  }

            public float distance() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 17); }
            public void distance(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 17, 4);  }

            public float size_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 21); }
            public void size_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 21, 4);  }

            public float size_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 25); }
            public void size_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 25, 4);  }


            public  MAV_FRAME? frame()
            {
                if(data_.field_bit !=  235 && !data_.set_field(235, -1))  return null;
                return (MAV_FRAME)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }


            public void frame(MAV_FRAME src)
            {
                if(data_.field_bit !=  235) data_.set_field(235, 0);
                ;
                Lib.set_bits((ulong)(src), 4, data_.bytes, data_.BIT);;
            }




            public float? x()
            {
                if(data_.field_bit !=  236 && !data_.set_field(236, -1))  return null;
                return   BitConverter.ToSingle(data_.bytes, data_.BYTE);;
            }


            public void x(float src)
            {
                if(data_.field_bit !=  236) data_.set_field(236, 0);
                ;
                Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.BYTE, 4);;
            }




            public float? y()
            {
                if(data_.field_bit !=  237 && !data_.set_field(237, -1))  return null;
                return   BitConverter.ToSingle(data_.bytes, data_.BYTE);;
            }


            public void y(float src)
            {
                if(data_.field_bit !=  237) data_.set_field(237, 0);
                ;
                Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.BYTE, 4);;
            }




            public float? z()
            {
                if(data_.field_bit !=  238 && !data_.set_field(238, -1))  return null;
                return   BitConverter.ToSingle(data_.bytes, data_.BYTE);;
            }


            public void z(float src)
            {
                if(data_.field_bit !=  238) data_.set_field(238, 0);
                ;
                Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.BYTE, 4);;
            }





            public void q(float src, int d0)
            {
                if(data_.field_bit !=  239) data_.set_field(239, 0);
                data_.set_item(d0, 0) ;
                Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.BYTE, 4);;
            }


            public q_ ? q() { return (data_.field_bit ==  239 || data_.set_field(239, -1)) ? new q_(data_) : (q_ ?)null ;}

            public struct q_
            {
                internal Pack.Cursor data_;
                internal q_(Pack.Cursor data) { this.data_ = data; }


                public void enumerate(Action<float /*item*/, int /*d0*/> dst)
                {
                    for(int d0 = 0; d0 < LANDING_TARGET.q_.d0; d0++)
                        if(data_.set_item(d0, -1)) dst(BitConverter.ToSingle(data_.bytes, data_.BYTE), d0);
                }


                public float? get(int d0)
                {
                    if(!data_.set_item(d0, -1))  return null;
                    return   BitConverter.ToSingle(data_.bytes, data_.BYTE);;
                }



                public const int d0 = 4 ;

            }


            public  LANDING_TARGET_TYPE? typE()
            {
                if(data_.field_bit !=  240 && !data_.set_field(240, -1))  return null;
                return (LANDING_TARGET_TYPE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 2)));;
            }


            public void typE(LANDING_TARGET_TYPE src)
            {
                if(data_.field_bit !=  240) data_.set_field(240, 0);
                ;
                Lib.set_bits((ulong)(src), 2, data_.bytes, data_.BIT);;
            }




            public sbyte? position_valid()
            {
                if(data_.field_bit !=  241 && !data_.set_field(241, -1))  return null;
                return (sbyte)(data_.bytes[data_.BYTE]);;
            }


            public void position_valid(sbyte src)
            {
                if(data_.field_bit !=  241) data_.set_field(241, 0);
                ;
                data_.bytes[data_.BYTE] = (byte)(src);;
            }





            public interface DST_
            {
                void time_usec(long src);
                void target_num(sbyte src);
                void frame(com.company.demo.GroundControl. MAV_FRAME src);
                void angle_x(float src);
                void angle_y(float src);
                void distance(float src);
                void size_x(float src);
                void size_y(float src);
                void x(float src);
                void y(float src);
                void z(float src);
                void q(float src, int d0);
                void typE(com.company.demo.GroundControl. LANDING_TARGET_TYPE src);
                void position_valid(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(172, 0, 0, 1, 30, 1, 235, 3, 0, 7);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.target_num(target_num()) ;
                {
                    var item = frame();
                    if(item.HasValue) dst.frame(item.Value);
                }
                dst.angle_x(angle_x()) ;
                dst.angle_y(angle_y()) ;
                dst.distance(distance()) ;
                dst.size_x(size_x()) ;
                dst.size_y(size_y()) ;
                {
                    var item = x();
                    if(item.HasValue) dst.x(item.Value);
                }
                {
                    var item = y();
                    if(item.HasValue) dst.y(item.Value);
                }
                {
                    var item = z();
                    if(item.HasValue) dst.z(item.Value);
                }
                {
                    var _fld = q();
                    if(_fld.HasValue)
                    {
                        var fld = _fld.Value;
                        for(int d0 = 0; d0 < LANDING_TARGET.q_.d0; d0++)
                        {
                            var item = fld.get(d0);
                            if(item.HasValue) dst.q(item.Value, d0);
                        }
                    }
                }
                {
                    var item = typE();
                    if(item.HasValue) dst.typE(item.Value);
                }
                {
                    var item = position_valid();
                    if(item.HasValue) dst.position_valid(item.Value);
                }
            }

            public interface SRC_
            {
                long time_usec();
                sbyte target_num();
                com.company.demo.GroundControl. MAV_FRAME?  frame();
                float angle_x();
                float angle_y();
                float distance();
                float size_x();
                float size_y();
                float?  x();
                float?  y();
                float?  z();
                bool q_exist();
                float?  q(int d0);
                com.company.demo.GroundControl. LANDING_TARGET_TYPE?  typE();
                sbyte?  position_valid();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                target_num(src.target_num());
                {
                    var item = src.frame();
                    if(item.HasValue)     frame(item.Value);
                }
                angle_x(src.angle_x());
                angle_y(src.angle_y());
                distance(src.distance());
                size_x(src.size_x());
                size_y(src.size_y());
                {
                    var item = src.x();
                    if(item.HasValue)     x(item.Value);
                }
                {
                    var item = src.y();
                    if(item.HasValue)     y(item.Value);
                }
                {
                    var item = src.z();
                    if(item.HasValue)     z(item.Value);
                }
                if(src.q_exist())
                    for(int d0 = 0; d0 < LANDING_TARGET.q_.d0; d0++)
                    {
                        var item = src.q(d0);
                        if(item.HasValue) q(item.Value, d0);
                    }
                {
                    var item = src.typE();
                    if(item.HasValue)     typE(item.Value);
                }
                {
                    var item = src.position_valid();
                    if(item.HasValue)     position_valid(item.Value);
                }
            }



        }
        /**
        *Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message
        *				 is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS
        *				 enum definition for further information. The innovaton test ratios show the magnitude of the sensor innovation
        *				 divided by the innovation check threshold. Under normal operation the innovaton test ratios should be
        *				 below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation
        *				 and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation
        *				 test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should
        *				 be optional and controllable by the user */

        public struct ESTIMATOR_STATUS
        {
            internal Pack.Cursor data_;
            internal ESTIMATOR_STATUS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                flags = 320
            }



            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public float vel_ratio() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void vel_ratio(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float pos_horiz_ratio() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void pos_horiz_ratio(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float pos_vert_ratio() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void pos_vert_ratio(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float mag_ratio() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void mag_ratio(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float hagl_ratio() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void hagl_ratio(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float tas_ratio() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void tas_ratio(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float pos_horiz_accuracy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void pos_horiz_accuracy(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public float pos_vert_accuracy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }
            public void pos_vert_accuracy(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 36, 4);  }


            public  ESTIMATOR_STATUS_FLAGS? flags()
            {
                if(data_.field_bit !=  320 && !data_.set_field(320, -1))  return null;
                return    ESTIMATOR_STATUS_FLAGS_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 4));;
            }


            public void flags(ESTIMATOR_STATUS_FLAGS src)
            {
                if(data_.field_bit !=  320) data_.set_field(320, 0);
                ;
                Lib.set_bits(ESTIMATOR_STATUS_FLAGS_.bits(src), 4, data_.bytes, data_.BIT) ;;
            }





            public interface DST_
            {
                void time_usec(long src);
                void flags(com.company.demo.GroundControl. ESTIMATOR_STATUS_FLAGS src);
                void vel_ratio(float src);
                void pos_horiz_ratio(float src);
                void pos_vert_ratio(float src);
                void mag_ratio(float src);
                void hagl_ratio(float src);
                void tas_ratio(float src);
                void pos_horiz_accuracy(float src);
                void pos_vert_accuracy(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(38, 0, 0, 1, 41, 1, 320, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                {
                    var item = flags();
                    if(item.HasValue) dst.flags(item.Value);
                }
                dst.vel_ratio(vel_ratio()) ;
                dst.pos_horiz_ratio(pos_horiz_ratio()) ;
                dst.pos_vert_ratio(pos_vert_ratio()) ;
                dst.mag_ratio(mag_ratio()) ;
                dst.hagl_ratio(hagl_ratio()) ;
                dst.tas_ratio(tas_ratio()) ;
                dst.pos_horiz_accuracy(pos_horiz_accuracy()) ;
                dst.pos_vert_accuracy(pos_vert_accuracy()) ;
            }

            public interface SRC_
            {
                long time_usec();
                com.company.demo.GroundControl. ESTIMATOR_STATUS_FLAGS?  flags();
                float vel_ratio();
                float pos_horiz_ratio();
                float pos_vert_ratio();
                float mag_ratio();
                float hagl_ratio();
                float tas_ratio();
                float pos_horiz_accuracy();
                float pos_vert_accuracy();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                {
                    var item = src.flags();
                    if(item.HasValue)     flags(item.Value);
                }
                vel_ratio(src.vel_ratio());
                pos_horiz_ratio(src.pos_horiz_ratio());
                pos_vert_ratio(src.pos_vert_ratio());
                mag_ratio(src.mag_ratio());
                hagl_ratio(src.hagl_ratio());
                tas_ratio(src.tas_ratio());
                pos_horiz_accuracy(src.pos_horiz_accuracy());
                pos_vert_accuracy(src.pos_vert_accuracy());
            }



        }

        public struct WIND_COV
        {
            internal Pack.Cursor data_;
            internal WIND_COV(Pack.Cursor data) { this.data_ = data; }




            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public float wind_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void wind_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float wind_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void wind_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float wind_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void wind_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float var_horiz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void var_horiz(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float var_vert() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void var_vert(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float wind_alt() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void wind_alt(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float horiz_accuracy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void horiz_accuracy(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public float vert_accuracy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }
            public void vert_accuracy(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 36, 4);  }



            public interface DST_
            {
                void time_usec(long src);
                void wind_x(float src);
                void wind_y(float src);
                void wind_z(float src);
                void var_horiz(float src);
                void var_vert(float src);
                void wind_alt(float src);
                void horiz_accuracy(float src);
                void vert_accuracy(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(160, 0, 0, 1, 40, 1, 320);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.wind_x(wind_x()) ;
                dst.wind_y(wind_y()) ;
                dst.wind_z(wind_z()) ;
                dst.var_horiz(var_horiz()) ;
                dst.var_vert(var_vert()) ;
                dst.wind_alt(wind_alt()) ;
                dst.horiz_accuracy(horiz_accuracy()) ;
                dst.vert_accuracy(vert_accuracy()) ;
            }

            public interface SRC_
            {
                long time_usec();
                float wind_x();
                float wind_y();
                float wind_z();
                float var_horiz();
                float var_vert();
                float wind_alt();
                float horiz_accuracy();
                float vert_accuracy();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                wind_x(src.wind_x());
                wind_y(src.wind_y());
                wind_z(src.wind_z());
                var_horiz(src.var_horiz());
                var_vert(src.var_vert());
                wind_alt(src.wind_alt());
                horiz_accuracy(src.horiz_accuracy());
                vert_accuracy(src.vert_accuracy());
            }



        }
        /**
        *GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position
        *				 estimate of the sytem */

        public struct GPS_INPUT
        {
            internal Pack.Cursor data_;
            internal GPS_INPUT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                ignore_flags = 488
            }



            public short time_week() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void time_week(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int time_week_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void time_week_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 6);  }

            public sbyte gps_id() { return (sbyte)(data_.bytes[data_.origin  + 14]); }
            public void gps_id(sbyte src) {    data_.bytes[data_.origin  + 14] = (byte)(src);  }

            public sbyte fix_type() { return (sbyte)(data_.bytes[data_.origin  + 15]); }
            public void fix_type(sbyte src) {    data_.bytes[data_.origin  + 15] = (byte)(src);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 16);  }

            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 4)); }
            public void lon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 20);  }

            public float alt() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void alt(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float hdop() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void hdop(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float vdop() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void vdop(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public float vn() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }
            public void vn(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 36, 4);  }

            public float ve() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }
            public void ve(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 40, 4);  }

            public float vd() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 44); }
            public void vd(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 44, 4);  }

            public float speed_accuracy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 48); }
            public void speed_accuracy(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 48, 4);  }

            public float horiz_accuracy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 52); }
            public void horiz_accuracy(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 52, 4);  }

            public float vert_accuracy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 56); }
            public void vert_accuracy(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 56, 4);  }

            public sbyte satellites_visible() { return (sbyte)(data_.bytes[data_.origin  + 60]); }
            public void satellites_visible(sbyte src) {    data_.bytes[data_.origin  + 60] = (byte)(src);  }


            public  GPS_INPUT_IGNORE_FLAGS? ignore_flags()
            {
                if(data_.field_bit !=  488 && !data_.set_field(488, -1))  return null;
                return    GPS_INPUT_IGNORE_FLAGS_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 4));;
            }


            public void ignore_flags(GPS_INPUT_IGNORE_FLAGS src)
            {
                if(data_.field_bit !=  488) data_.set_field(488, 0);
                ;
                Lib.set_bits(GPS_INPUT_IGNORE_FLAGS_.bits(src), 4, data_.bytes, data_.BIT) ;;
            }





            public interface DST_
            {
                void time_usec(long src);
                void gps_id(sbyte src);
                void ignore_flags(com.company.demo.GroundControl. GPS_INPUT_IGNORE_FLAGS src);
                void time_week_ms(int src);
                void time_week(short src);
                void fix_type(sbyte src);
                void lat(int src);
                void lon(int src);
                void alt(float src);
                void hdop(float src);
                void vdop(float src);
                void vn(float src);
                void ve(float src);
                void vd(float src);
                void speed_accuracy(float src);
                void horiz_accuracy(float src);
                void vert_accuracy(float src);
                void satellites_visible(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(73, 1, 1, 1, 62, 1, 488, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.gps_id(gps_id()) ;
                {
                    var item = ignore_flags();
                    if(item.HasValue) dst.ignore_flags(item.Value);
                }
                dst.time_week_ms(time_week_ms()) ;
                dst.time_week(time_week()) ;
                dst.fix_type(fix_type()) ;
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.alt(alt()) ;
                dst.hdop(hdop()) ;
                dst.vdop(vdop()) ;
                dst.vn(vn()) ;
                dst.ve(ve()) ;
                dst.vd(vd()) ;
                dst.speed_accuracy(speed_accuracy()) ;
                dst.horiz_accuracy(horiz_accuracy()) ;
                dst.vert_accuracy(vert_accuracy()) ;
                dst.satellites_visible(satellites_visible()) ;
            }

            public interface SRC_
            {
                long time_usec();
                sbyte gps_id();
                com.company.demo.GroundControl. GPS_INPUT_IGNORE_FLAGS?  ignore_flags();
                int time_week_ms();
                short time_week();
                sbyte fix_type();
                int lat();
                int lon();
                float alt();
                float hdop();
                float vdop();
                float vn();
                float ve();
                float vd();
                float speed_accuracy();
                float horiz_accuracy();
                float vert_accuracy();
                sbyte satellites_visible();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                gps_id(src.gps_id());
                {
                    var item = src.ignore_flags();
                    if(item.HasValue)     ignore_flags(item.Value);
                }
                time_week_ms(src.time_week_ms());
                time_week(src.time_week());
                fix_type(src.fix_type());
                lat(src.lat());
                lon(src.lon());
                alt(src.alt());
                hdop(src.hdop());
                vdop(src.vdop());
                vn(src.vn());
                ve(src.ve());
                vd(src.vd());
                speed_accuracy(src.speed_accuracy());
                horiz_accuracy(src.horiz_accuracy());
                vert_accuracy(src.vert_accuracy());
                satellites_visible(src.satellites_visible());
            }



        }
        /**
        *RTCM message for injecting into the onboard GPS (used for DGPS) */

        public struct GPS_RTCM_DATA
        {
            internal Pack.Cursor data_;
            internal GPS_RTCM_DATA(Pack.Cursor data) { this.data_ = data; }




            public sbyte flags() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void flags(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte len() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void len(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return GPS_RTCM_DATA.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 2 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != GPS_RTCM_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < GPS_RTCM_DATA.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != GPS_RTCM_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < GPS_RTCM_DATA.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 2 + index] = (byte)(src); }

                public const int item_len = 180 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, GPS_RTCM_DATA.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 2 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void flags(sbyte src);
                void len(sbyte src);
                void daTa(GPS_RTCM_DATA.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(88, 0, 0, 0, 182, 1, 1456);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.flags(flags()) ;
                dst.len(len()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                sbyte flags();
                sbyte len();
                void daTa(GPS_RTCM_DATA.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                flags(src.flags());
                len(src.len());
                src.daTa(daTa());
            }



        }
        /**
        *Message appropriate for high latency connections like Iridium */

        public struct HIGH_LATENCY
        {
            internal Pack.Cursor data_;
            internal HIGH_LATENCY(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                base_mode = 298,
                landed_state = 299,
                gps_fix_type = 300
            }



            public short heading() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void heading(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short wp_distance() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void wp_distance(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public int custom_mode() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }
            public void custom_mode(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 4);  }

            public short roll() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }
            public void roll(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 8);  }

            public short pitch() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }
            public void pitch(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 10);  }

            public sbyte throttle() { return (sbyte)(data_.bytes[data_.origin  + 12]); }
            public void throttle(sbyte src) {    data_.bytes[data_.origin  + 12] = (byte)(src);  }

            public short heading_sp() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 13, 2)); }
            public void heading_sp(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 13);  }

            public int latitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 15, 4)); }
            public void latitude(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 15);  }

            public int longitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 19, 4)); }
            public void longitude(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 19);  }

            public short altitude_amsl() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 23, 2)); }
            public void altitude_amsl(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 23);  }

            public short altitude_sp() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 25, 2)); }
            public void altitude_sp(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 25);  }

            public sbyte airspeed() { return (sbyte)(data_.bytes[data_.origin  + 27]); }
            public void airspeed(sbyte src) {    data_.bytes[data_.origin  + 27] = (byte)(src);  }

            public sbyte airspeed_sp() { return (sbyte)(data_.bytes[data_.origin  + 28]); }
            public void airspeed_sp(sbyte src) {    data_.bytes[data_.origin  + 28] = (byte)(src);  }

            public sbyte groundspeed() { return (sbyte)(data_.bytes[data_.origin  + 29]); }
            public void groundspeed(sbyte src) {    data_.bytes[data_.origin  + 29] = (byte)(src);  }

            public sbyte climb_rate() { return (sbyte)(data_.bytes[data_.origin  + 30]); }
            public void climb_rate(sbyte src) {    data_.bytes[data_.origin  + 30] = (byte)(src);  }

            public sbyte gps_nsat() { return (sbyte)(data_.bytes[data_.origin  + 31]); }
            public void gps_nsat(sbyte src) {    data_.bytes[data_.origin  + 31] = (byte)(src);  }

            public sbyte battery_remaining() { return (sbyte)(data_.bytes[data_.origin  + 32]); }
            public void battery_remaining(sbyte src) {    data_.bytes[data_.origin  + 32] = (byte)(src);  }

            public sbyte temperature() { return (sbyte)(data_.bytes[data_.origin  + 33]); }
            public void temperature(sbyte src) {    data_.bytes[data_.origin  + 33] = (byte)(src);  }

            public sbyte temperature_air() { return (sbyte)(data_.bytes[data_.origin  + 34]); }
            public void temperature_air(sbyte src) {    data_.bytes[data_.origin  + 34] = (byte)(src);  }

            public sbyte failsafe() { return (sbyte)(data_.bytes[data_.origin  + 35]); }
            public void failsafe(sbyte src) {    data_.bytes[data_.origin  + 35] = (byte)(src);  }

            public sbyte wp_num() { return (sbyte)(data_.bytes[data_.origin  + 36]); }
            public void wp_num(sbyte src) {    data_.bytes[data_.origin  + 36] = (byte)(src);  }


            public  MAV_MODE_FLAG? base_mode()
            {
                if(data_.field_bit !=  298 && !data_.set_field(298, -1))  return null;
                return    MAV_MODE_FLAG_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 4));;
            }


            public void base_mode(MAV_MODE_FLAG src)
            {
                if(data_.field_bit !=  298) data_.set_field(298, 0);
                ;
                Lib.set_bits(MAV_MODE_FLAG_.bits(src), 4, data_.bytes, data_.BIT) ;;
            }




            public  MAV_LANDED_STATE? landed_state()
            {
                if(data_.field_bit !=  299 && !data_.set_field(299, -1))  return null;
                return (MAV_LANDED_STATE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void landed_state(MAV_LANDED_STATE src)
            {
                if(data_.field_bit !=  299) data_.set_field(299, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }




            public  GPS_FIX_TYPE? gps_fix_type()
            {
                if(data_.field_bit !=  300 && !data_.set_field(300, -1))  return null;
                return (GPS_FIX_TYPE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }


            public void gps_fix_type(GPS_FIX_TYPE src)
            {
                if(data_.field_bit !=  300) data_.set_field(300, 0);
                ;
                Lib.set_bits((ulong)(src), 4, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void base_mode(com.company.demo.GroundControl. MAV_MODE_FLAG src);
                void custom_mode(int src);
                void landed_state(com.company.demo.GroundControl. MAV_LANDED_STATE src);
                void roll(short src);
                void pitch(short src);
                void heading(short src);
                void throttle(sbyte src);
                void heading_sp(short src);
                void latitude(int src);
                void longitude(int src);
                void altitude_amsl(short src);
                void altitude_sp(short src);
                void airspeed(sbyte src);
                void airspeed_sp(sbyte src);
                void groundspeed(sbyte src);
                void climb_rate(sbyte src);
                void gps_nsat(sbyte src);
                void gps_fix_type(com.company.demo.GroundControl. GPS_FIX_TYPE src);
                void battery_remaining(sbyte src);
                void temperature(sbyte src);
                void temperature_air(sbyte src);
                void failsafe(sbyte src);
                void wp_num(sbyte src);
                void wp_distance(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(87, 2, 1, 0, 38, 1, 298, 2, 0, 3);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = base_mode();
                    if(item.HasValue) dst.base_mode(item.Value);
                }
                dst.custom_mode(custom_mode()) ;
                {
                    var item = landed_state();
                    if(item.HasValue) dst.landed_state(item.Value);
                }
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.heading(heading()) ;
                dst.throttle(throttle()) ;
                dst.heading_sp(heading_sp()) ;
                dst.latitude(latitude()) ;
                dst.longitude(longitude()) ;
                dst.altitude_amsl(altitude_amsl()) ;
                dst.altitude_sp(altitude_sp()) ;
                dst.airspeed(airspeed()) ;
                dst.airspeed_sp(airspeed_sp()) ;
                dst.groundspeed(groundspeed()) ;
                dst.climb_rate(climb_rate()) ;
                dst.gps_nsat(gps_nsat()) ;
                {
                    var item = gps_fix_type();
                    if(item.HasValue) dst.gps_fix_type(item.Value);
                }
                dst.battery_remaining(battery_remaining()) ;
                dst.temperature(temperature()) ;
                dst.temperature_air(temperature_air()) ;
                dst.failsafe(failsafe()) ;
                dst.wp_num(wp_num()) ;
                dst.wp_distance(wp_distance()) ;
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. MAV_MODE_FLAG?  base_mode();
                int custom_mode();
                com.company.demo.GroundControl. MAV_LANDED_STATE?  landed_state();
                short roll();
                short pitch();
                short heading();
                sbyte throttle();
                short heading_sp();
                int latitude();
                int longitude();
                short altitude_amsl();
                short altitude_sp();
                sbyte airspeed();
                sbyte airspeed_sp();
                sbyte groundspeed();
                sbyte climb_rate();
                sbyte gps_nsat();
                com.company.demo.GroundControl. GPS_FIX_TYPE?  gps_fix_type();
                sbyte battery_remaining();
                sbyte temperature();
                sbyte temperature_air();
                sbyte failsafe();
                sbyte wp_num();
                short wp_distance();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.base_mode();
                    if(item.HasValue)     base_mode(item.Value);
                }
                custom_mode(src.custom_mode());
                {
                    var item = src.landed_state();
                    if(item.HasValue)     landed_state(item.Value);
                }
                roll(src.roll());
                pitch(src.pitch());
                heading(src.heading());
                throttle(src.throttle());
                heading_sp(src.heading_sp());
                latitude(src.latitude());
                longitude(src.longitude());
                altitude_amsl(src.altitude_amsl());
                altitude_sp(src.altitude_sp());
                airspeed(src.airspeed());
                airspeed_sp(src.airspeed_sp());
                groundspeed(src.groundspeed());
                climb_rate(src.climb_rate());
                gps_nsat(src.gps_nsat());
                {
                    var item = src.gps_fix_type();
                    if(item.HasValue)     gps_fix_type(item.Value);
                }
                battery_remaining(src.battery_remaining());
                temperature(src.temperature());
                temperature_air(src.temperature_air());
                failsafe(src.failsafe());
                wp_num(src.wp_num());
                wp_distance(src.wp_distance());
            }



        }
        /**
        *Vibration levels and accelerometer clipping */

        public struct VIBRATION
        {
            internal Pack.Cursor data_;
            internal VIBRATION(Pack.Cursor data) { this.data_ = data; }




            public int clipping_0() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void clipping_0(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public int clipping_1() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }
            public void clipping_1(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 4);  }

            public int clipping_2() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 4)); }
            public void clipping_2(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 8);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 12);  }

            public float vibration_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void vibration_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float vibration_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void vibration_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float vibration_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void vibration_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }



            public interface DST_
            {
                void time_usec(long src);
                void vibration_x(float src);
                void vibration_y(float src);
                void vibration_z(float src);
                void clipping_0(int src);
                void clipping_1(int src);
                void clipping_2(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(103, 0, 3, 1, 32, 1, 256);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.vibration_x(vibration_x()) ;
                dst.vibration_y(vibration_y()) ;
                dst.vibration_z(vibration_z()) ;
                dst.clipping_0(clipping_0()) ;
                dst.clipping_1(clipping_1()) ;
                dst.clipping_2(clipping_2()) ;
            }

            public interface SRC_
            {
                long time_usec();
                float vibration_x();
                float vibration_y();
                float vibration_z();
                int clipping_0();
                int clipping_1();
                int clipping_2();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                vibration_x(src.vibration_x());
                vibration_y(src.vibration_y());
                vibration_z(src.vibration_z());
                clipping_0(src.clipping_0());
                clipping_1(src.clipping_1());
                clipping_2(src.clipping_2());
            }



        }
        /**
        *This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system
        *				 will return to and land on. The position is set automatically by the system during the takeoff in case
        *				 it was not explicitely set by the operator before or after. The position the system will return to and
        *				 land on. The global and local positions encode the position in the respective coordinate frames, while
        *				 the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading
        *				 and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes
        *				 the point to which the system should fly in normal flight mode and then perform a landing sequence along
        *				 the vector */

        public struct HOME_POSITION
        {
            internal Pack.Cursor data_;
            internal HOME_POSITION(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                time_usec = 416
            }



            public int latitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void latitude(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public int longitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }
            public void longitude(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 4);  }

            public int altitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 4)); }
            public void altitude(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 8);  }

            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public q_ q()
            {
                return new  q_(data_);
            }

            public struct q_
            {
                internal Pack.Cursor data_;
                public q_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return HOME_POSITION.q_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != HOME_POSITION.q_.item_len) return false;
                    for(int i = 0; i < HOME_POSITION.q_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(q_ other)
                {
                    if(other.len() != HOME_POSITION.q_.item_len) return false;
                    for(int i = 0; i < HOME_POSITION.q_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24 + index * 4, 4); }

                public const int item_len = 4 ;


            }

            public void q(float[] src)
            {
                var len =  Math.Min(src.Length, HOME_POSITION.q_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 24 + index * 4, 4);
            }

            public float approach_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }
            public void approach_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 40, 4);  }

            public float approach_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 44); }
            public void approach_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 44, 4);  }

            public float approach_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 48); }
            public void approach_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 48, 4);  }


            public long? time_usec()
            {
                if(data_.field_bit !=  416 && !data_.set_field(416, -1))  return null;
                return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.BYTE, 8));;
            }


            public void time_usec(long src)
            {
                if(data_.field_bit !=  416) data_.set_field(416, 0);
                ;
                Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.BYTE);;
            }





            public interface DST_
            {
                void latitude(int src);
                void longitude(int src);
                void altitude(int src);
                void x(float src);
                void y(float src);
                void z(float src);
                void q(HOME_POSITION.q_ src);
                void approach_x(float src);
                void approach_y(float src);
                void approach_z(float src);
                void time_usec(long src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(210, 0, 0, 0, 53, 1, 416, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.latitude(latitude()) ;
                dst.longitude(longitude()) ;
                dst.altitude(altitude()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                dst.q(q());
                dst.approach_x(approach_x()) ;
                dst.approach_y(approach_y()) ;
                dst.approach_z(approach_z()) ;
                {
                    var item = time_usec();
                    if(item.HasValue) dst.time_usec(item.Value);
                }
            }

            public interface SRC_
            {
                int latitude();
                int longitude();
                int altitude();
                float x();
                float y();
                float z();
                void q(HOME_POSITION.q_ dst) ;
                float approach_x();
                float approach_y();
                float approach_z();
                long?  time_usec();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                latitude(src.latitude());
                longitude(src.longitude());
                altitude(src.altitude());
                x(src.x());
                y(src.y());
                z(src.z());
                src.q(q());
                approach_x(src.approach_x());
                approach_y(src.approach_y());
                approach_z(src.approach_z());
                {
                    var item = src.time_usec();
                    if(item.HasValue)     time_usec(item.Value);
                }
            }



        }
        /**
        *The position the system will return to and land on. The position is set automatically by the system during
        *				 the takeoff in case it was not explicitely set by the operator before or after. The global and local
        *				 positions encode the position in the respective coordinate frames, while the q parameter encodes the
        *				 orientation of the surface. Under normal conditions it describes the heading and terrain slope, which
        *				 can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which
        *				 the system should fly in normal flight mode and then perform a landing sequence along the vector */

        public struct SET_HOME_POSITION
        {
            internal Pack.Cursor data_;
            internal SET_HOME_POSITION(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                time_usec = 424
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public int latitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 1, 4)); }
            public void latitude(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 1);  }

            public int longitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 5, 4)); }
            public void longitude(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 5);  }

            public int altitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 9, 4)); }
            public void altitude(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 9);  }

            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 13); }
            public void x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 13, 4);  }

            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 17); }
            public void y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 17, 4);  }

            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 21); }
            public void z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 21, 4);  }

            public q_ q()
            {
                return new  q_(data_);
            }

            public struct q_
            {
                internal Pack.Cursor data_;
                public q_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return SET_HOME_POSITION.q_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 25 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != SET_HOME_POSITION.q_.item_len) return false;
                    for(int i = 0; i < SET_HOME_POSITION.q_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(q_ other)
                {
                    if(other.len() != SET_HOME_POSITION.q_.item_len) return false;
                    for(int i = 0; i < SET_HOME_POSITION.q_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 25 + index * 4, 4); }

                public const int item_len = 4 ;


            }

            public void q(float[] src)
            {
                var len =  Math.Min(src.Length, SET_HOME_POSITION.q_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 25 + index * 4, 4);
            }

            public float approach_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 41); }
            public void approach_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 41, 4);  }

            public float approach_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 45); }
            public void approach_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 45, 4);  }

            public float approach_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 49); }
            public void approach_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 49, 4);  }


            public long? time_usec()
            {
                if(data_.field_bit !=  424 && !data_.set_field(424, -1))  return null;
                return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.BYTE, 8));;
            }


            public void time_usec(long src)
            {
                if(data_.field_bit !=  424) data_.set_field(424, 0);
                ;
                Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.BYTE);;
            }





            public interface DST_
            {
                void target_system(sbyte src);
                void latitude(int src);
                void longitude(int src);
                void altitude(int src);
                void x(float src);
                void y(float src);
                void z(float src);
                void q(SET_HOME_POSITION.q_ src);
                void approach_x(float src);
                void approach_y(float src);
                void approach_z(float src);
                void time_usec(long src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(77, 0, 0, 0, 54, 1, 424, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.latitude(latitude()) ;
                dst.longitude(longitude()) ;
                dst.altitude(altitude()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
                dst.q(q());
                dst.approach_x(approach_x()) ;
                dst.approach_y(approach_y()) ;
                dst.approach_z(approach_z()) ;
                {
                    var item = time_usec();
                    if(item.HasValue) dst.time_usec(item.Value);
                }
            }

            public interface SRC_
            {
                sbyte target_system();
                int latitude();
                int longitude();
                int altitude();
                float x();
                float y();
                float z();
                void q(SET_HOME_POSITION.q_ dst) ;
                float approach_x();
                float approach_y();
                float approach_z();
                long?  time_usec();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                latitude(src.latitude());
                longitude(src.longitude());
                altitude(src.altitude());
                x(src.x());
                y(src.y());
                z(src.z());
                src.q(q());
                approach_x(src.approach_x());
                approach_y(src.approach_y());
                approach_z(src.approach_z());
                {
                    var item = src.time_usec();
                    if(item.HasValue)     time_usec(item.Value);
                }
            }



        }
        /**
        *This interface replaces DATA_STREAM */

        public struct MESSAGE_INTERVAL
        {
            internal Pack.Cursor data_;
            internal MESSAGE_INTERVAL(Pack.Cursor data) { this.data_ = data; }




            public short message_id() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void message_id(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int interval_us() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void interval_us(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }



            public interface DST_
            {
                void message_id(short src);
                void interval_us(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(41, 1, 0, 0, 6, 1, 48);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.message_id(message_id()) ;
                dst.interval_us(interval_us()) ;
            }

            public interface SRC_
            {
                short message_id();
                int interval_us();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                message_id(src.message_id());
                interval_us(src.interval_us());
            }



        }
        /**
        *Provides state for additional features */

        public struct EXTENDED_SYS_STATE
        {
            internal Pack.Cursor data_;
            internal EXTENDED_SYS_STATE(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                vtol_state = 0,
                landed_state = 1
            }




            public  MAV_VTOL_STATE? vtol_state()
            {
                if(data_.field_bit !=  0 && !data_.set_field(0, -1))  return null;
                return (MAV_VTOL_STATE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void vtol_state(MAV_VTOL_STATE src)
            {
                if(data_.field_bit !=  0) data_.set_field(0, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }




            public  MAV_LANDED_STATE? landed_state()
            {
                if(data_.field_bit !=  1 && !data_.set_field(1, -1))  return null;
                return (MAV_LANDED_STATE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void landed_state(MAV_LANDED_STATE src)
            {
                if(data_.field_bit !=  1) data_.set_field(1, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void vtol_state(com.company.demo.GroundControl. MAV_VTOL_STATE src);
                void landed_state(com.company.demo.GroundControl. MAV_LANDED_STATE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(176, 0, 0, 0, 1, 1, 0, 0, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = vtol_state();
                    if(item.HasValue) dst.vtol_state(item.Value);
                }
                {
                    var item = landed_state();
                    if(item.HasValue) dst.landed_state(item.Value);
                }
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. MAV_VTOL_STATE?  vtol_state();
                com.company.demo.GroundControl. MAV_LANDED_STATE?  landed_state();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.vtol_state();
                    if(item.HasValue)     vtol_state(item.Value);
                }
                {
                    var item = src.landed_state();
                    if(item.HasValue)     landed_state(item.Value);
                }
            }



        }
        /**
        *The location and information of an ADSB vehicle */

        public struct ADSB_VEHICLE
        {
            internal Pack.Cursor data_;
            internal ADSB_VEHICLE(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                altitude_type = 202,
                callsign = 203,
                emitter_type = 204,
                flags = 205
            }



            public short heading() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void heading(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short hor_velocity() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void hor_velocity(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short squawk() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void squawk(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public int ICAO_address() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void ICAO_address(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }

            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 4)); }
            public void lon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 14);  }

            public int altitude() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 18, 4)); }
            public void altitude(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 18);  }

            public short ver_velocity() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 22, 2)); }
            public void ver_velocity(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 22);  }

            public sbyte tslc() { return (sbyte)(data_.bytes[data_.origin  + 24]); }
            public void tslc(sbyte src) {    data_.bytes[data_.origin  + 24] = (byte)(src);  }


            public  ADSB_ALTITUDE_TYPE? altitude_type()
            {
                if(data_.field_bit !=  202 && !data_.set_field(202, -1))  return null;
                return (ADSB_ALTITUDE_TYPE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 1)));;
            }


            public void altitude_type(ADSB_ALTITUDE_TYPE src)
            {
                if(data_.field_bit !=  202) data_.set_field(202, 0);
                ;
                Lib.set_bits((ulong)(src), 1, data_.bytes, data_.BIT);;
            }




            public callsign_? callsign()
            {
                if(data_.field_bit !=  203 && !data_.set_field(203, -1))  return (callsign_?) null;
                return new callsign_(data_);
            }



            public char[] callsign(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  203) data_.set_field(203, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), ADSB_VEHICLE.callsign_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void callsign(byte[] src)
            {
                var len = Math.Min(src.Length, ADSB_VEHICLE.callsign_.item_len_max);
                if(data_.field_bit !=  203) data_.set_field(203, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public callsign_ callsign(int len)
            {
                if(data_.field_bit !=  203) data_.set_field(203, Math.Min(len, ADSB_VEHICLE.callsign_.item_len_max));
                return new callsign_(data_);
            }

            public struct callsign_
            {
                Pack.Cursor data_;
                public callsign_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(callsign_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public  ADSB_EMITTER_TYPE? emitter_type()
            {
                if(data_.field_bit !=  204 && !data_.set_field(204, -1))  return null;
                return (ADSB_EMITTER_TYPE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 5)));;
            }


            public void emitter_type(ADSB_EMITTER_TYPE src)
            {
                if(data_.field_bit !=  204) data_.set_field(204, 0);
                ;
                Lib.set_bits((ulong)(src), 5, data_.bytes, data_.BIT);;
            }




            public  ADSB_FLAGS? flags()
            {
                if(data_.field_bit !=  205 && !data_.set_field(205, -1))  return null;
                return    ADSB_FLAGS_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }


            public void flags(ADSB_FLAGS src)
            {
                if(data_.field_bit !=  205) data_.set_field(205, 0);
                ;
                Lib.set_bits(ADSB_FLAGS_.bits(src), 3, data_.bytes, data_.BIT) ;;
            }





            public interface DST_
            {
                void ICAO_address(int src);
                void lat(int src);
                void lon(int src);
                void altitude_type(com.company.demo.GroundControl. ADSB_ALTITUDE_TYPE src);
                void altitude(int src);
                void heading(short src);
                void hor_velocity(short src);
                void ver_velocity(short src);
                void callsign(ADSB_VEHICLE.callsign_ src);
                void emitter_type(com.company.demo.GroundControl. ADSB_EMITTER_TYPE src);
                void tslc(sbyte src);
                void flags(com.company.demo.GroundControl. ADSB_FLAGS src);
                void squawk(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(78, 3, 1, 0, 26, 1, 202, 2, 0, 4);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.ICAO_address(ICAO_address()) ;
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                {
                    var item = altitude_type();
                    if(item.HasValue) dst.altitude_type(item.Value);
                }
                dst.altitude(altitude()) ;
                dst.heading(heading()) ;
                dst.hor_velocity(hor_velocity()) ;
                dst.ver_velocity(ver_velocity()) ;
                {
                    var item = callsign();
                    if(item.HasValue) dst.callsign(item.Value);
                }
                {
                    var item = emitter_type();
                    if(item.HasValue) dst.emitter_type(item.Value);
                }
                dst.tslc(tslc()) ;
                {
                    var item = flags();
                    if(item.HasValue) dst.flags(item.Value);
                }
                dst.squawk(squawk()) ;
            }

            public interface SRC_
            {
                int ICAO_address();
                int lat();
                int lon();
                com.company.demo.GroundControl. ADSB_ALTITUDE_TYPE?  altitude_type();
                int altitude();
                short heading();
                short hor_velocity();
                short ver_velocity();
                int callsign_exist() ;
                void callsign(ADSB_VEHICLE.callsign_ dst) ;
                com.company.demo.GroundControl. ADSB_EMITTER_TYPE?  emitter_type();
                sbyte tslc();
                com.company.demo.GroundControl. ADSB_FLAGS?  flags();
                short squawk();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                ICAO_address(src.ICAO_address());
                lat(src.lat());
                lon(src.lon());
                {
                    var item = src.altitude_type();
                    if(item.HasValue)     altitude_type(item.Value);
                }
                altitude(src.altitude());
                heading(src.heading());
                hor_velocity(src.hor_velocity());
                ver_velocity(src.ver_velocity());
                {
                    var len = src.callsign_exist();
                    if(0 < len)
                        src.callsign(callsign(len));
                }
                {
                    var item = src.emitter_type();
                    if(item.HasValue)     emitter_type(item.Value);
                }
                tslc(src.tslc());
                {
                    var item = src.flags();
                    if(item.HasValue)     flags(item.Value);
                }
                squawk(src.squawk());
            }



        }
        /**
        *Information about a potential collision */

        public struct COLLISION
        {
            internal Pack.Cursor data_;
            internal COLLISION(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                sRc = 130,
                action = 131,
                threat_level = 132
            }



            public int id() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void id(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public float time_to_minimum_delta() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void time_to_minimum_delta(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float altitude_minimum_delta() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void altitude_minimum_delta(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float horizontal_minimum_delta() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void horizontal_minimum_delta(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }


            public  MAV_COLLISION_SRC? sRc()
            {
                if(data_.field_bit !=  130 && !data_.set_field(130, -1))  return null;
                return (MAV_COLLISION_SRC)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 1)));;
            }


            public void sRc(MAV_COLLISION_SRC src)
            {
                if(data_.field_bit !=  130) data_.set_field(130, 0);
                ;
                Lib.set_bits((ulong)(src), 1, data_.bytes, data_.BIT);;
            }




            public  MAV_COLLISION_ACTION? action()
            {
                if(data_.field_bit !=  131 && !data_.set_field(131, -1))  return null;
                return (MAV_COLLISION_ACTION)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void action(MAV_COLLISION_ACTION src)
            {
                if(data_.field_bit !=  131) data_.set_field(131, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }




            public  MAV_COLLISION_THREAT_LEVEL? threat_level()
            {
                if(data_.field_bit !=  132 && !data_.set_field(132, -1))  return null;
                return (MAV_COLLISION_THREAT_LEVEL)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 2)));;
            }


            public void threat_level(MAV_COLLISION_THREAT_LEVEL src)
            {
                if(data_.field_bit !=  132) data_.set_field(132, 0);
                ;
                Lib.set_bits((ulong)(src), 2, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void sRc(com.company.demo.GroundControl. MAV_COLLISION_SRC src);
                void id(int src);
                void action(com.company.demo.GroundControl. MAV_COLLISION_ACTION src);
                void threat_level(com.company.demo.GroundControl. MAV_COLLISION_THREAT_LEVEL src);
                void time_to_minimum_delta(float src);
                void altitude_minimum_delta(float src);
                void horizontal_minimum_delta(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(45, 0, 1, 0, 17, 1, 130, 2, 0, 3);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = sRc();
                    if(item.HasValue) dst.sRc(item.Value);
                }
                dst.id(id()) ;
                {
                    var item = action();
                    if(item.HasValue) dst.action(item.Value);
                }
                {
                    var item = threat_level();
                    if(item.HasValue) dst.threat_level(item.Value);
                }
                dst.time_to_minimum_delta(time_to_minimum_delta()) ;
                dst.altitude_minimum_delta(altitude_minimum_delta()) ;
                dst.horizontal_minimum_delta(horizontal_minimum_delta()) ;
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. MAV_COLLISION_SRC?  sRc();
                int id();
                com.company.demo.GroundControl. MAV_COLLISION_ACTION?  action();
                com.company.demo.GroundControl. MAV_COLLISION_THREAT_LEVEL?  threat_level();
                float time_to_minimum_delta();
                float altitude_minimum_delta();
                float horizontal_minimum_delta();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.sRc();
                    if(item.HasValue)     sRc(item.Value);
                }
                id(src.id());
                {
                    var item = src.action();
                    if(item.HasValue)     action(item.Value);
                }
                {
                    var item = src.threat_level();
                    if(item.HasValue)     threat_level(item.Value);
                }
                time_to_minimum_delta(src.time_to_minimum_delta());
                altitude_minimum_delta(src.altitude_minimum_delta());
                horizontal_minimum_delta(src.horizontal_minimum_delta());
            }



        }
        /**
        *Message implementing parts of the V2 payload specs in V1 frames for transitional support. */

        public struct V2_EXTENSION
        {
            internal Pack.Cursor data_;
            internal V2_EXTENSION(Pack.Cursor data) { this.data_ = data; }




            public short message_type() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void message_type(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public sbyte target_network() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void target_network(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public payload_ payload()
            {
                return new  payload_(data_);
            }

            public struct payload_
            {
                internal Pack.Cursor data_;
                public payload_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return V2_EXTENSION.payload_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 5 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != V2_EXTENSION.payload_.item_len) return false;
                    for(int i = 0; i < V2_EXTENSION.payload_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(payload_ other)
                {
                    if(other.len() != V2_EXTENSION.payload_.item_len) return false;
                    for(int i = 0; i < V2_EXTENSION.payload_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 5 + index] = (byte)(src); }

                public const int item_len = 249 ;


            }

            public void payload(sbyte[] src)
            {
                var len =  Math.Min(src.Length, V2_EXTENSION.payload_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 5 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void target_network(sbyte src);
                void target_system(sbyte src);
                void target_component(sbyte src);
                void message_type(short src);
                void payload(V2_EXTENSION.payload_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(174, 1, 0, 0, 254, 1, 2032);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_network(target_network()) ;
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.message_type(message_type()) ;
                dst.payload(payload());
            }

            public interface SRC_
            {
                sbyte target_network();
                sbyte target_system();
                sbyte target_component();
                short message_type();
                void payload(V2_EXTENSION.payload_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_network(src.target_network());
                target_system(src.target_system());
                target_component(src.target_component());
                message_type(src.message_type());
                src.payload(payload());
            }



        }
        /**
        *Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient
        *				 way for testing new messages and getting experimental debug output */

        public struct MEMORY_VECT
        {
            internal Pack.Cursor data_;
            internal MEMORY_VECT(Pack.Cursor data) { this.data_ = data; }




            public short address() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void address(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public sbyte ver() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void ver(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte typE() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void typE(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }

            public value_ value()
            {
                return new  value_(data_);
            }

            public struct value_
            {
                internal Pack.Cursor data_;
                public value_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return MEMORY_VECT.value_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 4 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != MEMORY_VECT.value_.item_len) return false;
                    for(int i = 0; i < MEMORY_VECT.value_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(value_ other)
                {
                    if(other.len() != MEMORY_VECT.value_.item_len) return false;
                    for(int i = 0; i < MEMORY_VECT.value_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 4 + index] = (byte)(src); }

                public const int item_len = 32 ;


            }

            public void value(sbyte[] src)
            {
                var len =  Math.Min(src.Length, MEMORY_VECT.value_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 4 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void address(short src);
                void ver(sbyte src);
                void typE(sbyte src);
                void value(MEMORY_VECT.value_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(30, 1, 0, 0, 36, 1, 288);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.address(address()) ;
                dst.ver(ver()) ;
                dst.typE(typE()) ;
                dst.value(value());
            }

            public interface SRC_
            {
                short address();
                sbyte ver();
                sbyte typE();
                void value(MEMORY_VECT.value_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                address(src.address());
                ver(src.ver());
                typE(src.typE());
                src.value(value());
            }



        }

        public struct DEBUG_VECT
        {
            internal Pack.Cursor data_;
            internal DEBUG_VECT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                name = 162
            }



            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public float x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }


            public name_? name()
            {
                if(data_.field_bit !=  162 && !data_.set_field(162, -1))  return (name_?) null;
                return new name_(data_);
            }



            public char[] name(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  162) data_.set_field(162, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), DEBUG_VECT.name_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void name(byte[] src)
            {
                var len = Math.Min(src.Length, DEBUG_VECT.name_.item_len_max);
                if(data_.field_bit !=  162) data_.set_field(162, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public name_ name(int len)
            {
                if(data_.field_bit !=  162) data_.set_field(162, Math.Min(len, DEBUG_VECT.name_.item_len_max));
                return new name_(data_);
            }

            public struct name_
            {
                Pack.Cursor data_;
                public name_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(name_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void name(DEBUG_VECT.name_ src);
                void time_usec(long src);
                void x(float src);
                void y(float src);
                void z(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(187, 0, 0, 1, 21, 1, 162, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = name();
                    if(item.HasValue) dst.name(item.Value);
                }
                dst.time_usec(time_usec()) ;
                dst.x(x()) ;
                dst.y(y()) ;
                dst.z(z()) ;
            }

            public interface SRC_
            {
                int name_exist() ;
                void name(DEBUG_VECT.name_ dst) ;
                long time_usec();
                float x();
                float y();
                float z();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var len = src.name_exist();
                    if(0 < len)
                        src.name(name(len));
                }
                time_usec(src.time_usec());
                x(src.x());
                y(src.y());
                z(src.z());
            }



        }
        /**
        *Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite
        *				 efficient way for testing new messages and getting experimental debug output */

        public struct NAMED_VALUE_FLOAT
        {
            internal Pack.Cursor data_;
            internal NAMED_VALUE_FLOAT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                name = 66
            }



            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public float value() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void value(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }


            public name_? name()
            {
                if(data_.field_bit !=  66 && !data_.set_field(66, -1))  return (name_?) null;
                return new name_(data_);
            }



            public char[] name(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  66) data_.set_field(66, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), NAMED_VALUE_FLOAT.name_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void name(byte[] src)
            {
                var len = Math.Min(src.Length, NAMED_VALUE_FLOAT.name_.item_len_max);
                if(data_.field_bit !=  66) data_.set_field(66, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public name_ name(int len)
            {
                if(data_.field_bit !=  66) data_.set_field(66, Math.Min(len, NAMED_VALUE_FLOAT.name_.item_len_max));
                return new name_(data_);
            }

            public struct name_
            {
                Pack.Cursor data_;
                public name_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(name_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void time_boot_ms(int src);
                void name(NAMED_VALUE_FLOAT.name_ src);
                void value(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(8, 0, 1, 0, 9, 1, 66, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                {
                    var item = name();
                    if(item.HasValue) dst.name(item.Value);
                }
                dst.value(value()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                int name_exist() ;
                void name(NAMED_VALUE_FLOAT.name_ dst) ;
                float value();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                {
                    var len = src.name_exist();
                    if(0 < len)
                        src.name(name(len));
                }
                value(src.value());
            }



        }
        /**
        *Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite
        *				 efficient way for testing new messages and getting experimental debug output */

        public struct NAMED_VALUE_INT
        {
            internal Pack.Cursor data_;
            internal NAMED_VALUE_INT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                name = 66
            }



            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public int value() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }
            public void value(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 4);  }


            public name_? name()
            {
                if(data_.field_bit !=  66 && !data_.set_field(66, -1))  return (name_?) null;
                return new name_(data_);
            }



            public char[] name(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  66) data_.set_field(66, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), NAMED_VALUE_INT.name_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void name(byte[] src)
            {
                var len = Math.Min(src.Length, NAMED_VALUE_INT.name_.item_len_max);
                if(data_.field_bit !=  66) data_.set_field(66, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public name_ name(int len)
            {
                if(data_.field_bit !=  66) data_.set_field(66, Math.Min(len, NAMED_VALUE_INT.name_.item_len_max));
                return new name_(data_);
            }

            public struct name_
            {
                Pack.Cursor data_;
                public name_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(name_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void time_boot_ms(int src);
                void name(NAMED_VALUE_INT.name_ src);
                void value(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(21, 0, 1, 0, 9, 1, 66, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                {
                    var item = name();
                    if(item.HasValue) dst.name(item.Value);
                }
                dst.value(value()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                int name_exist() ;
                void name(NAMED_VALUE_INT.name_ dst) ;
                int value();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                {
                    var len = src.name_exist();
                    if(0 < len)
                        src.name(name(len));
                }
                value(src.value());
            }



        }
        /**
        *Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING:
        *				 They consume quite some bandwidth, so use only for important status and error messages. If implemented
        *				 wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz) */

        public struct STATUSTEXT
        {
            internal Pack.Cursor data_;
            internal STATUSTEXT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                severity = 2,
                text = 3
            }




            public  MAV_SEVERITY? severity()
            {
                if(data_.field_bit !=  2 && !data_.set_field(2, -1))  return null;
                return (MAV_SEVERITY)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void severity(MAV_SEVERITY src)
            {
                if(data_.field_bit !=  2) data_.set_field(2, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }




            public text_? text()
            {
                if(data_.field_bit !=  3 && !data_.set_field(3, -1))  return (text_?) null;
                return new text_(data_);
            }



            public char[] text(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  3) data_.set_field(3, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), STATUSTEXT.text_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void text(byte[] src)
            {
                var len = Math.Min(src.Length, STATUSTEXT.text_.item_len_max);
                if(data_.field_bit !=  3) data_.set_field(3, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public text_ text(int len)
            {
                if(data_.field_bit !=  3) data_.set_field(3, Math.Min(len, STATUSTEXT.text_.item_len_max));
                return new text_(data_);
            }

            public struct text_
            {
                Pack.Cursor data_;
                public text_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(text_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void severity(com.company.demo.GroundControl. MAV_SEVERITY src);
                void text(STATUSTEXT.text_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(124, 0, 0, 0, 1, 1, 2, 2, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = severity();
                    if(item.HasValue) dst.severity(item.Value);
                }
                {
                    var item = text();
                    if(item.HasValue) dst.text(item.Value);
                }
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. MAV_SEVERITY?  severity();
                int text_exist() ;
                void text(STATUSTEXT.text_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.severity();
                    if(item.HasValue)     severity(item.Value);
                }
                {
                    var len = src.text_exist();
                    if(0 < len)
                        src.text(text(len));
                }
            }



        }
        /**
        *Send a debug value. The index is used to discriminate between values. These values show up in the plot
        *				 of QGroundControl as DEBUG N */

        public struct DEBUG
        {
            internal Pack.Cursor data_;
            internal DEBUG(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public sbyte ind() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void ind(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public float value() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 5); }
            public void value(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 5, 4);  }



            public interface DST_
            {
                void time_boot_ms(int src);
                void ind(sbyte src);
                void value(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(126, 0, 1, 0, 9, 1, 72);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.ind(ind()) ;
                dst.value(value()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                sbyte ind();
                float value();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                ind(src.ind());
                value(src.value());
            }



        }
        /**
        *Setup a MAVLink2 signing key. If called with secret_key of all zero and zero initial_timestamp will disable
        *				 signin */

        public struct SETUP_SIGNING
        {
            internal Pack.Cursor data_;
            internal SETUP_SIGNING(Pack.Cursor data) { this.data_ = data; }




            public long initial_timestamp() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void initial_timestamp(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 9]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 9] = (byte)(src);  }

            public secret_key_ secret_key()
            {
                return new  secret_key_(data_);
            }

            public struct secret_key_
            {
                internal Pack.Cursor data_;
                public secret_key_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return SETUP_SIGNING.secret_key_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 10 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != SETUP_SIGNING.secret_key_.item_len) return false;
                    for(int i = 0; i < SETUP_SIGNING.secret_key_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(secret_key_ other)
                {
                    if(other.len() != SETUP_SIGNING.secret_key_.item_len) return false;
                    for(int i = 0; i < SETUP_SIGNING.secret_key_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 10 + index] = (byte)(src); }

                public const int item_len = 32 ;


            }

            public void secret_key(sbyte[] src)
            {
                var len =  Math.Min(src.Length, SETUP_SIGNING.secret_key_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 10 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void secret_key(SETUP_SIGNING.secret_key_ src);
                void initial_timestamp(long src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(205, 0, 0, 1, 42, 1, 336);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.secret_key(secret_key());
                dst.initial_timestamp(initial_timestamp()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                void secret_key(SETUP_SIGNING.secret_key_ dst) ;
                long initial_timestamp();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                src.secret_key(secret_key());
                initial_timestamp(src.initial_timestamp());
            }



        }
        /**
        *Report button state change */

        public struct BUTTON_CHANGE
        {
            internal Pack.Cursor data_;
            internal BUTTON_CHANGE(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public int last_change_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }
            public void last_change_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 4);  }

            public sbyte state() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void state(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }



            public interface DST_
            {
                void time_boot_ms(int src);
                void last_change_ms(int src);
                void state(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(146, 0, 2, 0, 9, 1, 72);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.last_change_ms(last_change_ms()) ;
                dst.state(state()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                int last_change_ms();
                sbyte state();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                last_change_ms(src.last_change_ms());
                state(src.state());
            }



        }
        /**
        *Control vehicle tone generation (buzzer) */

        public struct PLAY_TUNE
        {
            internal Pack.Cursor data_;
            internal PLAY_TUNE(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                tune = 18
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }


            public tune_? tune()
            {
                if(data_.field_bit !=  18 && !data_.set_field(18, -1))  return (tune_?) null;
                return new tune_(data_);
            }



            public char[] tune(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  18) data_.set_field(18, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PLAY_TUNE.tune_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void tune(byte[] src)
            {
                var len = Math.Min(src.Length, PLAY_TUNE.tune_.item_len_max);
                if(data_.field_bit !=  18) data_.set_field(18, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public tune_ tune(int len)
            {
                if(data_.field_bit !=  18) data_.set_field(18, Math.Min(len, PLAY_TUNE.tune_.item_len_max));
                return new tune_(data_);
            }

            public struct tune_
            {
                Pack.Cursor data_;
                public tune_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(tune_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void tune(PLAY_TUNE.tune_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(203, 0, 0, 0, 3, 1, 18, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = tune();
                    if(item.HasValue) dst.tune(item.Value);
                }
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                int tune_exist() ;
                void tune(PLAY_TUNE.tune_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                {
                    var len = src.tune_exist();
                    if(0 < len)
                        src.tune(tune(len));
                }
            }



        }
        /**
        *WIP: Information about a camera */

        public struct CAMERA_INFORMATION
        {
            internal Pack.Cursor data_;
            internal CAMERA_INFORMATION(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                flags = 730,
                cam_definition_uri = 731
            }



            public short resolution_h() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void resolution_h(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short resolution_v() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void resolution_v(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short cam_definition_version() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void cam_definition_version(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public int firmware_version() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void firmware_version(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }

            public vendor_name_ vendor_name()
            {
                return new  vendor_name_(data_);
            }

            public struct vendor_name_
            {
                internal Pack.Cursor data_;
                public vendor_name_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return CAMERA_INFORMATION.vendor_name_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 14 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != CAMERA_INFORMATION.vendor_name_.item_len) return false;
                    for(int i = 0; i < CAMERA_INFORMATION.vendor_name_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(vendor_name_ other)
                {
                    if(other.len() != CAMERA_INFORMATION.vendor_name_.item_len) return false;
                    for(int i = 0; i < CAMERA_INFORMATION.vendor_name_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 14 + index] = (byte)(src); }

                public const int item_len = 32 ;


            }

            public void vendor_name(sbyte[] src)
            {
                var len =  Math.Min(src.Length, CAMERA_INFORMATION.vendor_name_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 14 + index] = (byte)(src[index]);
            }

            public model_name_ model_name()
            {
                return new  model_name_(data_);
            }

            public struct model_name_
            {
                internal Pack.Cursor data_;
                public model_name_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return CAMERA_INFORMATION.model_name_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 46 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != CAMERA_INFORMATION.model_name_.item_len) return false;
                    for(int i = 0; i < CAMERA_INFORMATION.model_name_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(model_name_ other)
                {
                    if(other.len() != CAMERA_INFORMATION.model_name_.item_len) return false;
                    for(int i = 0; i < CAMERA_INFORMATION.model_name_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 46 + index] = (byte)(src); }

                public const int item_len = 32 ;


            }

            public void model_name(sbyte[] src)
            {
                var len =  Math.Min(src.Length, CAMERA_INFORMATION.model_name_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 46 + index] = (byte)(src[index]);
            }

            public float focal_length() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 78); }
            public void focal_length(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 78, 4);  }

            public float sensor_size_h() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 82); }
            public void sensor_size_h(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 82, 4);  }

            public float sensor_size_v() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 86); }
            public void sensor_size_v(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 86, 4);  }

            public sbyte lens_id() { return (sbyte)(data_.bytes[data_.origin  + 90]); }
            public void lens_id(sbyte src) {    data_.bytes[data_.origin  + 90] = (byte)(src);  }


            public  CAMERA_CAP_FLAGS? flags()
            {
                if(data_.field_bit !=  730 && !data_.set_field(730, -1))  return null;
                return    CAMERA_CAP_FLAGS_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }


            public void flags(CAMERA_CAP_FLAGS src)
            {
                if(data_.field_bit !=  730) data_.set_field(730, 0);
                ;
                Lib.set_bits(CAMERA_CAP_FLAGS_.bits(src), 3, data_.bytes, data_.BIT) ;;
            }




            public cam_definition_uri_? cam_definition_uri()
            {
                if(data_.field_bit !=  731 && !data_.set_field(731, -1))  return (cam_definition_uri_?) null;
                return new cam_definition_uri_(data_);
            }



            public char[] cam_definition_uri(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  731) data_.set_field(731, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), CAMERA_INFORMATION.cam_definition_uri_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void cam_definition_uri(byte[] src)
            {
                var len = Math.Min(src.Length, CAMERA_INFORMATION.cam_definition_uri_.item_len_max);
                if(data_.field_bit !=  731) data_.set_field(731, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public cam_definition_uri_ cam_definition_uri(int len)
            {
                if(data_.field_bit !=  731) data_.set_field(731, Math.Min(len, CAMERA_INFORMATION.cam_definition_uri_.item_len_max));
                return new cam_definition_uri_(data_);
            }

            public struct cam_definition_uri_
            {
                Pack.Cursor data_;
                public cam_definition_uri_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(cam_definition_uri_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void time_boot_ms(int src);
                void vendor_name(CAMERA_INFORMATION.vendor_name_ src);
                void model_name(CAMERA_INFORMATION.model_name_ src);
                void firmware_version(int src);
                void focal_length(float src);
                void sensor_size_h(float src);
                void sensor_size_v(float src);
                void resolution_h(short src);
                void resolution_v(short src);
                void lens_id(sbyte src);
                void flags(com.company.demo.GroundControl. CAMERA_CAP_FLAGS src);
                void cam_definition_version(short src);
                void cam_definition_uri(CAMERA_INFORMATION.cam_definition_uri_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(157, 3, 2, 0, 92, 1, 730, 2, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.vendor_name(vendor_name());
                dst.model_name(model_name());
                dst.firmware_version(firmware_version()) ;
                dst.focal_length(focal_length()) ;
                dst.sensor_size_h(sensor_size_h()) ;
                dst.sensor_size_v(sensor_size_v()) ;
                dst.resolution_h(resolution_h()) ;
                dst.resolution_v(resolution_v()) ;
                dst.lens_id(lens_id()) ;
                {
                    var item = flags();
                    if(item.HasValue) dst.flags(item.Value);
                }
                dst.cam_definition_version(cam_definition_version()) ;
                {
                    var item = cam_definition_uri();
                    if(item.HasValue) dst.cam_definition_uri(item.Value);
                }
            }

            public interface SRC_
            {
                int time_boot_ms();
                void vendor_name(CAMERA_INFORMATION.vendor_name_ dst) ;
                void model_name(CAMERA_INFORMATION.model_name_ dst) ;
                int firmware_version();
                float focal_length();
                float sensor_size_h();
                float sensor_size_v();
                short resolution_h();
                short resolution_v();
                sbyte lens_id();
                com.company.demo.GroundControl. CAMERA_CAP_FLAGS?  flags();
                short cam_definition_version();
                int cam_definition_uri_exist() ;
                void cam_definition_uri(CAMERA_INFORMATION.cam_definition_uri_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                src.vendor_name(vendor_name());
                src.model_name(model_name());
                firmware_version(src.firmware_version());
                focal_length(src.focal_length());
                sensor_size_h(src.sensor_size_h());
                sensor_size_v(src.sensor_size_v());
                resolution_h(src.resolution_h());
                resolution_v(src.resolution_v());
                lens_id(src.lens_id());
                {
                    var item = src.flags();
                    if(item.HasValue)     flags(item.Value);
                }
                cam_definition_version(src.cam_definition_version());
                {
                    var len = src.cam_definition_uri_exist();
                    if(0 < len)
                        src.cam_definition_uri(cam_definition_uri(len));
                }
            }



        }
        /**
        *WIP: Settings of a camera, can be requested using MAV_CMD_REQUEST_CAMERA_SETTINGS. */

        public struct CAMERA_SETTINGS
        {
            internal Pack.Cursor data_;
            internal CAMERA_SETTINGS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                mode_id = 32
            }



            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }


            public  CAMERA_MODE? mode_id()
            {
                if(data_.field_bit !=  32 && !data_.set_field(32, -1))  return null;
                return (CAMERA_MODE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 2)));;
            }


            public void mode_id(CAMERA_MODE src)
            {
                if(data_.field_bit !=  32) data_.set_field(32, 0);
                ;
                Lib.set_bits((ulong)(src), 2, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void time_boot_ms(int src);
                void mode_id(com.company.demo.GroundControl. CAMERA_MODE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(181, 0, 1, 0, 5, 1, 32, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                {
                    var item = mode_id();
                    if(item.HasValue) dst.mode_id(item.Value);
                }
            }

            public interface SRC_
            {
                int time_boot_ms();
                com.company.demo.GroundControl. CAMERA_MODE?  mode_id();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                {
                    var item = src.mode_id();
                    if(item.HasValue)     mode_id(item.Value);
                }
            }



        }
        /**
        *WIP: Information about a storage medium. */

        public struct STORAGE_INFORMATION
        {
            internal Pack.Cursor data_;
            internal STORAGE_INFORMATION(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public sbyte storage_id() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void storage_id(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte storage_count() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void storage_count(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }

            public sbyte status() { return (sbyte)(data_.bytes[data_.origin  + 6]); }
            public void status(sbyte src) {    data_.bytes[data_.origin  + 6] = (byte)(src);  }

            public float total_capacity() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 7); }
            public void total_capacity(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 7, 4);  }

            public float used_capacity() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 11); }
            public void used_capacity(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 11, 4);  }

            public float available_capacity() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 15); }
            public void available_capacity(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 15, 4);  }

            public float read_speed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 19); }
            public void read_speed(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 19, 4);  }

            public float write_speed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 23); }
            public void write_speed(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 23, 4);  }



            public interface DST_
            {
                void time_boot_ms(int src);
                void storage_id(sbyte src);
                void storage_count(sbyte src);
                void status(sbyte src);
                void total_capacity(float src);
                void used_capacity(float src);
                void available_capacity(float src);
                void read_speed(float src);
                void write_speed(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(58, 0, 1, 0, 27, 1, 216);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.storage_id(storage_id()) ;
                dst.storage_count(storage_count()) ;
                dst.status(status()) ;
                dst.total_capacity(total_capacity()) ;
                dst.used_capacity(used_capacity()) ;
                dst.available_capacity(available_capacity()) ;
                dst.read_speed(read_speed()) ;
                dst.write_speed(write_speed()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                sbyte storage_id();
                sbyte storage_count();
                sbyte status();
                float total_capacity();
                float used_capacity();
                float available_capacity();
                float read_speed();
                float write_speed();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                storage_id(src.storage_id());
                storage_count(src.storage_count());
                status(src.status());
                total_capacity(src.total_capacity());
                used_capacity(src.used_capacity());
                available_capacity(src.available_capacity());
                read_speed(src.read_speed());
                write_speed(src.write_speed());
            }



        }
        /**
        *WIP: Information about the status of a capture */

        public struct CAMERA_CAPTURE_STATUS
        {
            internal Pack.Cursor data_;
            internal CAMERA_CAPTURE_STATUS(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public int recording_time_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }
            public void recording_time_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 4);  }

            public sbyte image_status() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void image_status(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }

            public sbyte video_status() { return (sbyte)(data_.bytes[data_.origin  + 9]); }
            public void video_status(sbyte src) {    data_.bytes[data_.origin  + 9] = (byte)(src);  }

            public float image_interval() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 10); }
            public void image_interval(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 10, 4);  }

            public float available_capacity() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 14); }
            public void available_capacity(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 14, 4);  }



            public interface DST_
            {
                void time_boot_ms(int src);
                void image_status(sbyte src);
                void video_status(sbyte src);
                void image_interval(float src);
                void recording_time_ms(int src);
                void available_capacity(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(216, 0, 2, 0, 18, 1, 144);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.image_status(image_status()) ;
                dst.video_status(video_status()) ;
                dst.image_interval(image_interval()) ;
                dst.recording_time_ms(recording_time_ms()) ;
                dst.available_capacity(available_capacity()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                sbyte image_status();
                sbyte video_status();
                float image_interval();
                int recording_time_ms();
                float available_capacity();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                image_status(src.image_status());
                video_status(src.video_status());
                image_interval(src.image_interval());
                recording_time_ms(src.recording_time_ms());
                available_capacity(src.available_capacity());
            }



        }
        /**
        *Information about a captured image */

        public struct CAMERA_IMAGE_CAPTURED
        {
            internal Pack.Cursor data_;
            internal CAMERA_IMAGE_CAPTURED(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                file_url = 402
            }



            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public long time_utc() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 8)); }
            public void time_utc(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 4);  }

            public sbyte camera_id() { return (sbyte)(data_.bytes[data_.origin  + 12]); }
            public void camera_id(sbyte src) {    data_.bytes[data_.origin  + 12] = (byte)(src);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 13, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 13);  }

            public int lon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 17, 4)); }
            public void lon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 17);  }

            public int alt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 21, 4)); }
            public void alt(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 21);  }

            public int relative_alt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 25, 4)); }
            public void relative_alt(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 25);  }

            public q_ q()
            {
                return new  q_(data_);
            }

            public struct q_
            {
                internal Pack.Cursor data_;
                public q_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return CAMERA_IMAGE_CAPTURED.q_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 29 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != CAMERA_IMAGE_CAPTURED.q_.item_len) return false;
                    for(int i = 0; i < CAMERA_IMAGE_CAPTURED.q_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(q_ other)
                {
                    if(other.len() != CAMERA_IMAGE_CAPTURED.q_.item_len) return false;
                    for(int i = 0; i < CAMERA_IMAGE_CAPTURED.q_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 29 + index * 4, 4); }

                public const int item_len = 4 ;


            }

            public void q(float[] src)
            {
                var len =  Math.Min(src.Length, CAMERA_IMAGE_CAPTURED.q_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 29 + index * 4, 4);
            }

            public int image_index() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 45, 4)); }
            public void image_index(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 45);  }

            public sbyte capture_result() { return (sbyte)(data_.bytes[data_.origin  + 49]); }
            public void capture_result(sbyte src) {    data_.bytes[data_.origin  + 49] = (byte)(src);  }


            public file_url_? file_url()
            {
                if(data_.field_bit !=  402 && !data_.set_field(402, -1))  return (file_url_?) null;
                return new file_url_(data_);
            }



            public char[] file_url(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  402) data_.set_field(402, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), CAMERA_IMAGE_CAPTURED.file_url_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void file_url(byte[] src)
            {
                var len = Math.Min(src.Length, CAMERA_IMAGE_CAPTURED.file_url_.item_len_max);
                if(data_.field_bit !=  402) data_.set_field(402, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public file_url_ file_url(int len)
            {
                if(data_.field_bit !=  402) data_.set_field(402, Math.Min(len, CAMERA_IMAGE_CAPTURED.file_url_.item_len_max));
                return new file_url_(data_);
            }

            public struct file_url_
            {
                Pack.Cursor data_;
                public file_url_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(file_url_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void time_boot_ms(int src);
                void time_utc(long src);
                void camera_id(sbyte src);
                void lat(int src);
                void lon(int src);
                void alt(int src);
                void relative_alt(int src);
                void q(CAMERA_IMAGE_CAPTURED.q_ src);
                void image_index(int src);
                void capture_result(sbyte src);
                void file_url(CAMERA_IMAGE_CAPTURED.file_url_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(10, 0, 1, 1, 51, 1, 402, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.time_utc(time_utc()) ;
                dst.camera_id(camera_id()) ;
                dst.lat(lat()) ;
                dst.lon(lon()) ;
                dst.alt(alt()) ;
                dst.relative_alt(relative_alt()) ;
                dst.q(q());
                dst.image_index(image_index()) ;
                dst.capture_result(capture_result()) ;
                {
                    var item = file_url();
                    if(item.HasValue) dst.file_url(item.Value);
                }
            }

            public interface SRC_
            {
                int time_boot_ms();
                long time_utc();
                sbyte camera_id();
                int lat();
                int lon();
                int alt();
                int relative_alt();
                void q(CAMERA_IMAGE_CAPTURED.q_ dst) ;
                int image_index();
                sbyte capture_result();
                int file_url_exist() ;
                void file_url(CAMERA_IMAGE_CAPTURED.file_url_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                time_utc(src.time_utc());
                camera_id(src.camera_id());
                lat(src.lat());
                lon(src.lon());
                alt(src.alt());
                relative_alt(src.relative_alt());
                src.q(q());
                image_index(src.image_index());
                capture_result(src.capture_result());
                {
                    var len = src.file_url_exist();
                    if(0 < len)
                        src.file_url(file_url(len));
                }
            }



        }
        /**
        *WIP: Information about flight since last arming */

        public struct FLIGHT_INFORMATION
        {
            internal Pack.Cursor data_;
            internal FLIGHT_INFORMATION(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public long arming_time_utc() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 8)); }
            public void arming_time_utc(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 4);  }

            public long takeoff_time_utc() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 8)); }
            public void takeoff_time_utc(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 12);  }

            public long flight_uuid() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 8)); }
            public void flight_uuid(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 20);  }



            public interface DST_
            {
                void time_boot_ms(int src);
                void arming_time_utc(long src);
                void takeoff_time_utc(long src);
                void flight_uuid(long src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(215, 0, 1, 3, 28, 1, 224);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.arming_time_utc(arming_time_utc()) ;
                dst.takeoff_time_utc(takeoff_time_utc()) ;
                dst.flight_uuid(flight_uuid()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                long arming_time_utc();
                long takeoff_time_utc();
                long flight_uuid();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                arming_time_utc(src.arming_time_utc());
                takeoff_time_utc(src.takeoff_time_utc());
                flight_uuid(src.flight_uuid());
            }



        }

        public struct MOUNT_ORIENTATION
        {
            internal Pack.Cursor data_;
            internal MOUNT_ORIENTATION(Pack.Cursor data) { this.data_ = data; }




            public int time_boot_ms() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void time_boot_ms(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void roll(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void pitch(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void yaw(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }



            public interface DST_
            {
                void time_boot_ms(int src);
                void roll(float src);
                void pitch(float src);
                void yaw(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(76, 0, 1, 0, 16, 1, 128);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_boot_ms(time_boot_ms()) ;
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
            }

            public interface SRC_
            {
                int time_boot_ms();
                float roll();
                float pitch();
                float yaw();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_boot_ms(src.time_boot_ms());
                roll(src.roll());
                pitch(src.pitch());
                yaw(src.yaw());
            }



        }
        /**
        *A message containing logged data (see also MAV_CMD_LOGGING_START) */

        public struct LOGGING_DATA
        {
            internal Pack.Cursor data_;
            internal LOGGING_DATA(Pack.Cursor data) { this.data_ = data; }




            public short sequence() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void sequence(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }

            public sbyte length() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void length(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte first_message_offset() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void first_message_offset(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return LOGGING_DATA.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 6 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != LOGGING_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < LOGGING_DATA.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != LOGGING_DATA.daTa_.item_len) return false;
                    for(int i = 0; i < LOGGING_DATA.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 6 + index] = (byte)(src); }

                public const int item_len = 249 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, LOGGING_DATA.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 6 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void sequence(short src);
                void length(sbyte src);
                void first_message_offset(sbyte src);
                void daTa(LOGGING_DATA.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(75, 1, 0, 0, 255, 1, 2040);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.sequence(sequence()) ;
                dst.length(length()) ;
                dst.first_message_offset(first_message_offset()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                short sequence();
                sbyte length();
                sbyte first_message_offset();
                void daTa(LOGGING_DATA.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                sequence(src.sequence());
                length(src.length());
                first_message_offset(src.first_message_offset());
                src.daTa(daTa());
            }



        }
        /**
        *A message containing logged data which requires a LOGGING_ACK to be sent back */

        public struct LOGGING_DATA_ACKED
        {
            internal Pack.Cursor data_;
            internal LOGGING_DATA_ACKED(Pack.Cursor data) { this.data_ = data; }




            public short sequence() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void sequence(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }

            public sbyte length() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void length(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte first_message_offset() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void first_message_offset(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return LOGGING_DATA_ACKED.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 6 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != LOGGING_DATA_ACKED.daTa_.item_len) return false;
                    for(int i = 0; i < LOGGING_DATA_ACKED.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != LOGGING_DATA_ACKED.daTa_.item_len) return false;
                    for(int i = 0; i < LOGGING_DATA_ACKED.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 6 + index] = (byte)(src); }

                public const int item_len = 249 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, LOGGING_DATA_ACKED.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 6 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void sequence(short src);
                void length(sbyte src);
                void first_message_offset(sbyte src);
                void daTa(LOGGING_DATA_ACKED.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(217, 1, 0, 0, 255, 1, 2040);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.sequence(sequence()) ;
                dst.length(length()) ;
                dst.first_message_offset(first_message_offset()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                short sequence();
                sbyte length();
                sbyte first_message_offset();
                void daTa(LOGGING_DATA_ACKED.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                sequence(src.sequence());
                length(src.length());
                first_message_offset(src.first_message_offset());
                src.daTa(daTa());
            }



        }
        /**
        *An ack for a LOGGING_DATA_ACKED message */

        public struct LOGGING_ACK
        {
            internal Pack.Cursor data_;
            internal LOGGING_ACK(Pack.Cursor data) { this.data_ = data; }




            public short sequence() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void sequence(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void sequence(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(220, 1, 0, 0, 4, 1, 32);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.sequence(sequence()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                short sequence();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                sequence(src.sequence());
            }



        }
        /**
        *WIP: Information about video stream */

        public struct VIDEO_STREAM_INFORMATION
        {
            internal Pack.Cursor data_;
            internal VIDEO_STREAM_INFORMATION(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                uri = 130
            }



            public short resolution_h() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void resolution_h(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short resolution_v() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void resolution_v(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short rotation() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void rotation(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public int bitrate() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void bitrate(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public sbyte camera_id() { return (sbyte)(data_.bytes[data_.origin  + 10]); }
            public void camera_id(sbyte src) {    data_.bytes[data_.origin  + 10] = (byte)(src);  }

            public sbyte status() { return (sbyte)(data_.bytes[data_.origin  + 11]); }
            public void status(sbyte src) {    data_.bytes[data_.origin  + 11] = (byte)(src);  }

            public float framerate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void framerate(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }


            public uri_? uri()
            {
                if(data_.field_bit !=  130 && !data_.set_field(130, -1))  return (uri_?) null;
                return new uri_(data_);
            }



            public char[] uri(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  130) data_.set_field(130, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), VIDEO_STREAM_INFORMATION.uri_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void uri(byte[] src)
            {
                var len = Math.Min(src.Length, VIDEO_STREAM_INFORMATION.uri_.item_len_max);
                if(data_.field_bit !=  130) data_.set_field(130, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public uri_ uri(int len)
            {
                if(data_.field_bit !=  130) data_.set_field(130, Math.Min(len, VIDEO_STREAM_INFORMATION.uri_.item_len_max));
                return new uri_(data_);
            }

            public struct uri_
            {
                Pack.Cursor data_;
                public uri_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(uri_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void camera_id(sbyte src);
                void status(sbyte src);
                void framerate(float src);
                void resolution_h(short src);
                void resolution_v(short src);
                void bitrate(int src);
                void rotation(short src);
                void uri(VIDEO_STREAM_INFORMATION.uri_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(1, 3, 1, 0, 17, 1, 130, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.camera_id(camera_id()) ;
                dst.status(status()) ;
                dst.framerate(framerate()) ;
                dst.resolution_h(resolution_h()) ;
                dst.resolution_v(resolution_v()) ;
                dst.bitrate(bitrate()) ;
                dst.rotation(rotation()) ;
                {
                    var item = uri();
                    if(item.HasValue) dst.uri(item.Value);
                }
            }

            public interface SRC_
            {
                sbyte camera_id();
                sbyte status();
                float framerate();
                short resolution_h();
                short resolution_v();
                int bitrate();
                short rotation();
                int uri_exist() ;
                void uri(VIDEO_STREAM_INFORMATION.uri_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                camera_id(src.camera_id());
                status(src.status());
                framerate(src.framerate());
                resolution_h(src.resolution_h());
                resolution_v(src.resolution_v());
                bitrate(src.bitrate());
                rotation(src.rotation());
                {
                    var len = src.uri_exist();
                    if(0 < len)
                        src.uri(uri(len));
                }
            }



        }
        /**
        *WIP: Message that sets video stream settings */

        public struct SET_VIDEO_STREAM_SETTINGS
        {
            internal Pack.Cursor data_;
            internal SET_VIDEO_STREAM_SETTINGS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                uri = 138
            }



            public short resolution_h() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void resolution_h(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short resolution_v() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void resolution_v(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short rotation() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void rotation(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public int bitrate() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void bitrate(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 10]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 10] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 11]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 11] = (byte)(src);  }

            public sbyte camera_id() { return (sbyte)(data_.bytes[data_.origin  + 12]); }
            public void camera_id(sbyte src) {    data_.bytes[data_.origin  + 12] = (byte)(src);  }

            public float framerate() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 13); }
            public void framerate(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 13, 4);  }


            public uri_? uri()
            {
                if(data_.field_bit !=  138 && !data_.set_field(138, -1))  return (uri_?) null;
                return new uri_(data_);
            }



            public char[] uri(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  138) data_.set_field(138, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), SET_VIDEO_STREAM_SETTINGS.uri_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void uri(byte[] src)
            {
                var len = Math.Min(src.Length, SET_VIDEO_STREAM_SETTINGS.uri_.item_len_max);
                if(data_.field_bit !=  138) data_.set_field(138, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public uri_ uri(int len)
            {
                if(data_.field_bit !=  138) data_.set_field(138, Math.Min(len, SET_VIDEO_STREAM_SETTINGS.uri_.item_len_max));
                return new uri_(data_);
            }

            public struct uri_
            {
                Pack.Cursor data_;
                public uri_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(uri_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void camera_id(sbyte src);
                void framerate(float src);
                void resolution_h(short src);
                void resolution_v(short src);
                void bitrate(int src);
                void rotation(short src);
                void uri(SET_VIDEO_STREAM_SETTINGS.uri_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(22, 3, 1, 0, 18, 1, 138, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.camera_id(camera_id()) ;
                dst.framerate(framerate()) ;
                dst.resolution_h(resolution_h()) ;
                dst.resolution_v(resolution_v()) ;
                dst.bitrate(bitrate()) ;
                dst.rotation(rotation()) ;
                {
                    var item = uri();
                    if(item.HasValue) dst.uri(item.Value);
                }
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                sbyte camera_id();
                float framerate();
                short resolution_h();
                short resolution_v();
                int bitrate();
                short rotation();
                int uri_exist() ;
                void uri(SET_VIDEO_STREAM_SETTINGS.uri_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                camera_id(src.camera_id());
                framerate(src.framerate());
                resolution_h(src.resolution_h());
                resolution_v(src.resolution_v());
                bitrate(src.bitrate());
                rotation(src.rotation());
                {
                    var len = src.uri_exist();
                    if(0 < len)
                        src.uri(uri(len));
                }
            }



        }
        /**
        *Configure AP SSID and Password. */

        public struct WIFI_CONFIG_AP
        {
            internal Pack.Cursor data_;
            internal WIFI_CONFIG_AP(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                ssid = 2,
                password = 3
            }




            public ssid_? ssid()
            {
                if(data_.field_bit !=  2 && !data_.set_field(2, -1))  return (ssid_?) null;
                return new ssid_(data_);
            }



            public char[] ssid(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  2) data_.set_field(2, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), WIFI_CONFIG_AP.ssid_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void ssid(byte[] src)
            {
                var len = Math.Min(src.Length, WIFI_CONFIG_AP.ssid_.item_len_max);
                if(data_.field_bit !=  2) data_.set_field(2, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public ssid_ ssid(int len)
            {
                if(data_.field_bit !=  2) data_.set_field(2, Math.Min(len, WIFI_CONFIG_AP.ssid_.item_len_max));
                return new ssid_(data_);
            }

            public struct ssid_
            {
                Pack.Cursor data_;
                public ssid_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(ssid_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public password_? password()
            {
                if(data_.field_bit !=  3 && !data_.set_field(3, -1))  return (password_?) null;
                return new password_(data_);
            }



            public char[] password(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  3) data_.set_field(3, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), WIFI_CONFIG_AP.password_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void password(byte[] src)
            {
                var len = Math.Min(src.Length, WIFI_CONFIG_AP.password_.item_len_max);
                if(data_.field_bit !=  3) data_.set_field(3, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public password_ password(int len)
            {
                if(data_.field_bit !=  3) data_.set_field(3, Math.Min(len, WIFI_CONFIG_AP.password_.item_len_max));
                return new password_(data_);
            }

            public struct password_
            {
                Pack.Cursor data_;
                public password_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(password_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void ssid(WIFI_CONFIG_AP.ssid_ src);
                void password(WIFI_CONFIG_AP.password_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(194, 0, 0, 0, 1, 1, 2, 2, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = ssid();
                    if(item.HasValue) dst.ssid(item.Value);
                }
                {
                    var item = password();
                    if(item.HasValue) dst.password(item.Value);
                }
            }

            public interface SRC_
            {
                int ssid_exist() ;
                void ssid(WIFI_CONFIG_AP.ssid_ dst) ;
                int password_exist() ;
                void password(WIFI_CONFIG_AP.password_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var len = src.ssid_exist();
                    if(0 < len)
                        src.ssid(ssid(len));
                }
                {
                    var len = src.password_exist();
                    if(0 < len)
                        src.password(password(len));
                }
            }



        }
        /**
        *WIP: Version and capability of protocol version. This message is the response to REQUEST_PROTOCOL_VERSION
        *				 and is used as part of the handshaking to establish which MAVLink version should be used on the network.
        *				 Every node should respond to REQUEST_PROTOCOL_VERSION to enable the handshaking. Library implementers
        *				 should consider adding this into the default decoding state machine to allow the protocol core to respond
        *				 directly */

        public struct PROTOCOL_VERSION
        {
            internal Pack.Cursor data_;
            internal PROTOCOL_VERSION(Pack.Cursor data) { this.data_ = data; }




            public short version() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void version(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short min_version() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void min_version(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short max_version() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void max_version(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public spec_version_hash_ spec_version_hash()
            {
                return new  spec_version_hash_(data_);
            }

            public struct spec_version_hash_
            {
                internal Pack.Cursor data_;
                public spec_version_hash_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return PROTOCOL_VERSION.spec_version_hash_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 6 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != PROTOCOL_VERSION.spec_version_hash_.item_len) return false;
                    for(int i = 0; i < PROTOCOL_VERSION.spec_version_hash_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(spec_version_hash_ other)
                {
                    if(other.len() != PROTOCOL_VERSION.spec_version_hash_.item_len) return false;
                    for(int i = 0; i < PROTOCOL_VERSION.spec_version_hash_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 6 + index] = (byte)(src); }

                public const int item_len = 8 ;


            }

            public void spec_version_hash(sbyte[] src)
            {
                var len =  Math.Min(src.Length, PROTOCOL_VERSION.spec_version_hash_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 6 + index] = (byte)(src[index]);
            }

            public library_version_hash_ library_version_hash()
            {
                return new  library_version_hash_(data_);
            }

            public struct library_version_hash_
            {
                internal Pack.Cursor data_;
                public library_version_hash_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return PROTOCOL_VERSION.library_version_hash_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 14 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != PROTOCOL_VERSION.library_version_hash_.item_len) return false;
                    for(int i = 0; i < PROTOCOL_VERSION.library_version_hash_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(library_version_hash_ other)
                {
                    if(other.len() != PROTOCOL_VERSION.library_version_hash_.item_len) return false;
                    for(int i = 0; i < PROTOCOL_VERSION.library_version_hash_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 14 + index] = (byte)(src); }

                public const int item_len = 8 ;


            }

            public void library_version_hash(sbyte[] src)
            {
                var len =  Math.Min(src.Length, PROTOCOL_VERSION.library_version_hash_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 14 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void version(short src);
                void min_version(short src);
                void max_version(short src);
                void spec_version_hash(PROTOCOL_VERSION.spec_version_hash_ src);
                void library_version_hash(PROTOCOL_VERSION.library_version_hash_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(150, 3, 0, 0, 22, 1, 176);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.version(version()) ;
                dst.min_version(min_version()) ;
                dst.max_version(max_version()) ;
                dst.spec_version_hash(spec_version_hash());
                dst.library_version_hash(library_version_hash());
            }

            public interface SRC_
            {
                short version();
                short min_version();
                short max_version();
                void spec_version_hash(PROTOCOL_VERSION.spec_version_hash_ dst) ;
                void library_version_hash(PROTOCOL_VERSION.library_version_hash_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                version(src.version());
                min_version(src.min_version());
                max_version(src.max_version());
                src.spec_version_hash(spec_version_hash());
                src.library_version_hash(library_version_hash());
            }



        }
        /**
        *General status information of an UAVCAN node. Please refer to the definition of the UAVCAN message "uavcan.protocol.NodeStatus"
        *				 for the background information. The UAVCAN specification is available at http:uavcan.org */

        public struct UAVCAN_NODE_STATUS
        {
            internal Pack.Cursor data_;
            internal UAVCAN_NODE_STATUS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                health = 120,
                mode = 121
            }



            public short vendor_specific_status_code() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void vendor_specific_status_code(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int uptime_sec() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void uptime_sec(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 6);  }

            public sbyte sub_mode() { return (sbyte)(data_.bytes[data_.origin  + 14]); }
            public void sub_mode(sbyte src) {    data_.bytes[data_.origin  + 14] = (byte)(src);  }


            public  UAVCAN_NODE_HEALTH? health()
            {
                if(data_.field_bit !=  120 && !data_.set_field(120, -1))  return null;
                return (UAVCAN_NODE_HEALTH)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 2)));;
            }


            public void health(UAVCAN_NODE_HEALTH src)
            {
                if(data_.field_bit !=  120) data_.set_field(120, 0);
                ;
                Lib.set_bits((ulong)(src), 2, data_.bytes, data_.BIT);;
            }




            public  UAVCAN_NODE_MODE? mode()
            {
                if(data_.field_bit !=  121 && !data_.set_field(121, -1))  return null;
                return    UAVCAN_NODE_MODE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }


            public void mode(UAVCAN_NODE_MODE src)
            {
                if(data_.field_bit !=  121) data_.set_field(121, 0);
                ;
                Lib.set_bits(UAVCAN_NODE_MODE_.bits(src), 3, data_.bytes, data_.BIT) ;;
            }





            public interface DST_
            {
                void time_usec(long src);
                void uptime_sec(int src);
                void health(com.company.demo.GroundControl. UAVCAN_NODE_HEALTH src);
                void mode(com.company.demo.GroundControl. UAVCAN_NODE_MODE src);
                void sub_mode(sbyte src);
                void vendor_specific_status_code(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(68, 1, 1, 1, 16, 1, 120, 0, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.uptime_sec(uptime_sec()) ;
                {
                    var item = health();
                    if(item.HasValue) dst.health(item.Value);
                }
                {
                    var item = mode();
                    if(item.HasValue) dst.mode(item.Value);
                }
                dst.sub_mode(sub_mode()) ;
                dst.vendor_specific_status_code(vendor_specific_status_code()) ;
            }

            public interface SRC_
            {
                long time_usec();
                int uptime_sec();
                com.company.demo.GroundControl. UAVCAN_NODE_HEALTH?  health();
                com.company.demo.GroundControl. UAVCAN_NODE_MODE?  mode();
                sbyte sub_mode();
                short vendor_specific_status_code();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                uptime_sec(src.uptime_sec());
                {
                    var item = src.health();
                    if(item.HasValue)     health(item.Value);
                }
                {
                    var item = src.mode();
                    if(item.HasValue)     mode(item.Value);
                }
                sub_mode(src.sub_mode());
                vendor_specific_status_code(src.vendor_specific_status_code());
            }



        }
        /**
        *General information describing a particular UAVCAN node. Please refer to the definition of the UAVCAN
        *				 service "uavcan.protocol.GetNodeInfo" for the background information. This message should be emitted
        *				 by the system whenever a new node appears online, or an existing node reboots. Additionally, it can be
        *				 emitted upon request from the other end of the MAVLink channel (see MAV_CMD_UAVCAN_GET_NODE_INFO). It
        *				 is also not prohibited to emit this message unconditionally at a low frequency. The UAVCAN specification
        *				 is available at http:uavcan.org */

        public struct UAVCAN_NODE_INFO
        {
            internal Pack.Cursor data_;
            internal UAVCAN_NODE_INFO(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                name = 290
            }



            public int uptime_sec() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void uptime_sec(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public int sw_vcs_commit() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 4)); }
            public void sw_vcs_commit(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 4);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 8);  }

            public sbyte hw_version_major() { return (sbyte)(data_.bytes[data_.origin  + 16]); }
            public void hw_version_major(sbyte src) {    data_.bytes[data_.origin  + 16] = (byte)(src);  }

            public sbyte hw_version_minor() { return (sbyte)(data_.bytes[data_.origin  + 17]); }
            public void hw_version_minor(sbyte src) {    data_.bytes[data_.origin  + 17] = (byte)(src);  }

            public hw_unique_id_ hw_unique_id()
            {
                return new  hw_unique_id_(data_);
            }

            public struct hw_unique_id_
            {
                internal Pack.Cursor data_;
                public hw_unique_id_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return UAVCAN_NODE_INFO.hw_unique_id_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 18 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != UAVCAN_NODE_INFO.hw_unique_id_.item_len) return false;
                    for(int i = 0; i < UAVCAN_NODE_INFO.hw_unique_id_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(hw_unique_id_ other)
                {
                    if(other.len() != UAVCAN_NODE_INFO.hw_unique_id_.item_len) return false;
                    for(int i = 0; i < UAVCAN_NODE_INFO.hw_unique_id_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 18 + index] = (byte)(src); }

                public const int item_len = 16 ;


            }

            public void hw_unique_id(sbyte[] src)
            {
                var len =  Math.Min(src.Length, UAVCAN_NODE_INFO.hw_unique_id_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 18 + index] = (byte)(src[index]);
            }

            public sbyte sw_version_major() { return (sbyte)(data_.bytes[data_.origin  + 34]); }
            public void sw_version_major(sbyte src) {    data_.bytes[data_.origin  + 34] = (byte)(src);  }

            public sbyte sw_version_minor() { return (sbyte)(data_.bytes[data_.origin  + 35]); }
            public void sw_version_minor(sbyte src) {    data_.bytes[data_.origin  + 35] = (byte)(src);  }


            public name_? name()
            {
                if(data_.field_bit !=  290 && !data_.set_field(290, -1))  return (name_?) null;
                return new name_(data_);
            }



            public char[] name(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  290) data_.set_field(290, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), UAVCAN_NODE_INFO.name_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void name(byte[] src)
            {
                var len = Math.Min(src.Length, UAVCAN_NODE_INFO.name_.item_len_max);
                if(data_.field_bit !=  290) data_.set_field(290, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public name_ name(int len)
            {
                if(data_.field_bit !=  290) data_.set_field(290, Math.Min(len, UAVCAN_NODE_INFO.name_.item_len_max));
                return new name_(data_);
            }

            public struct name_
            {
                Pack.Cursor data_;
                public name_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(name_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void time_usec(long src);
                void uptime_sec(int src);
                void name(UAVCAN_NODE_INFO.name_ src);
                void hw_version_major(sbyte src);
                void hw_version_minor(sbyte src);
                void hw_unique_id(UAVCAN_NODE_INFO.hw_unique_id_ src);
                void sw_version_major(sbyte src);
                void sw_version_minor(sbyte src);
                void sw_vcs_commit(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(127, 0, 2, 1, 37, 1, 290, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.uptime_sec(uptime_sec()) ;
                {
                    var item = name();
                    if(item.HasValue) dst.name(item.Value);
                }
                dst.hw_version_major(hw_version_major()) ;
                dst.hw_version_minor(hw_version_minor()) ;
                dst.hw_unique_id(hw_unique_id());
                dst.sw_version_major(sw_version_major()) ;
                dst.sw_version_minor(sw_version_minor()) ;
                dst.sw_vcs_commit(sw_vcs_commit()) ;
            }

            public interface SRC_
            {
                long time_usec();
                int uptime_sec();
                int name_exist() ;
                void name(UAVCAN_NODE_INFO.name_ dst) ;
                sbyte hw_version_major();
                sbyte hw_version_minor();
                void hw_unique_id(UAVCAN_NODE_INFO.hw_unique_id_ dst) ;
                sbyte sw_version_major();
                sbyte sw_version_minor();
                int sw_vcs_commit();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                uptime_sec(src.uptime_sec());
                {
                    var len = src.name_exist();
                    if(0 < len)
                        src.name(name(len));
                }
                hw_version_major(src.hw_version_major());
                hw_version_minor(src.hw_version_minor());
                src.hw_unique_id(hw_unique_id());
                sw_version_major(src.sw_version_major());
                sw_version_minor(src.sw_version_minor());
                sw_vcs_commit(src.sw_vcs_commit());
            }



        }
        /**
        *Request to read the value of a parameter with the either the param_id string id or param_index. */

        public struct PARAM_EXT_REQUEST_READ
        {
            internal Pack.Cursor data_;
            internal PARAM_EXT_REQUEST_READ(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                param_id = 34
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public short param_index() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void param_index(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }


            public param_id_? param_id()
            {
                if(data_.field_bit !=  34 && !data_.set_field(34, -1))  return (param_id_?) null;
                return new param_id_(data_);
            }



            public char[] param_id(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  34) data_.set_field(34, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PARAM_EXT_REQUEST_READ.param_id_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void param_id(byte[] src)
            {
                var len = Math.Min(src.Length, PARAM_EXT_REQUEST_READ.param_id_.item_len_max);
                if(data_.field_bit !=  34) data_.set_field(34, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public param_id_ param_id(int len)
            {
                if(data_.field_bit !=  34) data_.set_field(34, Math.Min(len, PARAM_EXT_REQUEST_READ.param_id_.item_len_max));
                return new param_id_(data_);
            }

            public struct param_id_
            {
                Pack.Cursor data_;
                public param_id_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(param_id_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void param_id(PARAM_EXT_REQUEST_READ.param_id_ src);
                void param_index(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(90, 0, 0, 0, 5, 1, 34, 2, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = param_id();
                    if(item.HasValue) dst.param_id(item.Value);
                }
                dst.param_index(param_index()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                int param_id_exist() ;
                void param_id(PARAM_EXT_REQUEST_READ.param_id_ dst) ;
                short param_index();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                {
                    var len = src.param_id_exist();
                    if(0 < len)
                        src.param_id(param_id(len));
                }
                param_index(src.param_index());
            }



        }
        /**
        *Request all parameters of this component. After this request, all parameters are emitted. */

        public struct PARAM_EXT_REQUEST_LIST
        {
            internal Pack.Cursor data_;
            internal PARAM_EXT_REQUEST_LIST(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(80, 0, 0, 0, 2, 1, 16);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
            }



        }
        /**
        *Emit the value of a parameter. The inclusion of param_count and param_index in the message allows the
        *				 recipient to keep track of received parameters and allows them to re-request missing parameters after
        *				 a loss or timeout */

        public struct PARAM_EXT_VALUE
        {
            internal Pack.Cursor data_;
            internal PARAM_EXT_VALUE(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                param_id = 35,
                param_value = 36,
                param_type = 37
            }



            public short param_count() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void param_count(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short param_index() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void param_index(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }


            public param_id_? param_id()
            {
                if(data_.field_bit !=  35 && !data_.set_field(35, -1))  return (param_id_?) null;
                return new param_id_(data_);
            }



            public char[] param_id(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  35) data_.set_field(35, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PARAM_EXT_VALUE.param_id_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void param_id(byte[] src)
            {
                var len = Math.Min(src.Length, PARAM_EXT_VALUE.param_id_.item_len_max);
                if(data_.field_bit !=  35) data_.set_field(35, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public param_id_ param_id(int len)
            {
                if(data_.field_bit !=  35) data_.set_field(35, Math.Min(len, PARAM_EXT_VALUE.param_id_.item_len_max));
                return new param_id_(data_);
            }

            public struct param_id_
            {
                Pack.Cursor data_;
                public param_id_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(param_id_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public param_value_? param_value()
            {
                if(data_.field_bit !=  36 && !data_.set_field(36, -1))  return (param_value_?) null;
                return new param_value_(data_);
            }



            public char[] param_value(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  36) data_.set_field(36, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PARAM_EXT_VALUE.param_value_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void param_value(byte[] src)
            {
                var len = Math.Min(src.Length, PARAM_EXT_VALUE.param_value_.item_len_max);
                if(data_.field_bit !=  36) data_.set_field(36, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public param_value_ param_value(int len)
            {
                if(data_.field_bit !=  36) data_.set_field(36, Math.Min(len, PARAM_EXT_VALUE.param_value_.item_len_max));
                return new param_value_(data_);
            }

            public struct param_value_
            {
                Pack.Cursor data_;
                public param_value_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(param_value_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public  MAV_PARAM_EXT_TYPE? param_type()
            {
                if(data_.field_bit !=  37 && !data_.set_field(37, -1))  return null;
                return (MAV_PARAM_EXT_TYPE)((1 + (sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }


            public void param_type(MAV_PARAM_EXT_TYPE src)
            {
                if(data_.field_bit !=  37) data_.set_field(37, 0);
                ;
                Lib.set_bits((ulong)(src   - 1), 4, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void param_id(PARAM_EXT_VALUE.param_id_ src);
                void param_value(PARAM_EXT_VALUE.param_value_ src);
                void param_type(com.company.demo.GroundControl. MAV_PARAM_EXT_TYPE src);
                void param_count(short src);
                void param_index(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(14, 2, 0, 0, 5, 1, 35, 3, 0, 3);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = param_id();
                    if(item.HasValue) dst.param_id(item.Value);
                }
                {
                    var item = param_value();
                    if(item.HasValue) dst.param_value(item.Value);
                }
                {
                    var item = param_type();
                    if(item.HasValue) dst.param_type(item.Value);
                }
                dst.param_count(param_count()) ;
                dst.param_index(param_index()) ;
            }

            public interface SRC_
            {
                int param_id_exist() ;
                void param_id(PARAM_EXT_VALUE.param_id_ dst) ;
                int param_value_exist() ;
                void param_value(PARAM_EXT_VALUE.param_value_ dst) ;
                com.company.demo.GroundControl. MAV_PARAM_EXT_TYPE?  param_type();
                short param_count();
                short param_index();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var len = src.param_id_exist();
                    if(0 < len)
                        src.param_id(param_id(len));
                }
                {
                    var len = src.param_value_exist();
                    if(0 < len)
                        src.param_value(param_value(len));
                }
                {
                    var item = src.param_type();
                    if(item.HasValue)     param_type(item.Value);
                }
                param_count(src.param_count());
                param_index(src.param_index());
            }



        }
        /**
        *Set a parameter value. In order to deal with message loss (and retransmission of PARAM_EXT_SET), when
        *				 setting a parameter value and the new value is the same as the current value, you will immediately get
        *				 a PARAM_ACK_ACCEPTED response. If the current state is PARAM_ACK_IN_PROGRESS, you will accordingly receive
        *				 a PARAM_ACK_IN_PROGRESS in response */

        public struct PARAM_EXT_SET
        {
            internal Pack.Cursor data_;
            internal PARAM_EXT_SET(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                param_id = 19,
                param_value = 20,
                param_type = 21
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }


            public param_id_? param_id()
            {
                if(data_.field_bit !=  19 && !data_.set_field(19, -1))  return (param_id_?) null;
                return new param_id_(data_);
            }



            public char[] param_id(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  19) data_.set_field(19, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PARAM_EXT_SET.param_id_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void param_id(byte[] src)
            {
                var len = Math.Min(src.Length, PARAM_EXT_SET.param_id_.item_len_max);
                if(data_.field_bit !=  19) data_.set_field(19, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public param_id_ param_id(int len)
            {
                if(data_.field_bit !=  19) data_.set_field(19, Math.Min(len, PARAM_EXT_SET.param_id_.item_len_max));
                return new param_id_(data_);
            }

            public struct param_id_
            {
                Pack.Cursor data_;
                public param_id_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(param_id_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public param_value_? param_value()
            {
                if(data_.field_bit !=  20 && !data_.set_field(20, -1))  return (param_value_?) null;
                return new param_value_(data_);
            }



            public char[] param_value(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  20) data_.set_field(20, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PARAM_EXT_SET.param_value_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void param_value(byte[] src)
            {
                var len = Math.Min(src.Length, PARAM_EXT_SET.param_value_.item_len_max);
                if(data_.field_bit !=  20) data_.set_field(20, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public param_value_ param_value(int len)
            {
                if(data_.field_bit !=  20) data_.set_field(20, Math.Min(len, PARAM_EXT_SET.param_value_.item_len_max));
                return new param_value_(data_);
            }

            public struct param_value_
            {
                Pack.Cursor data_;
                public param_value_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(param_value_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public  MAV_PARAM_EXT_TYPE? param_type()
            {
                if(data_.field_bit !=  21 && !data_.set_field(21, -1))  return null;
                return (MAV_PARAM_EXT_TYPE)((1 + (sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }


            public void param_type(MAV_PARAM_EXT_TYPE src)
            {
                if(data_.field_bit !=  21) data_.set_field(21, 0);
                ;
                Lib.set_bits((ulong)(src   - 1), 4, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void param_id(PARAM_EXT_SET.param_id_ src);
                void param_value(PARAM_EXT_SET.param_value_ src);
                void param_type(com.company.demo.GroundControl. MAV_PARAM_EXT_TYPE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(109, 0, 0, 0, 3, 1, 19, 3, 0, 3);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = param_id();
                    if(item.HasValue) dst.param_id(item.Value);
                }
                {
                    var item = param_value();
                    if(item.HasValue) dst.param_value(item.Value);
                }
                {
                    var item = param_type();
                    if(item.HasValue) dst.param_type(item.Value);
                }
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                int param_id_exist() ;
                void param_id(PARAM_EXT_SET.param_id_ dst) ;
                int param_value_exist() ;
                void param_value(PARAM_EXT_SET.param_value_ dst) ;
                com.company.demo.GroundControl. MAV_PARAM_EXT_TYPE?  param_type();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                {
                    var len = src.param_id_exist();
                    if(0 < len)
                        src.param_id(param_id(len));
                }
                {
                    var len = src.param_value_exist();
                    if(0 < len)
                        src.param_value(param_value(len));
                }
                {
                    var item = src.param_type();
                    if(item.HasValue)     param_type(item.Value);
                }
            }



        }
        /**
        *Response from a PARAM_EXT_SET message. */

        public struct PARAM_EXT_ACK
        {
            internal Pack.Cursor data_;
            internal PARAM_EXT_ACK(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                param_id = 3,
                param_value = 4,
                param_type = 5,
                param_result = 6
            }




            public param_id_? param_id()
            {
                if(data_.field_bit !=  3 && !data_.set_field(3, -1))  return (param_id_?) null;
                return new param_id_(data_);
            }



            public char[] param_id(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  3) data_.set_field(3, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PARAM_EXT_ACK.param_id_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void param_id(byte[] src)
            {
                var len = Math.Min(src.Length, PARAM_EXT_ACK.param_id_.item_len_max);
                if(data_.field_bit !=  3) data_.set_field(3, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public param_id_ param_id(int len)
            {
                if(data_.field_bit !=  3) data_.set_field(3, Math.Min(len, PARAM_EXT_ACK.param_id_.item_len_max));
                return new param_id_(data_);
            }

            public struct param_id_
            {
                Pack.Cursor data_;
                public param_id_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(param_id_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public param_value_? param_value()
            {
                if(data_.field_bit !=  4 && !data_.set_field(4, -1))  return (param_value_?) null;
                return new param_value_(data_);
            }



            public char[] param_value(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  4) data_.set_field(4, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), PARAM_EXT_ACK.param_value_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void param_value(byte[] src)
            {
                var len = Math.Min(src.Length, PARAM_EXT_ACK.param_value_.item_len_max);
                if(data_.field_bit !=  4) data_.set_field(4, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public param_value_ param_value(int len)
            {
                if(data_.field_bit !=  4) data_.set_field(4, Math.Min(len, PARAM_EXT_ACK.param_value_.item_len_max));
                return new param_value_(data_);
            }

            public struct param_value_
            {
                Pack.Cursor data_;
                public param_value_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(param_value_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public  MAV_PARAM_EXT_TYPE? param_type()
            {
                if(data_.field_bit !=  5 && !data_.set_field(5, -1))  return null;
                return (MAV_PARAM_EXT_TYPE)((1 + (sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }


            public void param_type(MAV_PARAM_EXT_TYPE src)
            {
                if(data_.field_bit !=  5) data_.set_field(5, 0);
                ;
                Lib.set_bits((ulong)(src   - 1), 4, data_.bytes, data_.BIT);;
            }




            public  PARAM_ACK? param_result()
            {
                if(data_.field_bit !=  6 && !data_.set_field(6, -1))  return null;
                return (PARAM_ACK)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 2)));;
            }


            public void param_result(PARAM_ACK src)
            {
                if(data_.field_bit !=  6) data_.set_field(6, 0);
                ;
                Lib.set_bits((ulong)(src), 2, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void param_id(PARAM_EXT_ACK.param_id_ src);
                void param_value(PARAM_EXT_ACK.param_value_ src);
                void param_type(com.company.demo.GroundControl. MAV_PARAM_EXT_TYPE src);
                void param_result(com.company.demo.GroundControl. PARAM_ACK src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(51, 0, 0, 0, 1, 1, 3, 3, 0, 4);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = param_id();
                    if(item.HasValue) dst.param_id(item.Value);
                }
                {
                    var item = param_value();
                    if(item.HasValue) dst.param_value(item.Value);
                }
                {
                    var item = param_type();
                    if(item.HasValue) dst.param_type(item.Value);
                }
                {
                    var item = param_result();
                    if(item.HasValue) dst.param_result(item.Value);
                }
            }

            public interface SRC_
            {
                int param_id_exist() ;
                void param_id(PARAM_EXT_ACK.param_id_ dst) ;
                int param_value_exist() ;
                void param_value(PARAM_EXT_ACK.param_value_ dst) ;
                com.company.demo.GroundControl. MAV_PARAM_EXT_TYPE?  param_type();
                com.company.demo.GroundControl. PARAM_ACK?  param_result();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var len = src.param_id_exist();
                    if(0 < len)
                        src.param_id(param_id(len));
                }
                {
                    var len = src.param_value_exist();
                    if(0 < len)
                        src.param_value(param_value(len));
                }
                {
                    var item = src.param_type();
                    if(item.HasValue)     param_type(item.Value);
                }
                {
                    var item = src.param_result();
                    if(item.HasValue)     param_result(item.Value);
                }
            }



        }
        /**
        *Obstacle distances in front of the sensor, starting from the left in increment degrees to the right */

        public struct OBSTACLE_DISTANCE
        {
            internal Pack.Cursor data_;
            internal OBSTACLE_DISTANCE(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                sensor_type = 1256
            }



            public distances_ distances()
            {
                return new  distances_(data_);
            }

            public struct distances_
            {
                internal Pack.Cursor data_;
                public distances_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return OBSTACLE_DISTANCE.distances_.item_len  ;}
                public short get(int index) { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + index * 2, 2)); }

                public bool same(short[] other)
                {
                    if(other.Length != OBSTACLE_DISTANCE.distances_.item_len) return false;
                    for(int i = 0; i < OBSTACLE_DISTANCE.distances_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(distances_ other)
                {
                    if(other.len() != OBSTACLE_DISTANCE.distances_.item_len) return false;
                    for(int i = 0; i < OBSTACLE_DISTANCE.distances_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(short src, int index) { Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + index * 2); }

                public const int item_len = 72 ;


            }

            public void distances(short[] src)
            {
                var len =  Math.Min(src.Length, OBSTACLE_DISTANCE.distances_.item_len);
                for(int index = 0; index < len; index++)
                    Lib.set_bytes((ulong)(src[index]), 2, data_.bytes,  data_.origin  + index * 2);
            }

            public short min_distance() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 144, 2)); }
            public void min_distance(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 144);  }

            public short max_distance() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 146, 2)); }
            public void max_distance(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 146);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 148, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 148);  }

            public sbyte increment() { return (sbyte)(data_.bytes[data_.origin  + 156]); }
            public void increment(sbyte src) {    data_.bytes[data_.origin  + 156] = (byte)(src);  }


            public  MAV_DISTANCE_SENSOR? sensor_type()
            {
                if(data_.field_bit !=  1256 && !data_.set_field(1256, -1))  return null;
                return (MAV_DISTANCE_SENSOR)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void sensor_type(MAV_DISTANCE_SENSOR src)
            {
                if(data_.field_bit !=  1256) data_.set_field(1256, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void time_usec(long src);
                void sensor_type(com.company.demo.GroundControl. MAV_DISTANCE_SENSOR src);
                void distances(OBSTACLE_DISTANCE.distances_ src);
                void increment(sbyte src);
                void min_distance(short src);
                void max_distance(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(66, 74, 0, 1, 158, 1, 1256, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                {
                    var item = sensor_type();
                    if(item.HasValue) dst.sensor_type(item.Value);
                }
                dst.distances(distances());
                dst.increment(increment()) ;
                dst.min_distance(min_distance()) ;
                dst.max_distance(max_distance()) ;
            }

            public interface SRC_
            {
                long time_usec();
                com.company.demo.GroundControl. MAV_DISTANCE_SENSOR?  sensor_type();
                void distances(OBSTACLE_DISTANCE.distances_ dst) ;
                sbyte increment();
                short min_distance();
                short max_distance();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                {
                    var item = src.sensor_type();
                    if(item.HasValue)     sensor_type(item.Value);
                }
                src.distances(distances());
                increment(src.increment());
                min_distance(src.min_distance());
                max_distance(src.max_distance());
            }



        }
        /**
        *Static data to configure the ADS-B transponder (send within 10 sec of a POR and every 10 sec thereafter */

        public struct UAVIONIX_ADSB_OUT_CFG
        {
            internal Pack.Cursor data_;
            internal UAVIONIX_ADSB_OUT_CFG(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                callsign = 51,
                emitterType = 52,
                aircraftSize = 53,
                gpsOffsetLat = 54,
                gpsOffsetLon = 55,
                rfSelect = 56
            }



            public short stallSpeed() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void stallSpeed(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int ICAO() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void ICAO(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }


            public callsign_? callsign()
            {
                if(data_.field_bit !=  51 && !data_.set_field(51, -1))  return (callsign_?) null;
                return new callsign_(data_);
            }



            public char[] callsign(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  51) data_.set_field(51, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), UAVIONIX_ADSB_OUT_CFG.callsign_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void callsign(byte[] src)
            {
                var len = Math.Min(src.Length, UAVIONIX_ADSB_OUT_CFG.callsign_.item_len_max);
                if(data_.field_bit !=  51) data_.set_field(51, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public callsign_ callsign(int len)
            {
                if(data_.field_bit !=  51) data_.set_field(51, Math.Min(len, UAVIONIX_ADSB_OUT_CFG.callsign_.item_len_max));
                return new callsign_(data_);
            }

            public struct callsign_
            {
                Pack.Cursor data_;
                public callsign_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(callsign_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }



            public  ADSB_EMITTER_TYPE? emitterType()
            {
                if(data_.field_bit !=  52 && !data_.set_field(52, -1))  return null;
                return (ADSB_EMITTER_TYPE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 5)));;
            }


            public void emitterType(ADSB_EMITTER_TYPE src)
            {
                if(data_.field_bit !=  52) data_.set_field(52, 0);
                ;
                Lib.set_bits((ulong)(src), 5, data_.bytes, data_.BIT);;
            }




            public  UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE? aircraftSize()
            {
                if(data_.field_bit !=  53 && !data_.set_field(53, -1))  return null;
                return (UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 4)));;
            }


            public void aircraftSize(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE src)
            {
                if(data_.field_bit !=  53) data_.set_field(53, 0);
                ;
                Lib.set_bits((ulong)(src), 4, data_.bytes, data_.BIT);;
            }




            public  UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT? gpsOffsetLat()
            {
                if(data_.field_bit !=  54 && !data_.set_field(54, -1))  return null;
                return (UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void gpsOffsetLat(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT src)
            {
                if(data_.field_bit !=  54) data_.set_field(54, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }




            public  UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON? gpsOffsetLon()
            {
                if(data_.field_bit !=  55 && !data_.set_field(55, -1))  return null;
                return (UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 1)));;
            }


            public void gpsOffsetLon(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON src)
            {
                if(data_.field_bit !=  55) data_.set_field(55, 0);
                ;
                Lib.set_bits((ulong)(src), 1, data_.bytes, data_.BIT);;
            }




            public  UAVIONIX_ADSB_OUT_RF_SELECT? rfSelect()
            {
                if(data_.field_bit !=  56 && !data_.set_field(56, -1))  return null;
                return (UAVIONIX_ADSB_OUT_RF_SELECT)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 2)));;
            }


            public void rfSelect(UAVIONIX_ADSB_OUT_RF_SELECT src)
            {
                if(data_.field_bit !=  56) data_.set_field(56, 0);
                ;
                Lib.set_bits((ulong)(src), 2, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void ICAO(int src);
                void callsign(UAVIONIX_ADSB_OUT_CFG.callsign_ src);
                void emitterType(com.company.demo.GroundControl. ADSB_EMITTER_TYPE src);
                void aircraftSize(com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE src);
                void gpsOffsetLat(com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT src);
                void gpsOffsetLon(com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON src);
                void stallSpeed(short src);
                void rfSelect(com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_RF_SELECT src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(84, 1, 1, 0, 7, 1, 51, 3, 0, 6);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.ICAO(ICAO()) ;
                {
                    var item = callsign();
                    if(item.HasValue) dst.callsign(item.Value);
                }
                {
                    var item = emitterType();
                    if(item.HasValue) dst.emitterType(item.Value);
                }
                {
                    var item = aircraftSize();
                    if(item.HasValue) dst.aircraftSize(item.Value);
                }
                {
                    var item = gpsOffsetLat();
                    if(item.HasValue) dst.gpsOffsetLat(item.Value);
                }
                {
                    var item = gpsOffsetLon();
                    if(item.HasValue) dst.gpsOffsetLon(item.Value);
                }
                dst.stallSpeed(stallSpeed()) ;
                {
                    var item = rfSelect();
                    if(item.HasValue) dst.rfSelect(item.Value);
                }
            }

            public interface SRC_
            {
                int ICAO();
                int callsign_exist() ;
                void callsign(UAVIONIX_ADSB_OUT_CFG.callsign_ dst) ;
                com.company.demo.GroundControl. ADSB_EMITTER_TYPE?  emitterType();
                com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE?  aircraftSize();
                com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT?  gpsOffsetLat();
                com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON?  gpsOffsetLon();
                short stallSpeed();
                com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_RF_SELECT?  rfSelect();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                ICAO(src.ICAO());
                {
                    var len = src.callsign_exist();
                    if(0 < len)
                        src.callsign(callsign(len));
                }
                {
                    var item = src.emitterType();
                    if(item.HasValue)     emitterType(item.Value);
                }
                {
                    var item = src.aircraftSize();
                    if(item.HasValue)     aircraftSize(item.Value);
                }
                {
                    var item = src.gpsOffsetLat();
                    if(item.HasValue)     gpsOffsetLat(item.Value);
                }
                {
                    var item = src.gpsOffsetLon();
                    if(item.HasValue)     gpsOffsetLon(item.Value);
                }
                stallSpeed(src.stallSpeed());
                {
                    var item = src.rfSelect();
                    if(item.HasValue)     rfSelect(item.Value);
                }
            }



        }
        /**
        *Dynamic data used to generate ADS-B out transponder data (send at 5Hz) */

        public struct UAVIONIX_ADSB_OUT_DYNAMIC
        {
            internal Pack.Cursor data_;
            internal UAVIONIX_ADSB_OUT_DYNAMIC(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                gpsFix = 298,
                emergencyStatus = 299,
                state = 300
            }



            public short accuracyVert() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void accuracyVert(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short accuracyVel() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void accuracyVel(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short squawk() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void squawk(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public int utcTime() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void utcTime(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public int accuracyHor() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void accuracyHor(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }

            public int gpsLat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 4)); }
            public void gpsLat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 14);  }

            public int gpsLon() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 18, 4)); }
            public void gpsLon(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 18);  }

            public int gpsAlt() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 22, 4)); }
            public void gpsAlt(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 22);  }

            public sbyte numSats() { return (sbyte)(data_.bytes[data_.origin  + 26]); }
            public void numSats(sbyte src) {    data_.bytes[data_.origin  + 26] = (byte)(src);  }

            public int baroAltMSL() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 27, 4)); }
            public void baroAltMSL(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 27);  }

            public short velVert() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 31, 2)); }
            public void velVert(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 31);  }

            public short velNS() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 33, 2)); }
            public void velNS(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 33);  }

            public short VelEW() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 35, 2)); }
            public void VelEW(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 35);  }


            public  UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX? gpsFix()
            {
                if(data_.field_bit !=  298 && !data_.set_field(298, -1))  return null;
                return (UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void gpsFix(UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX src)
            {
                if(data_.field_bit !=  298) data_.set_field(298, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }




            public  UAVIONIX_ADSB_EMERGENCY_STATUS? emergencyStatus()
            {
                if(data_.field_bit !=  299 && !data_.set_field(299, -1))  return null;
                return (UAVIONIX_ADSB_EMERGENCY_STATUS)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void emergencyStatus(UAVIONIX_ADSB_EMERGENCY_STATUS src)
            {
                if(data_.field_bit !=  299) data_.set_field(299, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }




            public  UAVIONIX_ADSB_OUT_DYNAMIC_STATE? state()
            {
                if(data_.field_bit !=  300 && !data_.set_field(300, -1))  return null;
                return    UAVIONIX_ADSB_OUT_DYNAMIC_STATE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }


            public void state(UAVIONIX_ADSB_OUT_DYNAMIC_STATE src)
            {
                if(data_.field_bit !=  300) data_.set_field(300, 0);
                ;
                Lib.set_bits(UAVIONIX_ADSB_OUT_DYNAMIC_STATE_.bits(src), 3, data_.bytes, data_.BIT) ;;
            }





            public interface DST_
            {
                void utcTime(int src);
                void gpsLat(int src);
                void gpsLon(int src);
                void gpsAlt(int src);
                void gpsFix(com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX src);
                void numSats(sbyte src);
                void baroAltMSL(int src);
                void accuracyHor(int src);
                void accuracyVert(short src);
                void accuracyVel(short src);
                void velVert(short src);
                void velNS(short src);
                void VelEW(short src);
                void emergencyStatus(com.company.demo.GroundControl. UAVIONIX_ADSB_EMERGENCY_STATUS src);
                void state(com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_DYNAMIC_STATE src);
                void squawk(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(143, 3, 2, 0, 38, 1, 298, 2, 0, 3);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.utcTime(utcTime()) ;
                dst.gpsLat(gpsLat()) ;
                dst.gpsLon(gpsLon()) ;
                dst.gpsAlt(gpsAlt()) ;
                {
                    var item = gpsFix();
                    if(item.HasValue) dst.gpsFix(item.Value);
                }
                dst.numSats(numSats()) ;
                dst.baroAltMSL(baroAltMSL()) ;
                dst.accuracyHor(accuracyHor()) ;
                dst.accuracyVert(accuracyVert()) ;
                dst.accuracyVel(accuracyVel()) ;
                dst.velVert(velVert()) ;
                dst.velNS(velNS()) ;
                dst.VelEW(VelEW()) ;
                {
                    var item = emergencyStatus();
                    if(item.HasValue) dst.emergencyStatus(item.Value);
                }
                {
                    var item = state();
                    if(item.HasValue) dst.state(item.Value);
                }
                dst.squawk(squawk()) ;
            }

            public interface SRC_
            {
                int utcTime();
                int gpsLat();
                int gpsLon();
                int gpsAlt();
                com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX?  gpsFix();
                sbyte numSats();
                int baroAltMSL();
                int accuracyHor();
                short accuracyVert();
                short accuracyVel();
                short velVert();
                short velNS();
                short VelEW();
                com.company.demo.GroundControl. UAVIONIX_ADSB_EMERGENCY_STATUS?  emergencyStatus();
                com.company.demo.GroundControl. UAVIONIX_ADSB_OUT_DYNAMIC_STATE?  state();
                short squawk();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                utcTime(src.utcTime());
                gpsLat(src.gpsLat());
                gpsLon(src.gpsLon());
                gpsAlt(src.gpsAlt());
                {
                    var item = src.gpsFix();
                    if(item.HasValue)     gpsFix(item.Value);
                }
                numSats(src.numSats());
                baroAltMSL(src.baroAltMSL());
                accuracyHor(src.accuracyHor());
                accuracyVert(src.accuracyVert());
                accuracyVel(src.accuracyVel());
                velVert(src.velVert());
                velNS(src.velNS());
                VelEW(src.VelEW());
                {
                    var item = src.emergencyStatus();
                    if(item.HasValue)     emergencyStatus(item.Value);
                }
                {
                    var item = src.state();
                    if(item.HasValue)     state(item.Value);
                }
                squawk(src.squawk());
            }



        }
        /**
        *Transceiver heartbeat with health report (updated every 10s) */

        public struct UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT
        {
            internal Pack.Cursor data_;
            internal UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                rfHealth = 0
            }




            public  UAVIONIX_ADSB_RF_HEALTH? rfHealth()
            {
                if(data_.field_bit !=  0 && !data_.set_field(0, -1))  return null;
                return    UAVIONIX_ADSB_RF_HEALTH_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 3));;
            }


            public void rfHealth(UAVIONIX_ADSB_RF_HEALTH src)
            {
                if(data_.field_bit !=  0) data_.set_field(0, 0);
                ;
                Lib.set_bits(UAVIONIX_ADSB_RF_HEALTH_.bits(src), 3, data_.bytes, data_.BIT) ;;
            }





            public interface DST_
            {
                void rfHealth(com.company.demo.GroundControl. UAVIONIX_ADSB_RF_HEALTH src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(26, 0, 0, 0, 1, 1, 0, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = rfHealth();
                    if(item.HasValue) dst.rfHealth(item.Value);
                }
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. UAVIONIX_ADSB_RF_HEALTH?  rfHealth();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.rfHealth();
                    if(item.HasValue)     rfHealth(item.Value);
                }
            }



        }
        /**
        *Offsets and calibrations values for hardware sensors. This makes it easier to debug the calibration process */

        public struct SENSOR_OFFSETS
        {
            internal Pack.Cursor data_;
            internal SENSOR_OFFSETS(Pack.Cursor data) { this.data_ = data; }




            public short mag_ofs_x() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void mag_ofs_x(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short mag_ofs_y() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void mag_ofs_y(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short mag_ofs_z() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void mag_ofs_z(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public float mag_declination() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 6); }
            public void mag_declination(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 6, 4);  }

            public int raw_press() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void raw_press(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }

            public int raw_temp() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 4)); }
            public void raw_temp(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 14);  }

            public float gyro_cal_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 18); }
            public void gyro_cal_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 18, 4);  }

            public float gyro_cal_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 22); }
            public void gyro_cal_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 22, 4);  }

            public float gyro_cal_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 26); }
            public void gyro_cal_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 26, 4);  }

            public float accel_cal_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 30); }
            public void accel_cal_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 30, 4);  }

            public float accel_cal_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 34); }
            public void accel_cal_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 34, 4);  }

            public float accel_cal_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 38); }
            public void accel_cal_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 38, 4);  }



            public interface DST_
            {
                void mag_ofs_x(short src);
                void mag_ofs_y(short src);
                void mag_ofs_z(short src);
                void mag_declination(float src);
                void raw_press(int src);
                void raw_temp(int src);
                void gyro_cal_x(float src);
                void gyro_cal_y(float src);
                void gyro_cal_z(float src);
                void accel_cal_x(float src);
                void accel_cal_y(float src);
                void accel_cal_z(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(128, 0, 0, 0, 42, 1, 336);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.mag_ofs_x(mag_ofs_x()) ;
                dst.mag_ofs_y(mag_ofs_y()) ;
                dst.mag_ofs_z(mag_ofs_z()) ;
                dst.mag_declination(mag_declination()) ;
                dst.raw_press(raw_press()) ;
                dst.raw_temp(raw_temp()) ;
                dst.gyro_cal_x(gyro_cal_x()) ;
                dst.gyro_cal_y(gyro_cal_y()) ;
                dst.gyro_cal_z(gyro_cal_z()) ;
                dst.accel_cal_x(accel_cal_x()) ;
                dst.accel_cal_y(accel_cal_y()) ;
                dst.accel_cal_z(accel_cal_z()) ;
            }

            public interface SRC_
            {
                short mag_ofs_x();
                short mag_ofs_y();
                short mag_ofs_z();
                float mag_declination();
                int raw_press();
                int raw_temp();
                float gyro_cal_x();
                float gyro_cal_y();
                float gyro_cal_z();
                float accel_cal_x();
                float accel_cal_y();
                float accel_cal_z();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                mag_ofs_x(src.mag_ofs_x());
                mag_ofs_y(src.mag_ofs_y());
                mag_ofs_z(src.mag_ofs_z());
                mag_declination(src.mag_declination());
                raw_press(src.raw_press());
                raw_temp(src.raw_temp());
                gyro_cal_x(src.gyro_cal_x());
                gyro_cal_y(src.gyro_cal_y());
                gyro_cal_z(src.gyro_cal_z());
                accel_cal_x(src.accel_cal_x());
                accel_cal_y(src.accel_cal_y());
                accel_cal_z(src.accel_cal_z());
            }



        }
        /**
        *Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the magnetometer offsets */

        public struct SET_MAG_OFFSETS
        {
            internal Pack.Cursor data_;
            internal SET_MAG_OFFSETS(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public short mag_ofs_x() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void mag_ofs_x(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short mag_ofs_y() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void mag_ofs_y(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public short mag_ofs_z() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }
            public void mag_ofs_z(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 6);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void mag_ofs_x(short src);
                void mag_ofs_y(short src);
                void mag_ofs_z(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(100, 0, 0, 0, 8, 1, 64);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.mag_ofs_x(mag_ofs_x()) ;
                dst.mag_ofs_y(mag_ofs_y()) ;
                dst.mag_ofs_z(mag_ofs_z()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                short mag_ofs_x();
                short mag_ofs_y();
                short mag_ofs_z();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                mag_ofs_x(src.mag_ofs_x());
                mag_ofs_y(src.mag_ofs_y());
                mag_ofs_z(src.mag_ofs_z());
            }



        }
        /**
        *state of APM memory */

        public struct MEMINFO
        {
            internal Pack.Cursor data_;
            internal MEMINFO(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                freemem32 = 32
            }



            public short brkval() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void brkval(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short freemem() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void freemem(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }


            public int? freemem32()
            {
                if(data_.field_bit !=  32 && !data_.set_field(32, -1))  return null;
                return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.BYTE, 4));;
            }


            public void freemem32(int src)
            {
                if(data_.field_bit !=  32) data_.set_field(32, 0);
                ;
                Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.BYTE);;
            }





            public interface DST_
            {
                void brkval(short src);
                void freemem(short src);
                void freemem32(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(159, 2, 0, 0, 5, 1, 32, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.brkval(brkval()) ;
                dst.freemem(freemem()) ;
                {
                    var item = freemem32();
                    if(item.HasValue) dst.freemem32(item.Value);
                }
            }

            public interface SRC_
            {
                short brkval();
                short freemem();
                int?  freemem32();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                brkval(src.brkval());
                freemem(src.freemem());
                {
                    var item = src.freemem32();
                    if(item.HasValue)     freemem32(item.Value);
                }
            }



        }
        /**
        *raw ADC output */

        public struct AP_ADC
        {
            internal Pack.Cursor data_;
            internal AP_ADC(Pack.Cursor data) { this.data_ = data; }




            public short adc1() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void adc1(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short adc2() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void adc2(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short adc3() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void adc3(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public short adc4() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }
            public void adc4(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 6);  }

            public short adc5() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 2)); }
            public void adc5(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 8);  }

            public short adc6() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 2)); }
            public void adc6(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 10);  }



            public interface DST_
            {
                void adc1(short src);
                void adc2(short src);
                void adc3(short src);
                void adc4(short src);
                void adc5(short src);
                void adc6(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(198, 6, 0, 0, 12, 1, 96);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.adc1(adc1()) ;
                dst.adc2(adc2()) ;
                dst.adc3(adc3()) ;
                dst.adc4(adc4()) ;
                dst.adc5(adc5()) ;
                dst.adc6(adc6()) ;
            }

            public interface SRC_
            {
                short adc1();
                short adc2();
                short adc3();
                short adc4();
                short adc5();
                short adc6();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                adc1(src.adc1());
                adc2(src.adc2());
                adc3(src.adc3());
                adc4(src.adc4());
                adc5(src.adc5());
                adc6(src.adc6());
            }



        }
        /**
        *Configure on-board Camera Control System. */

        public struct DIGICAM_CONFIGURE
        {
            internal Pack.Cursor data_;
            internal DIGICAM_CONFIGURE(Pack.Cursor data) { this.data_ = data; }




            public short shutter_speed() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void shutter_speed(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }

            public sbyte mode() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void mode(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte aperture() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void aperture(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }

            public sbyte iso() { return (sbyte)(data_.bytes[data_.origin  + 6]); }
            public void iso(sbyte src) {    data_.bytes[data_.origin  + 6] = (byte)(src);  }

            public sbyte exposure_type() { return (sbyte)(data_.bytes[data_.origin  + 7]); }
            public void exposure_type(sbyte src) {    data_.bytes[data_.origin  + 7] = (byte)(src);  }

            public sbyte command_id() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void command_id(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }

            public sbyte engine_cut_off() { return (sbyte)(data_.bytes[data_.origin  + 9]); }
            public void engine_cut_off(sbyte src) {    data_.bytes[data_.origin  + 9] = (byte)(src);  }

            public sbyte extra_param() { return (sbyte)(data_.bytes[data_.origin  + 10]); }
            public void extra_param(sbyte src) {    data_.bytes[data_.origin  + 10] = (byte)(src);  }

            public float extra_value() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 11); }
            public void extra_value(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 11, 4);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void mode(sbyte src);
                void shutter_speed(short src);
                void aperture(sbyte src);
                void iso(sbyte src);
                void exposure_type(sbyte src);
                void command_id(sbyte src);
                void engine_cut_off(sbyte src);
                void extra_param(sbyte src);
                void extra_value(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(114, 1, 0, 0, 15, 1, 120);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.mode(mode()) ;
                dst.shutter_speed(shutter_speed()) ;
                dst.aperture(aperture()) ;
                dst.iso(iso()) ;
                dst.exposure_type(exposure_type()) ;
                dst.command_id(command_id()) ;
                dst.engine_cut_off(engine_cut_off()) ;
                dst.extra_param(extra_param()) ;
                dst.extra_value(extra_value()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                sbyte mode();
                short shutter_speed();
                sbyte aperture();
                sbyte iso();
                sbyte exposure_type();
                sbyte command_id();
                sbyte engine_cut_off();
                sbyte extra_param();
                float extra_value();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                mode(src.mode());
                shutter_speed(src.shutter_speed());
                aperture(src.aperture());
                iso(src.iso());
                exposure_type(src.exposure_type());
                command_id(src.command_id());
                engine_cut_off(src.engine_cut_off());
                extra_param(src.extra_param());
                extra_value(src.extra_value());
            }



        }
        /**
        *Control on-board Camera Control System to take shots. */

        public struct DIGICAM_CONTROL
        {
            internal Pack.Cursor data_;
            internal DIGICAM_CONTROL(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public sbyte session() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void session(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte zoom_pos() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void zoom_pos(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }

            public sbyte zoom_step() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void zoom_step(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte focus_lock() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void focus_lock(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }

            public sbyte shot() { return (sbyte)(data_.bytes[data_.origin  + 6]); }
            public void shot(sbyte src) {    data_.bytes[data_.origin  + 6] = (byte)(src);  }

            public sbyte command_id() { return (sbyte)(data_.bytes[data_.origin  + 7]); }
            public void command_id(sbyte src) {    data_.bytes[data_.origin  + 7] = (byte)(src);  }

            public sbyte extra_param() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void extra_param(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }

            public float extra_value() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 9); }
            public void extra_value(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 9, 4);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void session(sbyte src);
                void zoom_pos(sbyte src);
                void zoom_step(sbyte src);
                void focus_lock(sbyte src);
                void shot(sbyte src);
                void command_id(sbyte src);
                void extra_param(sbyte src);
                void extra_value(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(49, 0, 0, 0, 13, 1, 104);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.session(session()) ;
                dst.zoom_pos(zoom_pos()) ;
                dst.zoom_step(zoom_step()) ;
                dst.focus_lock(focus_lock()) ;
                dst.shot(shot()) ;
                dst.command_id(command_id()) ;
                dst.extra_param(extra_param()) ;
                dst.extra_value(extra_value()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                sbyte session();
                sbyte zoom_pos();
                sbyte zoom_step();
                sbyte focus_lock();
                sbyte shot();
                sbyte command_id();
                sbyte extra_param();
                float extra_value();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                session(src.session());
                zoom_pos(src.zoom_pos());
                zoom_step(src.zoom_step());
                focus_lock(src.focus_lock());
                shot(src.shot());
                command_id(src.command_id());
                extra_param(src.extra_param());
                extra_value(src.extra_value());
            }



        }
        /**
        *Message to configure a camera mount, directional antenna, etc. */

        public struct MOUNT_CONFIGURE
        {
            internal Pack.Cursor data_;
            internal MOUNT_CONFIGURE(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                mount_mode = 40
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public sbyte stab_roll() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void stab_roll(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte stab_pitch() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void stab_pitch(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }

            public sbyte stab_yaw() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void stab_yaw(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }


            public  MAV_MOUNT_MODE? mount_mode()
            {
                if(data_.field_bit !=  40 && !data_.set_field(40, -1))  return null;
                return (MAV_MOUNT_MODE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void mount_mode(MAV_MOUNT_MODE src)
            {
                if(data_.field_bit !=  40) data_.set_field(40, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void mount_mode(com.company.demo.GroundControl. MAV_MOUNT_MODE src);
                void stab_roll(sbyte src);
                void stab_pitch(sbyte src);
                void stab_yaw(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(40, 0, 0, 0, 6, 1, 40, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = mount_mode();
                    if(item.HasValue) dst.mount_mode(item.Value);
                }
                dst.stab_roll(stab_roll()) ;
                dst.stab_pitch(stab_pitch()) ;
                dst.stab_yaw(stab_yaw()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                com.company.demo.GroundControl. MAV_MOUNT_MODE?  mount_mode();
                sbyte stab_roll();
                sbyte stab_pitch();
                sbyte stab_yaw();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                {
                    var item = src.mount_mode();
                    if(item.HasValue)     mount_mode(item.Value);
                }
                stab_roll(src.stab_roll());
                stab_pitch(src.stab_pitch());
                stab_yaw(src.stab_yaw());
            }



        }
        /**
        *Message to control a camera mount, directional antenna, etc. */

        public struct MOUNT_CONTROL
        {
            internal Pack.Cursor data_;
            internal MOUNT_CONTROL(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public int input_a() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void input_a(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public int input_b() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void input_b(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public int input_c() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void input_c(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }

            public sbyte save_position() { return (sbyte)(data_.bytes[data_.origin  + 14]); }
            public void save_position(sbyte src) {    data_.bytes[data_.origin  + 14] = (byte)(src);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void input_a(int src);
                void input_b(int src);
                void input_c(int src);
                void save_position(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(113, 0, 0, 0, 15, 1, 120);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.input_a(input_a()) ;
                dst.input_b(input_b()) ;
                dst.input_c(input_c()) ;
                dst.save_position(save_position()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                int input_a();
                int input_b();
                int input_c();
                sbyte save_position();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                input_a(src.input_a());
                input_b(src.input_b());
                input_c(src.input_c());
                save_position(src.save_position());
            }



        }
        /**
        *Message with some status from APM to GCS about camera or antenna mount */

        public struct MOUNT_STATUS
        {
            internal Pack.Cursor data_;
            internal MOUNT_STATUS(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public int pointing_a() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void pointing_a(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public int pointing_b() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void pointing_b(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public int pointing_c() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void pointing_c(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void pointing_a(int src);
                void pointing_b(int src);
                void pointing_c(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(44, 0, 0, 0, 14, 1, 112);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.pointing_a(pointing_a()) ;
                dst.pointing_b(pointing_b()) ;
                dst.pointing_c(pointing_c()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                int pointing_a();
                int pointing_b();
                int pointing_c();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                pointing_a(src.pointing_a());
                pointing_b(src.pointing_b());
                pointing_c(src.pointing_c());
            }



        }
        /**
        *GCS */

        public struct FENCE_POINT
        {
            internal Pack.Cursor data_;
            internal FENCE_POINT(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public sbyte idx() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void idx(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte count() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void count(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }

            public float lat() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void lat(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float lng() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void lng(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void idx(sbyte src);
                void count(sbyte src);
                void lat(float src);
                void lng(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(20, 0, 0, 0, 12, 1, 96);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.idx(idx()) ;
                dst.count(count()) ;
                dst.lat(lat()) ;
                dst.lng(lng()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                sbyte idx();
                sbyte count();
                float lat();
                float lng();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                idx(src.idx());
                count(src.count());
                lat(src.lat());
                lng(src.lng());
            }



        }
        /**
        *Request a current fence point from MAV */

        public struct FENCE_FETCH_POINT
        {
            internal Pack.Cursor data_;
            internal FENCE_FETCH_POINT(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public sbyte idx() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void idx(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void idx(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(119, 0, 0, 0, 3, 1, 24);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.idx(idx()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                sbyte idx();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                idx(src.idx());
            }



        }
        /**
        *Status of geo-fencing. Sent in extended status stream when fencing enabled */

        public struct FENCE_STATUS
        {
            internal Pack.Cursor data_;
            internal FENCE_STATUS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                breach_type = 56
            }



            public short breach_count() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void breach_count(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int breach_time() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void breach_time(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public sbyte breach_status() { return (sbyte)(data_.bytes[data_.origin  + 6]); }
            public void breach_status(sbyte src) {    data_.bytes[data_.origin  + 6] = (byte)(src);  }


            public  FENCE_BREACH? breach_type()
            {
                if(data_.field_bit !=  56 && !data_.set_field(56, -1))  return null;
                return (FENCE_BREACH)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 2)));;
            }


            public void breach_type(FENCE_BREACH src)
            {
                if(data_.field_bit !=  56) data_.set_field(56, 0);
                ;
                Lib.set_bits((ulong)(src), 2, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void breach_status(sbyte src);
                void breach_count(short src);
                void breach_type(com.company.demo.GroundControl. FENCE_BREACH src);
                void breach_time(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(93, 1, 1, 0, 8, 1, 56, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.breach_status(breach_status()) ;
                dst.breach_count(breach_count()) ;
                {
                    var item = breach_type();
                    if(item.HasValue) dst.breach_type(item.Value);
                }
                dst.breach_time(breach_time()) ;
            }

            public interface SRC_
            {
                sbyte breach_status();
                short breach_count();
                com.company.demo.GroundControl. FENCE_BREACH?  breach_type();
                int breach_time();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                breach_status(src.breach_status());
                breach_count(src.breach_count());
                {
                    var item = src.breach_type();
                    if(item.HasValue)     breach_type(item.Value);
                }
                breach_time(src.breach_time());
            }



        }
        /**
        *Status of DCM attitude estimator */

        public struct AHRS
        {
            internal Pack.Cursor data_;
            internal AHRS(Pack.Cursor data) { this.data_ = data; }




            public float omegaIx() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void omegaIx(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float omegaIy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void omegaIy(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float omegaIz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void omegaIz(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float accel_weight() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void accel_weight(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float renorm_val() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void renorm_val(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float error_rp() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void error_rp(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float error_yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void error_yaw(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }



            public interface DST_
            {
                void omegaIx(float src);
                void omegaIy(float src);
                void omegaIz(float src);
                void accel_weight(float src);
                void renorm_val(float src);
                void error_rp(float src);
                void error_yaw(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(214, 0, 0, 0, 28, 1, 224);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.omegaIx(omegaIx()) ;
                dst.omegaIy(omegaIy()) ;
                dst.omegaIz(omegaIz()) ;
                dst.accel_weight(accel_weight()) ;
                dst.renorm_val(renorm_val()) ;
                dst.error_rp(error_rp()) ;
                dst.error_yaw(error_yaw()) ;
            }

            public interface SRC_
            {
                float omegaIx();
                float omegaIy();
                float omegaIz();
                float accel_weight();
                float renorm_val();
                float error_rp();
                float error_yaw();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                omegaIx(src.omegaIx());
                omegaIy(src.omegaIy());
                omegaIz(src.omegaIz());
                accel_weight(src.accel_weight());
                renorm_val(src.renorm_val());
                error_rp(src.error_rp());
                error_yaw(src.error_yaw());
            }



        }
        /**
        *Status of simulation environment, if used */

        public struct SIMSTATE
        {
            internal Pack.Cursor data_;
            internal SIMSTATE(Pack.Cursor data) { this.data_ = data; }




            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void roll(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void pitch(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void yaw(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float xacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void xacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float yacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void yacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float zacc() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void zacc(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float xgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void xgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float ygyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void ygyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float zgyro() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void zgyro(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 36, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 36);  }

            public int lng() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 40, 4)); }
            public void lng(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 40);  }



            public interface DST_
            {
                void roll(float src);
                void pitch(float src);
                void yaw(float src);
                void xacc(float src);
                void yacc(float src);
                void zacc(float src);
                void xgyro(float src);
                void ygyro(float src);
                void zgyro(float src);
                void lat(int src);
                void lng(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(112, 0, 0, 0, 44, 1, 352);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
                dst.xacc(xacc()) ;
                dst.yacc(yacc()) ;
                dst.zacc(zacc()) ;
                dst.xgyro(xgyro()) ;
                dst.ygyro(ygyro()) ;
                dst.zgyro(zgyro()) ;
                dst.lat(lat()) ;
                dst.lng(lng()) ;
            }

            public interface SRC_
            {
                float roll();
                float pitch();
                float yaw();
                float xacc();
                float yacc();
                float zacc();
                float xgyro();
                float ygyro();
                float zgyro();
                int lat();
                int lng();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                roll(src.roll());
                pitch(src.pitch());
                yaw(src.yaw());
                xacc(src.xacc());
                yacc(src.yacc());
                zacc(src.zacc());
                xgyro(src.xgyro());
                ygyro(src.ygyro());
                zgyro(src.zgyro());
                lat(src.lat());
                lng(src.lng());
            }



        }
        /**
        *Status of key hardware */

        public struct HWSTATUS
        {
            internal Pack.Cursor data_;
            internal HWSTATUS(Pack.Cursor data) { this.data_ = data; }




            public short Vcc() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void Vcc(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public sbyte I2Cerr() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void I2Cerr(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }



            public interface DST_
            {
                void Vcc(short src);
                void I2Cerr(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(155, 1, 0, 0, 3, 1, 24);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.Vcc(Vcc()) ;
                dst.I2Cerr(I2Cerr()) ;
            }

            public interface SRC_
            {
                short Vcc();
                sbyte I2Cerr();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                Vcc(src.Vcc());
                I2Cerr(src.I2Cerr());
            }



        }
        /**
        *Status generated by radio */

        public struct RADIO
        {
            internal Pack.Cursor data_;
            internal RADIO(Pack.Cursor data) { this.data_ = data; }




            public short rxerrors() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void rxerrors(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short fixeD() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void fixeD(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public sbyte rssi() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void rssi(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte remrssi() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void remrssi(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }

            public sbyte txbuf() { return (sbyte)(data_.bytes[data_.origin  + 6]); }
            public void txbuf(sbyte src) {    data_.bytes[data_.origin  + 6] = (byte)(src);  }

            public sbyte noise() { return (sbyte)(data_.bytes[data_.origin  + 7]); }
            public void noise(sbyte src) {    data_.bytes[data_.origin  + 7] = (byte)(src);  }

            public sbyte remnoise() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void remnoise(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }



            public interface DST_
            {
                void rssi(sbyte src);
                void remrssi(sbyte src);
                void txbuf(sbyte src);
                void noise(sbyte src);
                void remnoise(sbyte src);
                void rxerrors(short src);
                void fixeD(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(32, 2, 0, 0, 9, 1, 72);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.rssi(rssi()) ;
                dst.remrssi(remrssi()) ;
                dst.txbuf(txbuf()) ;
                dst.noise(noise()) ;
                dst.remnoise(remnoise()) ;
                dst.rxerrors(rxerrors()) ;
                dst.fixeD(fixeD()) ;
            }

            public interface SRC_
            {
                sbyte rssi();
                sbyte remrssi();
                sbyte txbuf();
                sbyte noise();
                sbyte remnoise();
                short rxerrors();
                short fixeD();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                rssi(src.rssi());
                remrssi(src.remrssi());
                txbuf(src.txbuf());
                noise(src.noise());
                remnoise(src.remnoise());
                rxerrors(src.rxerrors());
                fixeD(src.fixeD());
            }



        }
        /**
        *Status of AP_Limits. Sent in extended status stream when AP_Limits is enabled */

        public struct LIMITS_STATUS
        {
            internal Pack.Cursor data_;
            internal LIMITS_STATUS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                limits_state = 146,
                mods_enabled = 147,
                mods_required = 148,
                mods_triggered = 149
            }



            public short breach_count() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void breach_count(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public int last_trigger() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 4)); }
            public void last_trigger(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 2);  }

            public int last_action() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void last_action(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public int last_recovery() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void last_recovery(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }

            public int last_clear() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 4)); }
            public void last_clear(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 14);  }


            public  LIMITS_STATE? limits_state()
            {
                if(data_.field_bit !=  146 && !data_.set_field(146, -1))  return null;
                return (LIMITS_STATE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void limits_state(LIMITS_STATE src)
            {
                if(data_.field_bit !=  146) data_.set_field(146, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }




            public  LIMIT_MODULE? mods_enabled()
            {
                if(data_.field_bit !=  147 && !data_.set_field(147, -1))  return null;
                return    LIMIT_MODULE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 2));;
            }


            public void mods_enabled(LIMIT_MODULE src)
            {
                if(data_.field_bit !=  147) data_.set_field(147, 0);
                ;
                Lib.set_bits(LIMIT_MODULE_.bits(src), 2, data_.bytes, data_.BIT) ;;
            }




            public  LIMIT_MODULE? mods_required()
            {
                if(data_.field_bit !=  148 && !data_.set_field(148, -1))  return null;
                return    LIMIT_MODULE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 2));;
            }


            public void mods_required(LIMIT_MODULE src)
            {
                if(data_.field_bit !=  148) data_.set_field(148, 0);
                ;
                Lib.set_bits(LIMIT_MODULE_.bits(src), 2, data_.bytes, data_.BIT) ;;
            }




            public  LIMIT_MODULE? mods_triggered()
            {
                if(data_.field_bit !=  149 && !data_.set_field(149, -1))  return null;
                return    LIMIT_MODULE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 2));;
            }


            public void mods_triggered(LIMIT_MODULE src)
            {
                if(data_.field_bit !=  149) data_.set_field(149, 0);
                ;
                Lib.set_bits(LIMIT_MODULE_.bits(src), 2, data_.bytes, data_.BIT) ;;
            }





            public interface DST_
            {
                void limits_state(com.company.demo.GroundControl. LIMITS_STATE src);
                void last_trigger(int src);
                void last_action(int src);
                void last_recovery(int src);
                void last_clear(int src);
                void breach_count(short src);
                void mods_enabled(com.company.demo.GroundControl. LIMIT_MODULE src);
                void mods_required(com.company.demo.GroundControl. LIMIT_MODULE src);
                void mods_triggered(com.company.demo.GroundControl. LIMIT_MODULE src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(186, 1, 4, 0, 19, 1, 146, 2, 0, 4);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = limits_state();
                    if(item.HasValue) dst.limits_state(item.Value);
                }
                dst.last_trigger(last_trigger()) ;
                dst.last_action(last_action()) ;
                dst.last_recovery(last_recovery()) ;
                dst.last_clear(last_clear()) ;
                dst.breach_count(breach_count()) ;
                {
                    var item = mods_enabled();
                    if(item.HasValue) dst.mods_enabled(item.Value);
                }
                {
                    var item = mods_required();
                    if(item.HasValue) dst.mods_required(item.Value);
                }
                {
                    var item = mods_triggered();
                    if(item.HasValue) dst.mods_triggered(item.Value);
                }
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. LIMITS_STATE?  limits_state();
                int last_trigger();
                int last_action();
                int last_recovery();
                int last_clear();
                short breach_count();
                com.company.demo.GroundControl. LIMIT_MODULE?  mods_enabled();
                com.company.demo.GroundControl. LIMIT_MODULE?  mods_required();
                com.company.demo.GroundControl. LIMIT_MODULE?  mods_triggered();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.limits_state();
                    if(item.HasValue)     limits_state(item.Value);
                }
                last_trigger(src.last_trigger());
                last_action(src.last_action());
                last_recovery(src.last_recovery());
                last_clear(src.last_clear());
                breach_count(src.breach_count());
                {
                    var item = src.mods_enabled();
                    if(item.HasValue)     mods_enabled(item.Value);
                }
                {
                    var item = src.mods_required();
                    if(item.HasValue)     mods_required(item.Value);
                }
                {
                    var item = src.mods_triggered();
                    if(item.HasValue)     mods_triggered(item.Value);
                }
            }



        }
        /**
        *Wind estimation */

        public struct WIND
        {
            internal Pack.Cursor data_;
            internal WIND(Pack.Cursor data) { this.data_ = data; }




            public float direction() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void direction(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float speed() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void speed(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float speed_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void speed_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }



            public interface DST_
            {
                void direction(float src);
                void speed(float src);
                void speed_z(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(97, 0, 0, 0, 12, 1, 96);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.direction(direction()) ;
                dst.speed(speed()) ;
                dst.speed_z(speed_z()) ;
            }

            public interface SRC_
            {
                float direction();
                float speed();
                float speed_z();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                direction(src.direction());
                speed(src.speed());
                speed_z(src.speed_z());
            }



        }
        /**
        *Data packet, size 16 */

        public struct DATA16
        {
            internal Pack.Cursor data_;
            internal DATA16(Pack.Cursor data) { this.data_ = data; }




            public sbyte typE() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void typE(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte len() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void len(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return DATA16.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 2 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != DATA16.daTa_.item_len) return false;
                    for(int i = 0; i < DATA16.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != DATA16.daTa_.item_len) return false;
                    for(int i = 0; i < DATA16.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 2 + index] = (byte)(src); }

                public const int item_len = 16 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, DATA16.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 2 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void typE(sbyte src);
                void len(sbyte src);
                void daTa(DATA16.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(36, 0, 0, 0, 18, 1, 144);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.typE(typE()) ;
                dst.len(len()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                sbyte typE();
                sbyte len();
                void daTa(DATA16.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                typE(src.typE());
                len(src.len());
                src.daTa(daTa());
            }



        }
        /**
        *Data packet, size 32 */

        public struct DATA32
        {
            internal Pack.Cursor data_;
            internal DATA32(Pack.Cursor data) { this.data_ = data; }




            public sbyte typE() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void typE(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte len() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void len(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return DATA32.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 2 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != DATA32.daTa_.item_len) return false;
                    for(int i = 0; i < DATA32.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != DATA32.daTa_.item_len) return false;
                    for(int i = 0; i < DATA32.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 2 + index] = (byte)(src); }

                public const int item_len = 32 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, DATA32.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 2 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void typE(sbyte src);
                void len(sbyte src);
                void daTa(DATA32.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(164, 0, 0, 0, 34, 1, 272);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.typE(typE()) ;
                dst.len(len()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                sbyte typE();
                sbyte len();
                void daTa(DATA32.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                typE(src.typE());
                len(src.len());
                src.daTa(daTa());
            }



        }
        /**
        *Data packet, size 64 */

        public struct DATA64
        {
            internal Pack.Cursor data_;
            internal DATA64(Pack.Cursor data) { this.data_ = data; }




            public sbyte typE() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void typE(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte len() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void len(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return DATA64.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 2 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != DATA64.daTa_.item_len) return false;
                    for(int i = 0; i < DATA64.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != DATA64.daTa_.item_len) return false;
                    for(int i = 0; i < DATA64.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 2 + index] = (byte)(src); }

                public const int item_len = 64 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, DATA64.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 2 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void typE(sbyte src);
                void len(sbyte src);
                void daTa(DATA64.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(141, 0, 0, 0, 66, 1, 528);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.typE(typE()) ;
                dst.len(len()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                sbyte typE();
                sbyte len();
                void daTa(DATA64.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                typE(src.typE());
                len(src.len());
                src.daTa(daTa());
            }



        }
        /**
        *Data packet, size 96 */

        public struct DATA96
        {
            internal Pack.Cursor data_;
            internal DATA96(Pack.Cursor data) { this.data_ = data; }




            public sbyte typE() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void typE(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte len() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void len(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return DATA96.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 2 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != DATA96.daTa_.item_len) return false;
                    for(int i = 0; i < DATA96.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != DATA96.daTa_.item_len) return false;
                    for(int i = 0; i < DATA96.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 2 + index] = (byte)(src); }

                public const int item_len = 96 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, DATA96.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 2 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void typE(sbyte src);
                void len(sbyte src);
                void daTa(DATA96.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(83, 0, 0, 0, 98, 1, 784);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.typE(typE()) ;
                dst.len(len()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                sbyte typE();
                sbyte len();
                void daTa(DATA96.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                typE(src.typE());
                len(src.len());
                src.daTa(daTa());
            }



        }
        /**
        *Rangefinder reporting */

        public struct RANGEFINDER
        {
            internal Pack.Cursor data_;
            internal RANGEFINDER(Pack.Cursor data) { this.data_ = data; }




            public float distance() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void distance(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float voltage() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void voltage(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }



            public interface DST_
            {
                void distance(float src);
                void voltage(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(153, 0, 0, 0, 8, 1, 64);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.distance(distance()) ;
                dst.voltage(voltage()) ;
            }

            public interface SRC_
            {
                float distance();
                float voltage();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                distance(src.distance());
                voltage(src.voltage());
            }



        }
        /**
        *Airspeed auto-calibration */

        public struct AIRSPEED_AUTOCAL
        {
            internal Pack.Cursor data_;
            internal AIRSPEED_AUTOCAL(Pack.Cursor data) { this.data_ = data; }




            public float vx() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void vx(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float vy() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void vy(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float vz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void vz(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float diff_pressure() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void diff_pressure(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float EAS2TAS() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void EAS2TAS(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float ratio() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void ratio(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float state_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void state_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float state_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void state_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float state_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void state_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public float Pax() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }
            public void Pax(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 36, 4);  }

            public float Pby() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }
            public void Pby(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 40, 4);  }

            public float Pcz() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 44); }
            public void Pcz(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 44, 4);  }



            public interface DST_
            {
                void vx(float src);
                void vy(float src);
                void vz(float src);
                void diff_pressure(float src);
                void EAS2TAS(float src);
                void ratio(float src);
                void state_x(float src);
                void state_y(float src);
                void state_z(float src);
                void Pax(float src);
                void Pby(float src);
                void Pcz(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(69, 0, 0, 0, 48, 1, 384);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.vx(vx()) ;
                dst.vy(vy()) ;
                dst.vz(vz()) ;
                dst.diff_pressure(diff_pressure()) ;
                dst.EAS2TAS(EAS2TAS()) ;
                dst.ratio(ratio()) ;
                dst.state_x(state_x()) ;
                dst.state_y(state_y()) ;
                dst.state_z(state_z()) ;
                dst.Pax(Pax()) ;
                dst.Pby(Pby()) ;
                dst.Pcz(Pcz()) ;
            }

            public interface SRC_
            {
                float vx();
                float vy();
                float vz();
                float diff_pressure();
                float EAS2TAS();
                float ratio();
                float state_x();
                float state_y();
                float state_z();
                float Pax();
                float Pby();
                float Pcz();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                vx(src.vx());
                vy(src.vy());
                vz(src.vz());
                diff_pressure(src.diff_pressure());
                EAS2TAS(src.EAS2TAS());
                ratio(src.ratio());
                state_x(src.state_x());
                state_y(src.state_y());
                state_z(src.state_z());
                Pax(src.Pax());
                Pby(src.Pby());
                Pcz(src.Pcz());
            }



        }
        /**
        *GCS */

        public struct RALLY_POINT
        {
            internal Pack.Cursor data_;
            internal RALLY_POINT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                flags = 144
            }



            public short land_dir() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void land_dir(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }

            public sbyte idx() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void idx(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte count() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void count(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 6);  }

            public int lng() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 10, 4)); }
            public void lng(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 10);  }

            public short alt() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 14, 2)); }
            public void alt(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 14);  }

            public short break_alt() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 2)); }
            public void break_alt(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 16);  }


            public  RALLY_FLAGS? flags()
            {
                if(data_.field_bit !=  144 && !data_.set_field(144, -1))  return null;
                return (RALLY_FLAGS)((1 + (sbyte)Lib.get_bits(data_.bytes, data_.BIT, 1)));;
            }


            public void flags(RALLY_FLAGS src)
            {
                if(data_.field_bit !=  144) data_.set_field(144, 0);
                ;
                Lib.set_bits((ulong)(src   - 1), 1, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void idx(sbyte src);
                void count(sbyte src);
                void lat(int src);
                void lng(int src);
                void alt(short src);
                void break_alt(short src);
                void land_dir(short src);
                void flags(com.company.demo.GroundControl. RALLY_FLAGS src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(197, 1, 0, 0, 19, 1, 144, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.idx(idx()) ;
                dst.count(count()) ;
                dst.lat(lat()) ;
                dst.lng(lng()) ;
                dst.alt(alt()) ;
                dst.break_alt(break_alt()) ;
                dst.land_dir(land_dir()) ;
                {
                    var item = flags();
                    if(item.HasValue) dst.flags(item.Value);
                }
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                sbyte idx();
                sbyte count();
                int lat();
                int lng();
                short alt();
                short break_alt();
                short land_dir();
                com.company.demo.GroundControl. RALLY_FLAGS?  flags();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                idx(src.idx());
                count(src.count());
                lat(src.lat());
                lng(src.lng());
                alt(src.alt());
                break_alt(src.break_alt());
                land_dir(src.land_dir());
                {
                    var item = src.flags();
                    if(item.HasValue)     flags(item.Value);
                }
            }



        }
        /**
        *Request a current rally point from MAV. MAV should respond with a RALLY_POINT message. MAV should not
        *				 respond if the request is invalid */

        public struct RALLY_FETCH_POINT
        {
            internal Pack.Cursor data_;
            internal RALLY_FETCH_POINT(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public sbyte idx() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void idx(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void idx(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(5, 0, 0, 0, 3, 1, 24);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.idx(idx()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                sbyte idx();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                idx(src.idx());
            }



        }
        /**
        *Status of compassmot calibration */

        public struct COMPASSMOT_STATUS
        {
            internal Pack.Cursor data_;
            internal COMPASSMOT_STATUS(Pack.Cursor data) { this.data_ = data; }




            public short throttle() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void throttle(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short interference() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void interference(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public float current() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void current(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float CompensationX() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void CompensationX(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float CompensationY() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void CompensationY(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float CompensationZ() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void CompensationZ(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }



            public interface DST_
            {
                void throttle(short src);
                void current(float src);
                void interference(short src);
                void CompensationX(float src);
                void CompensationY(float src);
                void CompensationZ(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(43, 2, 0, 0, 20, 1, 160);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.throttle(throttle()) ;
                dst.current(current()) ;
                dst.interference(interference()) ;
                dst.CompensationX(CompensationX()) ;
                dst.CompensationY(CompensationY()) ;
                dst.CompensationZ(CompensationZ()) ;
            }

            public interface SRC_
            {
                short throttle();
                float current();
                short interference();
                float CompensationX();
                float CompensationY();
                float CompensationZ();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                throttle(src.throttle());
                current(src.current());
                interference(src.interference());
                CompensationX(src.CompensationX());
                CompensationY(src.CompensationY());
                CompensationZ(src.CompensationZ());
            }



        }
        /**
        *Status of secondary AHRS filter if available */

        public struct AHRS2
        {
            internal Pack.Cursor data_;
            internal AHRS2(Pack.Cursor data) { this.data_ = data; }




            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void roll(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void pitch(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void yaw(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float altitude() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void altitude(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 16);  }

            public int lng() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 4)); }
            public void lng(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 20);  }



            public interface DST_
            {
                void roll(float src);
                void pitch(float src);
                void yaw(float src);
                void altitude(float src);
                void lat(int src);
                void lng(int src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(17, 0, 0, 0, 24, 1, 192);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
                dst.altitude(altitude()) ;
                dst.lat(lat()) ;
                dst.lng(lng()) ;
            }

            public interface SRC_
            {
                float roll();
                float pitch();
                float yaw();
                float altitude();
                int lat();
                int lng();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                roll(src.roll());
                pitch(src.pitch());
                yaw(src.yaw());
                altitude(src.altitude());
                lat(src.lat());
                lng(src.lng());
            }



        }
        /**
        *Camera Event */

        public struct CAMERA_STATUS
        {
            internal Pack.Cursor data_;
            internal CAMERA_STATUS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                event_id = 224
            }



            public short img_idx() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void img_idx(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 2);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 10]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 10] = (byte)(src);  }

            public sbyte cam_idx() { return (sbyte)(data_.bytes[data_.origin  + 11]); }
            public void cam_idx(sbyte src) {    data_.bytes[data_.origin  + 11] = (byte)(src);  }

            public float p1() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void p1(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float p2() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void p2(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float p3() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void p3(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float p4() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void p4(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }


            public  CAMERA_STATUS_TYPES? event_id()
            {
                if(data_.field_bit !=  224 && !data_.set_field(224, -1))  return null;
                return (CAMERA_STATUS_TYPES)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void event_id(CAMERA_STATUS_TYPES src)
            {
                if(data_.field_bit !=  224) data_.set_field(224, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void time_usec(long src);
                void target_system(sbyte src);
                void cam_idx(sbyte src);
                void img_idx(short src);
                void event_id(com.company.demo.GroundControl. CAMERA_STATUS_TYPES src);
                void p1(float src);
                void p2(float src);
                void p3(float src);
                void p4(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(211, 1, 0, 1, 29, 1, 224, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.target_system(target_system()) ;
                dst.cam_idx(cam_idx()) ;
                dst.img_idx(img_idx()) ;
                {
                    var item = event_id();
                    if(item.HasValue) dst.event_id(item.Value);
                }
                dst.p1(p1()) ;
                dst.p2(p2()) ;
                dst.p3(p3()) ;
                dst.p4(p4()) ;
            }

            public interface SRC_
            {
                long time_usec();
                sbyte target_system();
                sbyte cam_idx();
                short img_idx();
                com.company.demo.GroundControl. CAMERA_STATUS_TYPES?  event_id();
                float p1();
                float p2();
                float p3();
                float p4();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                target_system(src.target_system());
                cam_idx(src.cam_idx());
                img_idx(src.img_idx());
                {
                    var item = src.event_id();
                    if(item.HasValue)     event_id(item.Value);
                }
                p1(src.p1());
                p2(src.p2());
                p3(src.p3());
                p4(src.p4());
            }



        }
        /**
        *Camera Capture Feedback */

        public struct CAMERA_FEEDBACK
        {
            internal Pack.Cursor data_;
            internal CAMERA_FEEDBACK(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                flags = 352
            }



            public short img_idx() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void img_idx(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 2);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 10]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 10] = (byte)(src);  }

            public sbyte cam_idx() { return (sbyte)(data_.bytes[data_.origin  + 11]); }
            public void cam_idx(sbyte src) {    data_.bytes[data_.origin  + 11] = (byte)(src);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 12, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 12);  }

            public int lng() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 4)); }
            public void lng(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 16);  }

            public float alt_msl() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void alt_msl(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float alt_rel() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void alt_rel(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void roll(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void pitch(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }
            public void yaw(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 36, 4);  }

            public float foc_len() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }
            public void foc_len(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 40, 4);  }


            public  CAMERA_FEEDBACK_FLAGS? flags()
            {
                if(data_.field_bit !=  352 && !data_.set_field(352, -1))  return null;
                return (CAMERA_FEEDBACK_FLAGS)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void flags(CAMERA_FEEDBACK_FLAGS src)
            {
                if(data_.field_bit !=  352) data_.set_field(352, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void time_usec(long src);
                void target_system(sbyte src);
                void cam_idx(sbyte src);
                void img_idx(short src);
                void lat(int src);
                void lng(int src);
                void alt_msl(float src);
                void alt_rel(float src);
                void roll(float src);
                void pitch(float src);
                void yaw(float src);
                void foc_len(float src);
                void flags(com.company.demo.GroundControl. CAMERA_FEEDBACK_FLAGS src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(0, 1, 0, 1, 45, 1, 352, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.target_system(target_system()) ;
                dst.cam_idx(cam_idx()) ;
                dst.img_idx(img_idx()) ;
                dst.lat(lat()) ;
                dst.lng(lng()) ;
                dst.alt_msl(alt_msl()) ;
                dst.alt_rel(alt_rel()) ;
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
                dst.foc_len(foc_len()) ;
                {
                    var item = flags();
                    if(item.HasValue) dst.flags(item.Value);
                }
            }

            public interface SRC_
            {
                long time_usec();
                sbyte target_system();
                sbyte cam_idx();
                short img_idx();
                int lat();
                int lng();
                float alt_msl();
                float alt_rel();
                float roll();
                float pitch();
                float yaw();
                float foc_len();
                com.company.demo.GroundControl. CAMERA_FEEDBACK_FLAGS?  flags();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                target_system(src.target_system());
                cam_idx(src.cam_idx());
                img_idx(src.img_idx());
                lat(src.lat());
                lng(src.lng());
                alt_msl(src.alt_msl());
                alt_rel(src.alt_rel());
                roll(src.roll());
                pitch(src.pitch());
                yaw(src.yaw());
                foc_len(src.foc_len());
                {
                    var item = src.flags();
                    if(item.HasValue)     flags(item.Value);
                }
            }



        }
        /**
        *2nd Battery status */

        public struct BATTERY2
        {
            internal Pack.Cursor data_;
            internal BATTERY2(Pack.Cursor data) { this.data_ = data; }




            public short voltage() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin, 2)); }
            public void voltage(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin);  }

            public short current_battery() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void current_battery(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }



            public interface DST_
            {
                void voltage(short src);
                void current_battery(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(190, 1, 0, 0, 4, 1, 32);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.voltage(voltage()) ;
                dst.current_battery(current_battery()) ;
            }

            public interface SRC_
            {
                short voltage();
                short current_battery();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                voltage(src.voltage());
                current_battery(src.current_battery());
            }



        }
        /**
        *Status of third AHRS filter if available. This is for ANU research group (Ali and Sean) */

        public struct AHRS3
        {
            internal Pack.Cursor data_;
            internal AHRS3(Pack.Cursor data) { this.data_ = data; }




            public float roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void roll(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float pitch() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void pitch(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float yaw() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void yaw(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float altitude() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void altitude(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public int lat() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 16, 4)); }
            public void lat(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 16);  }

            public int lng() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin  + 20, 4)); }
            public void lng(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin  + 20);  }

            public float v1() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void v1(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float v2() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void v2(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float v3() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void v3(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public float v4() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }
            public void v4(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 36, 4);  }



            public interface DST_
            {
                void roll(float src);
                void pitch(float src);
                void yaw(float src);
                void altitude(float src);
                void lat(int src);
                void lng(int src);
                void v1(float src);
                void v2(float src);
                void v3(float src);
                void v4(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(65, 0, 0, 0, 40, 1, 320);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.roll(roll()) ;
                dst.pitch(pitch()) ;
                dst.yaw(yaw()) ;
                dst.altitude(altitude()) ;
                dst.lat(lat()) ;
                dst.lng(lng()) ;
                dst.v1(v1()) ;
                dst.v2(v2()) ;
                dst.v3(v3()) ;
                dst.v4(v4()) ;
            }

            public interface SRC_
            {
                float roll();
                float pitch();
                float yaw();
                float altitude();
                int lat();
                int lng();
                float v1();
                float v2();
                float v3();
                float v4();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                roll(src.roll());
                pitch(src.pitch());
                yaw(src.yaw());
                altitude(src.altitude());
                lat(src.lat());
                lng(src.lng());
                v1(src.v1());
                v2(src.v2());
                v3(src.v3());
                v4(src.v4());
            }



        }
        /**
        *Request the autopilot version from the system/component. */

        public struct AUTOPILOT_VERSION_REQUEST
        {
            internal Pack.Cursor data_;
            internal AUTOPILOT_VERSION_REQUEST(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(142, 0, 0, 0, 2, 1, 16);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
            }



        }
        /**
        *Send a block of log data to remote location */

        public struct REMOTE_LOG_DATA_BLOCK
        {
            internal Pack.Cursor data_;
            internal REMOTE_LOG_DATA_BLOCK(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                seqno = 1616
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return REMOTE_LOG_DATA_BLOCK.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 2 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != REMOTE_LOG_DATA_BLOCK.daTa_.item_len) return false;
                    for(int i = 0; i < REMOTE_LOG_DATA_BLOCK.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != REMOTE_LOG_DATA_BLOCK.daTa_.item_len) return false;
                    for(int i = 0; i < REMOTE_LOG_DATA_BLOCK.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 2 + index] = (byte)(src); }

                public const int item_len = 200 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, REMOTE_LOG_DATA_BLOCK.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 2 + index] = (byte)(src[index]);
            }


            public  MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS? seqno()
            {
                if(data_.field_bit !=  1616 && !data_.set_field(1616, -1))  return null;
                return (MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS)((2147483645 + (uint)Lib.get_bits(data_.bytes, data_.BIT, 1)));;
            }


            public void seqno(MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS src)
            {
                if(data_.field_bit !=  1616) data_.set_field(1616, 0);
                ;
                Lib.set_bits((ulong)(src   - 2147483645), 1, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void seqno(com.company.demo.GroundControl. MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS src);
                void daTa(REMOTE_LOG_DATA_BLOCK.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(144, 0, 0, 0, 203, 1, 1616, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = seqno();
                    if(item.HasValue) dst.seqno(item.Value);
                }
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                com.company.demo.GroundControl. MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS?  seqno();
                void daTa(REMOTE_LOG_DATA_BLOCK.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                {
                    var item = src.seqno();
                    if(item.HasValue)     seqno(item.Value);
                }
                src.daTa(daTa());
            }



        }
        /**
        *Send Status of each log block that autopilot board might have sent */

        public struct REMOTE_LOG_BLOCK_STATUS
        {
            internal Pack.Cursor data_;
            internal REMOTE_LOG_BLOCK_STATUS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                status = 48
            }



            public int seqno() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void seqno(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }


            public  MAV_REMOTE_LOG_DATA_BLOCK_STATUSES? status()
            {
                if(data_.field_bit !=  48 && !data_.set_field(48, -1))  return null;
                return (MAV_REMOTE_LOG_DATA_BLOCK_STATUSES)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 1)));;
            }


            public void status(MAV_REMOTE_LOG_DATA_BLOCK_STATUSES src)
            {
                if(data_.field_bit !=  48) data_.set_field(48, 0);
                ;
                Lib.set_bits((ulong)(src), 1, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void seqno(int src);
                void status(com.company.demo.GroundControl. MAV_REMOTE_LOG_DATA_BLOCK_STATUSES src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(171, 0, 1, 0, 7, 1, 48, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.seqno(seqno()) ;
                {
                    var item = status();
                    if(item.HasValue) dst.status(item.Value);
                }
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                int seqno();
                com.company.demo.GroundControl. MAV_REMOTE_LOG_DATA_BLOCK_STATUSES?  status();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                seqno(src.seqno());
                {
                    var item = src.status();
                    if(item.HasValue)     status(item.Value);
                }
            }



        }
        /**
        *Control vehicle LEDs */

        public struct LED_CONTROL
        {
            internal Pack.Cursor data_;
            internal LED_CONTROL(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public sbyte instance() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void instance(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte pattern() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void pattern(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }

            public sbyte custom_len() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void custom_len(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public custom_bytes_ custom_bytes()
            {
                return new  custom_bytes_(data_);
            }

            public struct custom_bytes_
            {
                internal Pack.Cursor data_;
                public custom_bytes_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return LED_CONTROL.custom_bytes_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 5 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != LED_CONTROL.custom_bytes_.item_len) return false;
                    for(int i = 0; i < LED_CONTROL.custom_bytes_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(custom_bytes_ other)
                {
                    if(other.len() != LED_CONTROL.custom_bytes_.item_len) return false;
                    for(int i = 0; i < LED_CONTROL.custom_bytes_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 5 + index] = (byte)(src); }

                public const int item_len = 24 ;


            }

            public void custom_bytes(sbyte[] src)
            {
                var len =  Math.Min(src.Length, LED_CONTROL.custom_bytes_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 5 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void instance(sbyte src);
                void pattern(sbyte src);
                void custom_len(sbyte src);
                void custom_bytes(LED_CONTROL.custom_bytes_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(177, 0, 0, 0, 29, 1, 232);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.instance(instance()) ;
                dst.pattern(pattern()) ;
                dst.custom_len(custom_len()) ;
                dst.custom_bytes(custom_bytes());
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                sbyte instance();
                sbyte pattern();
                sbyte custom_len();
                void custom_bytes(LED_CONTROL.custom_bytes_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                instance(src.instance());
                pattern(src.pattern());
                custom_len(src.custom_len());
                src.custom_bytes(custom_bytes());
            }



        }
        /**
        *Reports progress of compass calibration. */

        public struct MAG_CAL_PROGRESS
        {
            internal Pack.Cursor data_;
            internal MAG_CAL_PROGRESS(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                cal_status = 208
            }



            public sbyte compass_id() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void compass_id(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte cal_mask() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void cal_mask(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public sbyte attempt() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void attempt(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public sbyte completion_pct() { return (sbyte)(data_.bytes[data_.origin  + 3]); }
            public void completion_pct(sbyte src) {    data_.bytes[data_.origin  + 3] = (byte)(src);  }

            public completion_mask_ completion_mask()
            {
                return new  completion_mask_(data_);
            }

            public struct completion_mask_
            {
                internal Pack.Cursor data_;
                public completion_mask_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return MAG_CAL_PROGRESS.completion_mask_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 4 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != MAG_CAL_PROGRESS.completion_mask_.item_len) return false;
                    for(int i = 0; i < MAG_CAL_PROGRESS.completion_mask_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(completion_mask_ other)
                {
                    if(other.len() != MAG_CAL_PROGRESS.completion_mask_.item_len) return false;
                    for(int i = 0; i < MAG_CAL_PROGRESS.completion_mask_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 4 + index] = (byte)(src); }

                public const int item_len = 10 ;


            }

            public void completion_mask(sbyte[] src)
            {
                var len =  Math.Min(src.Length, MAG_CAL_PROGRESS.completion_mask_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 4 + index] = (byte)(src[index]);
            }

            public float direction_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 14); }
            public void direction_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 14, 4);  }

            public float direction_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 18); }
            public void direction_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 18, 4);  }

            public float direction_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 22); }
            public void direction_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 22, 4);  }


            public  MAG_CAL_STATUS? cal_status()
            {
                if(data_.field_bit !=  208 && !data_.set_field(208, -1))  return null;
                return (MAG_CAL_STATUS)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void cal_status(MAG_CAL_STATUS src)
            {
                if(data_.field_bit !=  208) data_.set_field(208, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void compass_id(sbyte src);
                void cal_mask(sbyte src);
                void cal_status(com.company.demo.GroundControl. MAG_CAL_STATUS src);
                void attempt(sbyte src);
                void completion_pct(sbyte src);
                void completion_mask(MAG_CAL_PROGRESS.completion_mask_ src);
                void direction_x(float src);
                void direction_y(float src);
                void direction_z(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(57, 0, 0, 0, 27, 1, 208, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.compass_id(compass_id()) ;
                dst.cal_mask(cal_mask()) ;
                {
                    var item = cal_status();
                    if(item.HasValue) dst.cal_status(item.Value);
                }
                dst.attempt(attempt()) ;
                dst.completion_pct(completion_pct()) ;
                dst.completion_mask(completion_mask());
                dst.direction_x(direction_x()) ;
                dst.direction_y(direction_y()) ;
                dst.direction_z(direction_z()) ;
            }

            public interface SRC_
            {
                sbyte compass_id();
                sbyte cal_mask();
                com.company.demo.GroundControl. MAG_CAL_STATUS?  cal_status();
                sbyte attempt();
                sbyte completion_pct();
                void completion_mask(MAG_CAL_PROGRESS.completion_mask_ dst) ;
                float direction_x();
                float direction_y();
                float direction_z();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                compass_id(src.compass_id());
                cal_mask(src.cal_mask());
                {
                    var item = src.cal_status();
                    if(item.HasValue)     cal_status(item.Value);
                }
                attempt(src.attempt());
                completion_pct(src.completion_pct());
                src.completion_mask(completion_mask());
                direction_x(src.direction_x());
                direction_y(src.direction_y());
                direction_z(src.direction_z());
            }



        }
        /**
        *Reports results of completed compass calibration. Sent until MAG_CAL_ACK received. */

        public struct MAG_CAL_REPORT
        {
            internal Pack.Cursor data_;
            internal MAG_CAL_REPORT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                cal_status = 344
            }



            public sbyte compass_id() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void compass_id(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte cal_mask() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void cal_mask(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public sbyte autosaved() { return (sbyte)(data_.bytes[data_.origin  + 2]); }
            public void autosaved(sbyte src) {    data_.bytes[data_.origin  + 2] = (byte)(src);  }

            public float fitness() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 3); }
            public void fitness(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 3, 4);  }

            public float ofs_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 7); }
            public void ofs_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 7, 4);  }

            public float ofs_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 11); }
            public void ofs_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 11, 4);  }

            public float ofs_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 15); }
            public void ofs_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 15, 4);  }

            public float diag_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 19); }
            public void diag_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 19, 4);  }

            public float diag_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 23); }
            public void diag_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 23, 4);  }

            public float diag_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 27); }
            public void diag_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 27, 4);  }

            public float offdiag_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 31); }
            public void offdiag_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 31, 4);  }

            public float offdiag_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 35); }
            public void offdiag_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 35, 4);  }

            public float offdiag_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 39); }
            public void offdiag_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 39, 4);  }


            public  MAG_CAL_STATUS? cal_status()
            {
                if(data_.field_bit !=  344 && !data_.set_field(344, -1))  return null;
                return (MAG_CAL_STATUS)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void cal_status(MAG_CAL_STATUS src)
            {
                if(data_.field_bit !=  344) data_.set_field(344, 0);
                ;
                Lib.set_bits((ulong)(src), 3, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void compass_id(sbyte src);
                void cal_mask(sbyte src);
                void cal_status(com.company.demo.GroundControl. MAG_CAL_STATUS src);
                void autosaved(sbyte src);
                void fitness(float src);
                void ofs_x(float src);
                void ofs_y(float src);
                void ofs_z(float src);
                void diag_x(float src);
                void diag_y(float src);
                void diag_z(float src);
                void offdiag_x(float src);
                void offdiag_y(float src);
                void offdiag_z(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(63, 0, 0, 0, 44, 1, 344, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.compass_id(compass_id()) ;
                dst.cal_mask(cal_mask()) ;
                {
                    var item = cal_status();
                    if(item.HasValue) dst.cal_status(item.Value);
                }
                dst.autosaved(autosaved()) ;
                dst.fitness(fitness()) ;
                dst.ofs_x(ofs_x()) ;
                dst.ofs_y(ofs_y()) ;
                dst.ofs_z(ofs_z()) ;
                dst.diag_x(diag_x()) ;
                dst.diag_y(diag_y()) ;
                dst.diag_z(diag_z()) ;
                dst.offdiag_x(offdiag_x()) ;
                dst.offdiag_y(offdiag_y()) ;
                dst.offdiag_z(offdiag_z()) ;
            }

            public interface SRC_
            {
                sbyte compass_id();
                sbyte cal_mask();
                com.company.demo.GroundControl. MAG_CAL_STATUS?  cal_status();
                sbyte autosaved();
                float fitness();
                float ofs_x();
                float ofs_y();
                float ofs_z();
                float diag_x();
                float diag_y();
                float diag_z();
                float offdiag_x();
                float offdiag_y();
                float offdiag_z();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                compass_id(src.compass_id());
                cal_mask(src.cal_mask());
                {
                    var item = src.cal_status();
                    if(item.HasValue)     cal_status(item.Value);
                }
                autosaved(src.autosaved());
                fitness(src.fitness());
                ofs_x(src.ofs_x());
                ofs_y(src.ofs_y());
                ofs_z(src.ofs_z());
                diag_x(src.diag_x());
                diag_y(src.diag_y());
                diag_z(src.diag_z());
                offdiag_x(src.offdiag_x());
                offdiag_y(src.offdiag_y());
                offdiag_z(src.offdiag_z());
            }



        }
        /**
        *EKF Status message including flags and variances */

        public struct EKF_STATUS_REPORT
        {
            internal Pack.Cursor data_;
            internal EKF_STATUS_REPORT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                flags = 160
            }



            public float velocity_variance() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void velocity_variance(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float pos_horiz_variance() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void pos_horiz_variance(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float pos_vert_variance() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void pos_vert_variance(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float compass_variance() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void compass_variance(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float terrain_alt_variance() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void terrain_alt_variance(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }


            public  EKF_STATUS_FLAGS? flags()
            {
                if(data_.field_bit !=  160 && !data_.set_field(160, -1))  return null;
                return    EKF_STATUS_FLAGS_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 4));;
            }


            public void flags(EKF_STATUS_FLAGS src)
            {
                if(data_.field_bit !=  160) data_.set_field(160, 0);
                ;
                Lib.set_bits(EKF_STATUS_FLAGS_.bits(src), 4, data_.bytes, data_.BIT) ;;
            }





            public interface DST_
            {
                void flags(com.company.demo.GroundControl. EKF_STATUS_FLAGS src);
                void velocity_variance(float src);
                void pos_horiz_variance(float src);
                void pos_vert_variance(float src);
                void compass_variance(float src);
                void terrain_alt_variance(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(96, 0, 0, 0, 21, 1, 160, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = flags();
                    if(item.HasValue) dst.flags(item.Value);
                }
                dst.velocity_variance(velocity_variance()) ;
                dst.pos_horiz_variance(pos_horiz_variance()) ;
                dst.pos_vert_variance(pos_vert_variance()) ;
                dst.compass_variance(compass_variance()) ;
                dst.terrain_alt_variance(terrain_alt_variance()) ;
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. EKF_STATUS_FLAGS?  flags();
                float velocity_variance();
                float pos_horiz_variance();
                float pos_vert_variance();
                float compass_variance();
                float terrain_alt_variance();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.flags();
                    if(item.HasValue)     flags(item.Value);
                }
                velocity_variance(src.velocity_variance());
                pos_horiz_variance(src.pos_horiz_variance());
                pos_vert_variance(src.pos_vert_variance());
                compass_variance(src.compass_variance());
                terrain_alt_variance(src.terrain_alt_variance());
            }



        }
        /**
        *PID tuning information */

        public struct PID_TUNING
        {
            internal Pack.Cursor data_;
            internal PID_TUNING(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                axis = 192
            }



            public float desired() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void desired(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float achieved() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void achieved(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float FF() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void FF(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float P() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void P(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float I() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void I(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float D() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void D(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }


            public  PID_TUNING_AXIS? axis()
            {
                if(data_.field_bit !=  192 && !data_.set_field(192, -1))  return null;
                return (PID_TUNING_AXIS)((1 + (sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void axis(PID_TUNING_AXIS src)
            {
                if(data_.field_bit !=  192) data_.set_field(192, 0);
                ;
                Lib.set_bits((ulong)(src   - 1), 3, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void axis(com.company.demo.GroundControl. PID_TUNING_AXIS src);
                void desired(float src);
                void achieved(float src);
                void FF(float src);
                void P(float src);
                void I(float src);
                void D(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(64, 0, 0, 0, 25, 1, 192, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = axis();
                    if(item.HasValue) dst.axis(item.Value);
                }
                dst.desired(desired()) ;
                dst.achieved(achieved()) ;
                dst.FF(FF()) ;
                dst.P(P()) ;
                dst.I(I()) ;
                dst.D(D()) ;
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. PID_TUNING_AXIS?  axis();
                float desired();
                float achieved();
                float FF();
                float P();
                float I();
                float D();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.axis();
                    if(item.HasValue)     axis(item.Value);
                }
                desired(src.desired());
                achieved(src.achieved());
                FF(src.FF());
                P(src.P());
                I(src.I());
                D(src.D());
            }



        }
        /**
        *3 axis gimbal mesuraments */

        public struct GIMBAL_REPORT
        {
            internal Pack.Cursor data_;
            internal GIMBAL_REPORT(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public float delta_time() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 2); }
            public void delta_time(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 2, 4);  }

            public float delta_angle_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 6); }
            public void delta_angle_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 6, 4);  }

            public float delta_angle_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 10); }
            public void delta_angle_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 10, 4);  }

            public float delta_angle_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 14); }
            public void delta_angle_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 14, 4);  }

            public float delta_velocity_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 18); }
            public void delta_velocity_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 18, 4);  }

            public float delta_velocity_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 22); }
            public void delta_velocity_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 22, 4);  }

            public float delta_velocity_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 26); }
            public void delta_velocity_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 26, 4);  }

            public float joint_roll() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 30); }
            public void joint_roll(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 30, 4);  }

            public float joint_el() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 34); }
            public void joint_el(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 34, 4);  }

            public float joint_az() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 38); }
            public void joint_az(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 38, 4);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void delta_time(float src);
                void delta_angle_x(float src);
                void delta_angle_y(float src);
                void delta_angle_z(float src);
                void delta_velocity_x(float src);
                void delta_velocity_y(float src);
                void delta_velocity_z(float src);
                void joint_roll(float src);
                void joint_el(float src);
                void joint_az(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(11, 0, 0, 0, 42, 1, 336);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.delta_time(delta_time()) ;
                dst.delta_angle_x(delta_angle_x()) ;
                dst.delta_angle_y(delta_angle_y()) ;
                dst.delta_angle_z(delta_angle_z()) ;
                dst.delta_velocity_x(delta_velocity_x()) ;
                dst.delta_velocity_y(delta_velocity_y()) ;
                dst.delta_velocity_z(delta_velocity_z()) ;
                dst.joint_roll(joint_roll()) ;
                dst.joint_el(joint_el()) ;
                dst.joint_az(joint_az()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                float delta_time();
                float delta_angle_x();
                float delta_angle_y();
                float delta_angle_z();
                float delta_velocity_x();
                float delta_velocity_y();
                float delta_velocity_z();
                float joint_roll();
                float joint_el();
                float joint_az();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                delta_time(src.delta_time());
                delta_angle_x(src.delta_angle_x());
                delta_angle_y(src.delta_angle_y());
                delta_angle_z(src.delta_angle_z());
                delta_velocity_x(src.delta_velocity_x());
                delta_velocity_y(src.delta_velocity_y());
                delta_velocity_z(src.delta_velocity_z());
                joint_roll(src.joint_roll());
                joint_el(src.joint_el());
                joint_az(src.joint_az());
            }



        }
        /**
        *Control message for rate gimbal */

        public struct GIMBAL_CONTROL
        {
            internal Pack.Cursor data_;
            internal GIMBAL_CONTROL(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public float demanded_rate_x() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 2); }
            public void demanded_rate_x(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 2, 4);  }

            public float demanded_rate_y() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 6); }
            public void demanded_rate_y(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 6, 4);  }

            public float demanded_rate_z() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 10); }
            public void demanded_rate_z(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 10, 4);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void demanded_rate_x(float src);
                void demanded_rate_y(float src);
                void demanded_rate_z(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(104, 0, 0, 0, 14, 1, 112);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.demanded_rate_x(demanded_rate_x()) ;
                dst.demanded_rate_y(demanded_rate_y()) ;
                dst.demanded_rate_z(demanded_rate_z()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                float demanded_rate_x();
                float demanded_rate_y();
                float demanded_rate_z();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                demanded_rate_x(src.demanded_rate_x());
                demanded_rate_y(src.demanded_rate_y());
                demanded_rate_z(src.demanded_rate_z());
            }



        }
        /**
        *100 Hz gimbal torque command telemetry */

        public struct GIMBAL_TORQUE_CMD_REPORT
        {
            internal Pack.Cursor data_;
            internal GIMBAL_TORQUE_CMD_REPORT(Pack.Cursor data) { this.data_ = data; }




            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public short rl_torque_cmd() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 2, 2)); }
            public void rl_torque_cmd(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 2);  }

            public short el_torque_cmd() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 4, 2)); }
            public void el_torque_cmd(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 4);  }

            public short az_torque_cmd() { return (short)((short)(short)Lib.get_bytes(data_.bytes,  data_.origin  + 6, 2)); }
            public void az_torque_cmd(short src) {   Lib.set_bytes((ulong)(src), 2, data_.bytes,  data_.origin  + 6);  }



            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void rl_torque_cmd(short src);
                void el_torque_cmd(short src);
                void az_torque_cmd(short src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(117, 0, 0, 0, 8, 1, 64);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.rl_torque_cmd(rl_torque_cmd()) ;
                dst.el_torque_cmd(el_torque_cmd()) ;
                dst.az_torque_cmd(az_torque_cmd()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                short rl_torque_cmd();
                short el_torque_cmd();
                short az_torque_cmd();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                rl_torque_cmd(src.rl_torque_cmd());
                el_torque_cmd(src.el_torque_cmd());
                az_torque_cmd(src.az_torque_cmd());
            }



        }
        /**
        *Heartbeat from a HeroBus attached GoPro */

        public struct GOPRO_HEARTBEAT
        {
            internal Pack.Cursor data_;
            internal GOPRO_HEARTBEAT(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                status = 2,
                capture_mode = 3,
                flags = 4
            }




            public  GOPRO_HEARTBEAT_STATUS? status()
            {
                if(data_.field_bit !=  2 && !data_.set_field(2, -1))  return null;
                return (GOPRO_HEARTBEAT_STATUS)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 2)));;
            }


            public void status(GOPRO_HEARTBEAT_STATUS src)
            {
                if(data_.field_bit !=  2) data_.set_field(2, 0);
                ;
                Lib.set_bits((ulong)(src), 2, data_.bytes, data_.BIT);;
            }




            public  GOPRO_CAPTURE_MODE? capture_mode()
            {
                if(data_.field_bit !=  3 && !data_.set_field(3, -1))  return null;
                return    GOPRO_CAPTURE_MODE_.from_bits(Lib.get_bits(data_.bytes, data_.BIT, 4));;
            }


            public void capture_mode(GOPRO_CAPTURE_MODE src)
            {
                if(data_.field_bit !=  3) data_.set_field(3, 0);
                ;
                Lib.set_bits(GOPRO_CAPTURE_MODE_.bits(src), 4, data_.bytes, data_.BIT) ;;
            }




            public  GOPRO_HEARTBEAT_FLAGS? flags()
            {
                if(data_.field_bit !=  4 && !data_.set_field(4, -1))  return null;
                return (GOPRO_HEARTBEAT_FLAGS)((1 + (sbyte)Lib.get_bits(data_.bytes, data_.BIT, 1)));;
            }


            public void flags(GOPRO_HEARTBEAT_FLAGS src)
            {
                if(data_.field_bit !=  4) data_.set_field(4, 0);
                ;
                Lib.set_bits((ulong)(src   - 1), 1, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void status(com.company.demo.GroundControl. GOPRO_HEARTBEAT_STATUS src);
                void capture_mode(com.company.demo.GroundControl. GOPRO_CAPTURE_MODE src);
                void flags(com.company.demo.GroundControl. GOPRO_HEARTBEAT_FLAGS src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(175, 0, 0, 0, 1, 1, 2, 2, 0, 3);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = status();
                    if(item.HasValue) dst.status(item.Value);
                }
                {
                    var item = capture_mode();
                    if(item.HasValue) dst.capture_mode(item.Value);
                }
                {
                    var item = flags();
                    if(item.HasValue) dst.flags(item.Value);
                }
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. GOPRO_HEARTBEAT_STATUS?  status();
                com.company.demo.GroundControl. GOPRO_CAPTURE_MODE?  capture_mode();
                com.company.demo.GroundControl. GOPRO_HEARTBEAT_FLAGS?  flags();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.status();
                    if(item.HasValue)     status(item.Value);
                }
                {
                    var item = src.capture_mode();
                    if(item.HasValue)     capture_mode(item.Value);
                }
                {
                    var item = src.flags();
                    if(item.HasValue)     flags(item.Value);
                }
            }



        }
        /**
        *Request a GOPRO_COMMAND response from the GoPro */

        public struct GOPRO_GET_REQUEST
        {
            internal Pack.Cursor data_;
            internal GOPRO_GET_REQUEST(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                cmd_id = 16
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }


            public  GOPRO_COMMAND? cmd_id()
            {
                if(data_.field_bit !=  16 && !data_.set_field(16, -1))  return null;
                return (GOPRO_COMMAND)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 5)));;
            }


            public void cmd_id(GOPRO_COMMAND src)
            {
                if(data_.field_bit !=  16) data_.set_field(16, 0);
                ;
                Lib.set_bits((ulong)(src), 5, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void cmd_id(com.company.demo.GroundControl. GOPRO_COMMAND src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(138, 0, 0, 0, 3, 1, 16, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = cmd_id();
                    if(item.HasValue) dst.cmd_id(item.Value);
                }
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                com.company.demo.GroundControl. GOPRO_COMMAND?  cmd_id();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                {
                    var item = src.cmd_id();
                    if(item.HasValue)     cmd_id(item.Value);
                }
            }



        }
        /**
        *Response from a GOPRO_COMMAND get request */

        public struct GOPRO_GET_RESPONSE
        {
            internal Pack.Cursor data_;
            internal GOPRO_GET_RESPONSE(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                cmd_id = 32,
                status = 33
            }



            public value_ value()
            {
                return new  value_(data_);
            }

            public struct value_
            {
                internal Pack.Cursor data_;
                public value_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return GOPRO_GET_RESPONSE.value_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != GOPRO_GET_RESPONSE.value_.item_len) return false;
                    for(int i = 0; i < GOPRO_GET_RESPONSE.value_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(value_ other)
                {
                    if(other.len() != GOPRO_GET_RESPONSE.value_.item_len) return false;
                    for(int i = 0; i < GOPRO_GET_RESPONSE.value_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + index] = (byte)(src); }

                public const int item_len = 4 ;


            }

            public void value(sbyte[] src)
            {
                var len =  Math.Min(src.Length, GOPRO_GET_RESPONSE.value_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + index] = (byte)(src[index]);
            }


            public  GOPRO_COMMAND? cmd_id()
            {
                if(data_.field_bit !=  32 && !data_.set_field(32, -1))  return null;
                return (GOPRO_COMMAND)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 5)));;
            }


            public void cmd_id(GOPRO_COMMAND src)
            {
                if(data_.field_bit !=  32) data_.set_field(32, 0);
                ;
                Lib.set_bits((ulong)(src), 5, data_.bytes, data_.BIT);;
            }




            public  GOPRO_REQUEST_STATUS? status()
            {
                if(data_.field_bit !=  33 && !data_.set_field(33, -1))  return null;
                return (GOPRO_REQUEST_STATUS)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 1)));;
            }


            public void status(GOPRO_REQUEST_STATUS src)
            {
                if(data_.field_bit !=  33) data_.set_field(33, 0);
                ;
                Lib.set_bits((ulong)(src), 1, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void cmd_id(com.company.demo.GroundControl. GOPRO_COMMAND src);
                void status(com.company.demo.GroundControl. GOPRO_REQUEST_STATUS src);
                void value(GOPRO_GET_RESPONSE.value_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(208, 0, 0, 0, 5, 1, 32, 0, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = cmd_id();
                    if(item.HasValue) dst.cmd_id(item.Value);
                }
                {
                    var item = status();
                    if(item.HasValue) dst.status(item.Value);
                }
                dst.value(value());
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. GOPRO_COMMAND?  cmd_id();
                com.company.demo.GroundControl. GOPRO_REQUEST_STATUS?  status();
                void value(GOPRO_GET_RESPONSE.value_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.cmd_id();
                    if(item.HasValue)     cmd_id(item.Value);
                }
                {
                    var item = src.status();
                    if(item.HasValue)     status(item.Value);
                }
                src.value(value());
            }



        }
        /**
        *Request to set a GOPRO_COMMAND with a desired */

        public struct GOPRO_SET_REQUEST
        {
            internal Pack.Cursor data_;
            internal GOPRO_SET_REQUEST(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                cmd_id = 48
            }



            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin ]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin ] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 1]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 1] = (byte)(src);  }

            public value_ value()
            {
                return new  value_(data_);
            }

            public struct value_
            {
                internal Pack.Cursor data_;
                public value_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return GOPRO_SET_REQUEST.value_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 2 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != GOPRO_SET_REQUEST.value_.item_len) return false;
                    for(int i = 0; i < GOPRO_SET_REQUEST.value_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(value_ other)
                {
                    if(other.len() != GOPRO_SET_REQUEST.value_.item_len) return false;
                    for(int i = 0; i < GOPRO_SET_REQUEST.value_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 2 + index] = (byte)(src); }

                public const int item_len = 4 ;


            }

            public void value(sbyte[] src)
            {
                var len =  Math.Min(src.Length, GOPRO_SET_REQUEST.value_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 2 + index] = (byte)(src[index]);
            }


            public  GOPRO_COMMAND? cmd_id()
            {
                if(data_.field_bit !=  48 && !data_.set_field(48, -1))  return null;
                return (GOPRO_COMMAND)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 5)));;
            }


            public void cmd_id(GOPRO_COMMAND src)
            {
                if(data_.field_bit !=  48) data_.set_field(48, 0);
                ;
                Lib.set_bits((ulong)(src), 5, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void cmd_id(com.company.demo.GroundControl. GOPRO_COMMAND src);
                void value(GOPRO_SET_REQUEST.value_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(118, 0, 0, 0, 7, 1, 48, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                {
                    var item = cmd_id();
                    if(item.HasValue) dst.cmd_id(item.Value);
                }
                dst.value(value());
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                com.company.demo.GroundControl. GOPRO_COMMAND?  cmd_id();
                void value(GOPRO_SET_REQUEST.value_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                {
                    var item = src.cmd_id();
                    if(item.HasValue)     cmd_id(item.Value);
                }
                src.value(value());
            }



        }
        /**
        *Response from a GOPRO_COMMAND set request */

        public struct GOPRO_SET_RESPONSE
        {
            internal Pack.Cursor data_;
            internal GOPRO_SET_RESPONSE(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                cmd_id = 0,
                status = 1
            }




            public  GOPRO_COMMAND? cmd_id()
            {
                if(data_.field_bit !=  0 && !data_.set_field(0, -1))  return null;
                return (GOPRO_COMMAND)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 5)));;
            }


            public void cmd_id(GOPRO_COMMAND src)
            {
                if(data_.field_bit !=  0) data_.set_field(0, 0);
                ;
                Lib.set_bits((ulong)(src), 5, data_.bytes, data_.BIT);;
            }




            public  GOPRO_REQUEST_STATUS? status()
            {
                if(data_.field_bit !=  1 && !data_.set_field(1, -1))  return null;
                return (GOPRO_REQUEST_STATUS)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 1)));;
            }


            public void status(GOPRO_REQUEST_STATUS src)
            {
                if(data_.field_bit !=  1) data_.set_field(1, 0);
                ;
                Lib.set_bits((ulong)(src), 1, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void cmd_id(com.company.demo.GroundControl. GOPRO_COMMAND src);
                void status(com.company.demo.GroundControl. GOPRO_REQUEST_STATUS src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(192, 0, 0, 0, 1, 1, 0, 0, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = cmd_id();
                    if(item.HasValue) dst.cmd_id(item.Value);
                }
                {
                    var item = status();
                    if(item.HasValue) dst.status(item.Value);
                }
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. GOPRO_COMMAND?  cmd_id();
                com.company.demo.GroundControl. GOPRO_REQUEST_STATUS?  status();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.cmd_id();
                    if(item.HasValue)     cmd_id(item.Value);
                }
                {
                    var item = src.status();
                    if(item.HasValue)     status(item.Value);
                }
            }



        }
        /**
        *RPM sensor output */

        public struct RPM
        {
            internal Pack.Cursor data_;
            internal RPM(Pack.Cursor data) { this.data_ = data; }




            public float rpm1() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void rpm1(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float rpm2() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void rpm2(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }



            public interface DST_
            {
                void rpm1(float src);
                void rpm2(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(183, 0, 0, 0, 8, 1, 64);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.rpm1(rpm1()) ;
                dst.rpm2(rpm2()) ;
            }

            public interface SRC_
            {
                float rpm1();
                float rpm2();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                rpm1(src.rpm1());
                rpm2(src.rpm2());
            }



        }
        /**
        *Read registers for a device */

        public struct DEVICE_OP_READ
        {
            internal Pack.Cursor data_;
            internal DEVICE_OP_READ(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                bustype = 82,
                busname = 83
            }



            public int request_id() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void request_id(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }

            public sbyte bus() { return (sbyte)(data_.bytes[data_.origin  + 6]); }
            public void bus(sbyte src) {    data_.bytes[data_.origin  + 6] = (byte)(src);  }

            public sbyte address() { return (sbyte)(data_.bytes[data_.origin  + 7]); }
            public void address(sbyte src) {    data_.bytes[data_.origin  + 7] = (byte)(src);  }

            public sbyte regstart() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void regstart(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }

            public sbyte count() { return (sbyte)(data_.bytes[data_.origin  + 9]); }
            public void count(sbyte src) {    data_.bytes[data_.origin  + 9] = (byte)(src);  }


            public  DEVICE_OP_BUSTYPE? bustype()
            {
                if(data_.field_bit !=  82 && !data_.set_field(82, -1))  return null;
                return (DEVICE_OP_BUSTYPE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 1)));;
            }


            public void bustype(DEVICE_OP_BUSTYPE src)
            {
                if(data_.field_bit !=  82) data_.set_field(82, 0);
                ;
                Lib.set_bits((ulong)(src), 1, data_.bytes, data_.BIT);;
            }




            public busname_? busname()
            {
                if(data_.field_bit !=  83 && !data_.set_field(83, -1))  return (busname_?) null;
                return new busname_(data_);
            }



            public char[] busname(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  83) data_.set_field(83, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), DEVICE_OP_READ.busname_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void busname(byte[] src)
            {
                var len = Math.Min(src.Length, DEVICE_OP_READ.busname_.item_len_max);
                if(data_.field_bit !=  83) data_.set_field(83, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public busname_ busname(int len)
            {
                if(data_.field_bit !=  83) data_.set_field(83, Math.Min(len, DEVICE_OP_READ.busname_.item_len_max));
                return new busname_(data_);
            }

            public struct busname_
            {
                Pack.Cursor data_;
                public busname_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(busname_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void request_id(int src);
                void bustype(com.company.demo.GroundControl. DEVICE_OP_BUSTYPE src);
                void bus(sbyte src);
                void address(sbyte src);
                void busname(DEVICE_OP_READ.busname_ src);
                void regstart(sbyte src);
                void count(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(70, 0, 1, 0, 11, 1, 82, 2, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.request_id(request_id()) ;
                {
                    var item = bustype();
                    if(item.HasValue) dst.bustype(item.Value);
                }
                dst.bus(bus()) ;
                dst.address(address()) ;
                {
                    var item = busname();
                    if(item.HasValue) dst.busname(item.Value);
                }
                dst.regstart(regstart()) ;
                dst.count(count()) ;
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                int request_id();
                com.company.demo.GroundControl. DEVICE_OP_BUSTYPE?  bustype();
                sbyte bus();
                sbyte address();
                int busname_exist() ;
                void busname(DEVICE_OP_READ.busname_ dst) ;
                sbyte regstart();
                sbyte count();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                request_id(src.request_id());
                {
                    var item = src.bustype();
                    if(item.HasValue)     bustype(item.Value);
                }
                bus(src.bus());
                address(src.address());
                {
                    var len = src.busname_exist();
                    if(0 < len)
                        src.busname(busname(len));
                }
                regstart(src.regstart());
                count(src.count());
            }



        }
        /**
        *Read registers reply */

        public struct DEVICE_OP_READ_REPLY
        {
            internal Pack.Cursor data_;
            internal DEVICE_OP_READ_REPLY(Pack.Cursor data) { this.data_ = data; }




            public int request_id() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void request_id(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public sbyte result() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void result(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte regstart() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void regstart(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }

            public sbyte count() { return (sbyte)(data_.bytes[data_.origin  + 6]); }
            public void count(sbyte src) {    data_.bytes[data_.origin  + 6] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return DEVICE_OP_READ_REPLY.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 7 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != DEVICE_OP_READ_REPLY.daTa_.item_len) return false;
                    for(int i = 0; i < DEVICE_OP_READ_REPLY.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != DEVICE_OP_READ_REPLY.daTa_.item_len) return false;
                    for(int i = 0; i < DEVICE_OP_READ_REPLY.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 7 + index] = (byte)(src); }

                public const int item_len = 128 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, DEVICE_OP_READ_REPLY.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 7 + index] = (byte)(src[index]);
            }



            public interface DST_
            {
                void request_id(int src);
                void result(sbyte src);
                void regstart(sbyte src);
                void count(sbyte src);
                void daTa(DEVICE_OP_READ_REPLY.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(165, 0, 1, 0, 135, 1, 1080);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.request_id(request_id()) ;
                dst.result(result()) ;
                dst.regstart(regstart()) ;
                dst.count(count()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                int request_id();
                sbyte result();
                sbyte regstart();
                sbyte count();
                void daTa(DEVICE_OP_READ_REPLY.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                request_id(src.request_id());
                result(src.result());
                regstart(src.regstart());
                count(src.count());
                src.daTa(daTa());
            }



        }
        /**
        *Write registers for a device */

        public struct DEVICE_OP_WRITE
        {
            internal Pack.Cursor data_;
            internal DEVICE_OP_WRITE(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                bustype = 1106,
                busname = 1107
            }



            public int request_id() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void request_id(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public sbyte target_system() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void target_system(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }

            public sbyte target_component() { return (sbyte)(data_.bytes[data_.origin  + 5]); }
            public void target_component(sbyte src) {    data_.bytes[data_.origin  + 5] = (byte)(src);  }

            public sbyte bus() { return (sbyte)(data_.bytes[data_.origin  + 6]); }
            public void bus(sbyte src) {    data_.bytes[data_.origin  + 6] = (byte)(src);  }

            public sbyte address() { return (sbyte)(data_.bytes[data_.origin  + 7]); }
            public void address(sbyte src) {    data_.bytes[data_.origin  + 7] = (byte)(src);  }

            public sbyte regstart() { return (sbyte)(data_.bytes[data_.origin  + 8]); }
            public void regstart(sbyte src) {    data_.bytes[data_.origin  + 8] = (byte)(src);  }

            public sbyte count() { return (sbyte)(data_.bytes[data_.origin  + 9]); }
            public void count(sbyte src) {    data_.bytes[data_.origin  + 9] = (byte)(src);  }

            public daTa_ daTa()
            {
                return new  daTa_(data_);
            }

            public struct daTa_
            {
                internal Pack.Cursor data_;
                public daTa_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return DEVICE_OP_WRITE.daTa_.item_len  ;}
                public sbyte get(int index) { return (sbyte)(data_.bytes[data_.origin  + 10 + index]); }

                public bool same(sbyte[] other)
                {
                    if(other.Length != DEVICE_OP_WRITE.daTa_.item_len) return false;
                    for(int i = 0; i < DEVICE_OP_WRITE.daTa_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(daTa_ other)
                {
                    if(other.len() != DEVICE_OP_WRITE.daTa_.item_len) return false;
                    for(int i = 0; i < DEVICE_OP_WRITE.daTa_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(sbyte src, int index) {  data_.bytes[data_.origin  + 10 + index] = (byte)(src); }

                public const int item_len = 128 ;


            }

            public void daTa(sbyte[] src)
            {
                var len =  Math.Min(src.Length, DEVICE_OP_WRITE.daTa_.item_len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.origin  + 10 + index] = (byte)(src[index]);
            }


            public  DEVICE_OP_BUSTYPE? bustype()
            {
                if(data_.field_bit !=  1106 && !data_.set_field(1106, -1))  return null;
                return (DEVICE_OP_BUSTYPE)(((sbyte)Lib.get_bits(data_.bytes, data_.BIT, 1)));;
            }


            public void bustype(DEVICE_OP_BUSTYPE src)
            {
                if(data_.field_bit !=  1106) data_.set_field(1106, 0);
                ;
                Lib.set_bits((ulong)(src), 1, data_.bytes, data_.BIT);;
            }




            public busname_? busname()
            {
                if(data_.field_bit !=  1107 && !data_.set_field(1107, -1))  return (busname_?) null;
                return new busname_(data_);
            }



            public char[] busname(string src, char[] reuse)
            {
                var len = src.Length;
                if(reuse == null || reuse.Length < len) reuse = src.ToCharArray();
                else src.CopyTo(0, reuse, 0, len);
                if(data_.field_bit !=  1107) data_.set_field(1107, Math.Min(Encoding.UTF8.GetByteCount(reuse, 0, len), DEVICE_OP_WRITE.busname_.item_len_max));
                Encoding.UTF8.GetBytes(reuse, 0, len, data_.bytes, data_.BYTE);
                return reuse;
            }


            public void busname(byte[] src)
            {
                var len = Math.Min(src.Length, DEVICE_OP_WRITE.busname_.item_len_max);
                if(data_.field_bit !=  1107) data_.set_field(1107, len);
                for(int index = 0; index < len; index++)
                    data_.bytes[data_.BYTE + index] = src[index];;
            }

            public busname_ busname(int len)
            {
                if(data_.field_bit !=  1107) data_.set_field(1107, Math.Min(len, DEVICE_OP_WRITE.busname_.item_len_max));
                return new busname_(data_);
            }

            public struct busname_
            {
                Pack.Cursor data_;
                public busname_(Pack.Cursor data) {this.data_ = data;}

                public void set(byte src, int index) {  data_.bytes[data_.BYTE + index] =  src ; }

                public byte get(int index)  { return data_.bytes[data_.BYTE + index]; ;}
                public string get() { return Encoding.UTF8.GetString(data_.bytes, data_.BYTE, data_.item_len) ;}

                public bool same(byte [] other)
                {
                    if(other.Length != len()) return false;
                    for(int i = 0; i < other.Length; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(busname_ other)
                {
                    if(other.len() != len()) return false;
                    for(int i = 0; i < len(); i++) if(other.get(i) != get(i)) return false;
                    return true;
                }
                public int len() { return data_.item_len;  }

                public const int item_len_max = 255 ;

            }




            public interface DST_
            {
                void target_system(sbyte src);
                void target_component(sbyte src);
                void request_id(int src);
                void bustype(com.company.demo.GroundControl. DEVICE_OP_BUSTYPE src);
                void bus(sbyte src);
                void address(sbyte src);
                void busname(DEVICE_OP_WRITE.busname_ src);
                void regstart(sbyte src);
                void count(sbyte src);
                void daTa(DEVICE_OP_WRITE.daTa_ src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(105, 0, 1, 0, 139, 1, 1106, 2, 0, 2);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.target_system(target_system()) ;
                dst.target_component(target_component()) ;
                dst.request_id(request_id()) ;
                {
                    var item = bustype();
                    if(item.HasValue) dst.bustype(item.Value);
                }
                dst.bus(bus()) ;
                dst.address(address()) ;
                {
                    var item = busname();
                    if(item.HasValue) dst.busname(item.Value);
                }
                dst.regstart(regstart()) ;
                dst.count(count()) ;
                dst.daTa(daTa());
            }

            public interface SRC_
            {
                sbyte target_system();
                sbyte target_component();
                int request_id();
                com.company.demo.GroundControl. DEVICE_OP_BUSTYPE?  bustype();
                sbyte bus();
                sbyte address();
                int busname_exist() ;
                void busname(DEVICE_OP_WRITE.busname_ dst) ;
                sbyte regstart();
                sbyte count();
                void daTa(DEVICE_OP_WRITE.daTa_ dst) ;

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                target_system(src.target_system());
                target_component(src.target_component());
                request_id(src.request_id());
                {
                    var item = src.bustype();
                    if(item.HasValue)     bustype(item.Value);
                }
                bus(src.bus());
                address(src.address());
                {
                    var len = src.busname_exist();
                    if(0 < len)
                        src.busname(busname(len));
                }
                regstart(src.regstart());
                count(src.count());
                src.daTa(daTa());
            }



        }
        /**
        *Write registers reply */

        public struct DEVICE_OP_WRITE_REPLY
        {
            internal Pack.Cursor data_;
            internal DEVICE_OP_WRITE_REPLY(Pack.Cursor data) { this.data_ = data; }




            public int request_id() { return (int)((int)(int)Lib.get_bytes(data_.bytes,  data_.origin, 4)); }
            public void request_id(int src) {   Lib.set_bytes((ulong)(src), 4, data_.bytes,  data_.origin);  }

            public sbyte result() { return (sbyte)(data_.bytes[data_.origin  + 4]); }
            public void result(sbyte src) {    data_.bytes[data_.origin  + 4] = (byte)(src);  }



            public interface DST_
            {
                void request_id(int src);
                void result(sbyte src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(33, 0, 1, 0, 5, 1, 40);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.request_id(request_id()) ;
                dst.result(result()) ;
            }

            public interface SRC_
            {
                int request_id();
                sbyte result();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                request_id(src.request_id());
                result(src.result());
            }



        }
        /**
        *Adaptive Controller tuning information */

        public struct ADAP_TUNING
        {
            internal Pack.Cursor data_;
            internal ADAP_TUNING(Pack.Cursor data) { this.data_ = data; }


            public OptFields AnyOptField() { return (OptFields)(data_.field_bit == -1 ? data_.next_field_bit() : data_.field_bit); }
            public enum OptFields
            {
                None = -1,
                axis = 384
            }



            public float desired() { return  BitConverter.ToSingle(data_.bytes, data_.origin); }
            public void desired(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin, 4);  }

            public float achieved() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 4); }
            public void achieved(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 4, 4);  }

            public float error() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 8); }
            public void error(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 8, 4);  }

            public float theta() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 12); }
            public void theta(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 12, 4);  }

            public float omega() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16); }
            public void omega(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16, 4);  }

            public float sigma() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 20); }
            public void sigma(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 20, 4);  }

            public float theta_dot() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 24); }
            public void theta_dot(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 24, 4);  }

            public float omega_dot() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28); }
            public void omega_dot(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28, 4);  }

            public float sigma_dot() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 32); }
            public void sigma_dot(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 32, 4);  }

            public float f() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 36); }
            public void f(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 36, 4);  }

            public float f_dot() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }
            public void f_dot(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 40, 4);  }

            public float u() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 44); }
            public void u(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 44, 4);  }


            public  PID_TUNING_AXIS? axis()
            {
                if(data_.field_bit !=  384 && !data_.set_field(384, -1))  return null;
                return (PID_TUNING_AXIS)((1 + (sbyte)Lib.get_bits(data_.bytes, data_.BIT, 3)));;
            }


            public void axis(PID_TUNING_AXIS src)
            {
                if(data_.field_bit !=  384) data_.set_field(384, 0);
                ;
                Lib.set_bits((ulong)(src   - 1), 3, data_.bytes, data_.BIT);;
            }





            public interface DST_
            {
                void axis(com.company.demo.GroundControl. PID_TUNING_AXIS src);
                void desired(float src);
                void achieved(float src);
                void error(float src);
                void theta(float src);
                void omega(float src);
                void sigma(float src);
                void theta_dot(float src);
                void omega_dot(float src);
                void sigma_dot(float src);
                void f(float src);
                void f_dot(float src);
                void u(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(115, 0, 0, 0, 49, 1, 384, 0, 0, 1);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                {
                    var item = axis();
                    if(item.HasValue) dst.axis(item.Value);
                }
                dst.desired(desired()) ;
                dst.achieved(achieved()) ;
                dst.error(error()) ;
                dst.theta(theta()) ;
                dst.omega(omega()) ;
                dst.sigma(sigma()) ;
                dst.theta_dot(theta_dot()) ;
                dst.omega_dot(omega_dot()) ;
                dst.sigma_dot(sigma_dot()) ;
                dst.f(f()) ;
                dst.f_dot(f_dot()) ;
                dst.u(u()) ;
            }

            public interface SRC_
            {
                com.company.demo.GroundControl. PID_TUNING_AXIS?  axis();
                float desired();
                float achieved();
                float error();
                float theta();
                float omega();
                float sigma();
                float theta_dot();
                float omega_dot();
                float sigma_dot();
                float f();
                float f_dot();
                float u();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                {
                    var item = src.axis();
                    if(item.HasValue)     axis(item.Value);
                }
                desired(src.desired());
                achieved(src.achieved());
                error(src.error());
                theta(src.theta());
                omega(src.omega());
                sigma(src.sigma());
                theta_dot(src.theta_dot());
                omega_dot(src.omega_dot());
                sigma_dot(src.sigma_dot());
                f(src.f());
                f_dot(src.f_dot());
                u(src.u());
            }



        }
        /**
        *camera vision based attitude and position deltas */

        public struct VISION_POSITION_DELTA
        {
            internal Pack.Cursor data_;
            internal VISION_POSITION_DELTA(Pack.Cursor data) { this.data_ = data; }




            public long time_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin, 8)); }
            public void time_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin);  }

            public long time_delta_usec() { return (long)((long)(long)Lib.get_bytes(data_.bytes,  data_.origin  + 8, 8)); }
            public void time_delta_usec(long src) {   Lib.set_bytes((ulong)(src), 8, data_.bytes,  data_.origin  + 8);  }

            public angle_delta_ angle_delta()
            {
                return new  angle_delta_(data_);
            }

            public struct angle_delta_
            {
                internal Pack.Cursor data_;
                public angle_delta_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return VISION_POSITION_DELTA.angle_delta_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 16 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != VISION_POSITION_DELTA.angle_delta_.item_len) return false;
                    for(int i = 0; i < VISION_POSITION_DELTA.angle_delta_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(angle_delta_ other)
                {
                    if(other.len() != VISION_POSITION_DELTA.angle_delta_.item_len) return false;
                    for(int i = 0; i < VISION_POSITION_DELTA.angle_delta_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 16 + index * 4, 4); }

                public const int item_len = 3 ;


            }

            public void angle_delta(float[] src)
            {
                var len =  Math.Min(src.Length, VISION_POSITION_DELTA.angle_delta_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 16 + index * 4, 4);
            }

            public position_delta_ position_delta()
            {
                return new  position_delta_(data_);
            }

            public struct position_delta_
            {
                internal Pack.Cursor data_;
                public position_delta_(Pack.Cursor data) { this.data_ = data; }
                public int len() { return VISION_POSITION_DELTA.position_delta_.item_len  ;}
                public float get(int index) { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 28 + index * 4); }

                public bool same(float[] other)
                {
                    if(other.Length != VISION_POSITION_DELTA.position_delta_.item_len) return false;
                    for(int i = 0; i < VISION_POSITION_DELTA.position_delta_.item_len  ; i++) if(other[i] != get(i)) return false;
                    return true;
                }

                public bool same(position_delta_ other)
                {
                    if(other.len() != VISION_POSITION_DELTA.position_delta_.item_len) return false;
                    for(int i = 0; i < VISION_POSITION_DELTA.position_delta_.item_len ; i++)	if(other.get(i) != get(i)) return false ;
                    return true;
                }

                public void set(float src, int index) { Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 28 + index * 4, 4); }

                public const int item_len = 3 ;


            }

            public void position_delta(float[] src)
            {
                var len =  Math.Min(src.Length, VISION_POSITION_DELTA.position_delta_.item_len);
                for(int index = 0; index < len; index++)
                    Array.Copy(BitConverter.GetBytes((float)(src[index])), 0, data_.bytes, data_.origin  + 28 + index * 4, 4);
            }

            public float confidence() { return  BitConverter.ToSingle(data_.bytes, data_.origin  + 40); }
            public void confidence(float src) {   Array.Copy(BitConverter.GetBytes((float)(src)), 0, data_.bytes, data_.origin  + 40, 4);  }



            public interface DST_
            {
                void time_usec(long src);
                void time_delta_usec(long src);
                void angle_delta(VISION_POSITION_DELTA.angle_delta_ src);
                void position_delta(VISION_POSITION_DELTA.position_delta_ src);
                void confidence(float src);

            }

            internal static readonly Pack.Meta meta_ =  new Pack.Meta(12, 0, 0, 2, 44, 1, 352);

            public  void push_< DST >(DST dst) where DST : struct, DST_
            {
                dst.time_usec(time_usec()) ;
                dst.time_delta_usec(time_delta_usec()) ;
                dst.angle_delta(angle_delta());
                dst.position_delta(position_delta());
                dst.confidence(confidence()) ;
            }

            public interface SRC_
            {
                long time_usec();
                long time_delta_usec();
                void angle_delta(VISION_POSITION_DELTA.angle_delta_ dst) ;
                void position_delta(VISION_POSITION_DELTA.position_delta_ dst) ;
                float confidence();

            }

            public void pull_<SRC>(SRC src) where SRC: struct, SRC_
            {
                time_usec(src.time_usec());
                time_delta_usec(src.time_delta_usec());
                src.angle_delta(angle_delta());
                src.position_delta(position_delta());
                confidence(src.confidence());
            }



        }

    }

    public abstract class CommunicationChannel : Stream
    {
        public override void Flush() { }
        public override long Seek(long offset, SeekOrigin origin) { throw new NotSupportedException(); }
        public override void SetLength(long value) { throw new NotSupportedException(); }
        public override bool CanRead { get { return true  ; } }
        public override bool CanWrite { get { return true; } }
        public override bool CanSeek => false;
        public override long Length => throw new NotSupportedException();

        public override long Position
        {
            get => throw new NotSupportedException();
            set => throw new NotSupportedException();
        }

        public CommunicationChannel()
        {
            receiver = new Receiver(this);
            transmitter = new Transmitter(this);
        }


        public override void Write(byte[] src, int offset, int bytes) { receiver.BytesIntoPacks(src, offset, bytes); }
        class Receiver : Lib.Channel.Receiver
        {
            readonly CommunicationChannel ch;
            public Receiver(CommunicationChannel ch): base(1) { this.ch = ch; }

            protected internal override Pack.Meta dispatch(int id, Pack pack)
            {
                switch(id)
                {
                    case 149 :
                        if(pack == null)return DATA_TRANSMISSION_HANDSHAKE.meta_ ;
                        ch.onDATA_TRANSMISSION_HANDSHAKE(pack);
                        break;
                    case 81 :
                        if(pack == null)return MISSION_ITEM_REACHED.meta_ ;
                        ch.onMISSION_ITEM_REACHED(pack);
                        break;
                    case 103 :
                        if(pack == null)return VIBRATION.meta_ ;
                        ch.onVIBRATION(pack);
                        break;
                    case 218 :
                        if(pack == null)return SET_POSITION_TARGET_GLOBAL_INT.meta_ ;
                        ch.onSET_POSITION_TARGET_GLOBAL_INT(pack);
                        break;
                    case 19 :
                        if(pack == null)return RAW_PRESSURE.meta_ ;
                        ch.onRAW_PRESSURE(pack);
                        break;
                    case 9 :
                        if(pack == null)return SYSTEM_TIME.meta_ ;
                        ch.onSYSTEM_TIME(pack);
                        break;
                    case 196 :
                        if(pack == null)return HIL_STATE_QUATERNION.meta_ ;
                        ch.onHIL_STATE_QUATERNION(pack);
                        break;
                    case 35 :
                        if(pack == null)return MISSION_ITEM.meta_ ;
                        ch.onMISSION_ITEM(pack);
                        break;
                    case 173 :
                        if(pack == null)return TERRAIN_DATA.meta_ ;
                        ch.onTERRAIN_DATA(pack);
                        break;
                    case 134 :
                        if(pack == null)return ATTITUDE.meta_ ;
                        ch.onATTITUDE(pack);
                        break;
                    case 72 :
                        if(pack == null)return LOG_REQUEST_DATA.meta_ ;
                        ch.onLOG_REQUEST_DATA(pack);
                        break;
                    case 179 :
                        if(pack == null)return SAFETY_ALLOWED_AREA.meta_ ;
                        ch.onSAFETY_ALLOWED_AREA(pack);
                        break;
                    case 162 :
                        if(pack == null)return GLOBAL_POSITION_INT.meta_ ;
                        ch.onGLOBAL_POSITION_INT(pack);
                        break;
                    case 74 :
                        if(pack == null)return SET_ATTITUDE_TARGET.meta_ ;
                        ch.onSET_ATTITUDE_TARGET(pack);
                        break;
                    case 24 :
                        if(pack == null)return SAFETY_SET_ALLOWED_AREA.meta_ ;
                        ch.onSAFETY_SET_ALLOWED_AREA(pack);
                        break;
                    case 110 :
                        if(pack == null)return GLOBAL_VISION_POSITION_ESTIMATE.meta_ ;
                        ch.onGLOBAL_VISION_POSITION_ESTIMATE(pack);
                        break;
                    case 136 :
                        if(pack == null)return PARAM_VALUE.meta_ ;
                        ch.onPARAM_VALUE(pack);
                        break;
                    case 7 :
                        if(pack == null)return SET_MODE.meta_ ;
                        ch.onSET_MODE(pack);
                        break;
                    case 2 :
                        if(pack == null)return SCALED_IMU3.meta_ ;
                        ch.onSCALED_IMU3(pack);
                        break;
                    case 94 :
                        if(pack == null)return SET_ACTUATOR_CONTROL_TARGET.meta_ ;
                        ch.onSET_ACTUATOR_CONTROL_TARGET(pack);
                        break;
                    case 101 :
                        if(pack == null)return COMMAND_LONG.meta_ ;
                        ch.onCOMMAND_LONG(pack);
                        break;
                    case 216 :
                        if(pack == null)return CAMERA_CAPTURE_STATUS.meta_ ;
                        ch.onCAMERA_CAPTURE_STATUS(pack);
                        break;
                    case 209 :
                        if(pack == null)return SET_POSITION_TARGET_LOCAL_NED.meta_ ;
                        ch.onSET_POSITION_TARGET_LOCAL_NED(pack);
                        break;
                    case 156 :
                        if(pack == null)return POWER_STATUS.meta_ ;
                        ch.onPOWER_STATUS(pack);
                        break;
                    case 79 :
                        if(pack == null)return SERVO_OUTPUT_RAW.meta_ ;
                        ch.onSERVO_OUTPUT_RAW(pack);
                        break;
                    case 185 :
                        if(pack == null)return GPS_GLOBAL_ORIGIN.meta_ ;
                        ch.onGPS_GLOBAL_ORIGIN(pack);
                        break;
                    case 201 :
                        if(pack == null)return NAV_CONTROLLER_OUTPUT.meta_ ;
                        ch.onNAV_CONTROLLER_OUTPUT(pack);
                        break;
                    case 37 :
                        if(pack == null)return LOG_REQUEST_LIST.meta_ ;
                        ch.onLOG_REQUEST_LIST(pack);
                        break;
                    case 73 :
                        if(pack == null)return GPS_INPUT.meta_ ;
                        ch.onGPS_INPUT(pack);
                        break;
                    case 102 :
                        if(pack == null)return LOG_REQUEST_END.meta_ ;
                        ch.onLOG_REQUEST_END(pack);
                        break;
                    case 207 :
                        if(pack == null)return CONTROL_SYSTEM_STATE.meta_ ;
                        ch.onCONTROL_SYSTEM_STATE(pack);
                        break;
                    case 168 :
                        if(pack == null)return HIL_GPS.meta_ ;
                        ch.onHIL_GPS(pack);
                        break;
                    case 158 :
                        if(pack == null)return LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET.meta_ ;
                        ch.onLOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(pack);
                        break;
                    case 161 :
                        if(pack == null)return LOG_ENTRY.meta_ ;
                        ch.onLOG_ENTRY(pack);
                        break;
                    case 41 :
                        if(pack == null)return MESSAGE_INTERVAL.meta_ ;
                        ch.onMESSAGE_INTERVAL(pack);
                        break;
                    case 133 :
                        if(pack == null)return POSITION_TARGET_GLOBAL_INT.meta_ ;
                        ch.onPOSITION_TARGET_GLOBAL_INT(pack);
                        break;
                    case 130 :
                        if(pack == null)return SCALED_PRESSURE3.meta_ ;
                        ch.onSCALED_PRESSURE3(pack);
                        break;
                    case 122 :
                        if(pack == null)return PING.meta_ ;
                        ch.onPING(pack);
                        break;
                    case 10 :
                        if(pack == null)return CAMERA_IMAGE_CAPTURED.meta_ ;
                        ch.onCAMERA_IMAGE_CAPTURED(pack);
                        break;
                    case 30 :
                        if(pack == null)return MEMORY_VECT.meta_ ;
                        ch.onMEMORY_VECT(pack);
                        break;
                    case 98 :
                        if(pack == null)return REQUEST_DATA_STREAM.meta_ ;
                        ch.onREQUEST_DATA_STREAM(pack);
                        break;
                    case 206 :
                        if(pack == null)return MISSION_REQUEST_PARTIAL_LIST.meta_ ;
                        ch.onMISSION_REQUEST_PARTIAL_LIST(pack);
                        break;
                    case 121 :
                        if(pack == null)return COMMAND_ACK.meta_ ;
                        ch.onCOMMAND_ACK(pack);
                        break;
                    case 85 :
                        if(pack == null)return MISSION_ACK.meta_ ;
                        ch.onMISSION_ACK(pack);
                        break;
                    case 191 :
                        if(pack == null)return CAMERA_TRIGGER.meta_ ;
                        ch.onCAMERA_TRIGGER(pack);
                        break;
                    case 99 :
                        if(pack == null)return SERIAL_CONTROL.meta_ ;
                        ch.onSERIAL_CONTROL(pack);
                        break;
                    case 180 :
                        if(pack == null)return LOCAL_POSITION_NED_COV.meta_ ;
                        ch.onLOCAL_POSITION_NED_COV(pack);
                        break;
                    case 163 :
                        if(pack == null)return RAW_IMU.meta_ ;
                        ch.onRAW_IMU(pack);
                        break;
                    case 200 :
                        if(pack == null)return ATT_POS_MOCAP.meta_ ;
                        ch.onATT_POS_MOCAP(pack);
                        break;
                    case 212 :
                        if(pack == null)return MISSION_SET_CURRENT.meta_ ;
                        ch.onMISSION_SET_CURRENT(pack);
                        break;
                    case 199 :
                        if(pack == null)return HIL_ACTUATOR_CONTROLS.meta_ ;
                        ch.onHIL_ACTUATOR_CONTROLS(pack);
                        break;
                    case 145 :
                        if(pack == null)return MISSION_WRITE_PARTIAL_LIST.meta_ ;
                        ch.onMISSION_WRITE_PARTIAL_LIST(pack);
                        break;
                    case 107 :
                        if(pack == null)return RADIO_STATUS.meta_ ;
                        ch.onRADIO_STATUS(pack);
                        break;
                    case 202 :
                        if(pack == null)return OPTICAL_FLOW_RAD.meta_ ;
                        ch.onOPTICAL_FLOW_RAD(pack);
                        break;
                    case 47 :
                        if(pack == null)return PARAM_REQUEST_LIST.meta_ ;
                        ch.onPARAM_REQUEST_LIST(pack);
                        break;
                    case 39 :
                        if(pack == null)return FOLLOW_TARGET.meta_ ;
                        ch.onFOLLOW_TARGET(pack);
                        break;
                    case 45 :
                        if(pack == null)return COLLISION.meta_ ;
                        ch.onCOLLISION(pack);
                        break;
                    case 46 :
                        if(pack == null)return TIMESYNC.meta_ ;
                        ch.onTIMESYNC(pack);
                        break;
                    case 178 :
                        if(pack == null)return SCALED_IMU2.meta_ ;
                        ch.onSCALED_IMU2(pack);
                        break;
                    case 71 :
                        if(pack == null)return ATTITUDE_QUATERNION.meta_ ;
                        ch.onATTITUDE_QUATERNION(pack);
                        break;
                    case 106 :
                        if(pack == null)return ATTITUDE_TARGET.meta_ ;
                        ch.onATTITUDE_TARGET(pack);
                        break;
                    case 169 :
                        if(pack == null)return HIL_SENSOR.meta_ ;
                        ch.onHIL_SENSOR(pack);
                        break;
                    case 78 :
                        if(pack == null)return ADSB_VEHICLE.meta_ ;
                        ch.onADSB_VEHICLE(pack);
                        break;
                    case 181 :
                        if(pack == null)return CAMERA_SETTINGS.meta_ ;
                        ch.onCAMERA_SETTINGS(pack);
                        break;
                    case 95 :
                        if(pack == null)return AUTH_KEY.meta_ ;
                        ch.onAUTH_KEY(pack);
                        break;
                    case 6 :
                        if(pack == null)return GLOBAL_POSITION_INT_COV.meta_ ;
                        ch.onGLOBAL_POSITION_INT_COV(pack);
                        break;
                    case 129 :
                        if(pack == null)return POSITION_TARGET_LOCAL_NED.meta_ ;
                        ch.onPOSITION_TARGET_LOCAL_NED(pack);
                        break;
                    case 56 :
                        if(pack == null)return GPS_RAW_INT.meta_ ;
                        ch.onGPS_RAW_INT(pack);
                        break;
                    case 3 :
                        if(pack == null)return ACTUATOR_CONTROL_TARGET.meta_ ;
                        ch.onACTUATOR_CONTROL_TARGET(pack);
                        break;
                    case 126 :
                        if(pack == null)return DEBUG.meta_ ;
                        ch.onDEBUG(pack);
                        break;
                    case 174 :
                        if(pack == null)return V2_EXTENSION.meta_ ;
                        ch.onV2_EXTENSION(pack);
                        break;
                    case 42 :
                        if(pack == null)return VISION_SPEED_ESTIMATE.meta_ ;
                        ch.onVISION_SPEED_ESTIMATE(pack);
                        break;
                    case 34 :
                        if(pack == null)return ALTITUDE.meta_ ;
                        ch.onALTITUDE(pack);
                        break;
                    case 8 :
                        if(pack == null)return NAMED_VALUE_FLOAT.meta_ ;
                        ch.onNAMED_VALUE_FLOAT(pack);
                        break;
                    case 82 :
                        if(pack == null)return HIL_CONTROLS.meta_ ;
                        ch.onHIL_CONTROLS(pack);
                        break;
                    case 166 :
                        if(pack == null)return PARAM_REQUEST_READ.meta_ ;
                        ch.onPARAM_REQUEST_READ(pack);
                        break;
                    case 176 :
                        if(pack == null)return EXTENDED_SYS_STATE.meta_ ;
                        ch.onEXTENDED_SYS_STATE(pack);
                        break;
                    case 87 :
                        if(pack == null)return HIGH_LATENCY.meta_ ;
                        ch.onHIGH_LATENCY(pack);
                        break;
                    case 13 :
                        if(pack == null)return OPTICAL_FLOW.meta_ ;
                        ch.onOPTICAL_FLOW(pack);
                        break;
                    case 15 :
                        if(pack == null)return VFR_HUD.meta_ ;
                        ch.onVFR_HUD(pack);
                        break;
                    case 131 :
                        if(pack == null)return LOCAL_POSITION_NED.meta_ ;
                        ch.onLOCAL_POSITION_NED(pack);
                        break;
                    case 31 :
                        if(pack == null)return DATA_STREAM.meta_ ;
                        ch.onDATA_STREAM(pack);
                        break;
                    case 125 :
                        if(pack == null)return HEARTBEAT.meta_ ;
                        ch.onHEARTBEAT(pack);
                        break;
                    case 54 :
                        if(pack == null)return MANUAL_CONTROL.meta_ ;
                        ch.onMANUAL_CONTROL(pack);
                        break;
                    case 29 :
                        if(pack == null)return PARAM_MAP_RC.meta_ ;
                        ch.onPARAM_MAP_RC(pack);
                        break;
                    case 23 :
                        if(pack == null)return RC_CHANNELS.meta_ ;
                        ch.onRC_CHANNELS(pack);
                        break;
                    case 59 :
                        if(pack == null)return MISSION_ITEM_INT.meta_ ;
                        ch.onMISSION_ITEM_INT(pack);
                        break;
                    case 77 :
                        if(pack == null)return SET_HOME_POSITION.meta_ ;
                        ch.onSET_HOME_POSITION(pack);
                        break;
                    case 148 :
                        if(pack == null)return RC_CHANNELS_RAW.meta_ ;
                        ch.onRC_CHANNELS_RAW(pack);
                        break;
                    case 52 :
                        if(pack == null)return GPS_INJECT_DATA.meta_ ;
                        ch.onGPS_INJECT_DATA(pack);
                        break;
                    case 204 :
                        if(pack == null)return LOG_DATA.meta_ ;
                        ch.onLOG_DATA(pack);
                        break;
                    case 135 :
                        if(pack == null)return VICON_POSITION_ESTIMATE.meta_ ;
                        ch.onVICON_POSITION_ESTIMATE(pack);
                        break;
                    case 53 :
                        if(pack == null)return SET_GPS_GLOBAL_ORIGIN.meta_ ;
                        ch.onSET_GPS_GLOBAL_ORIGIN(pack);
                        break;
                    case 146 :
                        if(pack == null)return BUTTON_CHANGE.meta_ ;
                        ch.onBUTTON_CHANGE(pack);
                        break;
                    case 189 :
                        if(pack == null)return MISSION_CURRENT.meta_ ;
                        ch.onMISSION_CURRENT(pack);
                        break;
                    case 67 :
                        if(pack == null)return RESOURCE_REQUEST.meta_ ;
                        ch.onRESOURCE_REQUEST(pack);
                        break;
                    case 132 :
                        if(pack == null)return SYS_STATUS.meta_ ;
                        ch.onSYS_STATUS(pack);
                        break;
                    case 88 :
                        if(pack == null)return GPS_RTCM_DATA.meta_ ;
                        ch.onGPS_RTCM_DATA(pack);
                        break;
                    case 124 :
                        if(pack == null)return STATUSTEXT.meta_ ;
                        ch.onSTATUSTEXT(pack);
                        break;
                    case 108 :
                        if(pack == null)return SIM_STATE.meta_ ;
                        ch.onSIM_STATE(pack);
                        break;
                    case 210 :
                        if(pack == null)return HOME_POSITION.meta_ ;
                        ch.onHOME_POSITION(pack);
                        break;
                    case 147 :
                        if(pack == null)return MISSION_REQUEST.meta_ ;
                        ch.onMISSION_REQUEST(pack);
                        break;
                    case 140 :
                        if(pack == null)return HIL_STATE.meta_ ;
                        ch.onHIL_STATE(pack);
                        break;
                    case 48 :
                        if(pack == null)return GPS_STATUS.meta_ ;
                        ch.onGPS_STATUS(pack);
                        break;
                    case 193 :
                        if(pack == null)return MISSION_CLEAR_ALL.meta_ ;
                        ch.onMISSION_CLEAR_ALL(pack);
                        break;
                    case 28 :
                        if(pack == null)return SwitchModeCommand.pack_.meta ;
                        ch.onSwitchModeCommand();
                        break;
                    case 91 :
                        if(pack == null)return GPS2_RTK.meta_ ;
                        ch.onGPS2_RTK(pack);
                        break;
                    case 116 :
                        if(pack == null)return HIL_OPTICAL_FLOW.meta_ ;
                        ch.onHIL_OPTICAL_FLOW(pack);
                        break;
                    case 184 :
                        if(pack == null)return HIL_RC_INPUTS_RAW.meta_ ;
                        ch.onHIL_RC_INPUTS_RAW(pack);
                        break;
                    case 151 :
                        if(pack == null)return SCALED_PRESSURE2.meta_ ;
                        ch.onSCALED_PRESSURE2(pack);
                        break;
                    case 92 :
                        if(pack == null)return TERRAIN_REQUEST.meta_ ;
                        ch.onTERRAIN_REQUEST(pack);
                        break;
                    case 25 :
                        if(pack == null)return MISSION_REQUEST_LIST.meta_ ;
                        ch.onMISSION_REQUEST_LIST(pack);
                        break;
                    case 4 :
                        if(pack == null)return LOG_ERASE.meta_ ;
                        ch.onLOG_ERASE(pack);
                        break;
                    case 21 :
                        if(pack == null)return NAMED_VALUE_INT.meta_ ;
                        ch.onNAMED_VALUE_INT(pack);
                        break;
                    case 89 :
                        if(pack == null)return GPS_RTK.meta_ ;
                        ch.onGPS_RTK(pack);
                        break;
                    case 38 :
                        if(pack == null)return ESTIMATOR_STATUS.meta_ ;
                        ch.onESTIMATOR_STATUS(pack);
                        break;
                    case 152 :
                        if(pack == null)return TERRAIN_CHECK.meta_ ;
                        ch.onTERRAIN_CHECK(pack);
                        break;
                    case 188 :
                        if(pack == null)return MISSION_REQUEST_INT.meta_ ;
                        ch.onMISSION_REQUEST_INT(pack);
                        break;
                    case 203 :
                        if(pack == null)return PLAY_TUNE.meta_ ;
                        ch.onPLAY_TUNE(pack);
                        break;
                    case 187 :
                        if(pack == null)return DEBUG_VECT.meta_ ;
                        ch.onDEBUG_VECT(pack);
                        break;
                    case 61 :
                        if(pack == null)return DISTANCE_SENSOR.meta_ ;
                        ch.onDISTANCE_SENSOR(pack);
                        break;
                    case 215 :
                        if(pack == null)return FLIGHT_INFORMATION.meta_ ;
                        ch.onFLIGHT_INFORMATION(pack);
                        break;
                    case 157 :
                        if(pack == null)return CAMERA_INFORMATION.meta_ ;
                        ch.onCAMERA_INFORMATION(pack);
                        break;
                    case 213 :
                        if(pack == null)return GPS2_RAW.meta_ ;
                        ch.onGPS2_RAW(pack);
                        break;
                    case 55 :
                        if(pack == null)return RC_CHANNELS_OVERRIDE.meta_ ;
                        ch.onRC_CHANNELS_OVERRIDE(pack);
                        break;
                    case 160 :
                        if(pack == null)return WIND_COV.meta_ ;
                        ch.onWIND_COV(pack);
                        break;
                    case 182 :
                        if(pack == null)return ATTITUDE_QUATERNION_COV.meta_ ;
                        ch.onATTITUDE_QUATERNION_COV(pack);
                        break;
                    case 16 :
                        if(pack == null)return VISION_POSITION_ESTIMATE.meta_ ;
                        ch.onVISION_POSITION_ESTIMATE(pack);
                        break;
                    case 111 :
                        if(pack == null)return BATTERY_STATUS.meta_ ;
                        ch.onBATTERY_STATUS(pack);
                        break;
                    case 62 :
                        if(pack == null)return CHANGE_OPERATOR_CONTROL_ACK.meta_ ;
                        ch.onCHANGE_OPERATOR_CONTROL_ACK(pack);
                        break;
                    case 60 :
                        if(pack == null)return AUTOPILOT_VERSION.meta_ ;
                        ch.onAUTOPILOT_VERSION(pack);
                        break;
                    case 120 :
                        if(pack == null)return RC_CHANNELS_SCALED.meta_ ;
                        ch.onRC_CHANNELS_SCALED(pack);
                        break;
                    case 27 :
                        if(pack == null)return FILE_TRANSFER_PROTOCOL.meta_ ;
                        ch.onFILE_TRANSFER_PROTOCOL(pack);
                        break;
                    case 170 :
                        if(pack == null)return ENCAPSULATED_DATA.meta_ ;
                        ch.onENCAPSULATED_DATA(pack);
                        break;
                    case 172 :
                        if(pack == null)return LANDING_TARGET.meta_ ;
                        ch.onLANDING_TARGET(pack);
                        break;
                    case 154 :
                        if(pack == null)return CHANGE_OPERATOR_CONTROL.meta_ ;
                        ch.onCHANGE_OPERATOR_CONTROL(pack);
                        break;
                    case 205 :
                        if(pack == null)return SETUP_SIGNING.meta_ ;
                        ch.onSETUP_SIGNING(pack);
                        break;
                    case 86 :
                        if(pack == null)return TERRAIN_REPORT.meta_ ;
                        ch.onTERRAIN_REPORT(pack);
                        break;
                    case 18 :
                        if(pack == null)return SCALED_PRESSURE.meta_ ;
                        ch.onSCALED_PRESSURE(pack);
                        break;
                    case 137 :
                        if(pack == null)return HIGHRES_IMU.meta_ ;
                        ch.onHIGHRES_IMU(pack);
                        break;
                    case 123 :
                        if(pack == null)return PARAM_SET.meta_ ;
                        ch.onPARAM_SET(pack);
                        break;
                    case 58 :
                        if(pack == null)return STORAGE_INFORMATION.meta_ ;
                        ch.onSTORAGE_INFORMATION(pack);
                        break;
                    case 195 :
                        if(pack == null)return SCALED_IMU.meta_ ;
                        ch.onSCALED_IMU(pack);
                        break;
                    case 50 :
                        if(pack == null)return MISSION_COUNT.meta_ ;
                        ch.onMISSION_COUNT(pack);
                        break;
                    case 139 :
                        if(pack == null)return PING33.meta_ ;
                        ch.onPING33(pack);
                        break;
                    case 167 :
                        if(pack == null)return COMMAND_INT.meta_ ;
                        ch.onCOMMAND_INT(pack);
                        break;
                    case 219 :
                        if(pack == null)return MANUAL_SETPOINT.meta_ ;
                        ch.onMANUAL_SETPOINT(pack);
                        break;
                }
                return null;
            }
        }
        readonly Receiver receiver;
        protected abstract void onRESOURCE_REQUEST(Pack pack);
        protected abstract void onATTITUDE_TARGET(Pack pack);
        protected abstract void onMISSION_COUNT(Pack pack);
        protected abstract void onADSB_VEHICLE(Pack pack);
        protected abstract void onMESSAGE_INTERVAL(Pack pack);
        protected abstract void onESTIMATOR_STATUS(Pack pack);
        protected abstract void onTIMESYNC(Pack pack);
        protected abstract void onGLOBAL_POSITION_INT_COV(Pack pack);
        protected abstract void onBUTTON_CHANGE(Pack pack);
        protected abstract void onSAFETY_SET_ALLOWED_AREA(Pack pack);
        protected abstract void onSTORAGE_INFORMATION(Pack pack);
        protected abstract void onCOLLISION(Pack pack);
        protected abstract void onALTITUDE(Pack pack);
        protected abstract void onHIL_STATE_QUATERNION(Pack pack);
        protected abstract void onCAMERA_INFORMATION(Pack pack);
        protected abstract void onGPS_STATUS(Pack pack);
        protected abstract void onPARAM_SET(Pack pack);
        protected abstract void onTERRAIN_DATA(Pack pack);
        protected abstract void onRC_CHANNELS_OVERRIDE(Pack pack);
        protected abstract void onSCALED_IMU(Pack pack);
        protected abstract void onDEBUG(Pack pack);
        protected abstract void onCAMERA_IMAGE_CAPTURED(Pack pack);
        protected abstract void onLOG_ENTRY(Pack pack);
        protected abstract void onACTUATOR_CONTROL_TARGET(Pack pack);
        protected abstract void onHIGH_LATENCY(Pack pack);
        protected abstract void onPARAM_REQUEST_READ(Pack pack);
        protected abstract void onSET_ATTITUDE_TARGET(Pack pack);
        protected abstract void onFOLLOW_TARGET(Pack pack);
        protected abstract void onHIL_STATE(Pack pack);
        protected abstract void onHOME_POSITION(Pack pack);
        protected abstract void onGPS2_RAW(Pack pack);
        protected abstract void onMEMORY_VECT(Pack pack);
        protected abstract void onREQUEST_DATA_STREAM(Pack pack);
        protected abstract void onHIL_CONTROLS(Pack pack);
        protected abstract void onHIL_SENSOR(Pack pack);
        protected abstract void onSETUP_SIGNING(Pack pack);
        protected abstract void onGPS_RTK(Pack pack);
        protected abstract void onPARAM_REQUEST_LIST(Pack pack);
        protected abstract void onLANDING_TARGET(Pack pack);
        protected abstract void onSET_ACTUATOR_CONTROL_TARGET(Pack pack);
        protected abstract void onCONTROL_SYSTEM_STATE(Pack pack);
        protected abstract void onSET_POSITION_TARGET_GLOBAL_INT(Pack pack);
        protected abstract void onVIBRATION(Pack pack);
        protected abstract void onPING33(Pack pack);
        protected abstract void onVFR_HUD(Pack pack);
        protected abstract void onMISSION_SET_CURRENT(Pack pack);
        protected abstract void onHIL_GPS(Pack pack);
        protected abstract void onNAV_CONTROLLER_OUTPUT(Pack pack);
        protected abstract void onAUTH_KEY(Pack pack);
        protected abstract void onLOCAL_POSITION_NED_COV(Pack pack);
        protected abstract void onATT_POS_MOCAP(Pack pack);
        protected abstract void onSTATUSTEXT(Pack pack);
        protected abstract void onPING(Pack pack);
        protected abstract void onCAMERA_CAPTURE_STATUS(Pack pack);
        protected abstract void onGLOBAL_POSITION_INT(Pack pack);
        protected abstract void onENCAPSULATED_DATA(Pack pack);
        protected abstract void onGPS_INPUT(Pack pack);
        protected abstract void onCOMMAND_LONG(Pack pack);
        protected abstract void onLOG_REQUEST_DATA(Pack pack);
        protected abstract void onGPS_RAW_INT(Pack pack);
        protected abstract void onRC_CHANNELS_SCALED(Pack pack);
        protected abstract void onCAMERA_SETTINGS(Pack pack);
        protected abstract void onRAW_PRESSURE(Pack pack);
        protected abstract void onNAMED_VALUE_FLOAT(Pack pack);
        protected abstract void onATTITUDE(Pack pack);
        protected abstract void onTERRAIN_REQUEST(Pack pack);
        protected abstract void onMISSION_WRITE_PARTIAL_LIST(Pack pack);
        protected abstract void onLOG_ERASE(Pack pack);
        protected abstract void onMANUAL_SETPOINT(Pack pack);
        protected abstract void onSAFETY_ALLOWED_AREA(Pack pack);
        protected abstract void onOPTICAL_FLOW_RAD(Pack pack);
        protected abstract void onLOG_DATA(Pack pack);
        protected abstract void onMISSION_CLEAR_ALL(Pack pack);
        protected abstract void onVICON_POSITION_ESTIMATE(Pack pack);
        protected abstract void onGPS2_RTK(Pack pack);
        protected abstract void onLOG_REQUEST_LIST(Pack pack);
        protected abstract void onSCALED_PRESSURE(Pack pack);
        protected abstract void onMISSION_REQUEST_INT(Pack pack);
        protected abstract void onV2_EXTENSION(Pack pack);
        protected abstract void onHEARTBEAT(Pack pack);
        protected abstract void onPARAM_MAP_RC(Pack pack);
        protected abstract void onPOWER_STATUS(Pack pack);
        protected abstract void onTERRAIN_CHECK(Pack pack);
        protected abstract void onLOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(Pack pack);
        protected abstract void onCOMMAND_ACK(Pack pack);
        protected abstract void onDATA_STREAM(Pack pack);
        protected abstract void onMISSION_REQUEST(Pack pack);
        protected abstract void onTERRAIN_REPORT(Pack pack);
        protected abstract void onSET_HOME_POSITION(Pack pack);
        protected abstract void onSwitchModeCommand();
        protected abstract void onHIL_RC_INPUTS_RAW(Pack pack);
        protected abstract void onSCALED_IMU3(Pack pack);
        protected abstract void onSET_MODE(Pack pack);
        protected abstract void onPOSITION_TARGET_GLOBAL_INT(Pack pack);
        protected abstract void onFLIGHT_INFORMATION(Pack pack);
        protected abstract void onSIM_STATE(Pack pack);
        protected abstract void onMISSION_ITEM_REACHED(Pack pack);
        protected abstract void onRC_CHANNELS_RAW(Pack pack);
        protected abstract void onSERVO_OUTPUT_RAW(Pack pack);
        protected abstract void onVISION_SPEED_ESTIMATE(Pack pack);
        protected abstract void onDEBUG_VECT(Pack pack);
        protected abstract void onLOG_REQUEST_END(Pack pack);
        protected abstract void onMISSION_ACK(Pack pack);
        protected abstract void onCHANGE_OPERATOR_CONTROL_ACK(Pack pack);
        protected abstract void onMISSION_CURRENT(Pack pack);
        protected abstract void onSYSTEM_TIME(Pack pack);
        protected abstract void onCAMERA_TRIGGER(Pack pack);
        protected abstract void onVISION_POSITION_ESTIMATE(Pack pack);
        protected abstract void onMANUAL_CONTROL(Pack pack);
        protected abstract void onRC_CHANNELS(Pack pack);
        protected abstract void onPARAM_VALUE(Pack pack);
        protected abstract void onBATTERY_STATUS(Pack pack);
        protected abstract void onSET_POSITION_TARGET_LOCAL_NED(Pack pack);
        protected abstract void onSERIAL_CONTROL(Pack pack);
        protected abstract void onSET_GPS_GLOBAL_ORIGIN(Pack pack);
        protected abstract void onAUTOPILOT_VERSION(Pack pack);
        protected abstract void onMISSION_REQUEST_LIST(Pack pack);
        protected abstract void onPLAY_TUNE(Pack pack);
        protected abstract void onSCALED_PRESSURE3(Pack pack);
        protected abstract void onMISSION_REQUEST_PARTIAL_LIST(Pack pack);
        protected abstract void onLOCAL_POSITION_NED(Pack pack);
        protected abstract void onDATA_TRANSMISSION_HANDSHAKE(Pack pack);
        protected abstract void onGPS_GLOBAL_ORIGIN(Pack pack);
        protected abstract void onSCALED_IMU2(Pack pack);
        protected abstract void onATTITUDE_QUATERNION(Pack pack);
        protected abstract void onHIL_ACTUATOR_CONTROLS(Pack pack);
        protected abstract void onPOSITION_TARGET_LOCAL_NED(Pack pack);
        protected abstract void onDISTANCE_SENSOR(Pack pack);
        protected abstract void onHIL_OPTICAL_FLOW(Pack pack);
        protected abstract void onSCALED_PRESSURE2(Pack pack);
        protected abstract void onWIND_COV(Pack pack);
        protected abstract void onCHANGE_OPERATOR_CONTROL(Pack pack);
        protected abstract void onSYS_STATUS(Pack pack);
        protected abstract void onMISSION_ITEM(Pack pack);
        protected abstract void onRAW_IMU(Pack pack);
        protected abstract void onCOMMAND_INT(Pack pack);
        protected abstract void onOPTICAL_FLOW(Pack pack);
        protected abstract void onMISSION_ITEM_INT(Pack pack);
        protected abstract void onHIGHRES_IMU(Pack pack);
        protected abstract void onEXTENDED_SYS_STATE(Pack pack);
        protected abstract void onGPS_INJECT_DATA(Pack pack);
        protected abstract void onATTITUDE_QUATERNION_COV(Pack pack);
        protected abstract void onNAMED_VALUE_INT(Pack pack);
        protected abstract void onRADIO_STATUS(Pack pack);
        protected abstract void onGPS_RTCM_DATA(Pack pack);
        protected abstract void onGLOBAL_VISION_POSITION_ESTIMATE(Pack pack);
        protected abstract void onFILE_TRANSFER_PROTOCOL(Pack pack);



        protected internal abstract Pack pullSendingPack();
        protected internal abstract bool pushSendingPack(Pack pack);
        public override int Read(byte[] dst, int offset, int bytes) { return transmitter.PacksIntoBytes(dst, offset, bytes); }
        class Transmitter : Lib.Channel.Transmitter
        {
            readonly CommunicationChannel ch;
            public  Transmitter(CommunicationChannel ch): base(1) { this.ch = ch; }
            protected internal override Pack pullSendingPack() { return ch.pullSendingPack(); }
        }
        readonly Transmitter transmitter;


        public bool send(FOLLOW_TARGET src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(ADSB_VEHICLE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(MESSAGE_INTERVAL src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(EKF_STATUS_REPORT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(ESTIMATOR_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(HWSTATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(TIMESYNC src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(PARAM_EXT_REQUEST_LIST src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(BUTTON_CHANGE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(UAVCAN_NODE_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(COLLISION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GIMBAL_TORQUE_CMD_REPORT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(ALTITUDE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(HIL_STATE_QUATERNION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SENSOR_OFFSETS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(STORAGE_INFORMATION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(CAMERA_INFORMATION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DEVICE_OP_WRITE_REPLY src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(TERRAIN_DATA src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GIMBAL_CONTROL src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(VIDEO_STREAM_INFORMATION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(AHRS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DEBUG src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(CAMERA_IMAGE_CAPTURED src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LOG_ENTRY src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(ACTUATOR_CONTROL_TARGET src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(HIGH_LATENCY src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(HOME_POSITION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(FENCE_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(REMOTE_LOG_BLOCK_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(OBSTACLE_DISTANCE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GPS2_RAW src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(MEMORY_VECT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(PARAM_EXT_REQUEST_READ src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(HIL_SENSOR src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SETUP_SIGNING src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GPS_RTK src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(UAVIONIX_ADSB_OUT_CFG src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LANDING_TARGET src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SET_ACTUATOR_CONTROL_TARGET src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(CONTROL_SYSTEM_STATE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DATA32 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(PING33 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(RALLY_POINT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(ADAP_TUNING src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(VIBRATION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(PARAM_EXT_VALUE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(BATTERY2 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LIMITS_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(CAMERA_FEEDBACK src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(HIL_GPS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(FENCE_FETCH_POINT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(RADIO src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(AIRSPEED_AUTOCAL src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(ATT_POS_MOCAP src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(STATUSTEXT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GOPRO_GET_REQUEST src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(CAMERA_CAPTURE_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(ENCAPSULATED_DATA src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GPS_INPUT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(COMPASSMOT_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LOG_REQUEST_DATA src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(CAMERA_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(CAMERA_SETTINGS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DEVICE_OP_READ_REPLY src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DIGICAM_CONTROL src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(NAMED_VALUE_FLOAT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GOPRO_HEARTBEAT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(AHRS2 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LOG_ERASE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(TERRAIN_REQUEST src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(MOUNT_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(PID_TUNING src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(OPTICAL_FLOW_RAD src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LOG_DATA src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(AHRS3 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(VICON_POSITION_ESTIMATE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GPS2_RTK src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(MAG_CAL_REPORT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LOG_REQUEST_LIST src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(MOUNT_CONFIGURE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(V2_EXTENSION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(POWER_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(REMOTE_LOG_DATA_BLOCK src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LOGGING_DATA_ACKED src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(TERRAIN_CHECK src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(TERRAIN_REPORT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SET_HOME_POSITION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }
        public bool sendSwitchModeCommand() { return  pushSendingPack(SwitchModeCommand.pack_); }

        public bool send(SCALED_IMU3 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(MOUNT_CONTROL src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LED_CONTROL src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SIM_STATE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(WIFI_CONFIG_AP src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DATA96 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(FLIGHT_INFORMATION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(MEMINFO src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LOGGING_ACK src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(VISION_SPEED_ESTIMATE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DEBUG_VECT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(CAMERA_TRIGGER src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LOG_REQUEST_END src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GOPRO_SET_RESPONSE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(PROTOCOL_VERSION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(RALLY_FETCH_POINT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(BATTERY_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(MOUNT_ORIENTATION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SERIAL_CONTROL src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(PARAM_EXT_SET src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(AUTOPILOT_VERSION src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SIMSTATE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SET_VIDEO_STREAM_SETTINGS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(PLAY_TUNE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DIGICAM_CONFIGURE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SCALED_PRESSURE3 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(PARAM_EXT_ACK src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(UAVCAN_NODE_INFO src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DATA16 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SET_MAG_OFFSETS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SCALED_IMU2 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(AP_ADC src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(WIND src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(AUTOPILOT_VERSION_REQUEST src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DATA_TRANSMISSION_HANDSHAKE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DATA64 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GIMBAL_REPORT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DEVICE_OP_WRITE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DISTANCE_SENSOR src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(HIL_OPTICAL_FLOW src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(SCALED_PRESSURE2 src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(WIND_COV src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GOPRO_SET_REQUEST src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(VISION_POSITION_DELTA src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(LOGGING_DATA src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(DEVICE_OP_READ src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(MAG_CAL_PROGRESS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(HIGHRES_IMU src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(EXTENDED_SYS_STATE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(UAVIONIX_ADSB_OUT_DYNAMIC src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GOPRO_GET_RESPONSE src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GPS_INJECT_DATA src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(NAMED_VALUE_INT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(RPM src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(GPS_RTCM_DATA src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(FILE_TRANSFER_PROTOCOL src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(RANGEFINDER src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(RADIO_STATUS src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(FENCE_POINT src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public bool send(RESOURCE_REQUEST src)
        {
            if(src.data_.bytes == null) return false;
            var pack = src.data_.unwrap();
            if(pushSendingPack(pack)) return true;
            src.data_.wrap(pack);
            return false;
        }

        public struct NEW
        {
            /**
            *current motion information from a designated system */
            public static FOLLOW_TARGET FOLLOW_TARGET(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.FOLLOW_TARGET.meta_);
                return new FOLLOW_TARGET(bytes);
            }
            /**
            *The location and information of an ADSB vehicle */
            public static ADSB_VEHICLE  ADSB_VEHICLE(Cursor cur)

            {
                cur.wrap(GroundControl.ADSB_VEHICLE.meta_);
                return new ADSB_VEHICLE(cur);
            }
            /**
            *This interface replaces DATA_STREAM */
            public static MESSAGE_INTERVAL MESSAGE_INTERVAL(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.MESSAGE_INTERVAL.meta_);
                return new MESSAGE_INTERVAL(bytes);
            }
            /**
            *EKF Status message including flags and variances */
            public static EKF_STATUS_REPORT  EKF_STATUS_REPORT(Cursor cur)

            {
                cur.wrap(GroundControl.EKF_STATUS_REPORT.meta_);
                return new EKF_STATUS_REPORT(cur);
            }
            /**
            *Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message
            *				 is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS
            *				 enum definition for further information. The innovaton test ratios show the magnitude of the sensor innovation
            *				 divided by the innovation check threshold. Under normal operation the innovaton test ratios should be
            *				 below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation
            *				 and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation
            *				 test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should
            *				 be optional and controllable by the user */
            public static ESTIMATOR_STATUS  ESTIMATOR_STATUS(Cursor cur)

            {
                cur.wrap(GroundControl.ESTIMATOR_STATUS.meta_);
                return new ESTIMATOR_STATUS(cur);
            }
            /**
            *Status of key hardware */
            public static HWSTATUS HWSTATUS(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.HWSTATUS.meta_);
                return new HWSTATUS(bytes);
            }
            /**
            *Time synchronization message. */
            public static TIMESYNC TIMESYNC(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.TIMESYNC.meta_);
                return new TIMESYNC(bytes);
            }
            /**
            *Request all parameters of this component. After this request, all parameters are emitted. */
            public static PARAM_EXT_REQUEST_LIST PARAM_EXT_REQUEST_LIST(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.PARAM_EXT_REQUEST_LIST.meta_);
                return new PARAM_EXT_REQUEST_LIST(bytes);
            }
            /**
            *Report button state change */
            public static BUTTON_CHANGE BUTTON_CHANGE(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.BUTTON_CHANGE.meta_);
                return new BUTTON_CHANGE(bytes);
            }
            /**
            *General status information of an UAVCAN node. Please refer to the definition of the UAVCAN message "uavcan.protocol.NodeStatus"
            *				 for the background information. The UAVCAN specification is available at http:uavcan.org */
            public static UAVCAN_NODE_STATUS  UAVCAN_NODE_STATUS(Cursor cur)

            {
                cur.wrap(GroundControl.UAVCAN_NODE_STATUS.meta_);
                return new UAVCAN_NODE_STATUS(cur);
            }
            /**
            *Information about a potential collision */
            public static COLLISION  COLLISION(Cursor cur)

            {
                cur.wrap(GroundControl.COLLISION.meta_);
                return new COLLISION(cur);
            }
            /**
            *100 Hz gimbal torque command telemetry */
            public static GIMBAL_TORQUE_CMD_REPORT GIMBAL_TORQUE_CMD_REPORT(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.GIMBAL_TORQUE_CMD_REPORT.meta_);
                return new GIMBAL_TORQUE_CMD_REPORT(bytes);
            }
            /**
            *The current system altitude. */
            public static ALTITUDE ALTITUDE(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.ALTITUDE.meta_);
                return new ALTITUDE(bytes);
            }
            /**
            *Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful
            *				 for high throughput applications such as hardware in the loop simulations */
            public static HIL_STATE_QUATERNION HIL_STATE_QUATERNION(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.HIL_STATE_QUATERNION.meta_);
                return new HIL_STATE_QUATERNION(bytes);
            }
            /**
            *Offsets and calibrations values for hardware sensors. This makes it easier to debug the calibration process */
            public static SENSOR_OFFSETS SENSOR_OFFSETS(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.SENSOR_OFFSETS.meta_);
                return new SENSOR_OFFSETS(bytes);
            }
            /**
            *WIP: Information about a storage medium. */
            public static STORAGE_INFORMATION STORAGE_INFORMATION(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.STORAGE_INFORMATION.meta_);
                return new STORAGE_INFORMATION(bytes);
            }
            /**
            *WIP: Information about a camera */
            public static CAMERA_INFORMATION  CAMERA_INFORMATION(Cursor cur)

            {
                cur.wrap(GroundControl.CAMERA_INFORMATION.meta_);
                return new CAMERA_INFORMATION(cur);
            }
            /**
            *Write registers reply */
            public static DEVICE_OP_WRITE_REPLY DEVICE_OP_WRITE_REPLY(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.DEVICE_OP_WRITE_REPLY.meta_);
                return new DEVICE_OP_WRITE_REPLY(bytes);
            }
            /**
            *Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUES */
            public static TERRAIN_DATA TERRAIN_DATA(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.TERRAIN_DATA.meta_);
                return new TERRAIN_DATA(bytes);
            }
            /**
            *Control message for rate gimbal */
            public static GIMBAL_CONTROL GIMBAL_CONTROL(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.GIMBAL_CONTROL.meta_);
                return new GIMBAL_CONTROL(bytes);
            }
            /**
            *WIP: Information about video stream */
            public static VIDEO_STREAM_INFORMATION  VIDEO_STREAM_INFORMATION(Cursor cur)

            {
                cur.wrap(GroundControl.VIDEO_STREAM_INFORMATION.meta_);
                return new VIDEO_STREAM_INFORMATION(cur);
            }
            /**
            *Status of DCM attitude estimator */
            public static AHRS AHRS(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.AHRS.meta_);
                return new AHRS(bytes);
            }
            /**
            *Send a debug value. The index is used to discriminate between values. These values show up in the plot
            *				 of QGroundControl as DEBUG N */
            public static DEBUG DEBUG(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.DEBUG.meta_);
                return new DEBUG(bytes);
            }
            /**
            *Information about a captured image */
            public static CAMERA_IMAGE_CAPTURED  CAMERA_IMAGE_CAPTURED(Cursor cur)

            {
                cur.wrap(GroundControl.CAMERA_IMAGE_CAPTURED.meta_);
                return new CAMERA_IMAGE_CAPTURED(cur);
            }
            /**
            *Reply to LOG_REQUEST_LIST */
            public static LOG_ENTRY LOG_ENTRY(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.LOG_ENTRY.meta_);
                return new LOG_ENTRY(bytes);
            }
            /**
            *Set the vehicle attitude and body angular rates. */
            public static ACTUATOR_CONTROL_TARGET ACTUATOR_CONTROL_TARGET(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.ACTUATOR_CONTROL_TARGET.meta_);
                return new ACTUATOR_CONTROL_TARGET(bytes);
            }
            /**
            *Message appropriate for high latency connections like Iridium */
            public static HIGH_LATENCY  HIGH_LATENCY(Cursor cur)

            {
                cur.wrap(GroundControl.HIGH_LATENCY.meta_);
                return new HIGH_LATENCY(cur);
            }
            /**
            *This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system
            *				 will return to and land on. The position is set automatically by the system during the takeoff in case
            *				 it was not explicitely set by the operator before or after. The position the system will return to and
            *				 land on. The global and local positions encode the position in the respective coordinate frames, while
            *				 the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading
            *				 and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes
            *				 the point to which the system should fly in normal flight mode and then perform a landing sequence along
            *				 the vector */
            public static HOME_POSITION  HOME_POSITION(Cursor cur)

            {
                cur.wrap(GroundControl.HOME_POSITION.meta_);
                return new HOME_POSITION(cur);
            }
            /**
            *Status of geo-fencing. Sent in extended status stream when fencing enabled */
            public static FENCE_STATUS  FENCE_STATUS(Cursor cur)

            {
                cur.wrap(GroundControl.FENCE_STATUS.meta_);
                return new FENCE_STATUS(cur);
            }
            /**
            *Send Status of each log block that autopilot board might have sent */
            public static REMOTE_LOG_BLOCK_STATUS  REMOTE_LOG_BLOCK_STATUS(Cursor cur)

            {
                cur.wrap(GroundControl.REMOTE_LOG_BLOCK_STATUS.meta_);
                return new REMOTE_LOG_BLOCK_STATUS(cur);
            }
            /**
            *Obstacle distances in front of the sensor, starting from the left in increment degrees to the right */
            public static OBSTACLE_DISTANCE  OBSTACLE_DISTANCE(Cursor cur)

            {
                cur.wrap(GroundControl.OBSTACLE_DISTANCE.meta_);
                return new OBSTACLE_DISTANCE(cur);
            }
            /**
            *Second GPS data. Coordinate frame is right-handed, Z-axis up (GPS frame). */
            public static GPS2_RAW  GPS2_RAW(Cursor cur)

            {
                cur.wrap(GroundControl.GPS2_RAW.meta_);
                return new GPS2_RAW(cur);
            }
            /**
            *Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient
            *				 way for testing new messages and getting experimental debug output */
            public static MEMORY_VECT MEMORY_VECT(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.MEMORY_VECT.meta_);
                return new MEMORY_VECT(bytes);
            }
            /**
            *Request to read the value of a parameter with the either the param_id string id or param_index. */
            public static PARAM_EXT_REQUEST_READ  PARAM_EXT_REQUEST_READ(Cursor cur)

            {
                cur.wrap(GroundControl.PARAM_EXT_REQUEST_READ.meta_);
                return new PARAM_EXT_REQUEST_READ(cur);
            }
            /**
            *The IMU readings in SI units in NED body frame */
            public static HIL_SENSOR HIL_SENSOR(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.HIL_SENSOR.meta_);
                return new HIL_SENSOR(bytes);
            }
            /**
            *Setup a MAVLink2 signing key. If called with secret_key of all zero and zero initial_timestamp will disable
            *				 signin */
            public static SETUP_SIGNING SETUP_SIGNING(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.SETUP_SIGNING.meta_);
                return new SETUP_SIGNING(bytes);
            }
            /**
            *RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */
            public static GPS_RTK GPS_RTK(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.GPS_RTK.meta_);
                return new GPS_RTK(bytes);
            }
            /**
            *Static data to configure the ADS-B transponder (send within 10 sec of a POR and every 10 sec thereafter */
            public static UAVIONIX_ADSB_OUT_CFG  UAVIONIX_ADSB_OUT_CFG(Cursor cur)

            {
                cur.wrap(GroundControl.UAVIONIX_ADSB_OUT_CFG.meta_);
                return new UAVIONIX_ADSB_OUT_CFG(cur);
            }
            /**
            *The location of a landing area captured from a downward facing camera */
            public static LANDING_TARGET  LANDING_TARGET(Cursor cur)

            {
                cur.wrap(GroundControl.LANDING_TARGET.meta_);
                return new LANDING_TARGET(cur);
            }
            /**
            *Set the vehicle attitude and body angular rates. */
            public static SET_ACTUATOR_CONTROL_TARGET SET_ACTUATOR_CONTROL_TARGET(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.SET_ACTUATOR_CONTROL_TARGET.meta_);
                return new SET_ACTUATOR_CONTROL_TARGET(bytes);
            }
            /**
            *The smoothed, monotonic system state used to feed the control loops of the system. */
            public static CONTROL_SYSTEM_STATE CONTROL_SYSTEM_STATE(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.CONTROL_SYSTEM_STATE.meta_);
                return new CONTROL_SYSTEM_STATE(bytes);
            }
            /**
            *Data packet, size 32 */
            public static DATA32 DATA32(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.DATA32.meta_);
                return new DATA32(bytes);
            }
            public static PING33  PING33(Cursor cur)     //switch blink mode user command bytes

            {
                cur.wrap(GroundControl.PING33.meta_);
                return new PING33(cur);
            }
            /**
            *GCS */
            public static RALLY_POINT  RALLY_POINT(Cursor cur)

            {
                cur.wrap(GroundControl.RALLY_POINT.meta_);
                return new RALLY_POINT(cur);
            }
            /**
            *Adaptive Controller tuning information */
            public static ADAP_TUNING  ADAP_TUNING(Cursor cur)

            {
                cur.wrap(GroundControl.ADAP_TUNING.meta_);
                return new ADAP_TUNING(cur);
            }
            /**
            *Vibration levels and accelerometer clipping */
            public static VIBRATION VIBRATION(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.VIBRATION.meta_);
                return new VIBRATION(bytes);
            }
            /**
            *Emit the value of a parameter. The inclusion of param_count and param_index in the message allows the
            *				 recipient to keep track of received parameters and allows them to re-request missing parameters after
            *				 a loss or timeout */
            public static PARAM_EXT_VALUE  PARAM_EXT_VALUE(Cursor cur)

            {
                cur.wrap(GroundControl.PARAM_EXT_VALUE.meta_);
                return new PARAM_EXT_VALUE(cur);
            }
            /**
            *2nd Battery status */
            public static BATTERY2 BATTERY2(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.BATTERY2.meta_);
                return new BATTERY2(bytes);
            }
            /**
            *Status of AP_Limits. Sent in extended status stream when AP_Limits is enabled */
            public static LIMITS_STATUS  LIMITS_STATUS(Cursor cur)

            {
                cur.wrap(GroundControl.LIMITS_STATUS.meta_);
                return new LIMITS_STATUS(cur);
            }
            /**
            *Camera Capture Feedback */
            public static CAMERA_FEEDBACK  CAMERA_FEEDBACK(Cursor cur)

            {
                cur.wrap(GroundControl.CAMERA_FEEDBACK.meta_);
                return new CAMERA_FEEDBACK(cur);
            }
            /**
            *The global position, as returned by the Global Positioning System (GPS). This is
            *				 NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame). */
            public static HIL_GPS HIL_GPS(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.HIL_GPS.meta_);
                return new HIL_GPS(bytes);
            }
            /**
            *Request a current fence point from MAV */
            public static FENCE_FETCH_POINT FENCE_FETCH_POINT(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.FENCE_FETCH_POINT.meta_);
                return new FENCE_FETCH_POINT(bytes);
            }
            /**
            *Status generated by radio */
            public static RADIO RADIO(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.RADIO.meta_);
                return new RADIO(bytes);
            }
            /**
            *Airspeed auto-calibration */
            public static AIRSPEED_AUTOCAL AIRSPEED_AUTOCAL(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.AIRSPEED_AUTOCAL.meta_);
                return new AIRSPEED_AUTOCAL(bytes);
            }
            /**
            *Motion capture attitude and position */
            public static ATT_POS_MOCAP ATT_POS_MOCAP(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.ATT_POS_MOCAP.meta_);
                return new ATT_POS_MOCAP(bytes);
            }
            /**
            *Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING:
            *				 They consume quite some bandwidth, so use only for important status and error messages. If implemented
            *				 wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz) */
            public static STATUSTEXT  STATUSTEXT(Cursor cur)

            {
                cur.wrap(GroundControl.STATUSTEXT.meta_);
                return new STATUSTEXT(cur);
            }
            /**
            *Request a GOPRO_COMMAND response from the GoPro */
            public static GOPRO_GET_REQUEST  GOPRO_GET_REQUEST(Cursor cur)

            {
                cur.wrap(GroundControl.GOPRO_GET_REQUEST.meta_);
                return new GOPRO_GET_REQUEST(cur);
            }
            /**
            *WIP: Information about the status of a capture */
            public static CAMERA_CAPTURE_STATUS CAMERA_CAPTURE_STATUS(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.CAMERA_CAPTURE_STATUS.meta_);
                return new CAMERA_CAPTURE_STATUS(bytes);
            }
            public static ENCAPSULATED_DATA ENCAPSULATED_DATA(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.ENCAPSULATED_DATA.meta_);
                return new ENCAPSULATED_DATA(bytes);
            }
            /**
            *GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position
            *				 estimate of the sytem */
            public static GPS_INPUT  GPS_INPUT(Cursor cur)

            {
                cur.wrap(GroundControl.GPS_INPUT.meta_);
                return new GPS_INPUT(cur);
            }
            /**
            *Status of compassmot calibration */
            public static COMPASSMOT_STATUS COMPASSMOT_STATUS(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.COMPASSMOT_STATUS.meta_);
                return new COMPASSMOT_STATUS(bytes);
            }
            /**
            *Request a chunk of a log */
            public static LOG_REQUEST_DATA LOG_REQUEST_DATA(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.LOG_REQUEST_DATA.meta_);
                return new LOG_REQUEST_DATA(bytes);
            }
            /**
            *Camera Event */
            public static CAMERA_STATUS  CAMERA_STATUS(Cursor cur)

            {
                cur.wrap(GroundControl.CAMERA_STATUS.meta_);
                return new CAMERA_STATUS(cur);
            }
            /**
            *WIP: Settings of a camera, can be requested using MAV_CMD_REQUEST_CAMERA_SETTINGS. */
            public static CAMERA_SETTINGS  CAMERA_SETTINGS(Cursor cur)

            {
                cur.wrap(GroundControl.CAMERA_SETTINGS.meta_);
                return new CAMERA_SETTINGS(cur);
            }
            /**
            *Read registers reply */
            public static DEVICE_OP_READ_REPLY DEVICE_OP_READ_REPLY(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.DEVICE_OP_READ_REPLY.meta_);
                return new DEVICE_OP_READ_REPLY(bytes);
            }
            /**
            *Control on-board Camera Control System to take shots. */
            public static DIGICAM_CONTROL DIGICAM_CONTROL(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.DIGICAM_CONTROL.meta_);
                return new DIGICAM_CONTROL(bytes);
            }
            /**
            *Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite
            *				 efficient way for testing new messages and getting experimental debug output */
            public static NAMED_VALUE_FLOAT  NAMED_VALUE_FLOAT(Cursor cur)

            {
                cur.wrap(GroundControl.NAMED_VALUE_FLOAT.meta_);
                return new NAMED_VALUE_FLOAT(cur);
            }
            /**
            *Heartbeat from a HeroBus attached GoPro */
            public static GOPRO_HEARTBEAT  GOPRO_HEARTBEAT(Cursor cur)

            {
                cur.wrap(GroundControl.GOPRO_HEARTBEAT.meta_);
                return new GOPRO_HEARTBEAT(cur);
            }
            /**
            *Status of secondary AHRS filter if available */
            public static AHRS2 AHRS2(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.AHRS2.meta_);
                return new AHRS2(bytes);
            }
            /**
            *Erase all logs */
            public static LOG_ERASE LOG_ERASE(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.LOG_ERASE.meta_);
                return new LOG_ERASE(bytes);
            }
            /**
            *Request for terrain data and terrain status */
            public static TERRAIN_REQUEST TERRAIN_REQUEST(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.TERRAIN_REQUEST.meta_);
                return new TERRAIN_REQUEST(bytes);
            }
            /**
            *Message with some status from APM to GCS about camera or antenna mount */
            public static MOUNT_STATUS MOUNT_STATUS(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.MOUNT_STATUS.meta_);
                return new MOUNT_STATUS(bytes);
            }
            /**
            *PID tuning information */
            public static PID_TUNING  PID_TUNING(Cursor cur)

            {
                cur.wrap(GroundControl.PID_TUNING.meta_);
                return new PID_TUNING(cur);
            }
            /**
            *Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor) */
            public static OPTICAL_FLOW_RAD OPTICAL_FLOW_RAD(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.OPTICAL_FLOW_RAD.meta_);
                return new OPTICAL_FLOW_RAD(bytes);
            }
            /**
            *Reply to LOG_REQUEST_DATA */
            public static LOG_DATA LOG_DATA(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.LOG_DATA.meta_);
                return new LOG_DATA(bytes);
            }
            /**
            *Status of third AHRS filter if available. This is for ANU research group (Ali and Sean) */
            public static AHRS3 AHRS3(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.AHRS3.meta_);
                return new AHRS3(bytes);
            }
            public static VICON_POSITION_ESTIMATE VICON_POSITION_ESTIMATE(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.VICON_POSITION_ESTIMATE.meta_);
                return new VICON_POSITION_ESTIMATE(bytes);
            }
            /**
            *RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */
            public static GPS2_RTK GPS2_RTK(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.GPS2_RTK.meta_);
                return new GPS2_RTK(bytes);
            }
            /**
            *Reports results of completed compass calibration. Sent until MAG_CAL_ACK received. */
            public static MAG_CAL_REPORT  MAG_CAL_REPORT(Cursor cur)

            {
                cur.wrap(GroundControl.MAG_CAL_REPORT.meta_);
                return new MAG_CAL_REPORT(cur);
            }
            /**
            *Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END
            *				 is called */
            public static LOG_REQUEST_LIST LOG_REQUEST_LIST(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.LOG_REQUEST_LIST.meta_);
                return new LOG_REQUEST_LIST(bytes);
            }
            /**
            *Message to configure a camera mount, directional antenna, etc. */
            public static MOUNT_CONFIGURE  MOUNT_CONFIGURE(Cursor cur)

            {
                cur.wrap(GroundControl.MOUNT_CONFIGURE.meta_);
                return new MOUNT_CONFIGURE(cur);
            }
            /**
            *Message implementing parts of the V2 payload specs in V1 frames for transitional support. */
            public static V2_EXTENSION V2_EXTENSION(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.V2_EXTENSION.meta_);
                return new V2_EXTENSION(bytes);
            }
            /**
            *Power supply status */
            public static POWER_STATUS  POWER_STATUS(Cursor cur)

            {
                cur.wrap(GroundControl.POWER_STATUS.meta_);
                return new POWER_STATUS(cur);
            }
            /**
            *Send a block of log data to remote location */
            public static REMOTE_LOG_DATA_BLOCK  REMOTE_LOG_DATA_BLOCK(Cursor cur)

            {
                cur.wrap(GroundControl.REMOTE_LOG_DATA_BLOCK.meta_);
                return new REMOTE_LOG_DATA_BLOCK(cur);
            }
            /**
            *A message containing logged data which requires a LOGGING_ACK to be sent back */
            public static LOGGING_DATA_ACKED LOGGING_DATA_ACKED(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.LOGGING_DATA_ACKED.meta_);
                return new LOGGING_DATA_ACKED(bytes);
            }
            /**
            *Request that the vehicle report terrain height at the given location. Used by GCS to check if vehicle
            *				 has all terrain data needed for a mission */
            public static TERRAIN_CHECK TERRAIN_CHECK(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.TERRAIN_CHECK.meta_);
                return new TERRAIN_CHECK(bytes);
            }
            /**
            *Response from a TERRAIN_CHECK request */
            public static TERRAIN_REPORT TERRAIN_REPORT(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.TERRAIN_REPORT.meta_);
                return new TERRAIN_REPORT(bytes);
            }
            /**
            *The position the system will return to and land on. The position is set automatically by the system during
            *				 the takeoff in case it was not explicitely set by the operator before or after. The global and local
            *				 positions encode the position in the respective coordinate frames, while the q parameter encodes the
            *				 orientation of the surface. Under normal conditions it describes the heading and terrain slope, which
            *				 can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which
            *				 the system should fly in normal flight mode and then perform a landing sequence along the vector */
            public static SET_HOME_POSITION  SET_HOME_POSITION(Cursor cur)

            {
                cur.wrap(GroundControl.SET_HOME_POSITION.meta_);
                return new SET_HOME_POSITION(cur);
            }
            /**
            *The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described
            *				 unit */
            public static SCALED_IMU3 SCALED_IMU3(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.SCALED_IMU3.meta_);
                return new SCALED_IMU3(bytes);
            }
            /**
            *Message to control a camera mount, directional antenna, etc. */
            public static MOUNT_CONTROL MOUNT_CONTROL(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.MOUNT_CONTROL.meta_);
                return new MOUNT_CONTROL(bytes);
            }
            /**
            *Control vehicle LEDs */
            public static LED_CONTROL LED_CONTROL(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.LED_CONTROL.meta_);
                return new LED_CONTROL(bytes);
            }
            /**
            *Status of simulation environment, if used */
            public static SIM_STATE SIM_STATE(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.SIM_STATE.meta_);
                return new SIM_STATE(bytes);
            }
            /**
            *Configure AP SSID and Password. */
            public static WIFI_CONFIG_AP  WIFI_CONFIG_AP(Cursor cur)

            {
                cur.wrap(GroundControl.WIFI_CONFIG_AP.meta_);
                return new WIFI_CONFIG_AP(cur);
            }
            /**
            *Data packet, size 96 */
            public static DATA96 DATA96(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.DATA96.meta_);
                return new DATA96(bytes);
            }
            /**
            *WIP: Information about flight since last arming */
            public static FLIGHT_INFORMATION FLIGHT_INFORMATION(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.FLIGHT_INFORMATION.meta_);
                return new FLIGHT_INFORMATION(bytes);
            }
            /**
            *state of APM memory */
            public static MEMINFO  MEMINFO(Cursor cur)

            {
                cur.wrap(GroundControl.MEMINFO.meta_);
                return new MEMINFO(cur);
            }
            /**
            *An ack for a LOGGING_DATA_ACKED message */
            public static LOGGING_ACK LOGGING_ACK(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.LOGGING_ACK.meta_);
                return new LOGGING_ACK(bytes);
            }
            public static VISION_SPEED_ESTIMATE VISION_SPEED_ESTIMATE(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.VISION_SPEED_ESTIMATE.meta_);
                return new VISION_SPEED_ESTIMATE(bytes);
            }
            public static DEBUG_VECT  DEBUG_VECT(Cursor cur)

            {
                cur.wrap(GroundControl.DEBUG_VECT.meta_);
                return new DEBUG_VECT(cur);
            }
            /**
            *Camera-IMU triggering and synchronisation message. */
            public static CAMERA_TRIGGER CAMERA_TRIGGER(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.CAMERA_TRIGGER.meta_);
                return new CAMERA_TRIGGER(bytes);
            }
            /**
            *Stop log transfer and resume normal logging */
            public static LOG_REQUEST_END LOG_REQUEST_END(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.LOG_REQUEST_END.meta_);
                return new LOG_REQUEST_END(bytes);
            }
            /**
            *Response from a GOPRO_COMMAND set request */
            public static GOPRO_SET_RESPONSE  GOPRO_SET_RESPONSE(Cursor cur)

            {
                cur.wrap(GroundControl.GOPRO_SET_RESPONSE.meta_);
                return new GOPRO_SET_RESPONSE(cur);
            }
            /**
            *WIP: Version and capability of protocol version. This message is the response to REQUEST_PROTOCOL_VERSION
            *				 and is used as part of the handshaking to establish which MAVLink version should be used on the network.
            *				 Every node should respond to REQUEST_PROTOCOL_VERSION to enable the handshaking. Library implementers
            *				 should consider adding this into the default decoding state machine to allow the protocol core to respond
            *				 directly */
            public static PROTOCOL_VERSION PROTOCOL_VERSION(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.PROTOCOL_VERSION.meta_);
                return new PROTOCOL_VERSION(bytes);
            }
            /**
            *Request a current rally point from MAV. MAV should respond with a RALLY_POINT message. MAV should not
            *				 respond if the request is invalid */
            public static RALLY_FETCH_POINT RALLY_FETCH_POINT(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.RALLY_FETCH_POINT.meta_);
                return new RALLY_FETCH_POINT(bytes);
            }
            /**
            *Battery information */
            public static BATTERY_STATUS  BATTERY_STATUS(Cursor cur)

            {
                cur.wrap(GroundControl.BATTERY_STATUS.meta_);
                return new BATTERY_STATUS(cur);
            }
            public static MOUNT_ORIENTATION MOUNT_ORIENTATION(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.MOUNT_ORIENTATION.meta_);
                return new MOUNT_ORIENTATION(bytes);
            }
            /**
            *Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or
            *				 telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages
            *				 or change the devices settings. A message with zero bytes can be used to change just the baudrate */
            public static SERIAL_CONTROL  SERIAL_CONTROL(Cursor cur)

            {
                cur.wrap(GroundControl.SERIAL_CONTROL.meta_);
                return new SERIAL_CONTROL(cur);
            }
            /**
            *Set a parameter value. In order to deal with message loss (and retransmission of PARAM_EXT_SET), when
            *				 setting a parameter value and the new value is the same as the current value, you will immediately get
            *				 a PARAM_ACK_ACCEPTED response. If the current state is PARAM_ACK_IN_PROGRESS, you will accordingly receive
            *				 a PARAM_ACK_IN_PROGRESS in response */
            public static PARAM_EXT_SET  PARAM_EXT_SET(Cursor cur)

            {
                cur.wrap(GroundControl.PARAM_EXT_SET.meta_);
                return new PARAM_EXT_SET(cur);
            }
            /**
            *Version and capability of autopilot software */
            public static AUTOPILOT_VERSION  AUTOPILOT_VERSION(Cursor cur)

            {
                cur.wrap(GroundControl.AUTOPILOT_VERSION.meta_);
                return new AUTOPILOT_VERSION(cur);
            }
            /**
            *Status of simulation environment, if used */
            public static SIMSTATE SIMSTATE(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.SIMSTATE.meta_);
                return new SIMSTATE(bytes);
            }
            /**
            *WIP: Message that sets video stream settings */
            public static SET_VIDEO_STREAM_SETTINGS  SET_VIDEO_STREAM_SETTINGS(Cursor cur)

            {
                cur.wrap(GroundControl.SET_VIDEO_STREAM_SETTINGS.meta_);
                return new SET_VIDEO_STREAM_SETTINGS(cur);
            }
            /**
            *Control vehicle tone generation (buzzer) */
            public static PLAY_TUNE  PLAY_TUNE(Cursor cur)

            {
                cur.wrap(GroundControl.PLAY_TUNE.meta_);
                return new PLAY_TUNE(cur);
            }
            /**
            *Configure on-board Camera Control System. */
            public static DIGICAM_CONFIGURE DIGICAM_CONFIGURE(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.DIGICAM_CONFIGURE.meta_);
                return new DIGICAM_CONFIGURE(bytes);
            }
            /**
            *Barometer readings for 3rd barometer */
            public static SCALED_PRESSURE3 SCALED_PRESSURE3(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.SCALED_PRESSURE3.meta_);
                return new SCALED_PRESSURE3(bytes);
            }
            /**
            *Response from a PARAM_EXT_SET message. */
            public static PARAM_EXT_ACK  PARAM_EXT_ACK(Cursor cur)

            {
                cur.wrap(GroundControl.PARAM_EXT_ACK.meta_);
                return new PARAM_EXT_ACK(cur);
            }
            /**
            *General information describing a particular UAVCAN node. Please refer to the definition of the UAVCAN
            *				 service "uavcan.protocol.GetNodeInfo" for the background information. This message should be emitted
            *				 by the system whenever a new node appears online, or an existing node reboots. Additionally, it can be
            *				 emitted upon request from the other end of the MAVLink channel (see MAV_CMD_UAVCAN_GET_NODE_INFO). It
            *				 is also not prohibited to emit this message unconditionally at a low frequency. The UAVCAN specification
            *				 is available at http:uavcan.org */
            public static UAVCAN_NODE_INFO  UAVCAN_NODE_INFO(Cursor cur)

            {
                cur.wrap(GroundControl.UAVCAN_NODE_INFO.meta_);
                return new UAVCAN_NODE_INFO(cur);
            }
            /**
            *Data packet, size 16 */
            public static DATA16 DATA16(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.DATA16.meta_);
                return new DATA16(bytes);
            }
            /**
            *Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the magnetometer offsets */
            public static SET_MAG_OFFSETS SET_MAG_OFFSETS(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.SET_MAG_OFFSETS.meta_);
                return new SET_MAG_OFFSETS(bytes);
            }
            /**
            *The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to
            *				 the described unit */
            public static SCALED_IMU2 SCALED_IMU2(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.SCALED_IMU2.meta_);
                return new SCALED_IMU2(bytes);
            }
            /**
            *raw ADC output */
            public static AP_ADC AP_ADC(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.AP_ADC.meta_);
                return new AP_ADC(bytes);
            }
            /**
            *Wind estimation */
            public static WIND WIND(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.WIND.meta_);
                return new WIND(bytes);
            }
            /**
            *Request the autopilot version from the system/component. */
            public static AUTOPILOT_VERSION_REQUEST AUTOPILOT_VERSION_REQUEST(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.AUTOPILOT_VERSION_REQUEST.meta_);
                return new AUTOPILOT_VERSION_REQUEST(bytes);
            }
            public static DATA_TRANSMISSION_HANDSHAKE DATA_TRANSMISSION_HANDSHAKE(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.DATA_TRANSMISSION_HANDSHAKE.meta_);
                return new DATA_TRANSMISSION_HANDSHAKE(bytes);
            }
            /**
            *Data packet, size 64 */
            public static DATA64 DATA64(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.DATA64.meta_);
                return new DATA64(bytes);
            }
            /**
            *3 axis gimbal mesuraments */
            public static GIMBAL_REPORT GIMBAL_REPORT(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.GIMBAL_REPORT.meta_);
                return new GIMBAL_REPORT(bytes);
            }
            /**
            *Write registers for a device */
            public static DEVICE_OP_WRITE  DEVICE_OP_WRITE(Cursor cur)

            {
                cur.wrap(GroundControl.DEVICE_OP_WRITE.meta_);
                return new DEVICE_OP_WRITE(cur);
            }
            public static DISTANCE_SENSOR  DISTANCE_SENSOR(Cursor cur)

            {
                cur.wrap(GroundControl.DISTANCE_SENSOR.meta_);
                return new DISTANCE_SENSOR(cur);
            }
            /**
            *Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor) */
            public static HIL_OPTICAL_FLOW HIL_OPTICAL_FLOW(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.HIL_OPTICAL_FLOW.meta_);
                return new HIL_OPTICAL_FLOW(bytes);
            }
            /**
            *Barometer readings for 2nd barometer */
            public static SCALED_PRESSURE2 SCALED_PRESSURE2(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.SCALED_PRESSURE2.meta_);
                return new SCALED_PRESSURE2(bytes);
            }
            public static WIND_COV WIND_COV(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.WIND_COV.meta_);
                return new WIND_COV(bytes);
            }
            /**
            *Request to set a GOPRO_COMMAND with a desired */
            public static GOPRO_SET_REQUEST  GOPRO_SET_REQUEST(Cursor cur)

            {
                cur.wrap(GroundControl.GOPRO_SET_REQUEST.meta_);
                return new GOPRO_SET_REQUEST(cur);
            }
            /**
            *camera vision based attitude and position deltas */
            public static VISION_POSITION_DELTA VISION_POSITION_DELTA(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.VISION_POSITION_DELTA.meta_);
                return new VISION_POSITION_DELTA(bytes);
            }
            /**
            *A message containing logged data (see also MAV_CMD_LOGGING_START) */
            public static LOGGING_DATA LOGGING_DATA(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.LOGGING_DATA.meta_);
                return new LOGGING_DATA(bytes);
            }
            /**
            *Read registers for a device */
            public static DEVICE_OP_READ  DEVICE_OP_READ(Cursor cur)

            {
                cur.wrap(GroundControl.DEVICE_OP_READ.meta_);
                return new DEVICE_OP_READ(cur);
            }
            /**
            *Reports progress of compass calibration. */
            public static MAG_CAL_PROGRESS  MAG_CAL_PROGRESS(Cursor cur)

            {
                cur.wrap(GroundControl.MAG_CAL_PROGRESS.meta_);
                return new MAG_CAL_PROGRESS(cur);
            }
            /**
            *The IMU readings in SI units in NED body frame */
            public static HIGHRES_IMU HIGHRES_IMU(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.HIGHRES_IMU.meta_);
                return new HIGHRES_IMU(bytes);
            }
            /**
            *Provides state for additional features */
            public static EXTENDED_SYS_STATE  EXTENDED_SYS_STATE(Cursor cur)

            {
                cur.wrap(GroundControl.EXTENDED_SYS_STATE.meta_);
                return new EXTENDED_SYS_STATE(cur);
            }
            /**
            *Dynamic data used to generate ADS-B out transponder data (send at 5Hz) */
            public static UAVIONIX_ADSB_OUT_DYNAMIC  UAVIONIX_ADSB_OUT_DYNAMIC(Cursor cur)

            {
                cur.wrap(GroundControl.UAVIONIX_ADSB_OUT_DYNAMIC.meta_);
                return new UAVIONIX_ADSB_OUT_DYNAMIC(cur);
            }
            /**
            *Response from a GOPRO_COMMAND get request */
            public static GOPRO_GET_RESPONSE  GOPRO_GET_RESPONSE(Cursor cur)

            {
                cur.wrap(GroundControl.GOPRO_GET_RESPONSE.meta_);
                return new GOPRO_GET_RESPONSE(cur);
            }
            /**
            *data for injecting into the onboard GPS (used for DGPS) */
            public static GPS_INJECT_DATA GPS_INJECT_DATA(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.GPS_INJECT_DATA.meta_);
                return new GPS_INJECT_DATA(bytes);
            }
            /**
            *Transceiver heartbeat with health report (updated every 10s) */
            public static UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT  UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT(Cursor cur)

            {
                cur.wrap(GroundControl.UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT.meta_);
                return new UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT(cur);
            }
            /**
            *Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite
            *				 efficient way for testing new messages and getting experimental debug output */
            public static NAMED_VALUE_INT  NAMED_VALUE_INT(Cursor cur)

            {
                cur.wrap(GroundControl.NAMED_VALUE_INT.meta_);
                return new NAMED_VALUE_INT(cur);
            }
            /**
            *RPM sensor output */
            public static RPM RPM(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.RPM.meta_);
                return new RPM(bytes);
            }
            /**
            *RTCM message for injecting into the onboard GPS (used for DGPS) */
            public static GPS_RTCM_DATA GPS_RTCM_DATA(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.GPS_RTCM_DATA.meta_);
                return new GPS_RTCM_DATA(bytes);
            }
            /**
            *File transfer message */
            public static FILE_TRANSFER_PROTOCOL FILE_TRANSFER_PROTOCOL(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.FILE_TRANSFER_PROTOCOL.meta_);
                return new FILE_TRANSFER_PROTOCOL(bytes);
            }
            /**
            *Rangefinder reporting */
            public static RANGEFINDER RANGEFINDER(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.RANGEFINDER.meta_);
                return new RANGEFINDER(bytes);
            }
            /**
            *Status generated by radio and injected into MAVLink stream. */
            public static RADIO_STATUS RADIO_STATUS(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.RADIO_STATUS.meta_);
                return new RADIO_STATUS(bytes);
            }
            /**
            *GCS */
            public static FENCE_POINT FENCE_POINT(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.FENCE_POINT.meta_);
                return new FENCE_POINT(bytes);
            }
            /**
            *The autopilot is requesting a resource (file, binary, other type of data) */
            public static RESOURCE_REQUEST RESOURCE_REQUEST(Pack.Cursor bytes)

            {
                bytes.wrap(GroundControl.RESOURCE_REQUEST.meta_);
                return new RESOURCE_REQUEST(bytes);
            }

        }

    }

}
namespace org.unirail
{
    using com.company.demo.GroundControl;


    public static partial class AdHoc
    {

        public const int RECEIVE_REQ_MAX_BYTES = 255;
        public const int RECEIVE_FULL_MAX_BYTES = 6850;



        public const int SEND_REQ_MAX_BYTES = 255;
        public const int SEND_FULL_MAX_BYTES = 6850;


        static AdHoc()
        {
            var _ad_hoc1031 = new Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, null);
            var _ad_hoc2118 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc141 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc281 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc630 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc349 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1498 = new Pack.Meta.Field(1, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc422 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc2043 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc1490 = new Pack.Meta.Field(1, true, 1, 4, 6, 3, 0, null, 3);
            var _ad_hoc828 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc1862 = new Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc2126 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc636 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc2414 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc684 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc190 = new Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, null);
            var _ad_hoc1133 = new Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, null);
            var _ad_hoc1332 = new Pack.Meta.Field(1, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc1185 = new Pack.Meta.Field(1, true, 1, 8, 1, 0, 0, null);
            var _ad_hoc350 = new Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, null);
            var _ad_hoc1512 = new Pack.Meta.Field(2, false, 1, 4, 6, 12, 5, null, 2);
            var _ad_hoc1471 = new Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc84 = new Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, null);
            var _ad_hoc1515 = new Pack.Meta.Field(1, false, 1, 4, 6, 2, 0, null, 2);
            var _ad_hoc352 = new Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, null);
            var _ad_hoc1508 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc1522 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc1503 = new Pack.Meta.Field(8, false, 1, 5, 3, 14, 5, null, 2, 2);
            var _ad_hoc377 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc2016 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc2119 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc1132 = new Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, null);
            var _ad_hoc1517 = new Pack.Meta.Field(2, false, 1, 4, 18, 10, 5, null);
            var _ad_hoc2106 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc1516 = new Pack.Meta.Field(2, false, 1, 1, 18, 10, 5, null);
            var _ad_hoc210 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1989 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc1018 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc804 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc424 = new Pack.Meta.Field(7, false, 1, 8, 1, 0, 0, null);
            var _ad_hoc1499 = new Pack.Meta.Field(7, false, 1, 6, 27, 0, 0, null);
            var _ad_hoc1491 = new Pack.Meta.Field(1, true, 1, 4, 18, 0, 0, null);
            var _ad_hoc1504 = new Pack.Meta.Field(7, false, 1, 6, 9, 2, 0, null, 2);
            var _ad_hoc1181 = new Pack.Meta.Field(1, true, 1, 8, 1, 0, 0, null);
            var _ad_hoc1954 = new Pack.Meta.Field(1, true, 1, 8, 1, 0, 0, null);
            var _ad_hoc58 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc966 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1494 = new Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc820 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc883 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc80 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc12 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc705 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1511 = new Pack.Meta.Field(2, false, 1, 4, 6, 12, 5, null, 2);
            var _ad_hoc285 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc1518 = new Pack.Meta.Field(2, false, 1, 4, 18, 10, 5, null);
            var _ad_hoc51 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc19 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1520 = new Pack.Meta.Field(5, false, 8, 1, 6, 2, 0, null, 2);
            var _ad_hoc1964 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc1472 = new Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc972 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc2111 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc1509 = new Pack.Meta.Field(1, false, 1, 4, 6, 2, 0, null, 2);
            var _ad_hoc1505 = new Pack.Meta.Field(8, false, 1, 9, 9, 12, 5, null, 2);
            var _ad_hoc326 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1513 = new Pack.Meta.Field(2, false, 1, 4, 18, 10, 5, null);
            var _ad_hoc1492 = new Pack.Meta.Field(2, true, 1, 4, 18, 10, 5, null);
            var _ad_hoc282 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc2110 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc211 = new Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, null);
            var _ad_hoc2084 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc1008 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc194 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc685 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1864 = new Pack.Meta.Field(2, false, 1, 4, 4, 6, 3, null);
            var _ad_hoc212 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1507 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc880 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc2085 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc1942 = new Pack.Meta.Field(1, true, 1, 8, 1, 0, 0, null);
            var _ad_hoc1331 = new Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1032 = new Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, null);
            var _ad_hoc629 = new Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, null);
            var _ad_hoc1488 = new Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, null);
            var _ad_hoc2083 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc218 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc233 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc372 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc706 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1502 = new Pack.Meta.Field(7, false, 1, 5, 3, 4, 0, null, 2, 2);
            var _ad_hoc587 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc71 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc202 = new Pack.Meta.Field(7, false, 1, 8, 1, 0, 0, null);
            var _ad_hoc243 = new Pack.Meta.Field(7, false, 1, 6, 1, 0, 0, null);
            var _ad_hoc105 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc882 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc192 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc306 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1510 = new Pack.Meta.Field(1, false, 1, 4, 6, 2, 0, null, 2);
            var _ad_hoc193 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1136 = new Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, null);
            var _ad_hoc219 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc963 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc150 = new Pack.Meta.Field(7, false, 1, 8, 1, 0, 0, null);
            var _ad_hoc86 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc354 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc999 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc826 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc213 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc645 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc411 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc686 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc191 = new Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, null);
            var _ad_hoc234 = new Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, null);
            var _ad_hoc2004 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc425 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc59 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1188 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc248 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc423 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc16 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1863 = new Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc353 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc628 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc802 = new Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, null);
            var _ad_hoc9 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc827 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc2116 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc881 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc195 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1029 = new Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1330 = new Pack.Meta.Field(1, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc106 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1333 = new Pack.Meta.Field(1, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc107 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc1853 = new Pack.Meta.Field(2, false, 1, 1, 18, 10, 5, null);
            var _ad_hoc2427 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc215 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc85 = new Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, null);
            var _ad_hoc342 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1487 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc421 = new Pack.Meta.Field(7, false, 1, 8, 1, 0, 0, null);
            var _ad_hoc1012 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc244 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc586 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc2117 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc2074 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc139 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1139 = new Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, null);
            var _ad_hoc196 = new Pack.Meta.Field(7, false, 1, 8, 1, 0, 0, null);
            var _ad_hoc1506 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc1134 = new Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, null);
            var _ad_hoc1865 = new Pack.Meta.Field(1, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc376 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1501 = new Pack.Meta.Field(7, false, 1, 5, 9, 2, 0, null, 2);
            var _ad_hoc683 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc351 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1986 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc208 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            var _ad_hoc585 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc2160 = new Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, null);
            var _ad_hoc957 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc152 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc2097 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc1519 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc189 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1003 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc188 = new Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, null);
            var _ad_hoc20 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1980 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc112 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1861 = new Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1521 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc214 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc688 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc83 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc104 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc11 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc420 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1138 = new Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, null);
            var _ad_hoc209 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc153 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc151 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc687 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc140 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc803 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1991 = new Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, null);
            var _ad_hoc426 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc149 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc4 = new Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, null);
            var _ad_hoc1033 = new Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, null);
            var _ad_hoc1135 = new Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, null);
            var _ad_hoc1030 = new Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, null);
            var _ad_hoc17 = new Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, null);
            var _ad_hoc1137 = new Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, null);
            var _ad_hoc710 = new Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, null);
            var _ad_hoc1500 = new Pack.Meta.Field(8, false, 1, 6, 9, 12, 5, null, 2);
            var _ad_hoc10 = new Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, null);
            COMMAND_LONG.meta_.fields_opts[0] = _ad_hoc202 ;
            HEARTBEAT.meta_.fields_opts[0] = _ad_hoc688 ;
            HEARTBEAT.meta_.fields_opts[1] = _ad_hoc686 ;
            HEARTBEAT.meta_.fields_opts[2] = _ad_hoc685 ;
            HEARTBEAT.meta_.fields_opts[3] = _ad_hoc687 ;
            SAFETY_ALLOWED_AREA.meta_.fields_opts[0] = _ad_hoc880 ;
            CAMERA_STATUS.meta_.fields_opts[0] = _ad_hoc684 ;
            GOPRO_GET_REQUEST.meta_.fields_opts[0] = _ad_hoc107 ;
            GOPRO_SET_REQUEST.meta_.fields_opts[0] = _ad_hoc17 ;
            GPS2_RAW.meta_.fields_opts[0] = _ad_hoc972 ;
            CAMERA_FEEDBACK.meta_.fields_opts[0] = _ad_hoc4 ;
            POSITION_TARGET_LOCAL_NED.meta_.fields_opts[0] = _ad_hoc86 ;
            PING33.meta_.fields_opts[0] = _ad_hoc1487 ;
            PING33.meta_.fields_opts[1] = _ad_hoc1488 ;
            PING33.meta_.fields_opts[2] = _ad_hoc1490 ;
            PING33.meta_.fields_opts[3] = _ad_hoc1491 ;
            PING33.meta_.fields_opts[4] = _ad_hoc1492 ;
            PING33.meta_.fields_opts[5] = _ad_hoc1494 ;
            PING33.meta_.fields_opts[6] = _ad_hoc1498 ;
            PING33.meta_.fields_opts[7] = _ad_hoc1499 ;
            PING33.meta_.fields_opts[8] = _ad_hoc1500 ;
            PING33.meta_.fields_opts[9] = _ad_hoc1501 ;
            PING33.meta_.fields_opts[10] = _ad_hoc1502 ;
            PING33.meta_.fields_opts[11] = _ad_hoc1503 ;
            PING33.meta_.fields_opts[12] = _ad_hoc1504 ;
            PING33.meta_.fields_opts[13] = _ad_hoc1505 ;
            PING33.meta_.fields_opts[14] = _ad_hoc1506 ;
            PING33.meta_.fields_opts[15] = _ad_hoc1507 ;
            PING33.meta_.fields_opts[16] = _ad_hoc1508 ;
            PING33.meta_.fields_opts[17] = _ad_hoc139 ;
            PING33.meta_.fields_opts[18] = _ad_hoc1509 ;
            PING33.meta_.fields_opts[19] = _ad_hoc1510 ;
            PING33.meta_.fields_opts[20] = _ad_hoc1511 ;
            PING33.meta_.fields_opts[21] = _ad_hoc1512 ;
            PING33.meta_.fields_opts[22] = _ad_hoc1513 ;
            PING33.meta_.fields_opts[23] = _ad_hoc1515 ;
            PING33.meta_.fields_opts[24] = _ad_hoc1516 ;
            PING33.meta_.fields_opts[25] = _ad_hoc1517 ;
            PING33.meta_.fields_opts[26] = _ad_hoc1518 ;
            PING33.meta_.fields_opts[27] = _ad_hoc1519 ;
            PING33.meta_.fields_opts[28] = _ad_hoc1520 ;
            PING33.meta_.fields_opts[29] = _ad_hoc1521 ;
            PING33.meta_.fields_opts[30] = _ad_hoc1522 ;
            LOCAL_POSITION_NED_COV.meta_.fields_opts[0] = _ad_hoc112 ;
            COLLISION.meta_.fields_opts[0] = _ad_hoc804 ;
            COLLISION.meta_.fields_opts[1] = _ad_hoc803 ;
            COLLISION.meta_.fields_opts[2] = _ad_hoc802 ;
            MAG_CAL_REPORT.meta_.fields_opts[0] = _ad_hoc83 ;
            GLOBAL_POSITION_INT_COV.meta_.fields_opts[0] = _ad_hoc636 ;
            SET_HOME_POSITION.meta_.fields_opts[0] = _ad_hoc1954 ;
            SET_POSITION_TARGET_LOCAL_NED.meta_.fields_opts[0] = _ad_hoc51 ;
            EKF_STATUS_REPORT.meta_.fields_opts[0] = _ad_hoc710 ;
            STATUSTEXT.meta_.fields_opts[0] = _ad_hoc683 ;
            STATUSTEXT.meta_.fields_opts[1] = _ad_hoc1991 ;
            GOPRO_SET_RESPONSE.meta_.fields_opts[0] = _ad_hoc882 ;
            GOPRO_SET_RESPONSE.meta_.fields_opts[1] = _ad_hoc883 ;
            REMOTE_LOG_BLOCK_STATUS.meta_.fields_opts[0] = _ad_hoc372 ;
            MISSION_REQUEST_PARTIAL_LIST.meta_.fields_opts[0] = _ad_hoc354 ;
            MISSION_REQUEST.meta_.fields_opts[0] = _ad_hoc218 ;
            POWER_STATUS.meta_.fields_opts[0] = _ad_hoc140 ;
            NAMED_VALUE_INT.meta_.fields_opts[0] = _ad_hoc1989 ;
            MAG_CAL_PROGRESS.meta_.fields_opts[0] = _ad_hoc141 ;
            MISSION_REQUEST_INT.meta_.fields_opts[0] = _ad_hoc105 ;
            DEBUG_VECT.meta_.fields_opts[0] = _ad_hoc1980 ;
            HIL_CONTROLS.meta_.fields_opts[0] = _ad_hoc353 ;
            UAVIONIX_ADSB_OUT_DYNAMIC.meta_.fields_opts[0] = _ad_hoc587 ;
            UAVIONIX_ADSB_OUT_DYNAMIC.meta_.fields_opts[1] = _ad_hoc585 ;
            UAVIONIX_ADSB_OUT_DYNAMIC.meta_.fields_opts[2] = _ad_hoc586 ;
            HOME_POSITION.meta_.fields_opts[0] = _ad_hoc1942 ;
            OBSTACLE_DISTANCE.meta_.fields_opts[0] = _ad_hoc282 ;
            ADAP_TUNING.meta_.fields_opts[0] = _ad_hoc963 ;
            PARAM_REQUEST_READ.meta_.fields_opts[0] = _ad_hoc1008 ;
            EXTENDED_SYS_STATE.meta_.fields_opts[0] = _ad_hoc19 ;
            EXTENDED_SYS_STATE.meta_.fields_opts[1] = _ad_hoc20 ;
            GOPRO_GET_RESPONSE.meta_.fields_opts[0] = _ad_hoc426 ;
            GOPRO_GET_RESPONSE.meta_.fields_opts[1] = _ad_hoc425 ;
            AUTH_KEY.meta_.fields_opts[0] = _ad_hoc1003 ;
            RALLY_POINT.meta_.fields_opts[0] = _ad_hoc645 ;
            PARAM_EXT_REQUEST_READ.meta_.fields_opts[0] = _ad_hoc2106 ;
            MISSION_ITEM_INT.meta_.fields_opts[0] = _ad_hoc195 ;
            MISSION_ITEM_INT.meta_.fields_opts[1] = _ad_hoc196 ;
            MISSION_ITEM_INT.meta_.fields_opts[2] = _ad_hoc194 ;
            GPS_INPUT.meta_.fields_opts[0] = _ad_hoc881 ;
            OPTICAL_FLOW.meta_.fields_opts[0] = _ad_hoc1471 ;
            OPTICAL_FLOW.meta_.fields_opts[1] = _ad_hoc1472 ;
            SET_VIDEO_STREAM_SETTINGS.meta_.fields_opts[0] = _ad_hoc2083 ;
            MISSION_WRITE_PARTIAL_LIST.meta_.fields_opts[0] = _ad_hoc422 ;
            SET_POSITION_TARGET_GLOBAL_INT.meta_.fields_opts[0] = _ad_hoc957 ;
            PARAM_MAP_RC.meta_.fields_opts[0] = _ad_hoc1188 ;
            BATTERY_STATUS.meta_.fields_opts[0] = _ad_hoc58 ;
            BATTERY_STATUS.meta_.fields_opts[1] = _ad_hoc59 ;
            LIMITS_STATUS.meta_.fields_opts[0] = _ad_hoc189 ;
            LIMITS_STATUS.meta_.fields_opts[1] = _ad_hoc188 ;
            LIMITS_STATUS.meta_.fields_opts[2] = _ad_hoc190 ;
            LIMITS_STATUS.meta_.fields_opts[3] = _ad_hoc191 ;
            MISSION_ACK.meta_.fields_opts[0] = _ad_hoc192 ;
            MISSION_ACK.meta_.fields_opts[1] = _ad_hoc193 ;
            PARAM_VALUE.meta_.fields_opts[0] = _ad_hoc1012 ;
            PARAM_VALUE.meta_.fields_opts[1] = _ad_hoc966 ;
            SET_MODE.meta_.fields_opts[0] = _ad_hoc80 ;
            VIDEO_STREAM_INFORMATION.meta_.fields_opts[0] = _ad_hoc2074 ;
            PARAM_SET.meta_.fields_opts[0] = _ad_hoc1018 ;
            PARAM_SET.meta_.fields_opts[1] = _ad_hoc1 ;
            COMMAND_INT.meta_.fields_opts[0] = _ad_hoc420 ;
            COMMAND_INT.meta_.fields_opts[1] = _ad_hoc421 ;
            FENCE_STATUS.meta_.fields_opts[0] = _ad_hoc85 ;
            UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT.meta_.fields_opts[0] = _ad_hoc377 ;
            MISSION_REQUEST_LIST.meta_.fields_opts[0] = _ad_hoc820 ;
            MISSION_CLEAR_ALL.meta_.fields_opts[0] = _ad_hoc71 ;
            UAVIONIX_ADSB_OUT_CFG.meta_.fields_opts[0] = _ad_hoc2126 ;
            UAVIONIX_ADSB_OUT_CFG.meta_.fields_opts[1] = _ad_hoc209 ;
            UAVIONIX_ADSB_OUT_CFG.meta_.fields_opts[2] = _ad_hoc212 ;
            UAVIONIX_ADSB_OUT_CFG.meta_.fields_opts[3] = _ad_hoc210 ;
            UAVIONIX_ADSB_OUT_CFG.meta_.fields_opts[4] = _ad_hoc208 ;
            UAVIONIX_ADSB_OUT_CFG.meta_.fields_opts[5] = _ad_hoc211 ;
            CAMERA_IMAGE_CAPTURED.meta_.fields_opts[0] = _ad_hoc2043 ;
            HIL_ACTUATOR_CONTROLS.meta_.fields_opts[0] = _ad_hoc326 ;
            PID_TUNING.meta_.fields_opts[0] = _ad_hoc104 ;
            GPS_RAW_INT.meta_.fields_opts[0] = _ad_hoc153 ;
            GPS_RAW_INT.meta_.fields_opts[1] = _ad_hoc1029 ;
            GPS_RAW_INT.meta_.fields_opts[2] = _ad_hoc1030 ;
            GPS_RAW_INT.meta_.fields_opts[3] = _ad_hoc1031 ;
            GPS_RAW_INT.meta_.fields_opts[4] = _ad_hoc1032 ;
            GPS_RAW_INT.meta_.fields_opts[5] = _ad_hoc1033 ;
            POSITION_TARGET_GLOBAL_INT.meta_.fields_opts[0] = _ad_hoc376 ;
            UAVCAN_NODE_STATUS.meta_.fields_opts[0] = _ad_hoc350 ;
            UAVCAN_NODE_STATUS.meta_.fields_opts[1] = _ad_hoc349 ;
            UAVCAN_NODE_INFO.meta_.fields_opts[0] = _ad_hoc2097 ;
            PARAM_EXT_ACK.meta_.fields_opts[0] = _ad_hoc2118 ;
            PARAM_EXT_ACK.meta_.fields_opts[1] = _ad_hoc2119 ;
            PARAM_EXT_ACK.meta_.fields_opts[2] = _ad_hoc233 ;
            PARAM_EXT_ACK.meta_.fields_opts[3] = _ad_hoc234 ;
            MISSION_ITEM.meta_.fields_opts[0] = _ad_hoc149 ;
            MISSION_ITEM.meta_.fields_opts[1] = _ad_hoc150 ;
            MISSION_ITEM.meta_.fields_opts[2] = _ad_hoc151 ;
            HIGH_LATENCY.meta_.fields_opts[0] = _ad_hoc213 ;
            HIGH_LATENCY.meta_.fields_opts[1] = _ad_hoc215 ;
            HIGH_LATENCY.meta_.fields_opts[2] = _ad_hoc214 ;
            CHANGE_OPERATOR_CONTROL.meta_.fields_opts[0] = _ad_hoc999 ;
            PARAM_EXT_SET.meta_.fields_opts[0] = _ad_hoc2116 ;
            PARAM_EXT_SET.meta_.fields_opts[1] = _ad_hoc2117 ;
            PARAM_EXT_SET.meta_.fields_opts[2] = _ad_hoc152 ;
            PARAM_EXT_VALUE.meta_.fields_opts[0] = _ad_hoc2110 ;
            PARAM_EXT_VALUE.meta_.fields_opts[1] = _ad_hoc2111 ;
            PARAM_EXT_VALUE.meta_.fields_opts[2] = _ad_hoc411 ;
            WIFI_CONFIG_AP.meta_.fields_opts[0] = _ad_hoc2084 ;
            WIFI_CONFIG_AP.meta_.fields_opts[1] = _ad_hoc2085 ;
            LANDING_TARGET.meta_.fields_opts[0] = _ad_hoc351 ;
            LANDING_TARGET.meta_.fields_opts[1] = _ad_hoc1861 ;
            LANDING_TARGET.meta_.fields_opts[2] = _ad_hoc1862 ;
            LANDING_TARGET.meta_.fields_opts[3] = _ad_hoc1863 ;
            LANDING_TARGET.meta_.fields_opts[4] = _ad_hoc1864 ;
            LANDING_TARGET.meta_.fields_opts[5] = _ad_hoc352 ;
            LANDING_TARGET.meta_.fields_opts[6] = _ad_hoc1865 ;
            GOPRO_HEARTBEAT.meta_.fields_opts[0] = _ad_hoc629 ;
            GOPRO_HEARTBEAT.meta_.fields_opts[1] = _ad_hoc630 ;
            GOPRO_HEARTBEAT.meta_.fields_opts[2] = _ad_hoc628 ;
            DEVICE_OP_READ.meta_.fields_opts[0] = _ad_hoc248 ;
            DEVICE_OP_READ.meta_.fields_opts[1] = _ad_hoc2414 ;
            CAMERA_SETTINGS.meta_.fields_opts[0] = _ad_hoc84 ;
            ESTIMATOR_STATUS.meta_.fields_opts[0] = _ad_hoc9 ;
            SYS_STATUS.meta_.fields_opts[0] = _ad_hoc828 ;
            SYS_STATUS.meta_.fields_opts[1] = _ad_hoc826 ;
            SYS_STATUS.meta_.fields_opts[2] = _ad_hoc827 ;
            SERIAL_CONTROL.meta_.fields_opts[0] = _ad_hoc706 ;
            SERIAL_CONTROL.meta_.fields_opts[1] = _ad_hoc705 ;
            NAMED_VALUE_FLOAT.meta_.fields_opts[0] = _ad_hoc1986 ;
            CAMERA_INFORMATION.meta_.fields_opts[0] = _ad_hoc342 ;
            CAMERA_INFORMATION.meta_.fields_opts[1] = _ad_hoc2016 ;
            REMOTE_LOG_DATA_BLOCK.meta_.fields_opts[0] = _ad_hoc219 ;
            SAFETY_SET_ALLOWED_AREA.meta_.fields_opts[0] = _ad_hoc306 ;
            MOUNT_CONFIGURE.meta_.fields_opts[0] = _ad_hoc106 ;
            ADSB_VEHICLE.meta_.fields_opts[0] = _ad_hoc10 ;
            ADSB_VEHICLE.meta_.fields_opts[1] = _ad_hoc1964 ;
            ADSB_VEHICLE.meta_.fields_opts[2] = _ad_hoc11 ;
            ADSB_VEHICLE.meta_.fields_opts[3] = _ad_hoc12 ;
            SET_GPS_GLOBAL_ORIGIN.meta_.fields_opts[0] = _ad_hoc1181 ;
            SERVO_OUTPUT_RAW.meta_.fields_opts[0] = _ad_hoc1132 ;
            SERVO_OUTPUT_RAW.meta_.fields_opts[1] = _ad_hoc1133 ;
            SERVO_OUTPUT_RAW.meta_.fields_opts[2] = _ad_hoc1134 ;
            SERVO_OUTPUT_RAW.meta_.fields_opts[3] = _ad_hoc1135 ;
            SERVO_OUTPUT_RAW.meta_.fields_opts[4] = _ad_hoc1136 ;
            SERVO_OUTPUT_RAW.meta_.fields_opts[5] = _ad_hoc1137 ;
            SERVO_OUTPUT_RAW.meta_.fields_opts[6] = _ad_hoc1138 ;
            SERVO_OUTPUT_RAW.meta_.fields_opts[7] = _ad_hoc1139 ;
            COMMAND_ACK.meta_.fields_opts[0] = _ad_hoc424 ;
            COMMAND_ACK.meta_.fields_opts[1] = _ad_hoc423 ;
            COMMAND_ACK.meta_.fields_opts[2] = _ad_hoc1330 ;
            COMMAND_ACK.meta_.fields_opts[3] = _ad_hoc1331 ;
            COMMAND_ACK.meta_.fields_opts[4] = _ad_hoc1332 ;
            COMMAND_ACK.meta_.fields_opts[5] = _ad_hoc1333 ;
            GPS_GLOBAL_ORIGIN.meta_.fields_opts[0] = _ad_hoc1185 ;
            AUTOPILOT_VERSION.meta_.fields_opts[0] = _ad_hoc281 ;
            AUTOPILOT_VERSION.meta_.fields_opts[1] = _ad_hoc1853 ;
            MISSION_COUNT.meta_.fields_opts[0] = _ad_hoc16 ;
            DISTANCE_SENSOR.meta_.fields_opts[0] = _ad_hoc244 ;
            DISTANCE_SENSOR.meta_.fields_opts[1] = _ad_hoc243 ;
            PLAY_TUNE.meta_.fields_opts[0] = _ad_hoc2004 ;
            MEMINFO.meta_.fields_opts[0] = _ad_hoc2160 ;
            DEVICE_OP_WRITE.meta_.fields_opts[0] = _ad_hoc285 ;
            DEVICE_OP_WRITE.meta_.fields_opts[1] = _ad_hoc2427 ;
        }
    }
}

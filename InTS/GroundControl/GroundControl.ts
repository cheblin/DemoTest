import {org as _org} from "./AdHoc";
import _Lib = _org.unirail.AdHoc;
import _Pack = _Lib.Pack;
import _Cursor = _Pack.Cursor;


export namespace com.company.demo {
	export namespace GroundControl {
		
		
		export const enum PID_TUNING_AXIS {
			
			PID_TUNING_ROLL    = 1,
			PID_TUNING_PITCH   = 2,
			PID_TUNING_YAW     = 3,
			PID_TUNING_ACCZ    = 4,
			PID_TUNING_STEER   = 5,
			PID_TUNING_LANDING = 6
		}
		
		/**
		 *Flags in EKF_STATUS message */
		
		export const enum ESTIMATOR_STATUS_FLAGS {
			
			ESTIMATOR_ATTITUDE           = 1,//True if the attitude estimate is good
			ESTIMATOR_VELOCITY_HORIZ     = 2,//True if the horizontal velocity estimate is good
			ESTIMATOR_VELOCITY_VERT      = 4,//True if the  vertical velocity estimate is good
			ESTIMATOR_POS_HORIZ_REL      = 8,//True if the horizontal position (relative) estimate is good
			ESTIMATOR_POS_HORIZ_ABS      = 16,//True if the horizontal position (absolute) estimate is good
			ESTIMATOR_POS_VERT_ABS       = 32,//True if the vertical position (absolute) estimate is good
			ESTIMATOR_POS_VERT_AGL       = 64,//True if the vertical position (above ground) estimate is good
			/**
			 *True if the EKF is in a constant position mode and is not using external measurements (eg GPS or optical
			 *			 flow */
			ESTIMATOR_CONST_POS_MODE     = 128,
			ESTIMATOR_PRED_POS_HORIZ_REL = 256,//True if the EKF has sufficient data to enter a mode that will provide a (relative) position estimat
			ESTIMATOR_PRED_POS_HORIZ_ABS = 512,//True if the EKF has sufficient data to enter a mode that will provide a (absolute) position estimat
			ESTIMATOR_GPS_GLITCH         = 1024//True if the EKF has detected a GPS glitch
		}
		
		export namespace ESTIMATOR_STATUS_FLAGS_ {
			export function from(id: number): ESTIMATOR_STATUS_FLAGS {
				switch (id) {
					case 0:
						return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_ATTITUDE;
					case 1:
						return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_VELOCITY_HORIZ;
					case 2:
						return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_VELOCITY_VERT;
					case 3:
						return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_HORIZ_REL;
					case 4:
						return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_HORIZ_ABS;
					case 5:
						return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_VERT_ABS;
					case 6:
						return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_VERT_AGL;
					case 7:
						return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_CONST_POS_MODE;
					case 8:
						return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_PRED_POS_HORIZ_REL;
					case 9:
						return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_PRED_POS_HORIZ_ABS;
					case 10:
						return ESTIMATOR_STATUS_FLAGS.ESTIMATOR_GPS_GLITCH;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: ESTIMATOR_STATUS_FLAGS): number {
				switch (en) {
					case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_ATTITUDE:
						return 0;
					case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_VELOCITY_HORIZ:
						return 1;
					case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_VELOCITY_VERT:
						return 2;
					case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_HORIZ_REL:
						return 3;
					case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_HORIZ_ABS:
						return 4;
					case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_VERT_ABS:
						return 5;
					case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_POS_VERT_AGL:
						return 6;
					case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_CONST_POS_MODE:
						return 7;
					case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_PRED_POS_HORIZ_REL:
						return 8;
					case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_PRED_POS_HORIZ_ABS:
						return 9;
					case ESTIMATOR_STATUS_FLAGS.ESTIMATOR_GPS_GLITCH:
						return 10;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		
		export const enum MAV_TYPE {
			
			GENERIC            = 0,//Generic micro air vehicle.
			FIXED_WING         = 1,//Fixed wing aircraft.
			QUADROTOR          = 2,//Quadrotor
			COAXIAL            = 3,//Coaxial helicopter
			HELICOPTER         = 4,//Normal helicopter with tail rotor.
			ANTENNA_TRACKER    = 5,//Ground installation
			GCS                = 6,//Operator control unit / ground control station
			AIRSHIP            = 7,//Airship, controlled
			FREE_BALLOON       = 8,//Free balloon, uncontrolled
			ROCKET             = 9,//Rocket
			GROUND_ROVER       = 10,//Ground rover
			SURFACE_BOAT       = 11,//Surface vessel, boat, ship
			SUBMARINE          = 12,//Submarine
			HEXAROTOR          = 13,//Hexarotor
			OCTOROTOR          = 14,//Octorotor
			TRICOPTER          = 15,//Tricopter
			FLAPPING_WING      = 16,//Flapping wing
			KITE               = 17,//Kite
			ONBOARD_CONTROLLER = 18,//Onboard companion controller
			VTOL_DUOROTOR      = 19,//Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter.
			VTOL_QUADROTOR     = 20,//Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter.
			VTOL_TILTROTOR     = 21,//Tiltrotor VTOL
			VTOL_RESERVED2     = 22,//VTOL reserved 2
			VTOL_RESERVED3     = 23,//VTOL reserved 3
			VTOL_RESERVED4     = 24,//VTOL reserved 4
			VTOL_RESERVED5     = 25,//VTOL reserved 5
			GIMBAL             = 26,//Onboard gimbal
			ADSB               = 27,//Onboard ADSB peripheral
			PARAFOIL           = 28//Steerable, nonrigid airfoil
		}
		
		
		export const enum GOPRO_CAPTURE_MODE {
			
			GOPRO_CAPTURE_MODE_VIDEO      = 0,//Video mode
			GOPRO_CAPTURE_MODE_PHOTO      = 1,//Photo mode
			GOPRO_CAPTURE_MODE_BURST      = 2,//Burst mode, hero 3+ only
			GOPRO_CAPTURE_MODE_TIME_LAPSE = 3,//Time lapse mode, hero 3+ only
			GOPRO_CAPTURE_MODE_MULTI_SHOT = 4,//Multi shot mode, hero 4 only
			GOPRO_CAPTURE_MODE_PLAYBACK   = 5,//Playback mode, hero 4 only, silver only except when LCD or HDMI is connected to black
			GOPRO_CAPTURE_MODE_SETUP      = 6,//Playback mode, hero 4 only
			GOPRO_CAPTURE_MODE_UNKNOWN    = 255//Mode not yet known
		}
		
		export namespace GOPRO_CAPTURE_MODE_ {
			export function from(id: number): GOPRO_CAPTURE_MODE {
				switch (id) {
					case 0:
						return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_VIDEO;
					case 1:
						return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_PHOTO;
					case 2:
						return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_BURST;
					case 3:
						return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_TIME_LAPSE;
					case 4:
						return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_MULTI_SHOT;
					case 5:
						return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_PLAYBACK;
					case 6:
						return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_SETUP;
					case 7:
						return GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_UNKNOWN;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: GOPRO_CAPTURE_MODE): number {
				switch (en) {
					case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_VIDEO:
						return 0;
					case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_PHOTO:
						return 1;
					case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_BURST:
						return 2;
					case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_TIME_LAPSE:
						return 3;
					case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_MULTI_SHOT:
						return 4;
					case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_PLAYBACK:
						return 5;
					case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_SETUP:
						return 6;
					case GOPRO_CAPTURE_MODE.GOPRO_CAPTURE_MODE_UNKNOWN:
						return 7;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *Micro air vehicle / autopilot classes. This identifies the individual model. */
		
		export const enum MAV_AUTOPILOT {
			
			GENERIC                                      = 0,//Generic autopilot, full support for everything
			RESERVED                                     = 1,//Reserved for future use.
			SLUGS                                        = 2,//SLUGS autopilot, http:slugsuav.soe.ucsc.edu
			ARDUPILOTMEGA                                = 3,//ArduPilotMega / ArduCopter, http:diydrones.com
			OPENPILOT                                    = 4,//OpenPilot, http:openpilot.org
			GENERIC_WAYPOINTS_ONLY                       = 5,//Generic autopilot only supporting simple waypoints
			GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY = 6,//Generic autopilot supporting waypoints and other simple navigation commands
			GENERIC_MISSION_FULL                         = 7,//Generic autopilot supporting the full mission command set
			INVALID                                      = 8,//No valid autopilot, e.g. a GCS or other MAVLink component
			PPZ                                          = 9,//PPZ UAV - http:nongnu.org/paparazzi
			UDB                                          = 10,//UAV Dev Board
			FP                                           = 11,//FlexiPilot
			PX4                                          = 12,//PX4 Autopilot - http:pixhawk.ethz.ch/px4/
			SMACCMPILOT                                  = 13,//SMACCMPilot - http:smaccmpilot.org
			AUTOQUAD                                     = 14,//AutoQuad -- http:autoquad.org
			ARMAZILA                                     = 15,//Armazila -- http:armazila.com
			AEROB                                        = 16,//Aerob -- http:aerob.ru
			ASLUAV                                       = 17,//ASLUAV autopilot -- http:www.asl.ethz.ch
			SMARTAP                                      = 18//SmartAP Autopilot - http:sky-drones.com
		}
		
		/**
		 *Enumeration of battery functions */
		
		export const enum MAV_BATTERY_FUNCTION {
			
			MAV_BATTERY_FUNCTION_UNKNOWN    = 0,//Battery function is unknown
			MAV_BATTERY_FUNCTION_ALL        = 1,//Battery supports all flight systems
			MAV_BATTERY_FUNCTION_PROPULSION = 2,//Battery for the propulsion system
			MAV_BATTERY_FUNCTION_AVIONICS   = 3,//Avionics battery
			MAV_BATTERY_TYPE_PAYLOAD        = 4//Payload battery
		}
		
		/**
		 *Type of landing target */
		
		export const enum LANDING_TARGET_TYPE {
			
			LANDING_TARGET_TYPE_LIGHT_BEACON    = 0,//Landing target signaled by light beacon (ex: IR-LOCK)
			LANDING_TARGET_TYPE_RADIO_BEACON    = 1,//Landing target signaled by radio beacon (ex: ILS, NDB)
			LANDING_TARGET_TYPE_VISION_FIDUCIAL = 2,//Landing target represented by a fiducial marker (ex: ARTag)
			LANDING_TARGET_TYPE_VISION_OTHER    = 3//Landing target represented by a pre-defined visual shape/feature (ex: X-marker, H-marker, square)
		}
		
		
		export const enum LIMIT_MODULE {
			
			LIMIT_GPSLOCK  = 1,//pre-initialization
			LIMIT_GEOFENCE = 2,//disabled
			LIMIT_ALTITUDE = 4//checking limits
		}
		
		export namespace LIMIT_MODULE_ {
			export function from(id: number): LIMIT_MODULE {
				switch (id) {
					case 0:
						return LIMIT_MODULE.LIMIT_GPSLOCK;
					case 1:
						return LIMIT_MODULE.LIMIT_GEOFENCE;
					case 2:
						return LIMIT_MODULE.LIMIT_ALTITUDE;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: LIMIT_MODULE): number {
				switch (en) {
					case LIMIT_MODULE.LIMIT_GPSLOCK:
						return 0;
					case LIMIT_MODULE.LIMIT_GEOFENCE:
						return 1;
					case LIMIT_MODULE.LIMIT_ALTITUDE:
						return 2;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *Enumeration of landed detector states */
		
		export const enum MAV_LANDED_STATE {
			
			MAV_LANDED_STATE_UNDEFINED = 0,//MAV landed state is unknown
			MAV_LANDED_STATE_ON_GROUND = 1,//MAV is landed (on ground)
			MAV_LANDED_STATE_IN_AIR    = 2,//MAV is in air
			MAV_LANDED_STATE_TAKEOFF   = 3,//MAV currently taking off
			MAV_LANDED_STATE_LANDING   = 4//MAV currently landing
		}
		
		/**
		 *Specifies the datatype of a MAVLink parameter. */
		
		export const enum MAV_PARAM_TYPE {
			
			MAV_PARAM_TYPE_UINT8  = 1,//8-bit unsigned integer
			MAV_PARAM_TYPE_INT8   = 2,//8-bit signed integer
			MAV_PARAM_TYPE_UINT16 = 3,//16-bit unsigned integer
			MAV_PARAM_TYPE_INT16  = 4,//16-bit signed integer
			MAV_PARAM_TYPE_UINT32 = 5,//32-bit unsigned integer
			MAV_PARAM_TYPE_INT32  = 6,//32-bit signed integer
			MAV_PARAM_TYPE_UINT64 = 7,//64-bit unsigned integer
			MAV_PARAM_TYPE_INT64  = 8,//64-bit signed integer
			MAV_PARAM_TYPE_REAL32 = 9,//32-bit floating-point
			MAV_PARAM_TYPE_REAL64 = 10//64-bit floating-point
		}
		
		/**
		 *Emergency status encoding */
		
		export const enum UAVIONIX_ADSB_EMERGENCY_STATUS {
			
			UAVIONIX_ADSB_OUT_NO_EMERGENCY                    = 0,
			UAVIONIX_ADSB_OUT_GENERAL_EMERGENCY               = 1,
			UAVIONIX_ADSB_OUT_LIFEGUARD_EMERGENCY             = 2,
			UAVIONIX_ADSB_OUT_MINIMUM_FUEL_EMERGENCY          = 3,
			UAVIONIX_ADSB_OUT_NO_COMM_EMERGENCY               = 4,
			UAVIONIX_ADSB_OUT_UNLAWFUL_INTERFERANCE_EMERGENCY = 5,
			UAVIONIX_ADSB_OUT_DOWNED_AIRCRAFT_EMERGENCY       = 6,
			UAVIONIX_ADSB_OUT_RESERVED                        = 7
		}
		
		/**
		 *Indicates the severity level, generally used for status messages to indicate their relative urgency. Based
		 *		 on RFC-5424 using expanded definitions at: http:www.kiwisyslog.com/kb/info:-syslog-message-levels/ */
		
		export const enum MAV_SEVERITY {
			
			MAV_SEVERITY_EMERGENCY = 0,//System is unusable. This is a "panic" condition.
			MAV_SEVERITY_ALERT     = 1,//Action should be taken immediately. Indicates error in non-critical systems.
			MAV_SEVERITY_CRITICAL  = 2,//Action must be taken immediately. Indicates failure in a primary system.
			MAV_SEVERITY_ERROR     = 3,//Indicates an error in secondary/redundant systems.
			/**
			 *Indicates about a possible future error if this is not resolved within a given timeframe. Example would
			 *			 be a low battery warning */
			MAV_SEVERITY_WARNING   = 4,
			/**
			 *An unusual event has occured, though not an error condition. This should be investigated for the root
			 *			 cause */
			MAV_SEVERITY_NOTICE    = 5,
			MAV_SEVERITY_INFO      = 6,//Normal operational messages. Useful for logging. No action is required for these messages.
			MAV_SEVERITY_DEBUG     = 7//Useful non-operational messages that can assist in debugging. These should not occur during normal operation
		}
		
		/**
		 *These defines are predefined OR-combined mode flags. There is no need to use values from this enum, but it
		 *		 simplifies the use of the mode flags. Note that manual input is enabled in all modes as a safety override. */
		
		export const enum MAV_MODE {
			
			PREFLIGHT              = 0,//System is not ready to fly, booting, calibrating, etc. No flag is set.
			MANUAL_DISARMED        = 64,//System is allowed to be active, under manual (RC) control, no stabilization
			MAV_MODE_TEST_DISARMED = 66,//UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only
			STABILIZE_DISARMED     = 80,//System is allowed to be active, under assisted RC control.
			GUIDED_DISARMED        = 88,//System is allowed to be active, under autonomous control, manual setpoint
			/**
			 *System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard
			 *			 and not pre-programmed by waypoints */
			MAV_MODE_AUTO_DISARMED = 92,
			MANUAL_ARMED           = 192,//System is allowed to be active, under manual (RC) control, no stabilization
			MAV_MODE_TEST_ARMED    = 194,//UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only
			STABILIZE_ARMED        = 208,//System is allowed to be active, under assisted RC control.
			GUIDED_ARMED           = 216,//System is allowed to be active, under autonomous control, manual setpoint
			/**
			 *System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard
			 *			 and not pre-programmed by waypoints */
			MAV_MODE_AUTO_ARMED    = 220
		}
		
		export namespace MAV_MODE_ {
			export function from(id: number): MAV_MODE {
				switch (id) {
					case 0:
						return MAV_MODE.PREFLIGHT;
					case 1:
						return MAV_MODE.MANUAL_DISARMED;
					case 2:
						return MAV_MODE.MAV_MODE_TEST_DISARMED;
					case 3:
						return MAV_MODE.STABILIZE_DISARMED;
					case 4:
						return MAV_MODE.GUIDED_DISARMED;
					case 5:
						return MAV_MODE.MAV_MODE_AUTO_DISARMED;
					case 6:
						return MAV_MODE.MANUAL_ARMED;
					case 7:
						return MAV_MODE.MAV_MODE_TEST_ARMED;
					case 8:
						return MAV_MODE.STABILIZE_ARMED;
					case 9:
						return MAV_MODE.GUIDED_ARMED;
					case 10:
						return MAV_MODE.MAV_MODE_AUTO_ARMED;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: MAV_MODE): number {
				switch (en) {
					case MAV_MODE.PREFLIGHT:
						return 0;
					case MAV_MODE.MANUAL_DISARMED:
						return 1;
					case MAV_MODE.MAV_MODE_TEST_DISARMED:
						return 2;
					case MAV_MODE.STABILIZE_DISARMED:
						return 3;
					case MAV_MODE.GUIDED_DISARMED:
						return 4;
					case MAV_MODE.MAV_MODE_AUTO_DISARMED:
						return 5;
					case MAV_MODE.MANUAL_ARMED:
						return 6;
					case MAV_MODE.MAV_MODE_TEST_ARMED:
						return 7;
					case MAV_MODE.STABILIZE_ARMED:
						return 8;
					case MAV_MODE.GUIDED_ARMED:
						return 9;
					case MAV_MODE.MAV_MODE_AUTO_ARMED:
						return 10;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *Enumeration of the ADSB altimeter types */
		
		export const enum ADSB_ALTITUDE_TYPE {
			
			ADSB_ALTITUDE_TYPE_PRESSURE_QNH = 0,//Altitude reported from a Baro source using QNH reference
			ADSB_ALTITUDE_TYPE_GEOMETRIC    = 1//Altitude reported from a GNSS source
		}
		
		/**
		 *Type of mission items being requested/sent in mission protocol. */
		
		export const enum MAV_MISSION_TYPE {
			
			MAV_MISSION_TYPE_MISSION = 0,//Items are mission commands for main mission.
			MAV_MISSION_TYPE_FENCE   = 1,//Specifies GeoFence area(s). Items are MAV_CMD_FENCE_ GeoFence items.
			/**
			 *Specifies the rally points for the vehicle. Rally points are alternative RTL points. Items are MAV_CMD_RALLY_POINT
			 *			 rally point items */
			MAV_MISSION_TYPE_RALLY   = 2,
			MAV_MISSION_TYPE_ALL     = 255//Only used in MISSION_CLEAR_ALL to clear all mission types.
		}
		
		export namespace MAV_MISSION_TYPE_ {
			export function from(id: number): MAV_MISSION_TYPE {
				switch (id) {
					case 0:
						return MAV_MISSION_TYPE.MAV_MISSION_TYPE_MISSION;
					case 1:
						return MAV_MISSION_TYPE.MAV_MISSION_TYPE_FENCE;
					case 2:
						return MAV_MISSION_TYPE.MAV_MISSION_TYPE_RALLY;
					case 3:
						return MAV_MISSION_TYPE.MAV_MISSION_TYPE_ALL;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: MAV_MISSION_TYPE): number {
				switch (en) {
					case MAV_MISSION_TYPE.MAV_MISSION_TYPE_MISSION:
						return 0;
					case MAV_MISSION_TYPE.MAV_MISSION_TYPE_FENCE:
						return 1;
					case MAV_MISSION_TYPE.MAV_MISSION_TYPE_RALLY:
						return 2;
					case MAV_MISSION_TYPE.MAV_MISSION_TYPE_ALL:
						return 3;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *Enumeration of distance sensor types */
		
		export const enum MAV_DISTANCE_SENSOR {
			
			MAV_DISTANCE_SENSOR_LASER      = 0,//Laser rangefinder, e.g. LightWare SF02/F or PulsedLight units
			MAV_DISTANCE_SENSOR_ULTRASOUND = 1,//Ultrasound rangefinder, e.g. MaxBotix units
			MAV_DISTANCE_SENSOR_INFRARED   = 2,//Infrared rangefinder, e.g. Sharp units
			MAV_DISTANCE_SENSOR_RADAR      = 3,//Radar type, e.g. uLanding units
			MAV_DISTANCE_SENSOR_UNKNOWN    = 4//Broken or unknown type, e.g. analog units
		}
		
		/**
		 *Enumeration of VTOL states */
		
		export const enum MAV_VTOL_STATE {
			
			MAV_VTOL_STATE_UNDEFINED        = 0,//MAV is not configured as VTOL
			MAV_VTOL_STATE_TRANSITION_TO_FW = 1,//VTOL is in transition from multicopter to fixed-wing
			MAV_VTOL_STATE_TRANSITION_TO_MC = 2,//VTOL is in transition from fixed-wing to multicopter
			MAV_VTOL_STATE_MC               = 3,//VTOL is in multicopter state
			MAV_VTOL_STATE_FW               = 4//VTOL is in fixed-wing state
		}
		
		/**
		 *Type of GPS fix */
		
		export const enum GPS_FIX_TYPE {
			
			GPS_FIX_TYPE_NO_GPS    = 0,//No GPS connected
			GPS_FIX_TYPE_NO_FIX    = 1,//No position information, GPS is connected
			GPS_FIX_TYPE_2D_FIX    = 2,//2D position
			GPS_FIX_TYPE_3D_FIX    = 3,//3D position
			GPS_FIX_TYPE_DGPS      = 4,//DGPS/SBAS aided 3D position
			GPS_FIX_TYPE_RTK_FLOAT = 5,//RTK float, 3D position
			GPS_FIX_TYPE_RTK_FIXED = 6,//RTK Fixed, 3D position
			GPS_FIX_TYPE_STATIC    = 7,//Static fixed, typically used for base stations
			GPS_FIX_TYPE_PPP       = 8//PPP, 3D position.
		}
		
		/**
		 *Specifies the datatype of a MAVLink extended parameter. */
		
		export const enum MAV_PARAM_EXT_TYPE {
			
			MAV_PARAM_EXT_TYPE_UINT8  = 1,//8-bit unsigned integer
			MAV_PARAM_EXT_TYPE_INT8   = 2,//8-bit signed integer
			MAV_PARAM_EXT_TYPE_UINT16 = 3,//16-bit unsigned integer
			MAV_PARAM_EXT_TYPE_INT16  = 4,//16-bit signed integer
			MAV_PARAM_EXT_TYPE_UINT32 = 5,//32-bit unsigned integer
			MAV_PARAM_EXT_TYPE_INT32  = 6,//32-bit signed integer
			MAV_PARAM_EXT_TYPE_UINT64 = 7,//64-bit unsigned integer
			MAV_PARAM_EXT_TYPE_INT64  = 8,//64-bit signed integer
			MAV_PARAM_EXT_TYPE_REAL32 = 9,//32-bit floating-point
			MAV_PARAM_EXT_TYPE_REAL64 = 10,//64-bit floating-point
			MAV_PARAM_EXT_TYPE_CUSTOM = 11//Custom Type
		}
		
		/**
		 *Enumeration of estimator types */
		
		export const enum MAV_ESTIMATOR_TYPE {
			
			MAV_ESTIMATOR_TYPE_NAIVE   = 1,//This is a naive estimator without any real covariance feedback.
			MAV_ESTIMATOR_TYPE_VISION  = 2,//Computer vision based estimate. Might be up to scale.
			MAV_ESTIMATOR_TYPE_VIO     = 3,//Visual-inertial estimate.
			MAV_ESTIMATOR_TYPE_GPS     = 4,//Plain GPS estimate.
			MAV_ESTIMATOR_TYPE_GPS_INS = 5//Estimator integrating GPS and inertial sensing.
		}
		
		
		export const enum CAMERA_FEEDBACK_FLAGS {
			
			CAMERA_FEEDBACK_PHOTO       = 0,//Shooting photos, not video
			CAMERA_FEEDBACK_VIDEO       = 1,//Shooting video, not stills
			CAMERA_FEEDBACK_BADEXPOSURE = 2,//Unable to achieve requested exposure (e.g. shutter speed too low)
			CAMERA_FEEDBACK_CLOSEDLOOP  = 3,//Closed loop feedback from camera, we know for sure it has successfully taken a picture
			/**
			 *Open loop camera, an image trigger has been requested but we can't know for sure it has successfully taken
			 *			 a pictur */
			CAMERA_FEEDBACK_OPENLOOP    = 4
		}
		
		/**
		 *Generalized UAVCAN node health */
		
		export const enum UAVCAN_NODE_HEALTH {
			
			UAVCAN_NODE_HEALTH_OK       = 0,//The node is functioning properly.
			UAVCAN_NODE_HEALTH_WARNING  = 1,//A critical parameter went out of range or the node has encountered a minor failure.
			UAVCAN_NODE_HEALTH_ERROR    = 2,//The node has encountered a major failure.
			UAVCAN_NODE_HEALTH_CRITICAL = 3//The node has suffered a fatal malfunction.
		}
		
		/**
		 *Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script.
		 *		 If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows:
		 *		 Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what
		 *		 ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data */
		
		export const enum MAV_CMD {
			
			/**
			 *Navigate to waypoint.
			 *					 1	Hold time in decimal seconds. (ignored by fixed wing, time to stay at waypoint for rotary wing)
			 *					 2	Acceptance radius in meters (if the sphere with this radius is hit, the waypoint counts as reached)
			 *					 3	0 to pass through the WP, if 	>	0 radius in meters to pass by WP. Positive value for clockwise orbit, negative value for counter-clockwise orbit. Allows trajectory control.
			 *					 4	Desired yaw angle at waypoint (rotary wing). NaN for unchanged.
			 *					 5	Latitude
			 *					 6	Longitude
			 *					 7	Altitude */
			MAV_CMD_NAV_WAYPOINT                       = 16,
			/**
			 *Loiter around this waypoint an unlimited amount of time
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
			 *			 4	Desired yaw angle.
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude */
			MAV_CMD_NAV_LOITER_UNLIM                   = 17,
			/**
			 *Loiter around this waypoint for X turns
			 *			 1	Turns
			 *			 2	Empty
			 *			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
			 *			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude */
			MAV_CMD_NAV_LOITER_TURNS                   = 18,
			/**
			 *Loiter around this waypoint for X seconds
			 *			 1	Seconds (decimal)
			 *			 2	Empty
			 *			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
			 *			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude */
			MAV_CMD_NAV_LOITER_TIME                    = 19,
			/**
			 *Return to launch location
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_NAV_RETURN_TO_LAUNCH               = 20,
			/**
			 *Land at location
			 *			 1	Abort Alt
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Desired yaw angle. NaN for unchanged.
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude (ground level) */
			MAV_CMD_NAV_LAND                           = 21,
			/**
			 *Takeoff from ground / hand
			 *			 1	Minimum pitch (if airspeed sensor present), desired pitch without sensor
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Yaw angle (if magnetometer present), ignored without magnetometer. NaN for unchanged.
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude */
			MAV_CMD_NAV_TAKEOFF                        = 22,
			/**
			 *Land at local position (local frame only)
			 *			 1	Landing target number (if available)
			 *			 2	Maximum accepted offset from desired landing position [m] - computed magnitude from spherical coordinates: d = sqrt(x^2 + y^2 + z^2), which gives the maximum accepted distance between the desired landing position and the position where the vehicle is about to land
			 *			 3	Landing descend rate [ms^-1]
			 *			 4	Desired yaw angle [rad]
			 *			 5	Y-axis position [m]
			 *			 6	X-axis position [m]
			 *			 7	Z-axis / ground level position [m] */
			MAV_CMD_NAV_LAND_LOCAL                     = 23,
			/**
			 *Takeoff from local position (local frame only)
			 *			 1	Minimum pitch (if airspeed sensor present), desired pitch without sensor [rad]
			 *			 2	Empty
			 *			 3	Takeoff ascend rate [ms^-1]
			 *			 4	Yaw angle [rad] (if magnetometer or another yaw estimation source present), ignored without one of these
			 *			 5	Y-axis position [m]
			 *			 6	X-axis position [m]
			 *			 7	Z-axis position [m] */
			MAV_CMD_NAV_TAKEOFF_LOCAL                  = 24,
			/**
			 *Vehicle following, i.e. this waypoint represents the position of a moving vehicle
			 *			 1	Following logic to use (e.g. loitering or sinusoidal following) - depends on specific autopilot implementation
			 *			 2	Ground speed of vehicle to be followed
			 *			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
			 *			 4	Desired yaw angle.
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude */
			MAV_CMD_NAV_FOLLOW                         = 25,
			/**
			 *Continue on the current course and climb/descend to specified altitude.  When the altitude is reached
			 *			 continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached
			 *			 1	Climb or Descend (0 = Neutral, command completes when within 5m of this command's altitude, 1 = Climbing, command completes when at or above this command's altitude, 2 = Descending, command completes when at or below this command's altitude.
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Desired altitude in meters */
			MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT        = 30,
			/**
			 *Begin loiter at the specified Latitude and Longitude.  If Lat=Lon=0, then loiter at the current position.
			 *			 Don't consider the navigation command complete (don't leave loiter) until the altitude has been reached.
			 *			 Additionally, if the Heading Required parameter is non-zero the  aircraft will not leave the loiter
			 *			 until heading toward the next waypoint.
			 *			 1	Heading Required (0 = False)
			 *			 2	Radius in meters. If positive loiter clockwise, negative counter-clockwise, 0 means no change to standard loiter.
			 *			 3	Empty
			 *			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude */
			MAV_CMD_NAV_LOITER_TO_ALT                  = 31,
			/**
			 *Being following a target
			 *			 1	System ID (the system ID of the FOLLOW_TARGET beacon). Send 0 to disable follow-me and return to the default position hold mode
			 *			 2	RESERVED
			 *			 3	RESERVED
			 *			 4	altitude flag: 0: Keep current altitude, 1: keep altitude difference to target, 2: go to a fixed altitude above home
			 *			 5	altitude
			 *			 6	RESERVED
			 *			 7	TTL in seconds in which the MAV should go to the default position hold mode after a message rx timeout */
			MAV_CMD_DO_FOLLOW                          = 32,
			/**
			 *Reposition the MAV after a follow target command has been sent
			 *			 1	Camera q1 (where 0 is on the ray from the camera to the tracking device)
			 *			 2	Camera q2
			 *			 3	Camera q3
			 *			 4	Camera q4
			 *			 5	altitude offset from target (m)
			 *			 6	X offset from target (m)
			 *			 7	Y offset from target (m) */
			MAV_CMD_DO_FOLLOW_REPOSITION               = 33,
			/**
			 *Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the
			 *			 vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras
			 *			 1	Region of intereset mode. (see MAV_ROI enum)
			 *			 2	Waypoint index/ target ID. (see MAV_ROI enum)
			 *			 3	ROI index (allows a vehicle to manage multiple ROI's)
			 *			 4	Empty
			 *			 5	x the location of the fixed ROI (see MAV_FRAME)
			 *			 6	y
			 *			 7	z */
			MAV_CMD_NAV_ROI                            = 80,
			/**
			 *Control autonomous path planning on the MAV.
			 *			 1	0: Disable local obstacle avoidance / local path planning (without resetting map), 1: Enable local path planning, 2: Enable and reset local path planning
			 *			 2	0: Disable full path planning (without resetting map), 1: Enable, 2: Enable and reset map/occupancy grid, 3: Enable and reset planned route, but not occupancy grid
			 *			 3	Empty
			 *			 4	Yaw angle at goal, in compass degrees, [0..360]
			 *			 5	Latitude/X of goal
			 *			 6	Longitude/Y of goal
			 *			 7	Altitude/Z of goal */
			MAV_CMD_NAV_PATHPLANNING                   = 81,
			/**
			 *Navigate to waypoint using a spline path.
			 *			 1	Hold time in decimal seconds. (ignored by fixed wing, time to stay at waypoint for rotary wing)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Latitude/X of goal
			 *			 6	Longitude/Y of goal
			 *			 7	Altitude/Z of goal */
			MAV_CMD_NAV_SPLINE_WAYPOINT                = 82,
			/**
			 *Mission command to wait for an altitude or downwards vertical speed. This is meant for high altitude balloon
			 *			 launches, allowing the aircraft to be idle until either an altitude is reached or a negative vertical
			 *			 speed is reached (indicating early balloon burst). The wiggle time is how often to wiggle the control
			 *			 surfaces to prevent them seizing up
			 *			 1	altitude (m)
			 *			 2	descent speed (m/s)
			 *			 3	Wiggle Time (s)
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_NAV_ALTITUDE_WAIT                  = 83,
			/**
			 *Takeoff from ground using VTOL mode
			 *			 1	Empty
			 *			 2	Front transition heading, see VTOL_TRANSITION_HEADING enum.
			 *			 3	Empty
			 *			 4	Yaw angle in degrees. NaN for unchanged.
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude */
			MAV_CMD_NAV_VTOL_TAKEOFF                   = 84,
			/**
			 *Land using VTOL mode
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Approach altitude (with the same reference as the Altitude field). NaN if unspecified.
			 *			 4	Yaw angle in degrees. NaN for unchanged.
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude (ground level) */
			MAV_CMD_NAV_VTOL_LAND                      = 85,
			/**
			 *hand control over to an external controller
			 *			 1	On / Off (	>	0.5f on)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_NAV_GUIDED_ENABLE                  = 92,
			/**
			 *Delay the next navigation command a number of seconds or until a specified time
			 *			 1	Delay in seconds (decimal, -1 to enable time-of-day fields)
			 *			 2	hour (24h format, UTC, -1 to ignore)
			 *			 3	minute (24h format, UTC, -1 to ignore)
			 *			 4	second (24h format, UTC)
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_NAV_DELAY                          = 93,
			/**
			 *Descend and place payload.  Vehicle descends until it detects a hanging payload has reached the ground,
			 *			 the gripper is opened to release the payloa
			 *			 1	Maximum distance to descend (meters)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Latitude (deg * 1E7)
			 *			 6	Longitude (deg * 1E7)
			 *			 7	Altitude (meters) */
			MAV_CMD_NAV_PAYLOAD_PLACE                  = 94,
			/**
			 *NOP - This command is only used to mark the upper limit of the NAV/ACTION commands in the enumeratio
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_NAV_LAST                           = 95,
			/**
			 *Delay mission state machine.
			 *			 1	Delay in seconds (decimal)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_CONDITION_DELAY                    = 112,
			/**
			 *Ascend/descend at rate.  Delay mission state machine until desired altitude reached.
			 *			 1	Descent / Ascend rate (m/s)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Finish Altitude */
			MAV_CMD_CONDITION_CHANGE_ALT               = 113,
			/**
			 *Delay mission state machine until within desired distance of next NAV point.
			 *			 1	Distance (meters)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_CONDITION_DISTANCE                 = 114,
			/**
			 *Reach a certain target angle.
			 *			 1	target angle: [0-360], 0 is north
			 *			 2	speed during yaw change:[deg per second]
			 *			 3	direction: negative: counter clockwise, positive: clockwise [-1,1]
			 *			 4	relative offset or absolute angle: [ 1,0]
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_CONDITION_YAW                      = 115,
			/**
			 *NOP - This command is only used to mark the upper limit of the CONDITION commands in the enumeratio
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_CONDITION_LAST                     = 159,
			/**
			 *Set system mode.
			 *			 1	Mode, as defined by ENUM MAV_MODE
			 *			 2	Custom mode - this is system specific, please refer to the individual autopilot specifications for details.
			 *			 3	Custom sub mode - this is system specific, please refer to the individual autopilot specifications for details.
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_SET_MODE                        = 176,
			/**
			 *Jump to the desired command in the mission list.  Repeat this action only the specified number of time
			 *			 1	Sequence number
			 *			 2	Repeat count
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_JUMP                            = 177,
			/**
			 *Change speed and/or throttle set points.
			 *			 1	Speed type (0=Airspeed, 1=Ground Speed)
			 *			 2	Speed  (m/s, -1 indicates no change)
			 *			 3	Throttle  ( Percent, -1 indicates no change)
			 *			 4	absolute or relative [0,1]
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_CHANGE_SPEED                    = 178,
			/**
			 *Changes the home location either to the current location or a specified location.
			 *			 1	Use current (1=use current location, 0=use specified location)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude */
			MAV_CMD_DO_SET_HOME                        = 179,
			/**
			 *Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value
			 *			 of the parameter
			 *			 1	Parameter number
			 *			 2	Parameter value
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_SET_PARAMETER                   = 180,
			/**
			 *Set a relay to a condition.
			 *			 1	Relay number
			 *			 2	Setting (1=on, 0=off, others possible depending on system hardware)
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_SET_RELAY                       = 181,
			/**
			 *Cycle a relay on and off for a desired number of cyles with a desired period.
			 *			 1	Relay number
			 *			 2	Cycle count
			 *			 3	Cycle time (seconds, decimal)
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_REPEAT_RELAY                    = 182,
			/**
			 *Set a servo to a desired PWM value.
			 *			 1	Servo number
			 *			 2	PWM (microseconds, 1000 to 2000 typical)
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_SET_SERVO                       = 183,
			/**
			 *Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period
			 *			 1	Servo number
			 *			 2	PWM (microseconds, 1000 to 2000 typical)
			 *			 3	Cycle count
			 *			 4	Cycle time (seconds)
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_REPEAT_SERVO                    = 184,
			/**
			 *Terminate flight immediately
			 *			 1	Flight termination activated if 	>	0.5
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_FLIGHTTERMINATION               = 185,
			/**
			 *Change altitude set point.
			 *			 1	Altitude in meters
			 *			 2	Mav frame of new altitude (see MAV_FRAME)
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_CHANGE_ALTITUDE                 = 186,
			/**
			 *Mission command to perform a landing. This is used as a marker in a mission to tell the autopilot where
			 *			 a sequence of mission items that represents a landing starts. It may also be sent via a COMMAND_LONG
			 *			 to trigger a landing, in which case the nearest (geographically) landing sequence in the mission will
			 *			 be used. The Latitude/Longitude is optional, and may be set to 0 if not needed. If specified then it
			 *			 will be used to help find the closest landing sequence
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Empty */
			MAV_CMD_DO_LAND_START                      = 189,
			/**
			 *Mission command to perform a landing from a rally point.
			 *			 1	Break altitude (meters)
			 *			 2	Landing speed (m/s)
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_RALLY_LAND                      = 190,
			/**
			 *Mission command to safely abort an autonmous landing.
			 *			 1	Altitude (meters)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_GO_AROUND                       = 191,
			/**
			 *Reposition the vehicle to a specific WGS84 global position.
			 *			 1	Ground speed, less than 0 (-1) for default
			 *			 2	Bitmask of option flags, see the MAV_DO_REPOSITION_FLAGS enum.
			 *			 3	Reserved
			 *			 4	Yaw heading, NaN for unchanged. For planes indicates loiter direction (0: clockwise, 1: counter clockwise)
			 *			 5	Latitude (deg * 1E7)
			 *			 6	Longitude (deg * 1E7)
			 *			 7	Altitude (meters) */
			MAV_CMD_DO_REPOSITION                      = 192,
			/**
			 *If in a GPS controlled position mode, hold the current position or continue.
			 *			 1	0: Pause current mission or reposition command, hold current position. 1: Continue mission. A VTOL capable vehicle should enter hover mode (multicopter and VTOL planes). A plane should loiter with the default loiter radius.
			 *			 2	Reserved
			 *			 3	Reserved
			 *			 4	Reserved
			 *			 5	Reserved
			 *			 6	Reserved
			 *			 7	Reserved */
			MAV_CMD_DO_PAUSE_CONTINUE                  = 193,
			/**
			 *Set moving direction to forward or reverse.
			 *			 1	Direction (0=Forward, 1=Reverse)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_SET_REVERSE                     = 194,
			/**
			 *Control onboard camera system.
			 *			 1	Camera ID (-1 for all)
			 *			 2	Transmission: 0: disabled, 1: enabled compressed, 2: enabled raw
			 *			 3	Transmission mode: 0: video stream, 	>	0: single images every n seconds (decimal)
			 *			 4	Recording: 0: disabled, 1: enabled compressed, 2: enabled raw
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_CONTROL_VIDEO                   = 200,
			/**
			 *Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the
			 *			 vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras
			 *			 1	Region of intereset mode. (see MAV_ROI enum)
			 *			 2	Waypoint index/ target ID. (see MAV_ROI enum)
			 *			 3	ROI index (allows a vehicle to manage multiple ROI's)
			 *			 4	Empty
			 *			 5	MAV_ROI_WPNEXT: pitch offset from next waypoint, MAV_ROI_LOCATION: latitude
			 *			 6	MAV_ROI_WPNEXT: roll offset from next waypoint, MAV_ROI_LOCATION: longitude
			 *			 7	MAV_ROI_WPNEXT: yaw offset from next waypoint, MAV_ROI_LOCATION: altitude */
			MAV_CMD_DO_SET_ROI                         = 201,
			/**
			 *Mission command to configure an on-board camera controller system.
			 *			 1	Modes: P, TV, AV, M, Etc
			 *			 2	Shutter speed: Divisor number for one second
			 *			 3	Aperture: F stop number
			 *			 4	ISO number e.g. 80, 100, 200, Etc
			 *			 5	Exposure type enumerator
			 *			 6	Command Identity
			 *			 7	Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off) */
			MAV_CMD_DO_DIGICAM_CONFIGURE               = 202,
			/**
			 *Mission command to control an on-board camera controller system.
			 *			 1	Session control e.g. show/hide lens
			 *			 2	Zoom's absolute position
			 *			 3	Zooming step value to offset zoom from the current position
			 *			 4	Focus Locking, Unlocking or Re-locking
			 *			 5	Shooting Command
			 *			 6	Command Identity
			 *			 7	Test shot identifier. If set to 1, image will only be captured, but not counted towards internal frame count. */
			MAV_CMD_DO_DIGICAM_CONTROL                 = 203,
			/**
			 *Mission command to configure a camera or antenna mount
			 *			 1	Mount operation mode (see MAV_MOUNT_MODE enum)
			 *			 2	stabilize roll? (1 = yes, 0 = no)
			 *			 3	stabilize pitch? (1 = yes, 0 = no)
			 *			 4	stabilize yaw? (1 = yes, 0 = no)
			 *			 5	roll input (0 = angle, 1 = angular rate)
			 *			 6	pitch input (0 = angle, 1 = angular rate)
			 *			 7	yaw input (0 = angle, 1 = angular rate) */
			MAV_CMD_DO_MOUNT_CONFIGURE                 = 204,
			/**
			 *Mission command to control a camera or antenna mount
			 *			 1	pitch depending on mount mode (degrees or degrees/second depending on pitch input).
			 *			 2	roll depending on mount mode (degrees or degrees/second depending on roll input).
			 *			 3	yaw depending on mount mode (degrees or degrees/second depending on yaw input).
			 *			 4	alt in meters depending on mount mode.
			 *			 5	latitude in degrees * 1E7, set if appropriate mount mode.
			 *			 6	longitude in degrees * 1E7, set if appropriate mount mode.
			 *			 7	MAV_MOUNT_MODE enum value */
			MAV_CMD_DO_MOUNT_CONTROL                   = 205,
			/**
			 *Mission command to set camera trigger distance for this flight. The camera is trigerred each time this
			 *			 distance is exceeded. This command can also be used to set the shutter integration time for the camera
			 *			 1	Camera trigger distance (meters). 0 to stop triggering.
			 *			 2	Camera shutter integration time (milliseconds). -1 or 0 to ignore
			 *			 3	Trigger camera once immediately. (0 = no trigger, 1 = trigger)
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_SET_CAM_TRIGG_DIST              = 206,
			/**
			 *Mission command to enable the geofence
			 *			 1	enable? (0=disable, 1=enable, 2=disable_floor_only)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_FENCE_ENABLE                    = 207,
			/**
			 *Mission command to trigger a parachute
			 *			 1	action (0=disable, 1=enable, 2=release, for some systems see PARACHUTE_ACTION enum, not in general message set.)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_PARACHUTE                       = 208,
			/**
			 *Mission command to perform motor test
			 *			 1	motor sequence number (a number from 1 to max number of motors on the vehicle)
			 *			 2	throttle type (0=throttle percentage, 1=PWM, 2=pilot throttle channel pass-through. See MOTOR_TEST_THROTTLE_TYPE enum)
			 *			 3	throttle
			 *			 4	timeout (in seconds)
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_MOTOR_TEST                      = 209,
			/**
			 *Change to/from inverted flight
			 *			 1	inverted (0=normal, 1=inverted)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_INVERTED_FLIGHT                 = 210,
			/**
			 *Mission command to operate EPM gripper
			 *			 1	gripper number (a number from 1 to max number of grippers on the vehicle)
			 *			 2	gripper action (0=release, 1=grab. See GRIPPER_ACTIONS enum)
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_GRIPPER                         = 211,
			/**
			 *Enable/disable autotune
			 *			 1	enable (1: enable, 0:disable)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_AUTOTUNE_ENABLE                 = 212,
			/**
			 *Sets a desired vehicle turn angle and speed change
			 *			 1	yaw angle to adjust steering by in centidegress
			 *			 2	speed - normalized to 0 .. 1
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_NAV_SET_YAW_SPEED                  = 213,
			/**
			 *Mission command to set camera trigger interval for this flight. If triggering is enabled, the camera is
			 *			 triggered each time this interval expires. This command can also be used to set the shutter integration
			 *			 time for the camera
			 *			 1	Camera trigger cycle time (milliseconds). -1 or 0 to ignore.
			 *			 2	Camera shutter integration time (milliseconds). Should be less than trigger cycle time. -1 or 0 to ignore.
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL          = 214,
			/**
			 *Mission command to control a camera or antenna mount, using a quaternion as reference.
			 *			 1	q1 - quaternion param #1, w (1 in null-rotation)
			 *			 2	q2 - quaternion param #2, x (0 in null-rotation)
			 *			 3	q3 - quaternion param #3, y (0 in null-rotation)
			 *			 4	q4 - quaternion param #4, z (0 in null-rotation)
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_MOUNT_CONTROL_QUAT              = 220,
			/**
			 *set id of master controller
			 *			 1	System ID
			 *			 2	Component ID
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_GUIDED_MASTER                   = 221,
			/**
			 *set limits for external control
			 *			 1	timeout - maximum time (in seconds) that external controller will be allowed to control vehicle. 0 means no timeout
			 *			 2	absolute altitude min (in meters, AMSL) - if vehicle moves below this alt, the command will be aborted and the mission will continue.  0 means no lower altitude limit
			 *			 3	absolute altitude max (in meters)- if vehicle moves above this alt, the command will be aborted and the mission will continue.  0 means no upper altitude limit
			 *			 4	horizontal move limit (in meters, AMSL) - if vehicle moves more than this distance from it's location at the moment the command was executed, the command will be aborted and the mission will continue. 0 means no horizontal altitude limit
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_GUIDED_LIMITS                   = 222,
			/**
			 *Control vehicle engine. This is interpreted by the vehicles engine controller to change the target engine
			 *			 state. It is intended for vehicles with internal combustion engine
			 *			 1	0: Stop engine, 1:Start Engine
			 *			 2	0: Warm start, 1:Cold start. Controls use of choke where applicable
			 *			 3	Height delay (meters). This is for commanding engine start only after the vehicle has gained the specified height. Used in VTOL vehicles during takeoff to start engine after the aircraft is off the ground. Zero for no delay.
			 *			 4	Empty
			 *			 5	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_ENGINE_CONTROL                  = 223,
			/**
			 *NOP - This command is only used to mark the upper limit of the DO commands in the enumeration
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_LAST                            = 240,
			/**
			 *Trigger calibration. This command will be only accepted if in pre-flight mode. Except for Temperature
			 *			 Calibration, only one sensor should be set in a single message and all others should be zero
			 *			 1	1: gyro calibration, 3: gyro temperature calibration
			 *			 2	1: magnetometer calibration
			 *			 3	1: ground pressure calibration
			 *			 4	1: radio RC calibration, 2: RC trim calibration
			 *			 5	1: accelerometer calibration, 2: board level calibration, 3: accelerometer temperature calibration
			 *			 6	1: APM: compass/motor interference calibration (PX4: airspeed calibration, deprecated), 2: airspeed calibration
			 *			 7	1: ESC calibration, 3: barometer temperature calibration */
			MAV_CMD_PREFLIGHT_CALIBRATION              = 241,
			/**
			 *Set sensor offsets. This command will be only accepted if in pre-flight mode.
			 *			 1	Sensor to adjust the offsets for: 0: gyros, 1: accelerometer, 2: magnetometer, 3: barometer, 4: optical flow, 5: second magnetometer, 6: third magnetometer
			 *			 2	X axis offset (or generic dimension 1), in the sensor's raw units
			 *			 3	Y axis offset (or generic dimension 2), in the sensor's raw units
			 *			 4	Z axis offset (or generic dimension 3), in the sensor's raw units
			 *			 5	Generic dimension 4, in the sensor's raw units
			 *			 6	Generic dimension 5, in the sensor's raw units
			 *			 7	Generic dimension 6, in the sensor's raw units */
			MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS       = 242,
			/**
			 *Trigger UAVCAN config. This command will be only accepted if in pre-flight mode.
			 *			 1	1: Trigger actuator ID assignment and direction mapping.
			 *			 2	Reserved
			 *			 3	Reserved
			 *			 4	Reserved
			 *			 5	Reserved
			 *			 6	Reserved
			 *			 7	Reserved */
			MAV_CMD_PREFLIGHT_UAVCAN                   = 243,
			/**
			 *Request storage of different parameter values and logs. This command will be only accepted if in pre-flight
			 *			 mode
			 *			 1	Parameter storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults
			 *			 2	Mission storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults
			 *			 3	Onboard logging: 0: Ignore, 1: Start default rate logging, -1: Stop logging, 	>	1: start logging with rate of param 3 in Hz (e.g. set to 1000 for 1000 Hz logging)
			 *			 4	Reserved
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_PREFLIGHT_STORAGE                  = 245,
			/**
			 *Request the reboot or shutdown of system components.
			 *			 1	0: Do nothing for autopilot, 1: Reboot autopilot, 2: Shutdown autopilot, 3: Reboot autopilot and keep it in the bootloader until upgraded.
			 *			 2	0: Do nothing for onboard computer, 1: Reboot onboard computer, 2: Shutdown onboard computer, 3: Reboot onboard computer and keep it in the bootloader until upgraded.
			 *			 3	WIP: 0: Do nothing for camera, 1: Reboot onboard camera, 2: Shutdown onboard camera, 3: Reboot onboard camera and keep it in the bootloader until upgraded
			 *			 4	WIP: 0: Do nothing for mount (e.g. gimbal), 1: Reboot mount, 2: Shutdown mount, 3: Reboot mount and keep it in the bootloader until upgraded
			 *			 5	Reserved, send 0
			 *			 6	Reserved, send 0
			 *			 7	WIP: ID (e.g. camera ID -1 for all IDs) */
			MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN          = 246,
			/**
			 *Hold / continue the current action
			 *			 1	MAV_GOTO_DO_HOLD: hold MAV_GOTO_DO_CONTINUE: continue with next item in mission plan
			 *			 2	MAV_GOTO_HOLD_AT_CURRENT_POSITION: Hold at current position MAV_GOTO_HOLD_AT_SPECIFIED_POSITION: hold at specified position
			 *			 3	MAV_FRAME coordinate frame of hold point
			 *			 4	Desired yaw angle in degrees
			 *			 5	Latitude / X position
			 *			 6	Longitude / Y position
			 *			 7	Altitude / Z position */
			MAV_CMD_OVERRIDE_GOTO                      = 252,
			/**
			 *start running a mission
			 *			 1	first_item: the first mission item to run
			 *			 2	last_item:  the last mission item to run (after this item is run, the mission ends) */
			MAV_CMD_MISSION_START                      = 300,
			/**
			 *Arms / Disarms a component
			 *			 1	1 to arm, 0 to disarm */
			MAV_CMD_COMPONENT_ARM_DISARM               = 400,
			/**
			 *Request the home position from the vehicle.
			 *			 1	Reserved
			 *			 2	Reserved
			 *			 3	Reserved
			 *			 4	Reserved
			 *			 5	Reserved
			 *			 6	Reserved
			 *			 7	Reserved */
			MAV_CMD_GET_HOME_POSITION                  = 410,
			/**
			 *Starts receiver pairing
			 *			 1	0:Spektrum
			 *			 2	0:Spektrum DSM2, 1:Spektrum DSMX */
			MAV_CMD_START_RX_PAIR                      = 500,
			/**
			 *Request the interval between messages for a particular MAVLink message ID
			 *			 1	The MAVLink message ID */
			MAV_CMD_GET_MESSAGE_INTERVAL               = 510,
			/**
			 *Request the interval between messages for a particular MAVLink message ID. This interface replaces REQUEST_DATA_STREA
			 *			 1	The MAVLink message ID
			 *			 2	The interval between two messages, in microseconds. Set to -1 to disable and 0 to request default rate. */
			MAV_CMD_SET_MESSAGE_INTERVAL               = 511,
			/**
			 *Request MAVLink protocol version compatibility
			 *			 1	1: Request supported protocol versions by all nodes on the network
			 *			 2	Reserved (all remaining params) */
			MAV_CMD_REQUEST_PROTOCOL_VERSION           = 519,
			/**
			 *Request autopilot capabilities
			 *			 1	1: Request autopilot version
			 *			 2	Reserved (all remaining params) */
			MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES     = 520,
			/**
			 *WIP: Request camera information (CAMERA_INFORMATION).
			 *			 1	0: No action 1: Request camera capabilities
			 *			 2	Reserved (all remaining params) */
			MAV_CMD_REQUEST_CAMERA_INFORMATION         = 521,
			/**
			 *WIP: Request camera settings (CAMERA_SETTINGS).
			 *			 1	0: No Action 1: Request camera settings
			 *			 2	Reserved (all remaining params) */
			MAV_CMD_REQUEST_CAMERA_SETTINGS            = 522,
			/**
			 *WIP: Request storage information (STORAGE_INFORMATION). Use the command's target_component to target a
			 *			 specific component's storage
			 *			 1	Storage ID (0 for all, 1 for first, 2 for second, etc.)
			 *			 2	0: No Action 1: Request storage information
			 *			 3	Reserved (all remaining params) */
			MAV_CMD_REQUEST_STORAGE_INFORMATION        = 525,
			/**
			 *WIP: Format a storage medium. Once format is complete, a STORAGE_INFORMATION message is sent. Use the
			 *			 command's target_component to target a specific component's storage
			 *			 1	Storage ID (1 for first, 2 for second, etc.)
			 *			 2	0: No action 1: Format storage
			 *			 3	Reserved (all remaining params) */
			MAV_CMD_STORAGE_FORMAT                     = 526,
			/**
			 *WIP: Request camera capture status (CAMERA_CAPTURE_STATUS)
			 *			 1	0: No Action 1: Request camera capture status
			 *			 2	Reserved (all remaining params) */
			MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS      = 527,
			/**
			 *WIP: Request flight information (FLIGHT_INFORMATION)
			 *			 1	1: Request flight information
			 *			 2	Reserved (all remaining params) */
			MAV_CMD_REQUEST_FLIGHT_INFORMATION         = 528,
			/**
			 *WIP: Reset all camera settings to Factory Default
			 *			 1	0: No Action 1: Reset all settings
			 *			 2	Reserved (all remaining params) */
			MAV_CMD_RESET_CAMERA_SETTINGS              = 529,
			/**
			 *Set camera running mode. Use NAN for reserved values.
			 *			 1	Reserved (Set to 0)
			 *			 2	Camera mode (see CAMERA_MODE enum)
			 *			 3	Reserved (all remaining params) */
			MAV_CMD_SET_CAMERA_MODE                    = 530,
			/**
			 *Start image capture sequence. Sends CAMERA_IMAGE_CAPTURED after each capture. Use NAN for reserved values
			 *			 1	Reserved (Set to 0)
			 *			 2	Duration between two consecutive pictures (in seconds)
			 *			 3	Number of images to capture total - 0 for unlimited capture
			 *			 4	Reserved (all remaining params) */
			MAV_CMD_IMAGE_START_CAPTURE                = 2000,
			/**
			 *Stop image capture sequence Use NAN for reserved values.
			 *			 1	Reserved (Set to 0)
			 *			 2	Reserved (all remaining params) */
			MAV_CMD_IMAGE_STOP_CAPTURE                 = 2001,
			/**
			 *WIP: Re-request a CAMERA_IMAGE_CAPTURE packet. Use NAN for reserved values.
			 *			 1	Sequence number for missing CAMERA_IMAGE_CAPTURE packet
			 *			 2	Reserved (all remaining params) */
			MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE       = 2002,
			/**
			 *Enable or disable on-board camera triggering system.
			 *			 1	Trigger enable/disable (0 for disable, 1 for start), -1 to ignore
			 *			 2	1 to reset the trigger sequence, -1 or 0 to ignore
			 *			 3	1 to pause triggering, but without switching the camera off or retracting it. -1 to ignore */
			MAV_CMD_DO_TRIGGER_CONTROL                 = 2003,
			/**
			 *Starts video capture (recording). Use NAN for reserved values.
			 *			 1	Reserved (Set to 0)
			 *			 2	Frequency CAMERA_CAPTURE_STATUS messages should be sent while recording (0 for no messages, otherwise frequency in Hz)
			 *			 3	Reserved (all remaining params) */
			MAV_CMD_VIDEO_START_CAPTURE                = 2500,
			/**
			 *Stop the current video capture (recording). Use NAN for reserved values.
			 *			 1	Reserved (Set to 0)
			 *			 2	Reserved (all remaining params) */
			MAV_CMD_VIDEO_STOP_CAPTURE                 = 2501,
			/**
			 *WIP: Start video streaming
			 *			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
			 *			 2	Reserved */
			MAV_CMD_VIDEO_START_STREAMING              = 2502,
			/**
			 *WIP: Stop the current video streaming
			 *			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
			 *			 2	Reserved */
			MAV_CMD_VIDEO_STOP_STREAMING               = 2503,
			/**
			 *WIP: Request video stream information (VIDEO_STREAM_INFORMATION)
			 *			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
			 *			 2	0: No Action 1: Request video stream information
			 *			 3	Reserved (all remaining params) */
			MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION   = 2504,
			/**
			 *Request to start streaming logging data over MAVLink (see also LOGGING_DATA message)
			 *			 1	Format: 0: ULog
			 *			 2	Reserved (set to 0)
			 *			 3	Reserved (set to 0)
			 *			 4	Reserved (set to 0)
			 *			 5	Reserved (set to 0)
			 *			 6	Reserved (set to 0)
			 *			 7	Reserved (set to 0) */
			MAV_CMD_LOGGING_START                      = 2510,
			/**
			 *Request to stop streaming log data over MAVLink
			 *			 1	Reserved (set to 0)
			 *			 2	Reserved (set to 0)
			 *			 3	Reserved (set to 0)
			 *			 4	Reserved (set to 0)
			 *			 5	Reserved (set to 0)
			 *			 6	Reserved (set to 0)
			 *			 7	Reserved (set to 0) */
			MAV_CMD_LOGGING_STOP                       = 2511,
			/**
			 *1	Landing gear ID (default: 0, -1 for all)
			 *			 2	Landing gear position (Down: 0, Up: 1, NAN for no change)
			 *			 3	Reserved, set to NAN
			 *			 4	Reserved, set to NAN
			 *			 5	Reserved, set to NAN
			 *			 6	Reserved, set to NAN
			 *			 7	Reserved, set to NAN */
			MAV_CMD_AIRFRAME_CONFIGURATION             = 2520,
			/**
			 *Create a panorama at the current position
			 *			 1	Viewing angle horizontal of the panorama (in degrees, +- 0.5 the total angle)
			 *			 2	Viewing angle vertical of panorama (in degrees)
			 *			 3	Speed of the horizontal rotation (in degrees per second)
			 *			 4	Speed of the vertical rotation (in degrees per second) */
			MAV_CMD_PANORAMA_CREATE                    = 2800,
			/**
			 *Request VTOL transition
			 *			 1	The target VTOL state, as defined by ENUM MAV_VTOL_STATE. Only MAV_VTOL_STATE_MC and MAV_VTOL_STATE_FW can be used. */
			MAV_CMD_DO_VTOL_TRANSITION                 = 3000,
			/**
			 *Request authorization to arm the vehicle to a external entity, the arm authorizer is resposible to request all data that is needs from the vehicle before authorize or deny the request. If approved the progress of command_ack message should be set with period of time that this authorization is valid in seconds or in case it was denied it should be set with one of the reasons in ARM_AUTH_DENIED_REASON.
			 *			 <p>
			 *			 1	Vehicle system id, this way ground station can request arm authorization on behalf of any vehicle */
			MAV_CMD_ARM_AUTHORIZATION_REQUEST          = 3001,
			/**
			 *This command sets the submode to standard guided when vehicle is in guided mode. The vehicle holds position and altitude and the user can input the desired velocites along all three axes. */
			MAV_CMD_SET_GUIDED_SUBMODE_STANDARD        = 4000,
			/**
			 *This command sets submode circle when vehicle is in guided mode. Vehicle flies along a circle facing the center of the circle. The user can input the velocity along the circle and change the radius. If no input is given the vehicle will hold position.
			 *			 <p>
			 *			 1	Radius of desired circle in CIRCLE_MODE
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	Unscaled target latitude of center of circle in CIRCLE_MODE
			 *			 6	Unscaled target longitude of center of circle in CIRCLE_MODE */
			MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE          = 4001,
			/**
			 *WIP: Delay mission state machine until gate has been reached.
			 *			 1	Geometry: 0: orthogonal to path between previous and next waypoint.
			 *			 2	Altitude: 0: ignore altitude
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude */
			MAV_CMD_CONDITION_GATE                     = 4501,
			/**
			 *Fence return point. There can only be one fence return point.
			 *			 <p>
			 *			 1	Reserved
			 *			 2	Reserved
			 *			 3	Reserved
			 *			 4	Reserved
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude */
			MAV_CMD_NAV_FENCE_RETURN_POINT             = 5000,
			/**
			 *Fence vertex for an inclusion polygon (the polygon must not be self-intersecting). The vehicle must stay within this area. Minimum of 3 vertices required.
			 *			 <p>
			 *			 1	Polygon vertex count
			 *			 2	Reserved
			 *			 3	Reserved
			 *			 4	Reserved
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Reserved */
			MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION = 5001,
			/**
			 *Fence vertex for an exclusion polygon (the polygon must not be self-intersecting). The vehicle must stay outside this area. Minimum of 3 vertices required.
			 *			 <p>
			 *			 1	Polygon vertex count
			 *			 2	Reserved
			 *			 3	Reserved
			 *			 4	Reserved
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Reserved */
			MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION = 5002,
			/**
			 *Circular fence area. The vehicle must stay inside this area.
			 *			 <p>
			 *			 1	radius in meters
			 *			 2	Reserved
			 *			 3	Reserved
			 *			 4	Reserved
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Reserved */
			MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION         = 5003,
			/**
			 *Circular fence area. The vehicle must stay outside this area.
			 *			 <p>
			 *			 1	radius in meters
			 *			 2	Reserved
			 *			 3	Reserved
			 *			 4	Reserved
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Reserved */
			MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION         = 5004,
			/**
			 *Rally point. You can have multiple rally points defined.
			 *			 <p>
			 *			 1	Reserved
			 *			 2	Reserved
			 *			 3	Reserved
			 *			 4	Reserved
			 *			 5	Latitude
			 *			 6	Longitude
			 *			 7	Altitude */
			MAV_CMD_NAV_RALLY_POINT                    = 5100,
			/**
			 *Commands the vehicle to respond with a sequence of messages UAVCAN_NODE_INFO, one message per every UAVCAN
			 *			 node that is online. Note that some of the response messages can be lost, which the receiver can detect
			 *			 easily by checking whether every received UAVCAN_NODE_STATUS has a matching message UAVCAN_NODE_INFO
			 *			 received earlier; if not, this command should be sent again in order to request re-transmission of the
			 *			 node information messages
			 *			 1	Reserved (set to 0)
			 *			 2	Reserved (set to 0)
			 *			 3	Reserved (set to 0)
			 *			 4	Reserved (set to 0)
			 *			 5	Reserved (set to 0)
			 *			 6	Reserved (set to 0)
			 *			 7	Reserved (set to 0) */
			MAV_CMD_UAVCAN_GET_NODE_INFO               = 5200,
			/**
			 *Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release
			 *			 position and velocity
			 *			 1	Operation mode. 0: prepare single payload deploy (overwriting previous requests), but do not execute it. 1: execute payload deploy immediately (rejecting further deploy commands during execution, but allowing abort). 2: add payload deploy to existing deployment list.
			 *			 2	Desired approach vector in degrees compass heading (0..360). A negative value indicates the system can define the approach vector at will.
			 *			 3	Desired ground speed at release time. This can be overriden by the airframe in case it needs to meet minimum airspeed. A negative value indicates the system can define the ground speed at will.
			 *			 4	Minimum altitude clearance to the release position in meters. A negative value indicates the system can define the clearance at will.
			 *			 5	Latitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT
			 *			 6	Longitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT
			 *			 7	Altitude, in meters AMSL */
			MAV_CMD_PAYLOAD_PREPARE_DEPLOY             = 30001,
			/**
			 *Control the payload deployment.
			 *			 1	Operation mode. 0: Abort deployment, continue normal mission. 1: switch to payload deploment mode. 100: delete first payload deployment request. 101: delete all payload deployment requests.
			 *			 2	Reserved
			 *			 3	Reserved
			 *			 4	Reserved
			 *			 5	Reserved
			 *			 6	Reserved
			 *			 7	Reserved */
			MAV_CMD_PAYLOAD_CONTROL_DEPLOY             = 30002,
			/**
			 *User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	Latitude unscaled
			 *			 6	Longitude unscaled
			 *			 7	Altitude, in meters AMSL */
			MAV_CMD_WAYPOINT_USER_1                    = 31000,
			/**
			 *User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	Latitude unscaled
			 *			 6	Longitude unscaled
			 *			 7	Altitude, in meters AMSL */
			MAV_CMD_WAYPOINT_USER_2                    = 31001,
			/**
			 *User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	Latitude unscaled
			 *			 6	Longitude unscaled
			 *			 7	Altitude, in meters AMSL */
			MAV_CMD_WAYPOINT_USER_3                    = 31002,
			/**
			 *User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	Latitude unscaled
			 *			 6	Longitude unscaled
			 *			 7	Altitude, in meters AMSL */
			MAV_CMD_WAYPOINT_USER_4                    = 31003,
			/**
			 *User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	Latitude unscaled
			 *			 6	Longitude unscaled
			 *			 7	Altitude, in meters AMSL */
			MAV_CMD_WAYPOINT_USER_5                    = 31004,
			/**
			 *User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
			 *			 ROI item
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	Latitude unscaled
			 *			 6	Longitude unscaled
			 *			 7	Altitude, in meters AMSL */
			MAV_CMD_SPATIAL_USER_1                     = 31005,
			/**
			 *User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
			 *			 ROI item
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	Latitude unscaled
			 *			 6	Longitude unscaled
			 *			 7	Altitude, in meters AMSL */
			MAV_CMD_SPATIAL_USER_2                     = 31006,
			/**
			 *User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
			 *			 ROI item
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	Latitude unscaled
			 *			 6	Longitude unscaled
			 *			 7	Altitude, in meters AMSL */
			MAV_CMD_SPATIAL_USER_3                     = 31007,
			/**
			 *User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
			 *			 ROI item
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	Latitude unscaled
			 *			 6	Longitude unscaled
			 *			 7	Altitude, in meters AMSL */
			MAV_CMD_SPATIAL_USER_4                     = 31008,
			/**
			 *User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
			 *			 ROI item
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	Latitude unscaled
			 *			 6	Longitude unscaled
			 *			 7	Altitude, in meters AMSL */
			MAV_CMD_SPATIAL_USER_5                     = 31009,
			/**
			 *User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
			 *			 item
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	User defined
			 *			 6	User defined
			 *			 7	User defined */
			MAV_CMD_USER_1                             = 31010,
			/**
			 *User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
			 *			 item
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	User defined
			 *			 6	User defined
			 *			 7	User defined */
			MAV_CMD_USER_2                             = 31011,
			/**
			 *User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
			 *			 item
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	User defined
			 *			 6	User defined
			 *			 7	User defined */
			MAV_CMD_USER_3                             = 31012,
			/**
			 *User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
			 *			 item
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	User defined
			 *			 6	User defined
			 *			 7	User defined */
			MAV_CMD_USER_4                             = 31013,
			/**
			 *User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
			 *			 item
			 *			 1	User defined
			 *			 2	User defined
			 *			 3	User defined
			 *			 4	User defined
			 *			 5	User defined
			 *			 6	User defined
			 *			 7	User defined */
			MAV_CMD_USER_5                             = 31014,
			/**
			 *A system wide power-off event has been initiated.
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_POWER_OFF_INITIATED                = 42000,
			/**
			 *FLY button has been clicked.
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_SOLO_BTN_FLY_CLICK                 = 42001,
			/**
			 *FLY button has been held for 1.5 seconds.
			 *			 1	Takeoff altitude
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_SOLO_BTN_FLY_HOLD                  = 42002,
			/**
			 *PAUSE button has been clicked.
			 *			 1	1 if Solo is in a shot mode, 0 otherwise
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_SOLO_BTN_PAUSE_CLICK               = 42003,
			/**
			 *Initiate a magnetometer calibration
			 *			 1	uint8_t bitmask of magnetometers (0 means all)
			 *			 2	Automatically retry on failure (0=no retry, 1=retry).
			 *			 3	Save without user input (0=require input, 1=autosave).
			 *			 4	Delay (seconds)
			 *			 5	Autoreboot (0=user reboot, 1=autoreboot)
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_START_MAG_CAL                   = 42424,
			/**
			 *Initiate a magnetometer calibration
			 *			 1	uint8_t bitmask of magnetometers (0 means all)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_ACCEPT_MAG_CAL                  = 42425,
			/**
			 *Cancel a running magnetometer calibration
			 *			 1	uint8_t bitmask of magnetometers (0 means all)
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_CANCEL_MAG_CAL                  = 42426,
			/**
			 *Command autopilot to get into factory test/diagnostic mode
			 *			 1	0 means get out of test mode, 1 means get into test mode
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_SET_FACTORY_TEST_MODE              = 42427,
			/**
			 *Reply with the version banner
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_DO_SEND_BANNER                     = 42428,
			/**
			 *Used when doing accelerometer calibration. When sent to the GCS tells it what position to put the vehicle
			 *			 in. When sent to the vehicle says what position the vehicle is in
			 *			 1	Position, one of the ACCELCAL_VEHICLE_POS enum values
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_ACCELCAL_VEHICLE_POS               = 42429,
			/**
			 *Causes the gimbal to reset and boot as if it was just powered on
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_GIMBAL_RESET                       = 42501,
			/**
			 *Reports progress and success or failure of gimbal axis calibration procedure
			 *			 1	Gimbal axis we're reporting calibration progress for
			 *			 2	Current calibration progress for this axis, 0x64=100%
			 *			 3	Status of the calibration
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS     = 42502,
			/**
			 *Starts commutation calibration on the gimbal
			 *			 1	Empty
			 *			 2	Empty
			 *			 3	Empty
			 *			 4	Empty
			 *			 5	Empty
			 *			 6	Empty
			 *			 7	Empty */
			MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION    = 42503,
			/**
			 *Erases gimbal application and parameters
			 *			 1	Magic number
			 *			 2	Magic number
			 *			 3	Magic number
			 *			 4	Magic number
			 *			 5	Magic number
			 *			 6	Magic number
			 *			 7	Magic number */
			MAV_CMD_GIMBAL_FULL_RESET                  = 42505
		}
		
		export namespace MAV_CMD_ {
			export function from(id: number): MAV_CMD {
				switch (id) {
					case 0:
						return MAV_CMD.MAV_CMD_NAV_WAYPOINT;
					case 1:
						return MAV_CMD.MAV_CMD_NAV_LOITER_UNLIM;
					case 2:
						return MAV_CMD.MAV_CMD_NAV_LOITER_TURNS;
					case 3:
						return MAV_CMD.MAV_CMD_NAV_LOITER_TIME;
					case 4:
						return MAV_CMD.MAV_CMD_NAV_RETURN_TO_LAUNCH;
					case 5:
						return MAV_CMD.MAV_CMD_NAV_LAND;
					case 6:
						return MAV_CMD.MAV_CMD_NAV_TAKEOFF;
					case 7:
						return MAV_CMD.MAV_CMD_NAV_LAND_LOCAL;
					case 8:
						return MAV_CMD.MAV_CMD_NAV_TAKEOFF_LOCAL;
					case 9:
						return MAV_CMD.MAV_CMD_NAV_FOLLOW;
					case 10:
						return MAV_CMD.MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT;
					case 11:
						return MAV_CMD.MAV_CMD_NAV_LOITER_TO_ALT;
					case 12:
						return MAV_CMD.MAV_CMD_DO_FOLLOW;
					case 13:
						return MAV_CMD.MAV_CMD_DO_FOLLOW_REPOSITION;
					case 14:
						return MAV_CMD.MAV_CMD_NAV_ROI;
					case 15:
						return MAV_CMD.MAV_CMD_NAV_PATHPLANNING;
					case 16:
						return MAV_CMD.MAV_CMD_NAV_SPLINE_WAYPOINT;
					case 17:
						return MAV_CMD.MAV_CMD_NAV_ALTITUDE_WAIT;
					case 18:
						return MAV_CMD.MAV_CMD_NAV_VTOL_TAKEOFF;
					case 19:
						return MAV_CMD.MAV_CMD_NAV_VTOL_LAND;
					case 20:
						return MAV_CMD.MAV_CMD_NAV_GUIDED_ENABLE;
					case 21:
						return MAV_CMD.MAV_CMD_NAV_DELAY;
					case 22:
						return MAV_CMD.MAV_CMD_NAV_PAYLOAD_PLACE;
					case 23:
						return MAV_CMD.MAV_CMD_NAV_LAST;
					case 24:
						return MAV_CMD.MAV_CMD_CONDITION_DELAY;
					case 25:
						return MAV_CMD.MAV_CMD_CONDITION_CHANGE_ALT;
					case 26:
						return MAV_CMD.MAV_CMD_CONDITION_DISTANCE;
					case 27:
						return MAV_CMD.MAV_CMD_CONDITION_YAW;
					case 28:
						return MAV_CMD.MAV_CMD_CONDITION_LAST;
					case 29:
						return MAV_CMD.MAV_CMD_DO_SET_MODE;
					case 30:
						return MAV_CMD.MAV_CMD_DO_JUMP;
					case 31:
						return MAV_CMD.MAV_CMD_DO_CHANGE_SPEED;
					case 32:
						return MAV_CMD.MAV_CMD_DO_SET_HOME;
					case 33:
						return MAV_CMD.MAV_CMD_DO_SET_PARAMETER;
					case 34:
						return MAV_CMD.MAV_CMD_DO_SET_RELAY;
					case 35:
						return MAV_CMD.MAV_CMD_DO_REPEAT_RELAY;
					case 36:
						return MAV_CMD.MAV_CMD_DO_SET_SERVO;
					case 37:
						return MAV_CMD.MAV_CMD_DO_REPEAT_SERVO;
					case 38:
						return MAV_CMD.MAV_CMD_DO_FLIGHTTERMINATION;
					case 39:
						return MAV_CMD.MAV_CMD_DO_CHANGE_ALTITUDE;
					case 40:
						return MAV_CMD.MAV_CMD_DO_LAND_START;
					case 41:
						return MAV_CMD.MAV_CMD_DO_RALLY_LAND;
					case 42:
						return MAV_CMD.MAV_CMD_DO_GO_AROUND;
					case 43:
						return MAV_CMD.MAV_CMD_DO_REPOSITION;
					case 44:
						return MAV_CMD.MAV_CMD_DO_PAUSE_CONTINUE;
					case 45:
						return MAV_CMD.MAV_CMD_DO_SET_REVERSE;
					case 46:
						return MAV_CMD.MAV_CMD_DO_CONTROL_VIDEO;
					case 47:
						return MAV_CMD.MAV_CMD_DO_SET_ROI;
					case 48:
						return MAV_CMD.MAV_CMD_DO_DIGICAM_CONFIGURE;
					case 49:
						return MAV_CMD.MAV_CMD_DO_DIGICAM_CONTROL;
					case 50:
						return MAV_CMD.MAV_CMD_DO_MOUNT_CONFIGURE;
					case 51:
						return MAV_CMD.MAV_CMD_DO_MOUNT_CONTROL;
					case 52:
						return MAV_CMD.MAV_CMD_DO_SET_CAM_TRIGG_DIST;
					case 53:
						return MAV_CMD.MAV_CMD_DO_FENCE_ENABLE;
					case 54:
						return MAV_CMD.MAV_CMD_DO_PARACHUTE;
					case 55:
						return MAV_CMD.MAV_CMD_DO_MOTOR_TEST;
					case 56:
						return MAV_CMD.MAV_CMD_DO_INVERTED_FLIGHT;
					case 57:
						return MAV_CMD.MAV_CMD_DO_GRIPPER;
					case 58:
						return MAV_CMD.MAV_CMD_DO_AUTOTUNE_ENABLE;
					case 59:
						return MAV_CMD.MAV_CMD_NAV_SET_YAW_SPEED;
					case 60:
						return MAV_CMD.MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL;
					case 61:
						return MAV_CMD.MAV_CMD_DO_MOUNT_CONTROL_QUAT;
					case 62:
						return MAV_CMD.MAV_CMD_DO_GUIDED_MASTER;
					case 63:
						return MAV_CMD.MAV_CMD_DO_GUIDED_LIMITS;
					case 64:
						return MAV_CMD.MAV_CMD_DO_ENGINE_CONTROL;
					case 65:
						return MAV_CMD.MAV_CMD_DO_LAST;
					case 66:
						return MAV_CMD.MAV_CMD_PREFLIGHT_CALIBRATION;
					case 67:
						return MAV_CMD.MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS;
					case 68:
						return MAV_CMD.MAV_CMD_PREFLIGHT_UAVCAN;
					case 69:
						return MAV_CMD.MAV_CMD_PREFLIGHT_STORAGE;
					case 70:
						return MAV_CMD.MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN;
					case 71:
						return MAV_CMD.MAV_CMD_OVERRIDE_GOTO;
					case 72:
						return MAV_CMD.MAV_CMD_MISSION_START;
					case 73:
						return MAV_CMD.MAV_CMD_COMPONENT_ARM_DISARM;
					case 74:
						return MAV_CMD.MAV_CMD_GET_HOME_POSITION;
					case 75:
						return MAV_CMD.MAV_CMD_START_RX_PAIR;
					case 76:
						return MAV_CMD.MAV_CMD_GET_MESSAGE_INTERVAL;
					case 77:
						return MAV_CMD.MAV_CMD_SET_MESSAGE_INTERVAL;
					case 78:
						return MAV_CMD.MAV_CMD_REQUEST_PROTOCOL_VERSION;
					case 79:
						return MAV_CMD.MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES;
					case 80:
						return MAV_CMD.MAV_CMD_REQUEST_CAMERA_INFORMATION;
					case 81:
						return MAV_CMD.MAV_CMD_REQUEST_CAMERA_SETTINGS;
					case 82:
						return MAV_CMD.MAV_CMD_REQUEST_STORAGE_INFORMATION;
					case 83:
						return MAV_CMD.MAV_CMD_STORAGE_FORMAT;
					case 84:
						return MAV_CMD.MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS;
					case 85:
						return MAV_CMD.MAV_CMD_REQUEST_FLIGHT_INFORMATION;
					case 86:
						return MAV_CMD.MAV_CMD_RESET_CAMERA_SETTINGS;
					case 87:
						return MAV_CMD.MAV_CMD_SET_CAMERA_MODE;
					case 88:
						return MAV_CMD.MAV_CMD_IMAGE_START_CAPTURE;
					case 89:
						return MAV_CMD.MAV_CMD_IMAGE_STOP_CAPTURE;
					case 90:
						return MAV_CMD.MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE;
					case 91:
						return MAV_CMD.MAV_CMD_DO_TRIGGER_CONTROL;
					case 92:
						return MAV_CMD.MAV_CMD_VIDEO_START_CAPTURE;
					case 93:
						return MAV_CMD.MAV_CMD_VIDEO_STOP_CAPTURE;
					case 94:
						return MAV_CMD.MAV_CMD_VIDEO_START_STREAMING;
					case 95:
						return MAV_CMD.MAV_CMD_VIDEO_STOP_STREAMING;
					case 96:
						return MAV_CMD.MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION;
					case 97:
						return MAV_CMD.MAV_CMD_LOGGING_START;
					case 98:
						return MAV_CMD.MAV_CMD_LOGGING_STOP;
					case 99:
						return MAV_CMD.MAV_CMD_AIRFRAME_CONFIGURATION;
					case 100:
						return MAV_CMD.MAV_CMD_PANORAMA_CREATE;
					case 101:
						return MAV_CMD.MAV_CMD_DO_VTOL_TRANSITION;
					case 102:
						return MAV_CMD.MAV_CMD_ARM_AUTHORIZATION_REQUEST;
					case 103:
						return MAV_CMD.MAV_CMD_SET_GUIDED_SUBMODE_STANDARD;
					case 104:
						return MAV_CMD.MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE;
					case 105:
						return MAV_CMD.MAV_CMD_CONDITION_GATE;
					case 106:
						return MAV_CMD.MAV_CMD_NAV_FENCE_RETURN_POINT;
					case 107:
						return MAV_CMD.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION;
					case 108:
						return MAV_CMD.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION;
					case 109:
						return MAV_CMD.MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION;
					case 110:
						return MAV_CMD.MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION;
					case 111:
						return MAV_CMD.MAV_CMD_NAV_RALLY_POINT;
					case 112:
						return MAV_CMD.MAV_CMD_UAVCAN_GET_NODE_INFO;
					case 113:
						return MAV_CMD.MAV_CMD_PAYLOAD_PREPARE_DEPLOY;
					case 114:
						return MAV_CMD.MAV_CMD_PAYLOAD_CONTROL_DEPLOY;
					case 115:
						return MAV_CMD.MAV_CMD_WAYPOINT_USER_1;
					case 116:
						return MAV_CMD.MAV_CMD_WAYPOINT_USER_2;
					case 117:
						return MAV_CMD.MAV_CMD_WAYPOINT_USER_3;
					case 118:
						return MAV_CMD.MAV_CMD_WAYPOINT_USER_4;
					case 119:
						return MAV_CMD.MAV_CMD_WAYPOINT_USER_5;
					case 120:
						return MAV_CMD.MAV_CMD_SPATIAL_USER_1;
					case 121:
						return MAV_CMD.MAV_CMD_SPATIAL_USER_2;
					case 122:
						return MAV_CMD.MAV_CMD_SPATIAL_USER_3;
					case 123:
						return MAV_CMD.MAV_CMD_SPATIAL_USER_4;
					case 124:
						return MAV_CMD.MAV_CMD_SPATIAL_USER_5;
					case 125:
						return MAV_CMD.MAV_CMD_USER_1;
					case 126:
						return MAV_CMD.MAV_CMD_USER_2;
					case 127:
						return MAV_CMD.MAV_CMD_USER_3;
					case 128:
						return MAV_CMD.MAV_CMD_USER_4;
					case 129:
						return MAV_CMD.MAV_CMD_USER_5;
					case 130:
						return MAV_CMD.MAV_CMD_POWER_OFF_INITIATED;
					case 131:
						return MAV_CMD.MAV_CMD_SOLO_BTN_FLY_CLICK;
					case 132:
						return MAV_CMD.MAV_CMD_SOLO_BTN_FLY_HOLD;
					case 133:
						return MAV_CMD.MAV_CMD_SOLO_BTN_PAUSE_CLICK;
					case 134:
						return MAV_CMD.MAV_CMD_DO_START_MAG_CAL;
					case 135:
						return MAV_CMD.MAV_CMD_DO_ACCEPT_MAG_CAL;
					case 136:
						return MAV_CMD.MAV_CMD_DO_CANCEL_MAG_CAL;
					case 137:
						return MAV_CMD.MAV_CMD_SET_FACTORY_TEST_MODE;
					case 138:
						return MAV_CMD.MAV_CMD_DO_SEND_BANNER;
					case 139:
						return MAV_CMD.MAV_CMD_ACCELCAL_VEHICLE_POS;
					case 140:
						return MAV_CMD.MAV_CMD_GIMBAL_RESET;
					case 141:
						return MAV_CMD.MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS;
					case 142:
						return MAV_CMD.MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION;
					case 143:
						return MAV_CMD.MAV_CMD_GIMBAL_FULL_RESET;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: MAV_CMD): number {
				switch (en) {
					case MAV_CMD.MAV_CMD_NAV_WAYPOINT:
						return 0;
					case MAV_CMD.MAV_CMD_NAV_LOITER_UNLIM:
						return 1;
					case MAV_CMD.MAV_CMD_NAV_LOITER_TURNS:
						return 2;
					case MAV_CMD.MAV_CMD_NAV_LOITER_TIME:
						return 3;
					case MAV_CMD.MAV_CMD_NAV_RETURN_TO_LAUNCH:
						return 4;
					case MAV_CMD.MAV_CMD_NAV_LAND:
						return 5;
					case MAV_CMD.MAV_CMD_NAV_TAKEOFF:
						return 6;
					case MAV_CMD.MAV_CMD_NAV_LAND_LOCAL:
						return 7;
					case MAV_CMD.MAV_CMD_NAV_TAKEOFF_LOCAL:
						return 8;
					case MAV_CMD.MAV_CMD_NAV_FOLLOW:
						return 9;
					case MAV_CMD.MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT:
						return 10;
					case MAV_CMD.MAV_CMD_NAV_LOITER_TO_ALT:
						return 11;
					case MAV_CMD.MAV_CMD_DO_FOLLOW:
						return 12;
					case MAV_CMD.MAV_CMD_DO_FOLLOW_REPOSITION:
						return 13;
					case MAV_CMD.MAV_CMD_NAV_ROI:
						return 14;
					case MAV_CMD.MAV_CMD_NAV_PATHPLANNING:
						return 15;
					case MAV_CMD.MAV_CMD_NAV_SPLINE_WAYPOINT:
						return 16;
					case MAV_CMD.MAV_CMD_NAV_ALTITUDE_WAIT:
						return 17;
					case MAV_CMD.MAV_CMD_NAV_VTOL_TAKEOFF:
						return 18;
					case MAV_CMD.MAV_CMD_NAV_VTOL_LAND:
						return 19;
					case MAV_CMD.MAV_CMD_NAV_GUIDED_ENABLE:
						return 20;
					case MAV_CMD.MAV_CMD_NAV_DELAY:
						return 21;
					case MAV_CMD.MAV_CMD_NAV_PAYLOAD_PLACE:
						return 22;
					case MAV_CMD.MAV_CMD_NAV_LAST:
						return 23;
					case MAV_CMD.MAV_CMD_CONDITION_DELAY:
						return 24;
					case MAV_CMD.MAV_CMD_CONDITION_CHANGE_ALT:
						return 25;
					case MAV_CMD.MAV_CMD_CONDITION_DISTANCE:
						return 26;
					case MAV_CMD.MAV_CMD_CONDITION_YAW:
						return 27;
					case MAV_CMD.MAV_CMD_CONDITION_LAST:
						return 28;
					case MAV_CMD.MAV_CMD_DO_SET_MODE:
						return 29;
					case MAV_CMD.MAV_CMD_DO_JUMP:
						return 30;
					case MAV_CMD.MAV_CMD_DO_CHANGE_SPEED:
						return 31;
					case MAV_CMD.MAV_CMD_DO_SET_HOME:
						return 32;
					case MAV_CMD.MAV_CMD_DO_SET_PARAMETER:
						return 33;
					case MAV_CMD.MAV_CMD_DO_SET_RELAY:
						return 34;
					case MAV_CMD.MAV_CMD_DO_REPEAT_RELAY:
						return 35;
					case MAV_CMD.MAV_CMD_DO_SET_SERVO:
						return 36;
					case MAV_CMD.MAV_CMD_DO_REPEAT_SERVO:
						return 37;
					case MAV_CMD.MAV_CMD_DO_FLIGHTTERMINATION:
						return 38;
					case MAV_CMD.MAV_CMD_DO_CHANGE_ALTITUDE:
						return 39;
					case MAV_CMD.MAV_CMD_DO_LAND_START:
						return 40;
					case MAV_CMD.MAV_CMD_DO_RALLY_LAND:
						return 41;
					case MAV_CMD.MAV_CMD_DO_GO_AROUND:
						return 42;
					case MAV_CMD.MAV_CMD_DO_REPOSITION:
						return 43;
					case MAV_CMD.MAV_CMD_DO_PAUSE_CONTINUE:
						return 44;
					case MAV_CMD.MAV_CMD_DO_SET_REVERSE:
						return 45;
					case MAV_CMD.MAV_CMD_DO_CONTROL_VIDEO:
						return 46;
					case MAV_CMD.MAV_CMD_DO_SET_ROI:
						return 47;
					case MAV_CMD.MAV_CMD_DO_DIGICAM_CONFIGURE:
						return 48;
					case MAV_CMD.MAV_CMD_DO_DIGICAM_CONTROL:
						return 49;
					case MAV_CMD.MAV_CMD_DO_MOUNT_CONFIGURE:
						return 50;
					case MAV_CMD.MAV_CMD_DO_MOUNT_CONTROL:
						return 51;
					case MAV_CMD.MAV_CMD_DO_SET_CAM_TRIGG_DIST:
						return 52;
					case MAV_CMD.MAV_CMD_DO_FENCE_ENABLE:
						return 53;
					case MAV_CMD.MAV_CMD_DO_PARACHUTE:
						return 54;
					case MAV_CMD.MAV_CMD_DO_MOTOR_TEST:
						return 55;
					case MAV_CMD.MAV_CMD_DO_INVERTED_FLIGHT:
						return 56;
					case MAV_CMD.MAV_CMD_DO_GRIPPER:
						return 57;
					case MAV_CMD.MAV_CMD_DO_AUTOTUNE_ENABLE:
						return 58;
					case MAV_CMD.MAV_CMD_NAV_SET_YAW_SPEED:
						return 59;
					case MAV_CMD.MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL:
						return 60;
					case MAV_CMD.MAV_CMD_DO_MOUNT_CONTROL_QUAT:
						return 61;
					case MAV_CMD.MAV_CMD_DO_GUIDED_MASTER:
						return 62;
					case MAV_CMD.MAV_CMD_DO_GUIDED_LIMITS:
						return 63;
					case MAV_CMD.MAV_CMD_DO_ENGINE_CONTROL:
						return 64;
					case MAV_CMD.MAV_CMD_DO_LAST:
						return 65;
					case MAV_CMD.MAV_CMD_PREFLIGHT_CALIBRATION:
						return 66;
					case MAV_CMD.MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS:
						return 67;
					case MAV_CMD.MAV_CMD_PREFLIGHT_UAVCAN:
						return 68;
					case MAV_CMD.MAV_CMD_PREFLIGHT_STORAGE:
						return 69;
					case MAV_CMD.MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN:
						return 70;
					case MAV_CMD.MAV_CMD_OVERRIDE_GOTO:
						return 71;
					case MAV_CMD.MAV_CMD_MISSION_START:
						return 72;
					case MAV_CMD.MAV_CMD_COMPONENT_ARM_DISARM:
						return 73;
					case MAV_CMD.MAV_CMD_GET_HOME_POSITION:
						return 74;
					case MAV_CMD.MAV_CMD_START_RX_PAIR:
						return 75;
					case MAV_CMD.MAV_CMD_GET_MESSAGE_INTERVAL:
						return 76;
					case MAV_CMD.MAV_CMD_SET_MESSAGE_INTERVAL:
						return 77;
					case MAV_CMD.MAV_CMD_REQUEST_PROTOCOL_VERSION:
						return 78;
					case MAV_CMD.MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES:
						return 79;
					case MAV_CMD.MAV_CMD_REQUEST_CAMERA_INFORMATION:
						return 80;
					case MAV_CMD.MAV_CMD_REQUEST_CAMERA_SETTINGS:
						return 81;
					case MAV_CMD.MAV_CMD_REQUEST_STORAGE_INFORMATION:
						return 82;
					case MAV_CMD.MAV_CMD_STORAGE_FORMAT:
						return 83;
					case MAV_CMD.MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS:
						return 84;
					case MAV_CMD.MAV_CMD_REQUEST_FLIGHT_INFORMATION:
						return 85;
					case MAV_CMD.MAV_CMD_RESET_CAMERA_SETTINGS:
						return 86;
					case MAV_CMD.MAV_CMD_SET_CAMERA_MODE:
						return 87;
					case MAV_CMD.MAV_CMD_IMAGE_START_CAPTURE:
						return 88;
					case MAV_CMD.MAV_CMD_IMAGE_STOP_CAPTURE:
						return 89;
					case MAV_CMD.MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE:
						return 90;
					case MAV_CMD.MAV_CMD_DO_TRIGGER_CONTROL:
						return 91;
					case MAV_CMD.MAV_CMD_VIDEO_START_CAPTURE:
						return 92;
					case MAV_CMD.MAV_CMD_VIDEO_STOP_CAPTURE:
						return 93;
					case MAV_CMD.MAV_CMD_VIDEO_START_STREAMING:
						return 94;
					case MAV_CMD.MAV_CMD_VIDEO_STOP_STREAMING:
						return 95;
					case MAV_CMD.MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION:
						return 96;
					case MAV_CMD.MAV_CMD_LOGGING_START:
						return 97;
					case MAV_CMD.MAV_CMD_LOGGING_STOP:
						return 98;
					case MAV_CMD.MAV_CMD_AIRFRAME_CONFIGURATION:
						return 99;
					case MAV_CMD.MAV_CMD_PANORAMA_CREATE:
						return 100;
					case MAV_CMD.MAV_CMD_DO_VTOL_TRANSITION:
						return 101;
					case MAV_CMD.MAV_CMD_ARM_AUTHORIZATION_REQUEST:
						return 102;
					case MAV_CMD.MAV_CMD_SET_GUIDED_SUBMODE_STANDARD:
						return 103;
					case MAV_CMD.MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE:
						return 104;
					case MAV_CMD.MAV_CMD_CONDITION_GATE:
						return 105;
					case MAV_CMD.MAV_CMD_NAV_FENCE_RETURN_POINT:
						return 106;
					case MAV_CMD.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION:
						return 107;
					case MAV_CMD.MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION:
						return 108;
					case MAV_CMD.MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION:
						return 109;
					case MAV_CMD.MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION:
						return 110;
					case MAV_CMD.MAV_CMD_NAV_RALLY_POINT:
						return 111;
					case MAV_CMD.MAV_CMD_UAVCAN_GET_NODE_INFO:
						return 112;
					case MAV_CMD.MAV_CMD_PAYLOAD_PREPARE_DEPLOY:
						return 113;
					case MAV_CMD.MAV_CMD_PAYLOAD_CONTROL_DEPLOY:
						return 114;
					case MAV_CMD.MAV_CMD_WAYPOINT_USER_1:
						return 115;
					case MAV_CMD.MAV_CMD_WAYPOINT_USER_2:
						return 116;
					case MAV_CMD.MAV_CMD_WAYPOINT_USER_3:
						return 117;
					case MAV_CMD.MAV_CMD_WAYPOINT_USER_4:
						return 118;
					case MAV_CMD.MAV_CMD_WAYPOINT_USER_5:
						return 119;
					case MAV_CMD.MAV_CMD_SPATIAL_USER_1:
						return 120;
					case MAV_CMD.MAV_CMD_SPATIAL_USER_2:
						return 121;
					case MAV_CMD.MAV_CMD_SPATIAL_USER_3:
						return 122;
					case MAV_CMD.MAV_CMD_SPATIAL_USER_4:
						return 123;
					case MAV_CMD.MAV_CMD_SPATIAL_USER_5:
						return 124;
					case MAV_CMD.MAV_CMD_USER_1:
						return 125;
					case MAV_CMD.MAV_CMD_USER_2:
						return 126;
					case MAV_CMD.MAV_CMD_USER_3:
						return 127;
					case MAV_CMD.MAV_CMD_USER_4:
						return 128;
					case MAV_CMD.MAV_CMD_USER_5:
						return 129;
					case MAV_CMD.MAV_CMD_POWER_OFF_INITIATED:
						return 130;
					case MAV_CMD.MAV_CMD_SOLO_BTN_FLY_CLICK:
						return 131;
					case MAV_CMD.MAV_CMD_SOLO_BTN_FLY_HOLD:
						return 132;
					case MAV_CMD.MAV_CMD_SOLO_BTN_PAUSE_CLICK:
						return 133;
					case MAV_CMD.MAV_CMD_DO_START_MAG_CAL:
						return 134;
					case MAV_CMD.MAV_CMD_DO_ACCEPT_MAG_CAL:
						return 135;
					case MAV_CMD.MAV_CMD_DO_CANCEL_MAG_CAL:
						return 136;
					case MAV_CMD.MAV_CMD_SET_FACTORY_TEST_MODE:
						return 137;
					case MAV_CMD.MAV_CMD_DO_SEND_BANNER:
						return 138;
					case MAV_CMD.MAV_CMD_ACCELCAL_VEHICLE_POS:
						return 139;
					case MAV_CMD.MAV_CMD_GIMBAL_RESET:
						return 140;
					case MAV_CMD.MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS:
						return 141;
					case MAV_CMD.MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION:
						return 142;
					case MAV_CMD.MAV_CMD_GIMBAL_FULL_RESET:
						return 143;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *Camera Modes. */
		
		export const enum CAMERA_MODE {
			
			CAMERA_MODE_IMAGE        = 0,//Camera is in image/photo capture mode.
			CAMERA_MODE_VIDEO        = 1,//Camera is in video capture mode.
			CAMERA_MODE_IMAGE_SURVEY = 2//Camera is in image survey capture mode. It allows for camera controller to do specific settings for surveys
		}
		
		/**
		 *Source of information about this collision. */
		
		export const enum MAV_COLLISION_SRC {
			
			MAV_COLLISION_SRC_ADSB                   = 0,//ID field references ADSB_VEHICLE packets
			MAV_COLLISION_SRC_MAVLINK_GPS_GLOBAL_INT = 1//ID field references MAVLink SRC ID
		}
		
		/**
		 *Possible remote log data block statuses */
		
		export const enum MAV_REMOTE_LOG_DATA_BLOCK_STATUSES {
			
			MAV_REMOTE_LOG_DATA_BLOCK_NACK = 0,//This block has NOT been received
			MAV_REMOTE_LOG_DATA_BLOCK_ACK  = 1//This block has been received
		}
		
		/**
		 *Status flags for ADS-B transponder dynamic output */
		
		export const enum UAVIONIX_ADSB_RF_HEALTH {
			
			UAVIONIX_ADSB_RF_HEALTH_INITIALIZING = 0,
			UAVIONIX_ADSB_RF_HEALTH_OK           = 1,
			UAVIONIX_ADSB_RF_HEALTH_FAIL_TX      = 2,
			UAVIONIX_ADSB_RF_HEALTH_FAIL_RX      = 16
		}
		
		export namespace UAVIONIX_ADSB_RF_HEALTH_ {
			export function from(id: number): UAVIONIX_ADSB_RF_HEALTH {
				switch (id) {
					case 0:
						return UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_INITIALIZING;
					case 1:
						return UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_OK;
					case 2:
						return UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_FAIL_TX;
					case 3:
						return UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_FAIL_RX;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: UAVIONIX_ADSB_RF_HEALTH): number {
				switch (en) {
					case UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_INITIALIZING:
						return 0;
					case UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_OK:
						return 1;
					case UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_FAIL_TX:
						return 2;
					case UAVIONIX_ADSB_RF_HEALTH.UAVIONIX_ADSB_RF_HEALTH_FAIL_RX:
						return 3;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *result from a mavlink command */
		
		export const enum MAV_RESULT {
			
			MAV_RESULT_ACCEPTED             = 0,//Command ACCEPTED and EXECUTED
			MAV_RESULT_TEMPORARILY_REJECTED = 1,//Command TEMPORARY REJECTED/DENIED
			MAV_RESULT_DENIED               = 2,//Command PERMANENTLY DENIED
			MAV_RESULT_UNSUPPORTED          = 3,//Command UNKNOWN/UNSUPPORTED
			MAV_RESULT_FAILED               = 4,//Command executed, but failed
			MAV_RESULT_IN_PROGRESS          = 5//WIP: Command being executed
		}
		
		/**
		 *Special ACK block numbers control activation of dataflash log streaming */
		
		export const enum MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS {
			
			MAV_REMOTE_LOG_DATA_BLOCK_STOP  = 2147483645,//UAV to stop sending DataFlash blocks
			MAV_REMOTE_LOG_DATA_BLOCK_START = 2147483646//UAV to start sending DataFlash blocks
		}
		
		/**
		 *Status for ADS-B transponder dynamic input */
		
		export const enum UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX {
			
			UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_0 = 0,
			UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_1 = 1,
			UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_2D     = 2,
			UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_3D     = 3,
			UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_DGPS   = 4,
			UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_RTK    = 5
		}
		
		
		export const enum GOPRO_COMMAND {
			
			GOPRO_COMMAND_POWER                 = 0,//(Get/Set)
			GOPRO_COMMAND_CAPTURE_MODE          = 1,//(Get/Set)
			GOPRO_COMMAND_SHUTTER               = 2,//(___/Set)
			GOPRO_COMMAND_BATTERY               = 3,//(Get/___)
			GOPRO_COMMAND_MODEL                 = 4,//(Get/___)
			GOPRO_COMMAND_VIDEO_SETTINGS        = 5,//(Get/Set)
			GOPRO_COMMAND_LOW_LIGHT             = 6,//(Get/Set)
			GOPRO_COMMAND_PHOTO_RESOLUTION      = 7,//(Get/Set)
			GOPRO_COMMAND_PHOTO_BURST_RATE      = 8,//(Get/Set)
			GOPRO_COMMAND_PROTUNE               = 9,//(Get/Set)
			GOPRO_COMMAND_PROTUNE_WHITE_BALANCE = 10,//(Get/Set) Hero 3+ Only
			GOPRO_COMMAND_PROTUNE_COLOUR        = 11,//(Get/Set) Hero 3+ Only
			GOPRO_COMMAND_PROTUNE_GAIN          = 12,//(Get/Set) Hero 3+ Only
			GOPRO_COMMAND_PROTUNE_SHARPNESS     = 13,//(Get/Set) Hero 3+ Only
			GOPRO_COMMAND_PROTUNE_EXPOSURE      = 14,//(Get/Set) Hero 3+ Only
			GOPRO_COMMAND_TIME                  = 15,//(Get/Set)
			GOPRO_COMMAND_CHARGING              = 16//(Get/Set)
		}
		
		
		export const enum GOPRO_REQUEST_STATUS {
			
			GOPRO_REQUEST_SUCCESS = 0,//The write message with ID indicated succeeded
			GOPRO_REQUEST_FAILED  = 1//The write message with ID indicated failed
		}
		
		/**
		 *Definitions for aircraft size */
		
		export const enum UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE {
			
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_NO_DATA     = 0,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L15M_W23M   = 1,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25M_W28P5M = 2,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25_34M     = 3,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_33M     = 4,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_38M     = 5,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_39P5M   = 6,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_45M     = 7,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_45M     = 8,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_52M     = 9,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_59P5M   = 10,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_67M     = 11,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W72P5M  = 12,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W80M    = 13,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W80M    = 14,
			UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W90M    = 15
		}
		
		
		export const enum MAV_STATE {
			
			UNINIT             = 0,//Uninitialized system, state is unknown.
			ACTIVE             = 1,//System is active and might be already airborne. Motors are engaged.
			BOOT               = 2,//System is booting up.
			CALIBRATING        = 3,//System is calibrating and not flight-ready.
			CRITICAL           = 4,//System is in a non-normal flight mode. It can however still navigate.
			/**
			 *System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in
			 *			 mayday and going down */
			EMERGENCY          = 5,
			FLIGHT_TERMINATION = 6,//System is terminating itself.
			POWEROFF           = 7,//System just initialized its power-down sequence, will shut down now.
			STANDBY            = 8//System is grounded and on standby. It can be launched any time.
		}
		
		/**
		 *SERIAL_CONTROL flags (bitmask) */
		
		export const enum SERIAL_CONTROL_FLAG {
			
			SERIAL_CONTROL_FLAG_REPLY     = 1,//Set if this is a reply
			SERIAL_CONTROL_FLAG_RESPOND   = 2,//Set if the sender wants the receiver to send a response as another SERIAL_CONTROL message
			/**
			 *Set if access to the serial port should be removed from whatever driver is currently using it, giving
			 *			 exclusive access to the SERIAL_CONTROL protocol. The port can be handed back by sending a request without
			 *			 this flag se */
			SERIAL_CONTROL_FLAG_EXCLUSIVE = 4,
			SERIAL_CONTROL_FLAG_BLOCKING  = 8,//Block on writes to the serial port
			SERIAL_CONTROL_FLAG_MULTI     = 16//Send multiple replies until port is drained
		}
		
		export namespace SERIAL_CONTROL_FLAG_ {
			export function from(id: number): SERIAL_CONTROL_FLAG {
				switch (id) {
					case 0:
						return SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_REPLY;
					case 1:
						return SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_RESPOND;
					case 2:
						return SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_EXCLUSIVE;
					case 3:
						return SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_BLOCKING;
					case 4:
						return SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_MULTI;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: SERIAL_CONTROL_FLAG): number {
				switch (en) {
					case SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_REPLY:
						return 0;
					case SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_RESPOND:
						return 1;
					case SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_EXCLUSIVE:
						return 2;
					case SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_BLOCKING:
						return 3;
					case SERIAL_CONTROL_FLAG.SERIAL_CONTROL_FLAG_MULTI:
						return 4;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *Camera capability flags (Bitmap). */
		
		export const enum CAMERA_CAP_FLAGS {
			
			CAMERA_CAP_FLAGS_CAPTURE_VIDEO                   = 1,//Camera is able to record video.
			CAMERA_CAP_FLAGS_CAPTURE_IMAGE                   = 2,//Camera is able to capture images.
			CAMERA_CAP_FLAGS_HAS_MODES                       = 4,//Camera has separate Video and Image/Photo modes (MAV_CMD_SET_CAMERA_MODE)
			CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE = 8,//Camera can capture images while in video mode
			CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE = 16,//Camera can capture videos while in Photo/Image mode
			CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE           = 32//Camera has image survey mode (MAV_CMD_SET_CAMERA_MODE)
		}
		
		export namespace CAMERA_CAP_FLAGS_ {
			export function from(id: number): CAMERA_CAP_FLAGS {
				switch (id) {
					case 0:
						return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAPTURE_VIDEO;
					case 1:
						return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAPTURE_IMAGE;
					case 2:
						return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_HAS_MODES;
					case 3:
						return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE;
					case 4:
						return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE;
					case 5:
						return CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: CAMERA_CAP_FLAGS): number {
				switch (en) {
					case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAPTURE_VIDEO:
						return 0;
					case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAPTURE_IMAGE:
						return 1;
					case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_HAS_MODES:
						return 2;
					case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE:
						return 3;
					case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE:
						return 4;
					case CAMERA_CAP_FLAGS.CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE:
						return 5;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		
		export const enum GOPRO_HEARTBEAT_FLAGS {
			
			GOPRO_FLAG_RECORDING = 1//GoPro is currently recording
		}
		
		/**
		 *Bitmask of (optional) autopilot capabilities (64 bit). If a bit is set, the autopilot supports this capability */
		
		export const enum MAV_PROTOCOL_CAPABILITY {
			
			MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT                  = 1,//Autopilot supports MISSION float message type.
			MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT                    = 2,//Autopilot supports the new param float message type.
			MAV_PROTOCOL_CAPABILITY_MISSION_INT                    = 4,//Autopilot supports MISSION_INT scaled integer message type.
			MAV_PROTOCOL_CAPABILITY_COMMAND_INT                    = 8,//Autopilot supports COMMAND_INT scaled integer message type.
			MAV_PROTOCOL_CAPABILITY_PARAM_UNION                    = 16,//Autopilot supports the new param union message type.
			MAV_PROTOCOL_CAPABILITY_FTP                            = 32,//Autopilot supports the new FILE_TRANSFER_PROTOCOL message type.
			MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET            = 64,//Autopilot supports commanding attitude offboard.
			MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED  = 128,//Autopilot supports commanding position and velocity targets in local NED frame.
			MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT = 256,//Autopilot supports commanding position and velocity targets in global scaled integers.
			MAV_PROTOCOL_CAPABILITY_TERRAIN                        = 512,//Autopilot supports terrain protocol / data handling.
			MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET            = 1024,//Autopilot supports direct actuator control.
			MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION             = 2048,//Autopilot supports the flight termination command.
			MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION            = 4096,//Autopilot supports onboard compass calibration.
			MAV_PROTOCOL_CAPABILITY_MAVLINK2                       = 8192,//Autopilot supports mavlink version 2.
			MAV_PROTOCOL_CAPABILITY_MISSION_FENCE                  = 16384,//Autopilot supports mission fence protocol.
			MAV_PROTOCOL_CAPABILITY_MISSION_RALLY                  = 32768,//Autopilot supports mission rally point protocol.
			MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION             = 65536//Autopilot supports the flight information protocol.
		}
		
		export namespace MAV_PROTOCOL_CAPABILITY_ {
			export function from(id: number): MAV_PROTOCOL_CAPABILITY {
				switch (id) {
					case 0:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT;
					case 1:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT;
					case 2:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_INT;
					case 3:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_COMMAND_INT;
					case 4:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_PARAM_UNION;
					case 5:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FTP;
					case 6:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET;
					case 7:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED;
					case 8:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT;
					case 9:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_TERRAIN;
					case 10:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET;
					case 11:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION;
					case 12:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION;
					case 13:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MAVLINK2;
					case 14:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_FENCE;
					case 15:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_RALLY;
					case 16:
						return MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: MAV_PROTOCOL_CAPABILITY): number {
				switch (en) {
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT:
						return 0;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT:
						return 1;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_INT:
						return 2;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_COMMAND_INT:
						return 3;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_PARAM_UNION:
						return 4;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FTP:
						return 5;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET:
						return 6;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED:
						return 7;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT:
						return 8;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_TERRAIN:
						return 9;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET:
						return 10;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION:
						return 11;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION:
						return 12;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MAVLINK2:
						return 13;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_FENCE:
						return 14;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_MISSION_RALLY:
						return 15;
					case MAV_PROTOCOL_CAPABILITY.MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION:
						return 16;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		
		export const enum GOPRO_HEARTBEAT_STATUS {
			
			GOPRO_HEARTBEAT_STATUS_DISCONNECTED = 0,//No GoPro connected
			GOPRO_HEARTBEAT_STATUS_INCOMPATIBLE = 1,//The detected GoPro is not HeroBus compatible
			GOPRO_HEARTBEAT_STATUS_CONNECTED    = 2,//A HeroBus compatible GoPro is connected
			GOPRO_HEARTBEAT_STATUS_ERROR        = 3//An unrecoverable error was encountered with the connected GoPro, it may require a power cycle
		}
		
		
		export const enum MAG_CAL_STATUS {
			
			MAG_CAL_NOT_STARTED      = 0,
			MAG_CAL_WAITING_TO_START = 1,
			MAG_CAL_RUNNING_STEP_ONE = 2,
			MAG_CAL_RUNNING_STEP_TWO = 3,
			MAG_CAL_SUCCESS          = 4,
			MAG_CAL_FAILED           = 5
		}
		
		
		export const enum CAMERA_STATUS_TYPES {
			
			CAMERA_STATUS_TYPE_HEARTBEAT  = 0,//Camera heartbeat, announce camera component ID at 1hz
			CAMERA_STATUS_TYPE_TRIGGER    = 1,//Camera image triggered
			CAMERA_STATUS_TYPE_DISCONNECT = 2,//Camera connection lost
			CAMERA_STATUS_TYPE_ERROR      = 3,//Camera unknown error
			CAMERA_STATUS_TYPE_LOWBATT    = 4,//Camera battery low. Parameter p1 shows reported voltage
			CAMERA_STATUS_TYPE_LOWSTORE   = 5,//Camera storage low. Parameter p1 shows reported shots remaining
			CAMERA_STATUS_TYPE_LOWSTOREV  = 6//Camera storage low. Parameter p1 shows reported video minutes remaining
		}
		
		/**
		 *SERIAL_CONTROL device types */
		
		export const enum SERIAL_CONTROL_DEV {
			
			SERIAL_CONTROL_DEV_TELEM1 = 0,//First telemetry port
			SERIAL_CONTROL_DEV_TELEM2 = 1,//Second telemetry port
			SERIAL_CONTROL_DEV_GPS1   = 2,//First GPS port
			SERIAL_CONTROL_DEV_GPS2   = 3,//Second GPS port
			SERIAL_CONTROL_DEV_SHELL  = 10//system shell
		}
		
		export namespace SERIAL_CONTROL_DEV_ {
			export function from(id: number): SERIAL_CONTROL_DEV {
				switch (id) {
					case 0:
						return SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_TELEM1;
					case 1:
						return SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_TELEM2;
					case 2:
						return SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_GPS1;
					case 3:
						return SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_GPS2;
					case 4:
						return SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_SHELL;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: SERIAL_CONTROL_DEV): number {
				switch (en) {
					case SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_TELEM1:
						return 0;
					case SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_TELEM2:
						return 1;
					case SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_GPS1:
						return 2;
					case SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_GPS2:
						return 3;
					case SERIAL_CONTROL_DEV.SERIAL_CONTROL_DEV_SHELL:
						return 4;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *result in a mavlink mission ack */
		
		export const enum MAV_MISSION_RESULT {
			
			MAV_MISSION_ACCEPTED          = 0,//mission accepted OK
			MAV_MISSION_ERROR             = 1,//generic error / not accepting mission commands at all right now
			MAV_MISSION_UNSUPPORTED_FRAME = 2,//coordinate frame is not supported
			MAV_MISSION_UNSUPPORTED       = 3,//command is not supported
			MAV_MISSION_NO_SPACE          = 4,//mission item exceeds storage space
			MAV_MISSION_INVALID           = 5,//one of the parameters has an invalid value
			MAV_MISSION_INVALID_PARAM1    = 6,//param1 has an invalid value
			MAV_MISSION_INVALID_PARAM2    = 7,//param2 has an invalid value
			MAV_MISSION_INVALID_PARAM3    = 8,//param3 has an invalid value
			MAV_MISSION_INVALID_PARAM4    = 9,//param4 has an invalid value
			MAV_MISSION_INVALID_PARAM5_X  = 10,//x/param5 has an invalid value
			MAV_MISSION_INVALID_PARAM6_Y  = 11,//y/param6 has an invalid value
			MAV_MISSION_INVALID_PARAM7    = 12,//param7 has an invalid value
			MAV_MISSION_INVALID_SEQUENCE  = 13,//received waypoint out of sequence
			MAV_MISSION_DENIED            = 14//not accepting any mission commands from this communication partner
		}
		
		/**
		 *Power supply status flags (bitmask) */
		
		export const enum MAV_POWER_STATUS {
			
			MAV_POWER_STATUS_BRICK_VALID                = 1,//main brick power supply valid
			MAV_POWER_STATUS_SERVO_VALID                = 2,//main servo power supply valid for FMU
			MAV_POWER_STATUS_USB_CONNECTED              = 4,//USB power is connected
			MAV_POWER_STATUS_PERIPH_OVERCURRENT         = 8,//peripheral supply is in over-current state
			MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT = 16,//hi-power peripheral supply is in over-current state
			MAV_POWER_STATUS_CHANGED                    = 32//Power status has changed since boot
		}
		
		export namespace MAV_POWER_STATUS_ {
			export function from(id: number): MAV_POWER_STATUS {
				switch (id) {
					case 0:
						return MAV_POWER_STATUS.MAV_POWER_STATUS_BRICK_VALID;
					case 1:
						return MAV_POWER_STATUS.MAV_POWER_STATUS_SERVO_VALID;
					case 2:
						return MAV_POWER_STATUS.MAV_POWER_STATUS_USB_CONNECTED;
					case 3:
						return MAV_POWER_STATUS.MAV_POWER_STATUS_PERIPH_OVERCURRENT;
					case 4:
						return MAV_POWER_STATUS.MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT;
					case 5:
						return MAV_POWER_STATUS.MAV_POWER_STATUS_CHANGED;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: MAV_POWER_STATUS): number {
				switch (en) {
					case MAV_POWER_STATUS.MAV_POWER_STATUS_BRICK_VALID:
						return 0;
					case MAV_POWER_STATUS.MAV_POWER_STATUS_SERVO_VALID:
						return 1;
					case MAV_POWER_STATUS.MAV_POWER_STATUS_USB_CONNECTED:
						return 2;
					case MAV_POWER_STATUS.MAV_POWER_STATUS_PERIPH_OVERCURRENT:
						return 3;
					case MAV_POWER_STATUS.MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT:
						return 4;
					case MAV_POWER_STATUS.MAV_POWER_STATUS_CHANGED:
						return 5;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *Generalized UAVCAN node mode */
		
		export const enum UAVCAN_NODE_MODE {
			
			UAVCAN_NODE_MODE_OPERATIONAL     = 0,//The node is performing its primary functions.
			UAVCAN_NODE_MODE_INITIALIZATION  = 1,//The node is initializing; this mode is entered immediately after startup.
			UAVCAN_NODE_MODE_MAINTENANCE     = 2,//The node is under maintenance.
			UAVCAN_NODE_MODE_SOFTWARE_UPDATE = 3,//The node is in the process of updating its software.
			UAVCAN_NODE_MODE_OFFLINE         = 7//The node is no longer available online.
		}
		
		export namespace UAVCAN_NODE_MODE_ {
			export function from(id: number): UAVCAN_NODE_MODE {
				switch (id) {
					case 0:
						return UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_OPERATIONAL;
					case 1:
						return UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_INITIALIZATION;
					case 2:
						return UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_MAINTENANCE;
					case 3:
						return UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_SOFTWARE_UPDATE;
					case 4:
						return UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_OFFLINE;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: UAVCAN_NODE_MODE): number {
				switch (en) {
					case UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_OPERATIONAL:
						return 0;
					case UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_INITIALIZATION:
						return 1;
					case UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_MAINTENANCE:
						return 2;
					case UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_SOFTWARE_UPDATE:
						return 3;
					case UAVCAN_NODE_MODE.UAVCAN_NODE_MODE_OFFLINE:
						return 4;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *These flags indicate status such as data validity of each data source. Set = data valid */
		
		export const enum ADSB_FLAGS {
			
			ADSB_FLAGS_VALID_COORDS   = 1,
			ADSB_FLAGS_VALID_ALTITUDE = 2,
			ADSB_FLAGS_VALID_HEADING  = 4,
			ADSB_FLAGS_VALID_VELOCITY = 8,
			ADSB_FLAGS_VALID_CALLSIGN = 16,
			ADSB_FLAGS_VALID_SQUAWK   = 32,
			ADSB_FLAGS_SIMULATED      = 64
		}
		
		export namespace ADSB_FLAGS_ {
			export function from(id: number): ADSB_FLAGS {
				switch (id) {
					case 0:
						return ADSB_FLAGS.ADSB_FLAGS_VALID_COORDS;
					case 1:
						return ADSB_FLAGS.ADSB_FLAGS_VALID_ALTITUDE;
					case 2:
						return ADSB_FLAGS.ADSB_FLAGS_VALID_HEADING;
					case 3:
						return ADSB_FLAGS.ADSB_FLAGS_VALID_VELOCITY;
					case 4:
						return ADSB_FLAGS.ADSB_FLAGS_VALID_CALLSIGN;
					case 5:
						return ADSB_FLAGS.ADSB_FLAGS_VALID_SQUAWK;
					case 6:
						return ADSB_FLAGS.ADSB_FLAGS_SIMULATED;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: ADSB_FLAGS): number {
				switch (en) {
					case ADSB_FLAGS.ADSB_FLAGS_VALID_COORDS:
						return 0;
					case ADSB_FLAGS.ADSB_FLAGS_VALID_ALTITUDE:
						return 1;
					case ADSB_FLAGS.ADSB_FLAGS_VALID_HEADING:
						return 2;
					case ADSB_FLAGS.ADSB_FLAGS_VALID_VELOCITY:
						return 3;
					case ADSB_FLAGS.ADSB_FLAGS_VALID_CALLSIGN:
						return 4;
					case ADSB_FLAGS.ADSB_FLAGS_VALID_SQUAWK:
						return 5;
					case ADSB_FLAGS.ADSB_FLAGS_SIMULATED:
						return 6;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *Result from a PARAM_EXT_SET message. */
		
		export const enum PARAM_ACK {
			
			PARAM_ACK_ACCEPTED          = 0,//Parameter value ACCEPTED and SET
			PARAM_ACK_VALUE_UNSUPPORTED = 1,//Parameter value UNKNOWN/UNSUPPORTED
			PARAM_ACK_FAILED            = 2,//Parameter failed to set
			/**
			 *Parameter value received but not yet validated or set. A subsequent PARAM_EXT_ACK will follow once operation
			 *			 is completed with the actual result. These are for parameters that may take longer to set. Instead of
			 *			 waiting for an ACK and potentially timing out, you will immediately receive this response to let you
			 *			 know it was received */
			PARAM_ACK_IN_PROGRESS       = 3
		}
		
		/**
		 *Enumeration of possible mount operation modes */
		
		export const enum MAV_MOUNT_MODE {
			
			MAV_MOUNT_MODE_RETRACT           = 0,//Load and keep safe position (Roll,Pitch,Yaw) from permant memory and stop stabilization
			MAV_MOUNT_MODE_NEUTRAL           = 1,//Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory.
			MAV_MOUNT_MODE_MAVLINK_TARGETING = 2,//Load neutral position and start MAVLink Roll,Pitch,Yaw control with stabilization
			MAV_MOUNT_MODE_RC_TARGETING      = 3,//Load neutral position and start RC Roll,Pitch,Yaw control with stabilization
			MAV_MOUNT_MODE_GPS_POINT         = 4//Load neutral position and start to point to Lat,Lon,Alt
		}
		
		/**
		 *Enumeration of sensor orientation, according to its rotations */
		
		export const enum MAV_SENSOR_ORIENTATION {
			
			NONE                       = 0,//Roll: 0, Pitch: 0, Yaw: 0
			YAW_45                     = 1,//Roll: 0, Pitch: 0, Yaw: 45
			YAW_90                     = 2,//Roll: 0, Pitch: 0, Yaw: 90
			YAW_135                    = 3,//Roll: 0, Pitch: 0, Yaw: 135
			YAW_180                    = 4,//Roll: 0, Pitch: 0, Yaw: 180
			YAW_225                    = 5,//Roll: 0, Pitch: 0, Yaw: 225
			YAW_270                    = 6,//Roll: 0, Pitch: 0, Yaw: 270
			YAW_315                    = 7,//Roll: 0, Pitch: 0, Yaw: 315
			ROLL_180                   = 8,//Roll: 180, Pitch: 0, Yaw: 0
			ROLL_180_YAW_45            = 9,//Roll: 180, Pitch: 0, Yaw: 45
			ROLL_180_YAW_90            = 10,//Roll: 180, Pitch: 0, Yaw: 90
			ROLL_180_YAW_135           = 11,//Roll: 180, Pitch: 0, Yaw: 135
			PITCH_180                  = 12,//Roll: 0, Pitch: 180, Yaw: 0
			ROLL_180_YAW_225           = 13,//Roll: 180, Pitch: 0, Yaw: 225
			ROLL_180_YAW_270           = 14,//Roll: 180, Pitch: 0, Yaw: 270
			ROLL_180_YAW_315           = 15,//Roll: 180, Pitch: 0, Yaw: 315
			ROLL_90                    = 16,//Roll: 90, Pitch: 0, Yaw: 0
			ROLL_90_YAW_45             = 17,//Roll: 90, Pitch: 0, Yaw: 45
			ROLL_90_YAW_90             = 18,//Roll: 90, Pitch: 0, Yaw: 90
			ROLL_90_YAW_135            = 19,//Roll: 90, Pitch: 0, Yaw: 135
			ROLL_270                   = 20,//Roll: 270, Pitch: 0, Yaw: 0
			ROLL_270_YAW_45            = 21,//Roll: 270, Pitch: 0, Yaw: 45
			ROLL_270_YAW_90            = 22,//Roll: 270, Pitch: 0, Yaw: 90
			ROLL_270_YAW_135           = 23,//Roll: 270, Pitch: 0, Yaw: 135
			PITCH_90                   = 24,//Roll: 0, Pitch: 90, Yaw: 0
			PITCH_270                  = 25,//Roll: 0, Pitch: 270, Yaw: 0
			PITCH_180_YAW_90           = 26,//Roll: 0, Pitch: 180, Yaw: 90
			PITCH_180_YAW_270          = 27,//Roll: 0, Pitch: 180, Yaw: 270
			ROLL_90_PITCH_90           = 28,//Roll: 90, Pitch: 90, Yaw: 0
			ROLL_180_PITCH_90          = 29,//Roll: 180, Pitch: 90, Yaw: 0
			ROLL_270_PITCH_90          = 30,//Roll: 270, Pitch: 90, Yaw: 0
			ROLL_90_PITCH_180          = 31,//Roll: 90, Pitch: 180, Yaw: 0
			ROLL_270_PITCH_180         = 32,//Roll: 270, Pitch: 180, Yaw: 0
			ROLL_90_PITCH_270          = 33,//Roll: 90, Pitch: 270, Yaw: 0
			ROLL_180_PITCH_270         = 34,//Roll: 180, Pitch: 270, Yaw: 0
			ROLL_270_PITCH_270         = 35,//Roll: 270, Pitch: 270, Yaw: 0
			ROLL_90_PITCH_180_YAW_90   = 36,//Roll: 90, Pitch: 180, Yaw: 90
			ROLL_90_YAW_270            = 37,//Roll: 90, Pitch: 0, Yaw: 270
			ROLL_315_PITCH_315_YAW_315 = 38//Roll: 315, Pitch: 315, Yaw: 315
		}
		
		/**
		 *State flags for ADS-B transponder dynamic report */
		
		export const enum UAVIONIX_ADSB_OUT_DYNAMIC_STATE {
			
			UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE        = 1,
			UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED    = 2,
			UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED = 4,
			UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND            = 8,
			UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT                = 16
		}
		
		export namespace UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ {
			export function from(id: number): UAVIONIX_ADSB_OUT_DYNAMIC_STATE {
				switch (id) {
					case 0:
						return UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE;
					case 1:
						return UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED;
					case 2:
						return UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED;
					case 3:
						return UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND;
					case 4:
						return UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: UAVIONIX_ADSB_OUT_DYNAMIC_STATE): number {
				switch (en) {
					case UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE:
						return 0;
					case UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED:
						return 1;
					case UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED:
						return 2;
					case UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND:
						return 3;
					case UAVIONIX_ADSB_OUT_DYNAMIC_STATE.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT:
						return 4;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *Possible actions an aircraft can take to avoid a collision. */
		
		export const enum MAV_COLLISION_ACTION {
			
			MAV_COLLISION_ACTION_NONE               = 0,//Ignore any potential collisions
			MAV_COLLISION_ACTION_REPORT             = 1,//Report potential collision
			MAV_COLLISION_ACTION_ASCEND_OR_DESCEND  = 2,//Ascend or Descend to avoid threat
			MAV_COLLISION_ACTION_MOVE_HORIZONTALLY  = 3,//Move horizontally to avoid threat
			MAV_COLLISION_ACTION_MOVE_PERPENDICULAR = 4,//Aircraft to move perpendicular to the collision's velocity vector
			MAV_COLLISION_ACTION_RTL                = 5,//Aircraft to fly directly back to its launch point
			MAV_COLLISION_ACTION_HOVER              = 6//Aircraft to stop in place
		}
		
		/**
		 *Aircraft-rated danger from this threat. */
		
		export const enum MAV_COLLISION_THREAT_LEVEL {
			
			MAV_COLLISION_THREAT_LEVEL_NONE = 0,//Not a threat
			MAV_COLLISION_THREAT_LEVEL_LOW  = 1,//Craft is mildly concerned about this threat
			MAV_COLLISION_THREAT_LEVEL_HIGH = 2//Craft is panicing, and may take actions to avoid threat
		}
		
		
		export const enum LIMITS_STATE {
			
			LIMITS_INIT       = 0,//pre-initialization
			LIMITS_DISABLED   = 1,//disabled
			LIMITS_ENABLED    = 2,//checking limits
			LIMITS_TRIGGERED  = 3,//a limit has been breached
			LIMITS_RECOVERING = 4,//taking action eg. RTL
			LIMITS_RECOVERED  = 5//we're no longer in breach of a limit
		}
		
		/**
		 *Transceiver RF control flags for ADS-B transponder dynamic reports */
		
		export const enum UAVIONIX_ADSB_OUT_RF_SELECT {
			
			UAVIONIX_ADSB_OUT_RF_SELECT_STANDBY    = 0,
			UAVIONIX_ADSB_OUT_RF_SELECT_RX_ENABLED = 1,
			UAVIONIX_ADSB_OUT_RF_SELECT_TX_ENABLED = 2
		}
		
		/**
		 *Enumeration of battery types */
		
		export const enum MAV_BATTERY_TYPE {
			
			UNKNOWN = 0,//Not specified.
			LIPO    = 1,//Lithium polymer battery
			LIFE    = 2,//Lithium-iron-phosphate battery
			LION    = 3,//Lithium-ION battery
			NIMH    = 4//Nickel metal hydride battery
		}
		
		/**
		 *Flags in EKF_STATUS message */
		
		export const enum EKF_STATUS_FLAGS {
			
			EKF_ATTITUDE           = 1,//set if EKF's attitude estimate is good
			EKF_VELOCITY_HORIZ     = 2,//set if EKF's horizontal velocity estimate is good
			EKF_VELOCITY_VERT      = 4,//set if EKF's vertical velocity estimate is good
			EKF_POS_HORIZ_REL      = 8,//set if EKF's horizontal position (relative) estimate is good
			EKF_POS_HORIZ_ABS      = 16,//set if EKF's horizontal position (absolute) estimate is good
			EKF_POS_VERT_ABS       = 32,//set if EKF's vertical position (absolute) estimate is good
			EKF_POS_VERT_AGL       = 64,//set if EKF's vertical position (above ground) estimate is good
			EKF_CONST_POS_MODE     = 128,//EKF is in constant position mode and does not know it's absolute or relative position
			EKF_PRED_POS_HORIZ_REL = 256,//set if EKF's predicted horizontal position (relative) estimate is good
			EKF_PRED_POS_HORIZ_ABS = 512//set if EKF's predicted horizontal position (absolute) estimate is good
		}
		
		export namespace EKF_STATUS_FLAGS_ {
			export function from(id: number): EKF_STATUS_FLAGS {
				switch (id) {
					case 0:
						return EKF_STATUS_FLAGS.EKF_ATTITUDE;
					case 1:
						return EKF_STATUS_FLAGS.EKF_VELOCITY_HORIZ;
					case 2:
						return EKF_STATUS_FLAGS.EKF_VELOCITY_VERT;
					case 3:
						return EKF_STATUS_FLAGS.EKF_POS_HORIZ_REL;
					case 4:
						return EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS;
					case 5:
						return EKF_STATUS_FLAGS.EKF_POS_VERT_ABS;
					case 6:
						return EKF_STATUS_FLAGS.EKF_POS_VERT_AGL;
					case 7:
						return EKF_STATUS_FLAGS.EKF_CONST_POS_MODE;
					case 8:
						return EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_REL;
					case 9:
						return EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_ABS;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: EKF_STATUS_FLAGS): number {
				switch (en) {
					case EKF_STATUS_FLAGS.EKF_ATTITUDE:
						return 0;
					case EKF_STATUS_FLAGS.EKF_VELOCITY_HORIZ:
						return 1;
					case EKF_STATUS_FLAGS.EKF_VELOCITY_VERT:
						return 2;
					case EKF_STATUS_FLAGS.EKF_POS_HORIZ_REL:
						return 3;
					case EKF_STATUS_FLAGS.EKF_POS_HORIZ_ABS:
						return 4;
					case EKF_STATUS_FLAGS.EKF_POS_VERT_ABS:
						return 5;
					case EKF_STATUS_FLAGS.EKF_POS_VERT_AGL:
						return 6;
					case EKF_STATUS_FLAGS.EKF_CONST_POS_MODE:
						return 7;
					case EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_REL:
						return 8;
					case EKF_STATUS_FLAGS.EKF_PRED_POS_HORIZ_ABS:
						return 9;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *These encode the sensors whose status is sent as part of the SYS_STATUS message. */
		
		export const enum MAV_SYS_STATUS_SENSOR {
			
			MAV_SYS_STATUS_SENSOR_3D_GYRO                = 1,//0x01 3D gyro
			MAV_SYS_STATUS_SENSOR_3D_ACCEL               = 2,//0x02 3D accelerometer
			MAV_SYS_STATUS_SENSOR_3D_MAG                 = 4,//0x04 3D magnetometer
			MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE      = 8,//0x08 absolute pressure
			MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE  = 16,//0x10 differential pressure
			MAV_SYS_STATUS_SENSOR_GPS                    = 32,//0x20 GPS
			MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW           = 64,//0x40 optical flow
			MAV_SYS_STATUS_SENSOR_VISION_POSITION        = 128,//0x80 computer vision position
			MAV_SYS_STATUS_SENSOR_LASER_POSITION         = 256,//0x100 laser based position
			MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH  = 512,//0x200 external ground truth (Vicon or Leica)
			MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL   = 1024,//0x400 3D angular rate control
			MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION = 2048,//0x800 attitude stabilization
			MAV_SYS_STATUS_SENSOR_YAW_POSITION           = 4096,//0x1000 yaw position
			MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL     = 8192,//0x2000 z/altitude control
			MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL    = 16384,//0x4000 x/y position control
			MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS          = 32768,//0x8000 motor outputs / control
			MAV_SYS_STATUS_SENSOR_RC_RECEIVER            = 65536,//0x10000 rc receiver
			MAV_SYS_STATUS_SENSOR_3D_GYRO2               = 131072,//0x20000 2nd 3D gyro
			MAV_SYS_STATUS_SENSOR_3D_ACCEL2              = 262144,//0x40000 2nd 3D accelerometer
			MAV_SYS_STATUS_SENSOR_3D_MAG2                = 524288,//0x80000 2nd 3D magnetometer
			MAV_SYS_STATUS_GEOFENCE                      = 1048576,//0x100000 geofence
			MAV_SYS_STATUS_AHRS                          = 2097152,//0x200000 AHRS subsystem health
			MAV_SYS_STATUS_TERRAIN                       = 4194304,//0x400000 Terrain subsystem health
			MAV_SYS_STATUS_REVERSE_MOTOR                 = 8388608,//0x800000 Motors are reversed
			MAV_SYS_STATUS_LOGGING                       = 16777216,//0x1000000 Logging
			MAV_SYS_STATUS_SENSOR_BATTERY                = 33554432//0x2000000 Battery
		}
		
		export namespace MAV_SYS_STATUS_SENSOR_ {
			export function from(id: number): MAV_SYS_STATUS_SENSOR {
				switch (id) {
					case 0:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_GYRO;
					case 1:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_ACCEL;
					case 2:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_MAG;
					case 3:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE;
					case 4:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE;
					case 5:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_GPS;
					case 6:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW;
					case 7:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_VISION_POSITION;
					case 8:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_LASER_POSITION;
					case 9:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH;
					case 10:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL;
					case 11:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION;
					case 12:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_YAW_POSITION;
					case 13:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL;
					case 14:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL;
					case 15:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS;
					case 16:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_RC_RECEIVER;
					case 17:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_GYRO2;
					case 18:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_ACCEL2;
					case 19:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_MAG2;
					case 20:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_GEOFENCE;
					case 21:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_AHRS;
					case 22:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_TERRAIN;
					case 23:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_REVERSE_MOTOR;
					case 24:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_LOGGING;
					case 25:
						return MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_BATTERY;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: MAV_SYS_STATUS_SENSOR): number {
				switch (en) {
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_GYRO:
						return 0;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_ACCEL:
						return 1;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_MAG:
						return 2;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE:
						return 3;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE:
						return 4;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_GPS:
						return 5;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW:
						return 6;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_VISION_POSITION:
						return 7;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_LASER_POSITION:
						return 8;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH:
						return 9;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL:
						return 10;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION:
						return 11;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_YAW_POSITION:
						return 12;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL:
						return 13;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL:
						return 14;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS:
						return 15;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_RC_RECEIVER:
						return 16;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_GYRO2:
						return 17;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_ACCEL2:
						return 18;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_3D_MAG2:
						return 19;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_GEOFENCE:
						return 20;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_AHRS:
						return 21;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_TERRAIN:
						return 22;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_REVERSE_MOTOR:
						return 23;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_LOGGING:
						return 24;
					case MAV_SYS_STATUS_SENSOR.MAV_SYS_STATUS_SENSOR_BATTERY:
						return 25;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		
		export const enum MAV_FRAME {
			
			/**
			 *Global coordinate frame, WGS84 coordinate system. First value / x: latitude, second value / y: longitude,
			 *					 third value / z: positive altitude over mean sea level (MSL */
			MAV_FRAME_GLOBAL                  = 0,
			MAV_FRAME_LOCAL_NED               = 1,//Local coordinate frame, Z-up (x: north, y: east, z: down).
			MAV_FRAME_MISSION                 = 2,//NOT a coordinate frame, indicates a mission command.
			/**
			 *Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home
			 *			 position. First value / x: latitude, second value / y: longitude, third value / z: positive altitude
			 *			 with 0 being at the altitude of the home location */
			MAV_FRAME_GLOBAL_RELATIVE_ALT     = 3,
			MAV_FRAME_LOCAL_ENU               = 4,//Local coordinate frame, Z-down (x: east, y: north, z: up)
			/**
			 *Global coordinate frame, WGS84 coordinate system. First value / x: latitude in degrees*1.0e-7, second
			 *			 value / y: longitude in degrees*1.0e-7, third value / z: positive altitude over mean sea level (MSL */
			MAV_FRAME_GLOBAL_INT              = 5,
			/**
			 *Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home
			 *			 position. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third
			 *			 value / z: positive altitude with 0 being at the altitude of the home location */
			MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6,
			/**
			 *Offset to the current local frame. Anything expressed in this frame should be added to the current local
			 *			 frame position */
			MAV_FRAME_LOCAL_OFFSET_NED        = 7,
			/**
			 *Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to
			 *			 command 2 m/s^2 acceleration to the right */
			MAV_FRAME_BODY_NED                = 8,
			/**
			 *Offset in body NED frame. This makes sense if adding setpoints to the current flight path, to avoid an
			 *			 obstacle - e.g. useful to command 2 m/s^2 acceleration to the east */
			MAV_FRAME_BODY_OFFSET_NED         = 9,
			/**
			 *Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude
			 *			 over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees, second value
			 *			 / y: longitude in degrees, third value / z: positive altitude in meters with 0 being at ground level
			 *			 in terrain model */
			MAV_FRAME_GLOBAL_TERRAIN_ALT      = 10,
			/**
			 *Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude
			 *			 over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees*10e-7, second
			 *			 value / y: longitude in degrees*10e-7, third value / z: positive altitude in meters with 0 being at ground
			 *			 level in terrain model */
			MAV_FRAME_GLOBAL_TERRAIN_ALT_INT  = 11
		}
		
		/**
		 *ADSB classification for the type of vehicle emitting the transponder signal */
		
		export const enum ADSB_EMITTER_TYPE {
			
			ADSB_EMITTER_TYPE_NO_INFO           = 0,
			ADSB_EMITTER_TYPE_LIGHT             = 1,
			ADSB_EMITTER_TYPE_SMALL             = 2,
			ADSB_EMITTER_TYPE_LARGE             = 3,
			ADSB_EMITTER_TYPE_HIGH_VORTEX_LARGE = 4,
			ADSB_EMITTER_TYPE_HEAVY             = 5,
			ADSB_EMITTER_TYPE_HIGHLY_MANUV      = 6,
			ADSB_EMITTER_TYPE_ROTOCRAFT         = 7,
			ADSB_EMITTER_TYPE_UNASSIGNED        = 8,
			ADSB_EMITTER_TYPE_GLIDER            = 9,
			ADSB_EMITTER_TYPE_LIGHTER_AIR       = 10,
			ADSB_EMITTER_TYPE_PARACHUTE         = 11,
			ADSB_EMITTER_TYPE_ULTRA_LIGHT       = 12,
			ADSB_EMITTER_TYPE_UNASSIGNED2       = 13,
			ADSB_EMITTER_TYPE_UAV               = 14,
			ADSB_EMITTER_TYPE_SPACE             = 15,
			ADSB_EMITTER_TYPE_UNASSGINED3       = 16,
			ADSB_EMITTER_TYPE_EMERGENCY_SURFACE = 17,
			ADSB_EMITTER_TYPE_SERVICE_SURFACE   = 18,
			ADSB_EMITTER_TYPE_POINT_OBSTACLE    = 19
		}
		
		/**
		 *GPS lataral offset encoding */
		
		export const enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT {
			
			NO_DATA  = 0,
			LEFT_2M  = 1,
			LEFT_4M  = 2,
			LEFT_6M  = 3,
			RIGHT_0M = 4,
			RIGHT_2M = 5,
			RIGHT_4M = 6,
			RIGHT_6M = 7
		}
		
		/**
		 *GPS longitudinal offset encoding */
		
		export const enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON {
			
			UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_NO_DATA           = 0,
			UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_APPLIED_BY_SENSOR = 1
		}
		
		
		export const enum GPS_INPUT_IGNORE_FLAGS {
			
			GPS_INPUT_IGNORE_FLAG_ALT                 = 1,//ignore altitude field
			GPS_INPUT_IGNORE_FLAG_HDOP                = 2,//ignore hdop field
			GPS_INPUT_IGNORE_FLAG_VDOP                = 4,//ignore vdop field
			GPS_INPUT_IGNORE_FLAG_VEL_HORIZ           = 8,//ignore horizontal velocity field (vn and ve)
			GPS_INPUT_IGNORE_FLAG_VEL_VERT            = 16,//ignore vertical velocity field (vd)
			GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY      = 32,//ignore speed accuracy field
			GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY = 64,//ignore horizontal accuracy field
			GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY   = 128//ignore vertical accuracy field
		}
		
		export namespace GPS_INPUT_IGNORE_FLAGS_ {
			export function from(id: number): GPS_INPUT_IGNORE_FLAGS {
				switch (id) {
					case 0:
						return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_ALT;
					case 1:
						return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_HDOP;
					case 2:
						return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VDOP;
					case 3:
						return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VEL_HORIZ;
					case 4:
						return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VEL_VERT;
					case 5:
						return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY;
					case 6:
						return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY;
					case 7:
						return GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: GPS_INPUT_IGNORE_FLAGS): number {
				switch (en) {
					case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_ALT:
						return 0;
					case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_HDOP:
						return 1;
					case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VDOP:
						return 2;
					case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VEL_HORIZ:
						return 3;
					case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VEL_VERT:
						return 4;
					case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY:
						return 5;
					case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY:
						return 6;
					case GPS_INPUT_IGNORE_FLAGS.GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY:
						return 7;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *Flags in RALLY_POINT message */
		
		export const enum RALLY_FLAGS {
			
			FAVORABLE_WIND   = 1,//Flag set when requiring favorable winds for landing.
			/**
			 *Flag set when plane is to immediately descend to break altitude and land without GCS intervention. Flag
			 *			 not set when plane is to loiter at Rally point until commanded to land */
			LAND_IMMEDIATELY = 2
		}
		
		
		export const enum FENCE_BREACH {
			
			FENCE_BREACH_NONE     = 0,//No last fence breach
			FENCE_BREACH_MINALT   = 1,//Breached minimum altitude
			FENCE_BREACH_MAXALT   = 2,//Breached maximum altitude
			FENCE_BREACH_BOUNDARY = 3//Breached fence boundary
		}
		
		/**
		 *These flags encode the MAV mode. */
		
		export const enum MAV_MODE_FLAG {
			
			MAV_MODE_FLAG_CUSTOM_MODE_ENABLED  = 1,//0b00000001 Reserved for future use.
			/**
			 *0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should
			 *			 not be used for stable implementations */
			MAV_MODE_FLAG_TEST_ENABLED         = 2,
			/**
			 *0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not,
			 *			 depends on the actual implementation */
			MAV_MODE_FLAG_AUTO_ENABLED         = 4,
			MAV_MODE_FLAG_GUIDED_ENABLED       = 8,//0b00001000 guided mode enabled, system flies waypoints / mission items.
			/**
			 *0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further
			 *			 control inputs to move around */
			MAV_MODE_FLAG_STABILIZE_ENABLED    = 16,
			/**
			 *0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software
			 *			 is full operational */
			MAV_MODE_FLAG_HIL_ENABLED          = 32,
			MAV_MODE_FLAG_MANUAL_INPUT_ENABLED = 64,//0b01000000 remote control input is enabled.
			/**
			 *0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. Additional
			 *					 note: this flag is to be ignore when sent in the command MAV_CMD_DO_SET_MODE and MAV_CMD_COMPONENT_ARM_DISARM
			 *					 shall be used instead. The flag can still be used to report the armed state */
			MAV_MODE_FLAG_SAFETY_ARMED         = 128
		}
		
		export namespace MAV_MODE_FLAG_ {
			export function from(id: number): MAV_MODE_FLAG {
				switch (id) {
					case 0:
						return MAV_MODE_FLAG.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
					case 1:
						return MAV_MODE_FLAG.MAV_MODE_FLAG_TEST_ENABLED;
					case 2:
						return MAV_MODE_FLAG.MAV_MODE_FLAG_AUTO_ENABLED;
					case 3:
						return MAV_MODE_FLAG.MAV_MODE_FLAG_GUIDED_ENABLED;
					case 4:
						return MAV_MODE_FLAG.MAV_MODE_FLAG_STABILIZE_ENABLED;
					case 5:
						return MAV_MODE_FLAG.MAV_MODE_FLAG_HIL_ENABLED;
					case 6:
						return MAV_MODE_FLAG.MAV_MODE_FLAG_MANUAL_INPUT_ENABLED;
					case 7:
						return MAV_MODE_FLAG.MAV_MODE_FLAG_SAFETY_ARMED;
					
				}
				throw  new Error("Unknown enum ID ");
			}
			
			export function into(en: MAV_MODE_FLAG): number {
				switch (en) {
					case MAV_MODE_FLAG.MAV_MODE_FLAG_CUSTOM_MODE_ENABLED:
						return 0;
					case MAV_MODE_FLAG.MAV_MODE_FLAG_TEST_ENABLED:
						return 1;
					case MAV_MODE_FLAG.MAV_MODE_FLAG_AUTO_ENABLED:
						return 2;
					case MAV_MODE_FLAG.MAV_MODE_FLAG_GUIDED_ENABLED:
						return 3;
					case MAV_MODE_FLAG.MAV_MODE_FLAG_STABILIZE_ENABLED:
						return 4;
					case MAV_MODE_FLAG.MAV_MODE_FLAG_HIL_ENABLED:
						return 5;
					case MAV_MODE_FLAG.MAV_MODE_FLAG_MANUAL_INPUT_ENABLED:
						return 6;
					case MAV_MODE_FLAG.MAV_MODE_FLAG_SAFETY_ARMED:
						return 7;
					
					default:
						throw  new Error("Unknown enum " + en);
				}
			}
		}
		
		/**
		 *Bus types for device operations */
		
		export const enum DEVICE_OP_BUSTYPE {
			
			DEVICE_OP_BUSTYPE_I2C = 0,//I2C Device operation
			DEVICE_OP_BUSTYPE_SPI = 1//SPI Device operation
		}
		
		export interface ATTITUDE_TARGET {
			time_boot_ms(): number;
			
			type_mask(): number;
			
			q(): ATTITUDE_TARGET.q;
			
			body_roll_rate(): number;
			
			body_pitch_rate(): number;
			
			body_yaw_rate(): number;
			
			thrust(): number;
			
		}
		
		export namespace ATTITUDE_TARGET {
			
			export const meta_ = new _Pack.Meta(106, 0, 1, 0, 37, 296);
			
			
			export interface q extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace q {
				export class Field extends _Cursor.View implements q, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 5 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 5, other.data_.bytes.buffer, other.data_.origin + 5, _Host.ATTITUDE_TARGET.q.item_len) === 0;
						for (let i = 0; i < _Host.ATTITUDE_TARGET.q.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.ATTITUDE_TARGET.q.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			
			
			class Impl_ extends _Cursor.View implements ATTITUDE_TARGET {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public type_mask(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				
				public q(): ATTITUDE_TARGET.q {
					
					return this.data_.as_field(ATTITUDE_TARGET.q.field);
				}
				
				public body_roll_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 21, true);}
				
				
				public body_pitch_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 25, true);}
				
				
				public body_yaw_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 29, true);}
				
				
				public thrust(): number { return this.data_.bytes.getFloat32(this.data_.origin + 33, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				type_mask_(src: number);
				
				q_(src: _Host.ATTITUDE_TARGET.q);
				
				body_roll_rate_(src: number);
				
				body_pitch_rate_(src: number);
				
				body_yaw_rate_(src: number);
				
				thrust_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: ATTITUDE_TARGET, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.type_mask_(src.type_mask());
				dst.q_(src.q());
				
				dst.body_roll_rate_(src.body_roll_rate());
				
				dst.body_pitch_rate_(src.body_pitch_rate());
				
				dst.body_yaw_rate_(src.body_yaw_rate());
				
				dst.thrust_(src.thrust());
				
			}
			
		}
		
		export interface MISSION_COUNT {
			count(): number;
			
			target_system(): number;
			
			target_component(): number;
			
			mission_type(): MAV_MISSION_TYPE | null;
			
		}
		
		export namespace MISSION_COUNT {
			
			export const meta_ = new _Pack.Meta(50, 1, 0, 0, 5, 32, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements MISSION_COUNT {
				
				public count(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				
				public mission_type(): MAV_MISSION_TYPE | null {
					if (this.data_.field_bit != 32 && !this.data_.set_field(32, -1)) return null;
					
					return _Host.MAV_MISSION_TYPE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				count_(src: number);
				
				mission_type_(src: _Host.MAV_MISSION_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_COUNT, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.count_(src.count());
				
				{
					const item = src.mission_type();
					if (item !== null) dst.mission_type_(item);
					
				}
				
			}
			
		}
		
		export interface ADSB_VEHICLE {
			heading(): number;
			
			heading_(src: number);
			
			hor_velocity(): number;
			
			hor_velocity_(src: number);
			
			squawk(): number;
			
			squawk_(src: number);
			
			ICAO_address(): number;
			
			ICAO_address_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
			altitude(): number;
			
			altitude_(src: number);
			
			ver_velocity(): number;
			
			ver_velocity_(src: number);
			
			tslc(): number;
			
			tslc_(src: number);
			
			altitude_type(): ADSB_ALTITUDE_TYPE | null;
			
			altitude_type_(src: ADSB_ALTITUDE_TYPE);
			
			callsign(): _Cursor.UTF8 | null;
			
			callsign_(src: string | Uint8Array): _Cursor.UTF8;
			
			callsign$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
			emitter_type(): ADSB_EMITTER_TYPE | null;
			
			emitter_type_(src: ADSB_EMITTER_TYPE);
			
			flags(): ADSB_FLAGS | null;
			
			flags_(src: ADSB_FLAGS);
			
		}
		
		export namespace ADSB_VEHICLE {
			
			export const meta_ = new _Pack.Meta(78, 3, 1, 0, 26, 202, 2, 4);
			
			
			export namespace callsign {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements ADSB_VEHICLE {
				
				public heading(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public heading_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public hor_velocity(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public hor_velocity_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public squawk(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public squawk_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public ICAO_address(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public ICAO_address_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 14, true);}
				
				public lon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 14, src, true); }
				
				public altitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 18, true);}
				
				public altitude_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 18, src, true); }
				
				public ver_velocity(): number { return this.data_.bytes.getInt16(this.data_.origin + 22, true);}
				
				public ver_velocity_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 22, src, true); }
				
				public tslc(): number { return this.data_.bytes.getInt8(this.data_.origin + 24);}
				
				public tslc_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 24, src); }
				
				
				public altitude_type(): ADSB_ALTITUDE_TYPE | null {
					if (this.data_.field_bit != 202 && !this.data_.set_field(202, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 1);
				}
				
				
				public altitude_type_(src: ADSB_ALTITUDE_TYPE) {
					if (this.data_.field_bit != 202) this.data_.set_field(202, 0);
					
					_Lib.set_bits(src, 1, this.data_.bytes, this.data_.BIT);
				}
				
				
				callsign(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 203 && !this.data_.set_field(203, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				callsign_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -203 - 1);
					
					let len = Math.min(src.byteLength, _Host.ADSB_VEHICLE.callsign.item_len_max);
					this.data_.set_field(203, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				callsign$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.ADSB_VEHICLE.callsign.item_len_max)
					this.data_.set_field(203, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
				public emitter_type(): ADSB_EMITTER_TYPE | null {
					if (this.data_.field_bit != 204 && !this.data_.set_field(204, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 5);
				}
				
				
				public emitter_type_(src: ADSB_EMITTER_TYPE) {
					if (this.data_.field_bit != 204) this.data_.set_field(204, 0);
					
					_Lib.set_bits(src, 5, this.data_.bytes, this.data_.BIT);
				}
				
				
				public flags(): ADSB_FLAGS | null {
					if (this.data_.field_bit != 205 && !this.data_.set_field(205, -1)) return null;
					
					return _Host.ADSB_FLAGS_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
				public flags_(src: ADSB_FLAGS) {
					if (this.data_.field_bit != 205) this.data_.set_field(205, 0);
					
					_Lib.set_bits(_Host.ADSB_FLAGS_.into(src), 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				ICAO_address_(src: number);
				
				lat_(src: number);
				
				lon_(src: number);
				
				altitude_type_(src: _Host.ADSB_ALTITUDE_TYPE);
				
				altitude_(src: number);
				
				heading_(src: number);
				
				hor_velocity_(src: number);
				
				ver_velocity_(src: number);
				
				callsign_(src: _Cursor.UTF8);
				
				emitter_type_(src: _Host.ADSB_EMITTER_TYPE);
				
				tslc_(src: number);
				
				flags_(src: _Host.ADSB_FLAGS);
				
				squawk_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: ADSB_VEHICLE, dst: DST) {
				
				dst.ICAO_address_(src.ICAO_address());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				{
					const item = src.altitude_type();
					if (item !== null) dst.altitude_type_(item);
					
				}
				
				dst.altitude_(src.altitude());
				
				dst.heading_(src.heading());
				
				dst.hor_velocity_(src.hor_velocity());
				
				dst.ver_velocity_(src.ver_velocity());
				
				{
					const item = src.callsign();
					if (item !== null) dst.callsign_(item);
					
				}
				
				{
					const item = src.emitter_type();
					if (item !== null) dst.emitter_type_(item);
					
				}
				
				dst.tslc_(src.tslc());
				
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
				dst.squawk_(src.squawk());
				
			}
			
			export interface SRC_ {
				ICAO_address(): number;
				
				lat(): number;
				
				lon(): number;
				
				altitude_type(): _Host.ADSB_ALTITUDE_TYPE | null;
				
				altitude(): number;
				
				heading(): number;
				
				hor_velocity(): number;
				
				ver_velocity(): number;
				
				callsign(): string | Uint8Array | null;
				
				emitter_type(): _Host.ADSB_EMITTER_TYPE | null;
				
				tslc(): number;
				
				flags(): _Host.ADSB_FLAGS | null;
				
				squawk(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: ADSB_VEHICLE) {
				
				dst.ICAO_address_(src.ICAO_address());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				{
					const item = src.altitude_type();
					if (item !== null) dst.altitude_type_(item);
					
				}
				
				dst.altitude_(src.altitude());
				
				dst.heading_(src.heading());
				
				dst.hor_velocity_(src.hor_velocity());
				
				dst.ver_velocity_(src.ver_velocity());
				
				
				{
					const item = src.callsign();
					if (item !== null) dst.callsign_(item);
				}
				
				{
					const item = src.emitter_type();
					if (item !== null) dst.emitter_type_(item);
					
				}
				
				dst.tslc_(src.tslc());
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
				dst.squawk_(src.squawk());
				
			}
			
		}
		
		export interface MESSAGE_INTERVAL {
			message_id(): number;
			
			message_id_(src: number);
			
			interval_us(): number;
			
			interval_us_(src: number);
			
		}
		
		export namespace MESSAGE_INTERVAL {
			
			export const meta_ = new _Pack.Meta(41, 1, 0, 0, 6, 48);
			
			
			class Impl_ extends _Cursor.View implements MESSAGE_INTERVAL {
				
				public message_id(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public message_id_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public interval_us(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public interval_us_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				message_id_(src: number);
				
				interval_us_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MESSAGE_INTERVAL, dst: DST) {
				
				dst.message_id_(src.message_id());
				
				dst.interval_us_(src.interval_us());
				
			}
			
			export interface SRC_ {
				message_id(): number;
				
				interval_us(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: MESSAGE_INTERVAL) {
				
				dst.message_id_(src.message_id());
				
				dst.interval_us_(src.interval_us());
				
			}
			
		}
		
		export interface EKF_STATUS_REPORT {
			velocity_variance(): number;
			
			velocity_variance_(src: number);
			
			pos_horiz_variance(): number;
			
			pos_horiz_variance_(src: number);
			
			pos_vert_variance(): number;
			
			pos_vert_variance_(src: number);
			
			compass_variance(): number;
			
			compass_variance_(src: number);
			
			terrain_alt_variance(): number;
			
			terrain_alt_variance_(src: number);
			
			flags(): EKF_STATUS_FLAGS | null;
			
			flags_(src: EKF_STATUS_FLAGS);
			
		}
		
		export namespace EKF_STATUS_REPORT {
			
			export const meta_ = new _Pack.Meta(96, 0, 0, 0, 21, 160, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements EKF_STATUS_REPORT {
				
				public velocity_variance(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public velocity_variance_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public pos_horiz_variance(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public pos_horiz_variance_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public pos_vert_variance(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public pos_vert_variance_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public compass_variance(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public compass_variance_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public terrain_alt_variance(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public terrain_alt_variance_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				
				public flags(): EKF_STATUS_FLAGS | null {
					if (this.data_.field_bit != 160 && !this.data_.set_field(160, -1)) return null;
					
					return _Host.EKF_STATUS_FLAGS_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 4));
				}
				
				
				public flags_(src: EKF_STATUS_FLAGS) {
					if (this.data_.field_bit != 160) this.data_.set_field(160, 0);
					
					_Lib.set_bits(_Host.EKF_STATUS_FLAGS_.into(src), 4, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				flags_(src: _Host.EKF_STATUS_FLAGS);
				
				velocity_variance_(src: number);
				
				pos_horiz_variance_(src: number);
				
				pos_vert_variance_(src: number);
				
				compass_variance_(src: number);
				
				terrain_alt_variance_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: EKF_STATUS_REPORT, dst: DST) {
				
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
				dst.velocity_variance_(src.velocity_variance());
				
				dst.pos_horiz_variance_(src.pos_horiz_variance());
				
				dst.pos_vert_variance_(src.pos_vert_variance());
				
				dst.compass_variance_(src.compass_variance());
				
				dst.terrain_alt_variance_(src.terrain_alt_variance());
				
			}
			
			export interface SRC_ {
				flags(): _Host.EKF_STATUS_FLAGS | null;
				
				velocity_variance(): number;
				
				pos_horiz_variance(): number;
				
				pos_vert_variance(): number;
				
				compass_variance(): number;
				
				terrain_alt_variance(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: EKF_STATUS_REPORT) {
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
				dst.velocity_variance_(src.velocity_variance());
				
				dst.pos_horiz_variance_(src.pos_horiz_variance());
				
				dst.pos_vert_variance_(src.pos_vert_variance());
				
				dst.compass_variance_(src.compass_variance());
				
				dst.terrain_alt_variance_(src.terrain_alt_variance());
				
			}
			
		}
		
		export interface ESTIMATOR_STATUS {
			time_usec(): number;
			
			time_usec_(src: number);
			
			vel_ratio(): number;
			
			vel_ratio_(src: number);
			
			pos_horiz_ratio(): number;
			
			pos_horiz_ratio_(src: number);
			
			pos_vert_ratio(): number;
			
			pos_vert_ratio_(src: number);
			
			mag_ratio(): number;
			
			mag_ratio_(src: number);
			
			hagl_ratio(): number;
			
			hagl_ratio_(src: number);
			
			tas_ratio(): number;
			
			tas_ratio_(src: number);
			
			pos_horiz_accuracy(): number;
			
			pos_horiz_accuracy_(src: number);
			
			pos_vert_accuracy(): number;
			
			pos_vert_accuracy_(src: number);
			
			flags(): ESTIMATOR_STATUS_FLAGS | null;
			
			flags_(src: ESTIMATOR_STATUS_FLAGS);
			
		}
		
		export namespace ESTIMATOR_STATUS {
			
			export const meta_ = new _Pack.Meta(38, 0, 0, 1, 41, 320, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements ESTIMATOR_STATUS {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public vel_ratio(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public vel_ratio_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public pos_horiz_ratio(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public pos_horiz_ratio_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public pos_vert_ratio(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public pos_vert_ratio_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public mag_ratio(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public mag_ratio_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public hagl_ratio(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public hagl_ratio_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public tas_ratio(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public tas_ratio_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public pos_horiz_accuracy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public pos_horiz_accuracy_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public pos_vert_accuracy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				public pos_vert_accuracy_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 36, src, true); }
				
				
				public flags(): ESTIMATOR_STATUS_FLAGS | null {
					if (this.data_.field_bit != 320 && !this.data_.set_field(320, -1)) return null;
					
					return _Host.ESTIMATOR_STATUS_FLAGS_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 4));
				}
				
				
				public flags_(src: ESTIMATOR_STATUS_FLAGS) {
					if (this.data_.field_bit != 320) this.data_.set_field(320, 0);
					
					_Lib.set_bits(_Host.ESTIMATOR_STATUS_FLAGS_.into(src), 4, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				flags_(src: _Host.ESTIMATOR_STATUS_FLAGS);
				
				vel_ratio_(src: number);
				
				pos_horiz_ratio_(src: number);
				
				pos_vert_ratio_(src: number);
				
				mag_ratio_(src: number);
				
				hagl_ratio_(src: number);
				
				tas_ratio_(src: number);
				
				pos_horiz_accuracy_(src: number);
				
				pos_vert_accuracy_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: ESTIMATOR_STATUS, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
				dst.vel_ratio_(src.vel_ratio());
				
				dst.pos_horiz_ratio_(src.pos_horiz_ratio());
				
				dst.pos_vert_ratio_(src.pos_vert_ratio());
				
				dst.mag_ratio_(src.mag_ratio());
				
				dst.hagl_ratio_(src.hagl_ratio());
				
				dst.tas_ratio_(src.tas_ratio());
				
				dst.pos_horiz_accuracy_(src.pos_horiz_accuracy());
				
				dst.pos_vert_accuracy_(src.pos_vert_accuracy());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				flags(): _Host.ESTIMATOR_STATUS_FLAGS | null;
				
				vel_ratio(): number;
				
				pos_horiz_ratio(): number;
				
				pos_vert_ratio(): number;
				
				mag_ratio(): number;
				
				hagl_ratio(): number;
				
				tas_ratio(): number;
				
				pos_horiz_accuracy(): number;
				
				pos_vert_accuracy(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: ESTIMATOR_STATUS) {
				
				dst.time_usec_(src.time_usec());
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
				dst.vel_ratio_(src.vel_ratio());
				
				dst.pos_horiz_ratio_(src.pos_horiz_ratio());
				
				dst.pos_vert_ratio_(src.pos_vert_ratio());
				
				dst.mag_ratio_(src.mag_ratio());
				
				dst.hagl_ratio_(src.hagl_ratio());
				
				dst.tas_ratio_(src.tas_ratio());
				
				dst.pos_horiz_accuracy_(src.pos_horiz_accuracy());
				
				dst.pos_vert_accuracy_(src.pos_vert_accuracy());
				
			}
			
		}
		
		export interface HWSTATUS {
			Vcc(): number;
			
			Vcc_(src: number);
			
			I2Cerr(): number;
			
			I2Cerr_(src: number);
			
		}
		
		export namespace HWSTATUS {
			
			export const meta_ = new _Pack.Meta(155, 1, 0, 0, 3, 24);
			
			
			class Impl_ extends _Cursor.View implements HWSTATUS {
				
				public Vcc(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public Vcc_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public I2Cerr(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public I2Cerr_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				Vcc_(src: number);
				
				I2Cerr_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HWSTATUS, dst: DST) {
				
				dst.Vcc_(src.Vcc());
				
				dst.I2Cerr_(src.I2Cerr());
				
			}
			
			export interface SRC_ {
				Vcc(): number;
				
				I2Cerr(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: HWSTATUS) {
				
				dst.Vcc_(src.Vcc());
				
				dst.I2Cerr_(src.I2Cerr());
				
			}
			
		}
		
		export interface TIMESYNC {
			tc1(): number;
			
			tc1_(src: number);
			
			ts1(): number;
			
			ts1_(src: number);
			
		}
		
		export namespace TIMESYNC {
			
			export const meta_ = new _Pack.Meta(46, 0, 0, 0, 16, 128);
			
			
			class Impl_ extends _Cursor.View implements TIMESYNC {
				
				public tc1(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public tc1_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public ts1(): number { return this.data_.bytes.getUint32(this.data_.origin + 8, true) + this.data_.bytes.getInt32(this.data_.origin + 8 + 4, true) * _Lib.JS_HI;}
				
				public ts1_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 8, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 8 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				tc1_(src: number);
				
				ts1_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: TIMESYNC, dst: DST) {
				
				dst.tc1_(src.tc1());
				
				dst.ts1_(src.ts1());
				
			}
			
			export interface SRC_ {
				tc1(): number;
				
				ts1(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: TIMESYNC) {
				
				dst.tc1_(src.tc1());
				
				dst.ts1_(src.ts1());
				
			}
			
		}
		
		export interface PARAM_EXT_REQUEST_LIST {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
		}
		
		export namespace PARAM_EXT_REQUEST_LIST {
			
			export const meta_ = new _Pack.Meta(80, 0, 0, 0, 2, 16);
			
			
			class Impl_ extends _Cursor.View implements PARAM_EXT_REQUEST_LIST {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: PARAM_EXT_REQUEST_LIST, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: PARAM_EXT_REQUEST_LIST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
			}
			
		}
		
		export interface GLOBAL_POSITION_INT_COV {
			time_usec(): number;
			
			lat(): number;
			
			lon(): number;
			
			alt(): number;
			
			relative_alt(): number;
			
			vx(): number;
			
			vy(): number;
			
			vz(): number;
			
			covariance(): GLOBAL_POSITION_INT_COV.covariance;
			
			estimator_type(): MAV_ESTIMATOR_TYPE | null;
			
		}
		
		export namespace GLOBAL_POSITION_INT_COV {
			
			export const meta_ = new _Pack.Meta(6, 0, 0, 1, 181, 1440, 0, 1);
			
			
			export interface covariance extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace covariance {
				export class Field extends _Cursor.View implements covariance, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 36 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 36, other.data_.bytes.buffer, other.data_.origin + 36, _Host.GLOBAL_POSITION_INT_COV.covariance.item_len) === 0;
						for (let i = 0; i < _Host.GLOBAL_POSITION_INT_COV.covariance.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.GLOBAL_POSITION_INT_COV.covariance.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 36;
				
			}
			
			
			class Impl_ extends _Cursor.View implements GLOBAL_POSITION_INT_COV {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 8, true);}
				
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 12, true);}
				
				
				public alt(): number { return this.data_.bytes.getInt32(this.data_.origin + 16, true);}
				
				
				public relative_alt(): number { return this.data_.bytes.getInt32(this.data_.origin + 20, true);}
				
				
				public vx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
				public vy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				
				public vz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				
				public covariance(): GLOBAL_POSITION_INT_COV.covariance {
					
					return this.data_.as_field(GLOBAL_POSITION_INT_COV.covariance.field);
				}
				
				
				public estimator_type(): MAV_ESTIMATOR_TYPE | null {
					if (this.data_.field_bit != 1440 && !this.data_.set_field(1440, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				estimator_type_(src: _Host.MAV_ESTIMATOR_TYPE);
				
				lat_(src: number);
				
				lon_(src: number);
				
				alt_(src: number);
				
				relative_alt_(src: number);
				
				vx_(src: number);
				
				vy_(src: number);
				
				vz_(src: number);
				
				covariance_(src: _Host.GLOBAL_POSITION_INT_COV.covariance);
				
			}
			
			export function push_<DST extends DST_>(src: GLOBAL_POSITION_INT_COV, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				{
					const item = src.estimator_type();
					if (item !== null) dst.estimator_type_(item);
					
				}
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.relative_alt_(src.relative_alt());
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				dst.covariance_(src.covariance());
				
			}
			
		}
		
		export interface BUTTON_CHANGE {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			last_change_ms(): number;
			
			last_change_ms_(src: number);
			
			state(): number;
			
			state_(src: number);
			
		}
		
		export namespace BUTTON_CHANGE {
			
			export const meta_ = new _Pack.Meta(146, 0, 2, 0, 9, 72);
			
			
			class Impl_ extends _Cursor.View implements BUTTON_CHANGE {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public last_change_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				public last_change_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 4, src, true); }
				
				public state(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public state_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				last_change_ms_(src: number);
				
				state_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: BUTTON_CHANGE, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.last_change_ms_(src.last_change_ms());
				
				dst.state_(src.state());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				last_change_ms(): number;
				
				state(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: BUTTON_CHANGE) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.last_change_ms_(src.last_change_ms());
				
				dst.state_(src.state());
				
			}
			
		}
		
		export interface SAFETY_SET_ALLOWED_AREA {
			target_system(): number;
			
			target_component(): number;
			
			p1x(): number;
			
			p1y(): number;
			
			p1z(): number;
			
			p2x(): number;
			
			p2y(): number;
			
			p2z(): number;
			
			frame(): MAV_FRAME | null;
			
		}
		
		export namespace SAFETY_SET_ALLOWED_AREA {
			
			export const meta_ = new _Pack.Meta(24, 0, 0, 0, 27, 208, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements SAFETY_SET_ALLOWED_AREA {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public p1x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 2, true);}
				
				
				public p1y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 6, true);}
				
				
				public p1z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 10, true);}
				
				
				public p2x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 14, true);}
				
				
				public p2y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 18, true);}
				
				
				public p2z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 22, true);}
				
				
				public frame(): MAV_FRAME | null {
					if (this.data_.field_bit != 208 && !this.data_.set_field(208, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				frame_(src: _Host.MAV_FRAME);
				
				p1x_(src: number);
				
				p1y_(src: number);
				
				p1z_(src: number);
				
				p2x_(src: number);
				
				p2y_(src: number);
				
				p2z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SAFETY_SET_ALLOWED_AREA, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.frame();
					if (item !== null) dst.frame_(item);
					
				}
				
				dst.p1x_(src.p1x());
				
				dst.p1y_(src.p1y());
				
				dst.p1z_(src.p1z());
				
				dst.p2x_(src.p2x());
				
				dst.p2y_(src.p2y());
				
				dst.p2z_(src.p2z());
				
			}
			
		}
		
		export interface UAVCAN_NODE_STATUS {
			vendor_specific_status_code(): number;
			
			vendor_specific_status_code_(src: number);
			
			uptime_sec(): number;
			
			uptime_sec_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			sub_mode(): number;
			
			sub_mode_(src: number);
			
			health(): UAVCAN_NODE_HEALTH | null;
			
			health_(src: UAVCAN_NODE_HEALTH);
			
			mode(): UAVCAN_NODE_MODE | null;
			
			mode_(src: UAVCAN_NODE_MODE);
			
		}
		
		export namespace UAVCAN_NODE_STATUS {
			
			export const meta_ = new _Pack.Meta(68, 1, 1, 1, 16, 120, 0, 2);
			
			
			class Impl_ extends _Cursor.View implements UAVCAN_NODE_STATUS {
				
				public vendor_specific_status_code(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public vendor_specific_status_code_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public uptime_sec(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public uptime_sec_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 6, true) + this.data_.bytes.getInt32(this.data_.origin + 6 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 6, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 6 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public sub_mode(): number { return this.data_.bytes.getInt8(this.data_.origin + 14);}
				
				public sub_mode_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 14, src); }
				
				
				public health(): UAVCAN_NODE_HEALTH | null {
					if (this.data_.field_bit != 120 && !this.data_.set_field(120, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 2);
				}
				
				
				public health_(src: UAVCAN_NODE_HEALTH) {
					if (this.data_.field_bit != 120) this.data_.set_field(120, 0);
					
					_Lib.set_bits(src, 2, this.data_.bytes, this.data_.BIT);
				}
				
				
				public mode(): UAVCAN_NODE_MODE | null {
					if (this.data_.field_bit != 121 && !this.data_.set_field(121, -1)) return null;
					
					return _Host.UAVCAN_NODE_MODE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
				public mode_(src: UAVCAN_NODE_MODE) {
					if (this.data_.field_bit != 121) this.data_.set_field(121, 0);
					
					_Lib.set_bits(_Host.UAVCAN_NODE_MODE_.into(src), 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				uptime_sec_(src: number);
				
				health_(src: _Host.UAVCAN_NODE_HEALTH);
				
				mode_(src: _Host.UAVCAN_NODE_MODE);
				
				sub_mode_(src: number);
				
				vendor_specific_status_code_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: UAVCAN_NODE_STATUS, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.uptime_sec_(src.uptime_sec());
				
				{
					const item = src.health();
					if (item !== null) dst.health_(item);
					
				}
				
				{
					const item = src.mode();
					if (item !== null) dst.mode_(item);
					
				}
				
				dst.sub_mode_(src.sub_mode());
				
				dst.vendor_specific_status_code_(src.vendor_specific_status_code());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				uptime_sec(): number;
				
				health(): _Host.UAVCAN_NODE_HEALTH | null;
				
				mode(): _Host.UAVCAN_NODE_MODE | null;
				
				sub_mode(): number;
				
				vendor_specific_status_code(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: UAVCAN_NODE_STATUS) {
				
				dst.time_usec_(src.time_usec());
				
				dst.uptime_sec_(src.uptime_sec());
				{
					const item = src.health();
					if (item !== null) dst.health_(item);
					
				}
				{
					const item = src.mode();
					if (item !== null) dst.mode_(item);
					
				}
				
				dst.sub_mode_(src.sub_mode());
				
				dst.vendor_specific_status_code_(src.vendor_specific_status_code());
				
			}
			
		}
		
		export interface COLLISION {
			id(): number;
			
			id_(src: number);
			
			time_to_minimum_delta(): number;
			
			time_to_minimum_delta_(src: number);
			
			altitude_minimum_delta(): number;
			
			altitude_minimum_delta_(src: number);
			
			horizontal_minimum_delta(): number;
			
			horizontal_minimum_delta_(src: number);
			
			sRc(): MAV_COLLISION_SRC | null;
			
			sRc_(src: MAV_COLLISION_SRC);
			
			action(): MAV_COLLISION_ACTION | null;
			
			action_(src: MAV_COLLISION_ACTION);
			
			threat_level(): MAV_COLLISION_THREAT_LEVEL | null;
			
			threat_level_(src: MAV_COLLISION_THREAT_LEVEL);
			
		}
		
		export namespace COLLISION {
			
			export const meta_ = new _Pack.Meta(45, 0, 1, 0, 17, 130, 2, 3);
			
			
			class Impl_ extends _Cursor.View implements COLLISION {
				
				public id(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public id_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public time_to_minimum_delta(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public time_to_minimum_delta_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public altitude_minimum_delta(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public altitude_minimum_delta_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public horizontal_minimum_delta(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public horizontal_minimum_delta_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				
				public sRc(): MAV_COLLISION_SRC | null {
					if (this.data_.field_bit != 130 && !this.data_.set_field(130, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 1);
				}
				
				
				public sRc_(src: MAV_COLLISION_SRC) {
					if (this.data_.field_bit != 130) this.data_.set_field(130, 0);
					
					_Lib.set_bits(src, 1, this.data_.bytes, this.data_.BIT);
				}
				
				
				public action(): MAV_COLLISION_ACTION | null {
					if (this.data_.field_bit != 131 && !this.data_.set_field(131, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public action_(src: MAV_COLLISION_ACTION) {
					if (this.data_.field_bit != 131) this.data_.set_field(131, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				public threat_level(): MAV_COLLISION_THREAT_LEVEL | null {
					if (this.data_.field_bit != 132 && !this.data_.set_field(132, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 2);
				}
				
				
				public threat_level_(src: MAV_COLLISION_THREAT_LEVEL) {
					if (this.data_.field_bit != 132) this.data_.set_field(132, 0);
					
					_Lib.set_bits(src, 2, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				sRc_(src: _Host.MAV_COLLISION_SRC);
				
				id_(src: number);
				
				action_(src: _Host.MAV_COLLISION_ACTION);
				
				threat_level_(src: _Host.MAV_COLLISION_THREAT_LEVEL);
				
				time_to_minimum_delta_(src: number);
				
				altitude_minimum_delta_(src: number);
				
				horizontal_minimum_delta_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: COLLISION, dst: DST) {
				
				{
					const item = src.sRc();
					if (item !== null) dst.sRc_(item);
					
				}
				
				dst.id_(src.id());
				
				{
					const item = src.action();
					if (item !== null) dst.action_(item);
					
				}
				
				{
					const item = src.threat_level();
					if (item !== null) dst.threat_level_(item);
					
				}
				
				dst.time_to_minimum_delta_(src.time_to_minimum_delta());
				
				dst.altitude_minimum_delta_(src.altitude_minimum_delta());
				
				dst.horizontal_minimum_delta_(src.horizontal_minimum_delta());
				
			}
			
			export interface SRC_ {
				sRc(): _Host.MAV_COLLISION_SRC | null;
				
				id(): number;
				
				action(): _Host.MAV_COLLISION_ACTION | null;
				
				threat_level(): _Host.MAV_COLLISION_THREAT_LEVEL | null;
				
				time_to_minimum_delta(): number;
				
				altitude_minimum_delta(): number;
				
				horizontal_minimum_delta(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: COLLISION) {
				{
					const item = src.sRc();
					if (item !== null) dst.sRc_(item);
					
				}
				
				dst.id_(src.id());
				{
					const item = src.action();
					if (item !== null) dst.action_(item);
					
				}
				{
					const item = src.threat_level();
					if (item !== null) dst.threat_level_(item);
					
				}
				
				dst.time_to_minimum_delta_(src.time_to_minimum_delta());
				
				dst.altitude_minimum_delta_(src.altitude_minimum_delta());
				
				dst.horizontal_minimum_delta_(src.horizontal_minimum_delta());
				
			}
			
		}
		
		export interface GIMBAL_TORQUE_CMD_REPORT {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			rl_torque_cmd(): number;
			
			rl_torque_cmd_(src: number);
			
			el_torque_cmd(): number;
			
			el_torque_cmd_(src: number);
			
			az_torque_cmd(): number;
			
			az_torque_cmd_(src: number);
			
		}
		
		export namespace GIMBAL_TORQUE_CMD_REPORT {
			
			export const meta_ = new _Pack.Meta(117, 0, 0, 0, 8, 64);
			
			
			class Impl_ extends _Cursor.View implements GIMBAL_TORQUE_CMD_REPORT {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public rl_torque_cmd(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public rl_torque_cmd_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public el_torque_cmd(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public el_torque_cmd_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public az_torque_cmd(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				public az_torque_cmd_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 6, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				rl_torque_cmd_(src: number);
				
				el_torque_cmd_(src: number);
				
				az_torque_cmd_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: GIMBAL_TORQUE_CMD_REPORT, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.rl_torque_cmd_(src.rl_torque_cmd());
				
				dst.el_torque_cmd_(src.el_torque_cmd());
				
				dst.az_torque_cmd_(src.az_torque_cmd());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				rl_torque_cmd(): number;
				
				el_torque_cmd(): number;
				
				az_torque_cmd(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GIMBAL_TORQUE_CMD_REPORT) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.rl_torque_cmd_(src.rl_torque_cmd());
				
				dst.el_torque_cmd_(src.el_torque_cmd());
				
				dst.az_torque_cmd_(src.az_torque_cmd());
				
			}
			
		}
		
		export interface ALTITUDE {
			time_usec(): number;
			
			time_usec_(src: number);
			
			altitude_monotonic(): number;
			
			altitude_monotonic_(src: number);
			
			altitude_amsl(): number;
			
			altitude_amsl_(src: number);
			
			altitude_local(): number;
			
			altitude_local_(src: number);
			
			altitude_relative(): number;
			
			altitude_relative_(src: number);
			
			altitude_terrain(): number;
			
			altitude_terrain_(src: number);
			
			bottom_clearance(): number;
			
			bottom_clearance_(src: number);
			
		}
		
		export namespace ALTITUDE {
			
			export const meta_ = new _Pack.Meta(34, 0, 0, 1, 32, 256);
			
			
			class Impl_ extends _Cursor.View implements ALTITUDE {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public altitude_monotonic(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public altitude_monotonic_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public altitude_amsl(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public altitude_amsl_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public altitude_local(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public altitude_local_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public altitude_relative(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public altitude_relative_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public altitude_terrain(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public altitude_terrain_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public bottom_clearance(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public bottom_clearance_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				altitude_monotonic_(src: number);
				
				altitude_amsl_(src: number);
				
				altitude_local_(src: number);
				
				altitude_relative_(src: number);
				
				altitude_terrain_(src: number);
				
				bottom_clearance_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: ALTITUDE, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.altitude_monotonic_(src.altitude_monotonic());
				
				dst.altitude_amsl_(src.altitude_amsl());
				
				dst.altitude_local_(src.altitude_local());
				
				dst.altitude_relative_(src.altitude_relative());
				
				dst.altitude_terrain_(src.altitude_terrain());
				
				dst.bottom_clearance_(src.bottom_clearance());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				altitude_monotonic(): number;
				
				altitude_amsl(): number;
				
				altitude_local(): number;
				
				altitude_relative(): number;
				
				altitude_terrain(): number;
				
				bottom_clearance(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: ALTITUDE) {
				
				dst.time_usec_(src.time_usec());
				
				dst.altitude_monotonic_(src.altitude_monotonic());
				
				dst.altitude_amsl_(src.altitude_amsl());
				
				dst.altitude_local_(src.altitude_local());
				
				dst.altitude_relative_(src.altitude_relative());
				
				dst.altitude_terrain_(src.altitude_terrain());
				
				dst.bottom_clearance_(src.bottom_clearance());
				
			}
			
		}
		
		export interface HIL_STATE_QUATERNION {
			ind_airspeed(): number;
			
			ind_airspeed_(src: number);
			
			true_airspeed(): number;
			
			true_airspeed_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			attitude_quaternion(): HIL_STATE_QUATERNION.attitude_quaternion;
			
			attitude_quaternion_(src: HIL_STATE_QUATERNION.attitude_quaternion | number[]);
			
			attitude_quaternion$(src: Iterator<number>, len: number);
			
			rollspeed(): number;
			
			rollspeed_(src: number);
			
			pitchspeed(): number;
			
			pitchspeed_(src: number);
			
			yawspeed(): number;
			
			yawspeed_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
			alt(): number;
			
			alt_(src: number);
			
			vx(): number;
			
			vx_(src: number);
			
			vy(): number;
			
			vy_(src: number);
			
			vz(): number;
			
			vz_(src: number);
			
			xacc(): number;
			
			xacc_(src: number);
			
			yacc(): number;
			
			yacc_(src: number);
			
			zacc(): number;
			
			zacc_(src: number);
			
		}
		
		export namespace HIL_STATE_QUATERNION {
			
			export const meta_ = new _Pack.Meta(196, 2, 0, 1, 64, 512);
			
			
			export interface attitude_quaternion extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace attitude_quaternion {
				export class Field extends _Cursor.View implements attitude_quaternion, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 12 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 12, other.data_.bytes.buffer, other.data_.origin + 12, _Host.HIL_STATE_QUATERNION.attitude_quaternion.item_len) === 0;
						for (let i = 0; i < _Host.HIL_STATE_QUATERNION.attitude_quaternion.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.HIL_STATE_QUATERNION.attitude_quaternion.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 12 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			
			
			class Impl_ extends _Cursor.View implements HIL_STATE_QUATERNION {
				
				public ind_airspeed(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public ind_airspeed_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public true_airspeed(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public true_airspeed_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 4, true) + this.data_.bytes.getInt32(this.data_.origin + 4 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 4, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 4 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public attitude_quaternion(): HIL_STATE_QUATERNION.attitude_quaternion {
					
					return this.data_.as_field(HIL_STATE_QUATERNION.attitude_quaternion.field);
				}
				
				public attitude_quaternion_(src: HIL_STATE_QUATERNION.attitude_quaternion | number[]): attitude_quaternion {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.HIL_STATE_QUATERNION.attitude_quaternion.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 12 + index * 4, src[index], true);
						return this.data_.as_field(attitude_quaternion.field);
					}
					for (let index = 0; index < _Host.HIL_STATE_QUATERNION.attitude_quaternion.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 12 + index * 4, src.get(index), true);
					
					return this.data_.as_field(attitude_quaternion.field);
				}
				
				public attitude_quaternion$(src: Iterator<number>, len: number): attitude_quaternion {
					let len_ = Math.min(len, _Host.HIL_STATE_QUATERNION.attitude_quaternion.item_len);
					
					len = Math.min(len, _Host.HIL_STATE_QUATERNION.attitude_quaternion.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 12 + index * 4, v.value, true);
						}
					return this.data_.as_field(attitude_quaternion.field);
				}
				
				public rollspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public rollspeed_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public pitchspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public pitchspeed_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public yawspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				public yawspeed_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 36, src, true); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 40, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 40, src, true); }
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 44, true);}
				
				public lon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 44, src, true); }
				
				public alt(): number { return this.data_.bytes.getInt32(this.data_.origin + 48, true);}
				
				public alt_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 48, src, true); }
				
				public vx(): number { return this.data_.bytes.getInt16(this.data_.origin + 52, true);}
				
				public vx_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 52, src, true); }
				
				public vy(): number { return this.data_.bytes.getInt16(this.data_.origin + 54, true);}
				
				public vy_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 54, src, true); }
				
				public vz(): number { return this.data_.bytes.getInt16(this.data_.origin + 56, true);}
				
				public vz_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 56, src, true); }
				
				public xacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 58, true);}
				
				public xacc_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 58, src, true); }
				
				public yacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 60, true);}
				
				public yacc_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 60, src, true); }
				
				public zacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 62, true);}
				
				public zacc_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 62, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				attitude_quaternion_(src: _Host.HIL_STATE_QUATERNION.attitude_quaternion);
				
				rollspeed_(src: number);
				
				pitchspeed_(src: number);
				
				yawspeed_(src: number);
				
				lat_(src: number);
				
				lon_(src: number);
				
				alt_(src: number);
				
				vx_(src: number);
				
				vy_(src: number);
				
				vz_(src: number);
				
				ind_airspeed_(src: number);
				
				true_airspeed_(src: number);
				
				xacc_(src: number);
				
				yacc_(src: number);
				
				zacc_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HIL_STATE_QUATERNION, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				dst.attitude_quaternion_(src.attitude_quaternion());
				
				dst.rollspeed_(src.rollspeed());
				
				dst.pitchspeed_(src.pitchspeed());
				
				dst.yawspeed_(src.yawspeed());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
				dst.ind_airspeed_(src.ind_airspeed());
				
				dst.true_airspeed_(src.true_airspeed());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				attitude_quaternion(dst: _Host.HIL_STATE_QUATERNION.attitude_quaternion);
				
				rollspeed(): number;
				
				pitchspeed(): number;
				
				yawspeed(): number;
				
				lat(): number;
				
				lon(): number;
				
				alt(): number;
				
				vx(): number;
				
				vy(): number;
				
				vz(): number;
				
				ind_airspeed(): number;
				
				true_airspeed(): number;
				
				xacc(): number;
				
				yacc(): number;
				
				zacc(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: HIL_STATE_QUATERNION) {
				
				dst.time_usec_(src.time_usec());
				src.attitude_quaternion(dst.attitude_quaternion());
				
				dst.rollspeed_(src.rollspeed());
				
				dst.pitchspeed_(src.pitchspeed());
				
				dst.yawspeed_(src.yawspeed());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
				dst.ind_airspeed_(src.ind_airspeed());
				
				dst.true_airspeed_(src.true_airspeed());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
			}
			
		}
		
		export interface SENSOR_OFFSETS {
			mag_ofs_x(): number;
			
			mag_ofs_x_(src: number);
			
			mag_ofs_y(): number;
			
			mag_ofs_y_(src: number);
			
			mag_ofs_z(): number;
			
			mag_ofs_z_(src: number);
			
			mag_declination(): number;
			
			mag_declination_(src: number);
			
			raw_press(): number;
			
			raw_press_(src: number);
			
			raw_temp(): number;
			
			raw_temp_(src: number);
			
			gyro_cal_x(): number;
			
			gyro_cal_x_(src: number);
			
			gyro_cal_y(): number;
			
			gyro_cal_y_(src: number);
			
			gyro_cal_z(): number;
			
			gyro_cal_z_(src: number);
			
			accel_cal_x(): number;
			
			accel_cal_x_(src: number);
			
			accel_cal_y(): number;
			
			accel_cal_y_(src: number);
			
			accel_cal_z(): number;
			
			accel_cal_z_(src: number);
			
		}
		
		export namespace SENSOR_OFFSETS {
			
			export const meta_ = new _Pack.Meta(128, 0, 0, 0, 42, 336);
			
			
			class Impl_ extends _Cursor.View implements SENSOR_OFFSETS {
				
				public mag_ofs_x(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public mag_ofs_x_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public mag_ofs_y(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public mag_ofs_y_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public mag_ofs_z(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public mag_ofs_z_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public mag_declination(): number { return this.data_.bytes.getFloat32(this.data_.origin + 6, true);}
				
				public mag_declination_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 6, src, true); }
				
				public raw_press(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public raw_press_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
				public raw_temp(): number { return this.data_.bytes.getInt32(this.data_.origin + 14, true);}
				
				public raw_temp_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 14, src, true); }
				
				public gyro_cal_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 18, true);}
				
				public gyro_cal_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 18, src, true); }
				
				public gyro_cal_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 22, true);}
				
				public gyro_cal_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 22, src, true); }
				
				public gyro_cal_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 26, true);}
				
				public gyro_cal_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 26, src, true); }
				
				public accel_cal_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 30, true);}
				
				public accel_cal_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 30, src, true); }
				
				public accel_cal_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 34, true);}
				
				public accel_cal_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 34, src, true); }
				
				public accel_cal_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 38, true);}
				
				public accel_cal_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 38, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				mag_ofs_x_(src: number);
				
				mag_ofs_y_(src: number);
				
				mag_ofs_z_(src: number);
				
				mag_declination_(src: number);
				
				raw_press_(src: number);
				
				raw_temp_(src: number);
				
				gyro_cal_x_(src: number);
				
				gyro_cal_y_(src: number);
				
				gyro_cal_z_(src: number);
				
				accel_cal_x_(src: number);
				
				accel_cal_y_(src: number);
				
				accel_cal_z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SENSOR_OFFSETS, dst: DST) {
				
				dst.mag_ofs_x_(src.mag_ofs_x());
				
				dst.mag_ofs_y_(src.mag_ofs_y());
				
				dst.mag_ofs_z_(src.mag_ofs_z());
				
				dst.mag_declination_(src.mag_declination());
				
				dst.raw_press_(src.raw_press());
				
				dst.raw_temp_(src.raw_temp());
				
				dst.gyro_cal_x_(src.gyro_cal_x());
				
				dst.gyro_cal_y_(src.gyro_cal_y());
				
				dst.gyro_cal_z_(src.gyro_cal_z());
				
				dst.accel_cal_x_(src.accel_cal_x());
				
				dst.accel_cal_y_(src.accel_cal_y());
				
				dst.accel_cal_z_(src.accel_cal_z());
				
			}
			
			export interface SRC_ {
				mag_ofs_x(): number;
				
				mag_ofs_y(): number;
				
				mag_ofs_z(): number;
				
				mag_declination(): number;
				
				raw_press(): number;
				
				raw_temp(): number;
				
				gyro_cal_x(): number;
				
				gyro_cal_y(): number;
				
				gyro_cal_z(): number;
				
				accel_cal_x(): number;
				
				accel_cal_y(): number;
				
				accel_cal_z(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SENSOR_OFFSETS) {
				
				dst.mag_ofs_x_(src.mag_ofs_x());
				
				dst.mag_ofs_y_(src.mag_ofs_y());
				
				dst.mag_ofs_z_(src.mag_ofs_z());
				
				dst.mag_declination_(src.mag_declination());
				
				dst.raw_press_(src.raw_press());
				
				dst.raw_temp_(src.raw_temp());
				
				dst.gyro_cal_x_(src.gyro_cal_x());
				
				dst.gyro_cal_y_(src.gyro_cal_y());
				
				dst.gyro_cal_z_(src.gyro_cal_z());
				
				dst.accel_cal_x_(src.accel_cal_x());
				
				dst.accel_cal_y_(src.accel_cal_y());
				
				dst.accel_cal_z_(src.accel_cal_z());
				
			}
			
		}
		
		export interface STORAGE_INFORMATION {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			storage_id(): number;
			
			storage_id_(src: number);
			
			storage_count(): number;
			
			storage_count_(src: number);
			
			status(): number;
			
			status_(src: number);
			
			total_capacity(): number;
			
			total_capacity_(src: number);
			
			used_capacity(): number;
			
			used_capacity_(src: number);
			
			available_capacity(): number;
			
			available_capacity_(src: number);
			
			read_speed(): number;
			
			read_speed_(src: number);
			
			write_speed(): number;
			
			write_speed_(src: number);
			
		}
		
		export namespace STORAGE_INFORMATION {
			
			export const meta_ = new _Pack.Meta(58, 0, 1, 0, 27, 216);
			
			
			class Impl_ extends _Cursor.View implements STORAGE_INFORMATION {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public storage_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public storage_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public storage_count(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public storage_count_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				public status(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				public status_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 6, src); }
				
				public total_capacity(): number { return this.data_.bytes.getFloat32(this.data_.origin + 7, true);}
				
				public total_capacity_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 7, src, true); }
				
				public used_capacity(): number { return this.data_.bytes.getFloat32(this.data_.origin + 11, true);}
				
				public used_capacity_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 11, src, true); }
				
				public available_capacity(): number { return this.data_.bytes.getFloat32(this.data_.origin + 15, true);}
				
				public available_capacity_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 15, src, true); }
				
				public read_speed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 19, true);}
				
				public read_speed_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 19, src, true); }
				
				public write_speed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 23, true);}
				
				public write_speed_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 23, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				storage_id_(src: number);
				
				storage_count_(src: number);
				
				status_(src: number);
				
				total_capacity_(src: number);
				
				used_capacity_(src: number);
				
				available_capacity_(src: number);
				
				read_speed_(src: number);
				
				write_speed_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: STORAGE_INFORMATION, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.storage_id_(src.storage_id());
				
				dst.storage_count_(src.storage_count());
				
				dst.status_(src.status());
				
				dst.total_capacity_(src.total_capacity());
				
				dst.used_capacity_(src.used_capacity());
				
				dst.available_capacity_(src.available_capacity());
				
				dst.read_speed_(src.read_speed());
				
				dst.write_speed_(src.write_speed());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				storage_id(): number;
				
				storage_count(): number;
				
				status(): number;
				
				total_capacity(): number;
				
				used_capacity(): number;
				
				available_capacity(): number;
				
				read_speed(): number;
				
				write_speed(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: STORAGE_INFORMATION) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.storage_id_(src.storage_id());
				
				dst.storage_count_(src.storage_count());
				
				dst.status_(src.status());
				
				dst.total_capacity_(src.total_capacity());
				
				dst.used_capacity_(src.used_capacity());
				
				dst.available_capacity_(src.available_capacity());
				
				dst.read_speed_(src.read_speed());
				
				dst.write_speed_(src.write_speed());
				
			}
			
		}
		
		export interface CAMERA_INFORMATION {
			resolution_h(): number;
			
			resolution_h_(src: number);
			
			resolution_v(): number;
			
			resolution_v_(src: number);
			
			cam_definition_version(): number;
			
			cam_definition_version_(src: number);
			
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			firmware_version(): number;
			
			firmware_version_(src: number);
			
			vendor_name(): CAMERA_INFORMATION.vendor_name;
			
			vendor_name_(src: CAMERA_INFORMATION.vendor_name | number[]);
			
			vendor_name$(src: Iterator<number>, len: number);
			
			model_name(): CAMERA_INFORMATION.model_name;
			
			model_name_(src: CAMERA_INFORMATION.model_name | number[]);
			
			model_name$(src: Iterator<number>, len: number);
			
			focal_length(): number;
			
			focal_length_(src: number);
			
			sensor_size_h(): number;
			
			sensor_size_h_(src: number);
			
			sensor_size_v(): number;
			
			sensor_size_v_(src: number);
			
			lens_id(): number;
			
			lens_id_(src: number);
			
			flags(): CAMERA_CAP_FLAGS | null;
			
			flags_(src: CAMERA_CAP_FLAGS);
			
			cam_definition_uri(): _Cursor.UTF8 | null;
			
			cam_definition_uri_(src: string | Uint8Array): _Cursor.UTF8;
			
			cam_definition_uri$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace CAMERA_INFORMATION {
			
			export const meta_ = new _Pack.Meta(157, 3, 2, 0, 92, 730, 2, 2);
			
			
			export interface vendor_name extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace vendor_name {
				export class Field extends _Cursor.View implements vendor_name, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 14 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 14, other.data_.bytes.buffer, other.data_.origin + 14, _Host.CAMERA_INFORMATION.vendor_name.item_len) === 0;
						for (let i = 0; i < _Host.CAMERA_INFORMATION.vendor_name.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.CAMERA_INFORMATION.vendor_name.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 14 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 32;
				
			}
			
			export interface model_name extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace model_name {
				export class Field extends _Cursor.View implements model_name, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 46 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 46, other.data_.bytes.buffer, other.data_.origin + 46, _Host.CAMERA_INFORMATION.model_name.item_len) === 0;
						for (let i = 0; i < _Host.CAMERA_INFORMATION.model_name.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.CAMERA_INFORMATION.model_name.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 46 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 32;
				
			}
			export namespace cam_definition_uri {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements CAMERA_INFORMATION {
				
				public resolution_h(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public resolution_h_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public resolution_v(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public resolution_v_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public cam_definition_version(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public cam_definition_version_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public firmware_version(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public firmware_version_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
				public vendor_name(): CAMERA_INFORMATION.vendor_name {
					
					return this.data_.as_field(CAMERA_INFORMATION.vendor_name.field);
				}
				
				public vendor_name_(src: CAMERA_INFORMATION.vendor_name | number[]): vendor_name {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.CAMERA_INFORMATION.vendor_name.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 14 + index, src[index]);
						return this.data_.as_field(vendor_name.field);
					}
					for (let index = 0; index < _Host.CAMERA_INFORMATION.vendor_name.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 14 + index, src.get(index));
					
					return this.data_.as_field(vendor_name.field);
				}
				
				public vendor_name$(src: Iterator<number>, len: number): vendor_name {
					let len_ = Math.min(len, _Host.CAMERA_INFORMATION.vendor_name.item_len);
					
					len = Math.min(len, _Host.CAMERA_INFORMATION.vendor_name.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 14 + index, v.value);
						}
					return this.data_.as_field(vendor_name.field);
				}
				
				public model_name(): CAMERA_INFORMATION.model_name {
					
					return this.data_.as_field(CAMERA_INFORMATION.model_name.field);
				}
				
				public model_name_(src: CAMERA_INFORMATION.model_name | number[]): model_name {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.CAMERA_INFORMATION.model_name.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 46 + index, src[index]);
						return this.data_.as_field(model_name.field);
					}
					for (let index = 0; index < _Host.CAMERA_INFORMATION.model_name.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 46 + index, src.get(index));
					
					return this.data_.as_field(model_name.field);
				}
				
				public model_name$(src: Iterator<number>, len: number): model_name {
					let len_ = Math.min(len, _Host.CAMERA_INFORMATION.model_name.item_len);
					
					len = Math.min(len, _Host.CAMERA_INFORMATION.model_name.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 46 + index, v.value);
						}
					return this.data_.as_field(model_name.field);
				}
				
				public focal_length(): number { return this.data_.bytes.getFloat32(this.data_.origin + 78, true);}
				
				public focal_length_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 78, src, true); }
				
				public sensor_size_h(): number { return this.data_.bytes.getFloat32(this.data_.origin + 82, true);}
				
				public sensor_size_h_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 82, src, true); }
				
				public sensor_size_v(): number { return this.data_.bytes.getFloat32(this.data_.origin + 86, true);}
				
				public sensor_size_v_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 86, src, true); }
				
				public lens_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 90);}
				
				public lens_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 90, src); }
				
				
				public flags(): CAMERA_CAP_FLAGS | null {
					if (this.data_.field_bit != 730 && !this.data_.set_field(730, -1)) return null;
					
					return _Host.CAMERA_CAP_FLAGS_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
				public flags_(src: CAMERA_CAP_FLAGS) {
					if (this.data_.field_bit != 730) this.data_.set_field(730, 0);
					
					_Lib.set_bits(_Host.CAMERA_CAP_FLAGS_.into(src), 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				cam_definition_uri(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 731 && !this.data_.set_field(731, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				cam_definition_uri_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -731 - 1);
					
					let len = Math.min(src.byteLength, _Host.CAMERA_INFORMATION.cam_definition_uri.item_len_max);
					this.data_.set_field(731, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				cam_definition_uri$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.CAMERA_INFORMATION.cam_definition_uri.item_len_max)
					this.data_.set_field(731, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				vendor_name_(src: _Host.CAMERA_INFORMATION.vendor_name);
				
				model_name_(src: _Host.CAMERA_INFORMATION.model_name);
				
				firmware_version_(src: number);
				
				focal_length_(src: number);
				
				sensor_size_h_(src: number);
				
				sensor_size_v_(src: number);
				
				resolution_h_(src: number);
				
				resolution_v_(src: number);
				
				lens_id_(src: number);
				
				flags_(src: _Host.CAMERA_CAP_FLAGS);
				
				cam_definition_version_(src: number);
				
				cam_definition_uri_(src: _Cursor.UTF8);
				
			}
			
			export function push_<DST extends DST_>(src: CAMERA_INFORMATION, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				dst.vendor_name_(src.vendor_name());
				dst.model_name_(src.model_name());
				
				dst.firmware_version_(src.firmware_version());
				
				dst.focal_length_(src.focal_length());
				
				dst.sensor_size_h_(src.sensor_size_h());
				
				dst.sensor_size_v_(src.sensor_size_v());
				
				dst.resolution_h_(src.resolution_h());
				
				dst.resolution_v_(src.resolution_v());
				
				dst.lens_id_(src.lens_id());
				
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
				dst.cam_definition_version_(src.cam_definition_version());
				
				{
					const item = src.cam_definition_uri();
					if (item !== null) dst.cam_definition_uri_(item);
					
				}
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				vendor_name(dst: _Host.CAMERA_INFORMATION.vendor_name);
				
				model_name(dst: _Host.CAMERA_INFORMATION.model_name);
				
				firmware_version(): number;
				
				focal_length(): number;
				
				sensor_size_h(): number;
				
				sensor_size_v(): number;
				
				resolution_h(): number;
				
				resolution_v(): number;
				
				lens_id(): number;
				
				flags(): _Host.CAMERA_CAP_FLAGS | null;
				
				cam_definition_version(): number;
				
				cam_definition_uri(): string | Uint8Array | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: CAMERA_INFORMATION) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				src.vendor_name(dst.vendor_name());
				src.model_name(dst.model_name());
				
				dst.firmware_version_(src.firmware_version());
				
				dst.focal_length_(src.focal_length());
				
				dst.sensor_size_h_(src.sensor_size_h());
				
				dst.sensor_size_v_(src.sensor_size_v());
				
				dst.resolution_h_(src.resolution_h());
				
				dst.resolution_v_(src.resolution_v());
				
				dst.lens_id_(src.lens_id());
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
				dst.cam_definition_version_(src.cam_definition_version());
				
				
				{
					const item = src.cam_definition_uri();
					if (item !== null) dst.cam_definition_uri_(item);
				}
				
				
			}
			
		}
		
		export interface GPS_STATUS {
			satellites_visible(): number;
			
			satellite_prn(): GPS_STATUS.satellite_prn;
			
			satellite_used(): GPS_STATUS.satellite_used;
			
			satellite_elevation(): GPS_STATUS.satellite_elevation;
			
			satellite_azimuth(): GPS_STATUS.satellite_azimuth;
			
			satellite_snr(): GPS_STATUS.satellite_snr;
			
		}
		
		export namespace GPS_STATUS {
			
			export const meta_ = new _Pack.Meta(48, 0, 0, 0, 101, 808);
			
			
			export interface satellite_prn extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace satellite_prn {
				export class Field extends _Cursor.View implements satellite_prn, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 1 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 1, other.data_.bytes.buffer, other.data_.origin + 1, _Host.GPS_STATUS.satellite_prn.item_len) === 0;
						for (let i = 0; i < _Host.GPS_STATUS.satellite_prn.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.GPS_STATUS.satellite_prn.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 20;
				
			}
			
			export interface satellite_used extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace satellite_used {
				export class Field extends _Cursor.View implements satellite_used, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 21 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 21, other.data_.bytes.buffer, other.data_.origin + 21, _Host.GPS_STATUS.satellite_used.item_len) === 0;
						for (let i = 0; i < _Host.GPS_STATUS.satellite_used.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.GPS_STATUS.satellite_used.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 20;
				
			}
			
			export interface satellite_elevation extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace satellite_elevation {
				export class Field extends _Cursor.View implements satellite_elevation, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 41 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 41, other.data_.bytes.buffer, other.data_.origin + 41, _Host.GPS_STATUS.satellite_elevation.item_len) === 0;
						for (let i = 0; i < _Host.GPS_STATUS.satellite_elevation.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.GPS_STATUS.satellite_elevation.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 20;
				
			}
			
			export interface satellite_azimuth extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace satellite_azimuth {
				export class Field extends _Cursor.View implements satellite_azimuth, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 61 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 61, other.data_.bytes.buffer, other.data_.origin + 61, _Host.GPS_STATUS.satellite_azimuth.item_len) === 0;
						for (let i = 0; i < _Host.GPS_STATUS.satellite_azimuth.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.GPS_STATUS.satellite_azimuth.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 20;
				
			}
			
			export interface satellite_snr extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace satellite_snr {
				export class Field extends _Cursor.View implements satellite_snr, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 81 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 81, other.data_.bytes.buffer, other.data_.origin + 81, _Host.GPS_STATUS.satellite_snr.item_len) === 0;
						for (let i = 0; i < _Host.GPS_STATUS.satellite_snr.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.GPS_STATUS.satellite_snr.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 20;
				
			}
			
			
			class Impl_ extends _Cursor.View implements GPS_STATUS {
				
				public satellites_visible(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public satellite_prn(): GPS_STATUS.satellite_prn {
					
					return this.data_.as_field(GPS_STATUS.satellite_prn.field);
				}
				
				public satellite_used(): GPS_STATUS.satellite_used {
					
					return this.data_.as_field(GPS_STATUS.satellite_used.field);
				}
				
				public satellite_elevation(): GPS_STATUS.satellite_elevation {
					
					return this.data_.as_field(GPS_STATUS.satellite_elevation.field);
				}
				
				public satellite_azimuth(): GPS_STATUS.satellite_azimuth {
					
					return this.data_.as_field(GPS_STATUS.satellite_azimuth.field);
				}
				
				public satellite_snr(): GPS_STATUS.satellite_snr {
					
					return this.data_.as_field(GPS_STATUS.satellite_snr.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				satellites_visible_(src: number);
				
				satellite_prn_(src: _Host.GPS_STATUS.satellite_prn);
				
				satellite_used_(src: _Host.GPS_STATUS.satellite_used);
				
				satellite_elevation_(src: _Host.GPS_STATUS.satellite_elevation);
				
				satellite_azimuth_(src: _Host.GPS_STATUS.satellite_azimuth);
				
				satellite_snr_(src: _Host.GPS_STATUS.satellite_snr);
				
			}
			
			export function push_<DST extends DST_>(src: GPS_STATUS, dst: DST) {
				
				dst.satellites_visible_(src.satellites_visible());
				dst.satellite_prn_(src.satellite_prn());
				dst.satellite_used_(src.satellite_used());
				dst.satellite_elevation_(src.satellite_elevation());
				dst.satellite_azimuth_(src.satellite_azimuth());
				dst.satellite_snr_(src.satellite_snr());
				
			}
			
		}
		
		export interface DEVICE_OP_WRITE_REPLY {
			request_id(): number;
			
			request_id_(src: number);
			
			result(): number;
			
			result_(src: number);
			
		}
		
		export namespace DEVICE_OP_WRITE_REPLY {
			
			export const meta_ = new _Pack.Meta(33, 0, 1, 0, 5, 40);
			
			
			class Impl_ extends _Cursor.View implements DEVICE_OP_WRITE_REPLY {
				
				public request_id(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public request_id_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public result(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public result_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				request_id_(src: number);
				
				result_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: DEVICE_OP_WRITE_REPLY, dst: DST) {
				
				dst.request_id_(src.request_id());
				
				dst.result_(src.result());
				
			}
			
			export interface SRC_ {
				request_id(): number;
				
				result(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DEVICE_OP_WRITE_REPLY) {
				
				dst.request_id_(src.request_id());
				
				dst.result_(src.result());
				
			}
			
		}
		
		export interface PARAM_SET {
			target_system(): number;
			
			target_component(): number;
			
			param_value(): number;
			
			param_id(): _Cursor.UTF8 | null;
			
			param_type(): MAV_PARAM_TYPE | null;
			
		}
		
		export namespace PARAM_SET {
			
			export const meta_ = new _Pack.Meta(123, 0, 0, 0, 7, 50, 2, 2);
			
			
			export namespace param_id {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements PARAM_SET {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public param_value(): number { return this.data_.bytes.getFloat32(this.data_.origin + 2, true);}
				
				
				param_id(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 50 && !this.data_.set_field(50, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				
				public param_type(): MAV_PARAM_TYPE | null {
					if (this.data_.field_bit != 51 && !this.data_.set_field(51, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				param_id_(src: _Cursor.UTF8);
				
				param_value_(src: number);
				
				param_type_(src: _Host.MAV_PARAM_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: PARAM_SET, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
					
				}
				
				dst.param_value_(src.param_value());
				
				{
					const item = src.param_type();
					if (item !== null) dst.param_type_(item);
					
				}
				
			}
			
		}
		
		export interface TERRAIN_DATA {
			grid_spacing(): number;
			
			grid_spacing_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
			gridbit(): number;
			
			gridbit_(src: number);
			
			daTa(): TERRAIN_DATA.daTa;
			
			daTa_(src: TERRAIN_DATA.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace TERRAIN_DATA {
			
			export const meta_ = new _Pack.Meta(173, 1, 0, 0, 43, 344);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt16(this.data_.origin + 11 + index * 2, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 11, other.data_.bytes.buffer, other.data_.origin + 11, _Host.TERRAIN_DATA.daTa.item_len) === 0;
						for (let i = 0; i < _Host.TERRAIN_DATA.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.TERRAIN_DATA.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt16(this.data_.origin + 11 + index * 2, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 16;
				
			}
			
			
			class Impl_ extends _Cursor.View implements TERRAIN_DATA {
				
				public grid_spacing(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public grid_spacing_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public lon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public gridbit(): number { return this.data_.bytes.getInt8(this.data_.origin + 10);}
				
				public gridbit_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 10, src); }
				
				public daTa(): TERRAIN_DATA.daTa {
					
					return this.data_.as_field(TERRAIN_DATA.daTa.field);
				}
				
				public daTa_(src: TERRAIN_DATA.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.TERRAIN_DATA.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt16(this.data_.origin + 11 + index * 2, src[index], true);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.TERRAIN_DATA.daTa.item_len; index++)
						this.data_.bytes.setInt16(this.data_.origin + 11 + index * 2, src.get(index), true);
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.TERRAIN_DATA.daTa.item_len);
					
					len = Math.min(len, _Host.TERRAIN_DATA.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt16(this.data_.origin + 11 + index * 2, v.value, true);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				lat_(src: number);
				
				lon_(src: number);
				
				grid_spacing_(src: number);
				
				gridbit_(src: number);
				
				daTa_(src: _Host.TERRAIN_DATA.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: TERRAIN_DATA, dst: DST) {
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.grid_spacing_(src.grid_spacing());
				
				dst.gridbit_(src.gridbit());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				lat(): number;
				
				lon(): number;
				
				grid_spacing(): number;
				
				gridbit(): number;
				
				daTa(dst: _Host.TERRAIN_DATA.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: TERRAIN_DATA) {
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.grid_spacing_(src.grid_spacing());
				
				dst.gridbit_(src.gridbit());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface GIMBAL_CONTROL {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			demanded_rate_x(): number;
			
			demanded_rate_x_(src: number);
			
			demanded_rate_y(): number;
			
			demanded_rate_y_(src: number);
			
			demanded_rate_z(): number;
			
			demanded_rate_z_(src: number);
			
		}
		
		export namespace GIMBAL_CONTROL {
			
			export const meta_ = new _Pack.Meta(104, 0, 0, 0, 14, 112);
			
			
			class Impl_ extends _Cursor.View implements GIMBAL_CONTROL {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public demanded_rate_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 2, true);}
				
				public demanded_rate_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 2, src, true); }
				
				public demanded_rate_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 6, true);}
				
				public demanded_rate_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 6, src, true); }
				
				public demanded_rate_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 10, true);}
				
				public demanded_rate_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 10, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				demanded_rate_x_(src: number);
				
				demanded_rate_y_(src: number);
				
				demanded_rate_z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: GIMBAL_CONTROL, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.demanded_rate_x_(src.demanded_rate_x());
				
				dst.demanded_rate_y_(src.demanded_rate_y());
				
				dst.demanded_rate_z_(src.demanded_rate_z());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				demanded_rate_x(): number;
				
				demanded_rate_y(): number;
				
				demanded_rate_z(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GIMBAL_CONTROL) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.demanded_rate_x_(src.demanded_rate_x());
				
				dst.demanded_rate_y_(src.demanded_rate_y());
				
				dst.demanded_rate_z_(src.demanded_rate_z());
				
			}
			
		}
		
		export interface RC_CHANNELS_OVERRIDE {
			chan1_raw(): number;
			
			chan2_raw(): number;
			
			chan3_raw(): number;
			
			chan4_raw(): number;
			
			chan5_raw(): number;
			
			chan6_raw(): number;
			
			chan7_raw(): number;
			
			chan8_raw(): number;
			
			target_system(): number;
			
			target_component(): number;
			
		}
		
		export namespace RC_CHANNELS_OVERRIDE {
			
			export const meta_ = new _Pack.Meta(55, 8, 0, 0, 18, 144);
			
			
			class Impl_ extends _Cursor.View implements RC_CHANNELS_OVERRIDE {
				
				public chan1_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public chan2_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				public chan3_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				
				public chan4_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				
				public chan5_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				
				public chan6_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				
				public chan7_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				
				public chan8_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 16);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 17);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				chan1_raw_(src: number);
				
				chan2_raw_(src: number);
				
				chan3_raw_(src: number);
				
				chan4_raw_(src: number);
				
				chan5_raw_(src: number);
				
				chan6_raw_(src: number);
				
				chan7_raw_(src: number);
				
				chan8_raw_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: RC_CHANNELS_OVERRIDE, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.chan1_raw_(src.chan1_raw());
				
				dst.chan2_raw_(src.chan2_raw());
				
				dst.chan3_raw_(src.chan3_raw());
				
				dst.chan4_raw_(src.chan4_raw());
				
				dst.chan5_raw_(src.chan5_raw());
				
				dst.chan6_raw_(src.chan6_raw());
				
				dst.chan7_raw_(src.chan7_raw());
				
				dst.chan8_raw_(src.chan8_raw());
				
			}
			
		}
		
		export interface SCALED_IMU {
			time_boot_ms(): number;
			
			xacc(): number;
			
			yacc(): number;
			
			zacc(): number;
			
			xgyro(): number;
			
			ygyro(): number;
			
			zgyro(): number;
			
			xmag(): number;
			
			ymag(): number;
			
			zmag(): number;
			
		}
		
		export namespace SCALED_IMU {
			
			export const meta_ = new _Pack.Meta(195, 0, 1, 0, 22, 176);
			
			
			class Impl_ extends _Cursor.View implements SCALED_IMU {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public xacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				
				public yacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				
				public zacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				
				public xgyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				
				public ygyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				
				public zgyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				
				public xmag(): number { return this.data_.bytes.getInt16(this.data_.origin + 16, true);}
				
				
				public ymag(): number { return this.data_.bytes.getInt16(this.data_.origin + 18, true);}
				
				
				public zmag(): number { return this.data_.bytes.getInt16(this.data_.origin + 20, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				xacc_(src: number);
				
				yacc_(src: number);
				
				zacc_(src: number);
				
				xgyro_(src: number);
				
				ygyro_(src: number);
				
				zgyro_(src: number);
				
				xmag_(src: number);
				
				ymag_(src: number);
				
				zmag_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SCALED_IMU, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.xmag_(src.xmag());
				
				dst.ymag_(src.ymag());
				
				dst.zmag_(src.zmag());
				
			}
			
		}
		
		export interface VIDEO_STREAM_INFORMATION {
			resolution_h(): number;
			
			resolution_h_(src: number);
			
			resolution_v(): number;
			
			resolution_v_(src: number);
			
			rotation(): number;
			
			rotation_(src: number);
			
			bitrate(): number;
			
			bitrate_(src: number);
			
			camera_id(): number;
			
			camera_id_(src: number);
			
			status(): number;
			
			status_(src: number);
			
			framerate(): number;
			
			framerate_(src: number);
			
			uri(): _Cursor.UTF8 | null;
			
			uri_(src: string | Uint8Array): _Cursor.UTF8;
			
			uri$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace VIDEO_STREAM_INFORMATION {
			
			export const meta_ = new _Pack.Meta(1, 3, 1, 0, 17, 130, 2, 1);
			
			
			export namespace uri {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements VIDEO_STREAM_INFORMATION {
				
				public resolution_h(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public resolution_h_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public resolution_v(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public resolution_v_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public rotation(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public rotation_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public bitrate(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public bitrate_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public camera_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 10);}
				
				public camera_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 10, src); }
				
				public status(): number { return this.data_.bytes.getInt8(this.data_.origin + 11);}
				
				public status_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 11, src); }
				
				public framerate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public framerate_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				
				uri(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 130 && !this.data_.set_field(130, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				uri_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -130 - 1);
					
					let len = Math.min(src.byteLength, _Host.VIDEO_STREAM_INFORMATION.uri.item_len_max);
					this.data_.set_field(130, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				uri$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.VIDEO_STREAM_INFORMATION.uri.item_len_max)
					this.data_.set_field(130, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				camera_id_(src: number);
				
				status_(src: number);
				
				framerate_(src: number);
				
				resolution_h_(src: number);
				
				resolution_v_(src: number);
				
				bitrate_(src: number);
				
				rotation_(src: number);
				
				uri_(src: _Cursor.UTF8);
				
			}
			
			export function push_<DST extends DST_>(src: VIDEO_STREAM_INFORMATION, dst: DST) {
				
				dst.camera_id_(src.camera_id());
				
				dst.status_(src.status());
				
				dst.framerate_(src.framerate());
				
				dst.resolution_h_(src.resolution_h());
				
				dst.resolution_v_(src.resolution_v());
				
				dst.bitrate_(src.bitrate());
				
				dst.rotation_(src.rotation());
				
				{
					const item = src.uri();
					if (item !== null) dst.uri_(item);
					
				}
				
			}
			
			export interface SRC_ {
				camera_id(): number;
				
				status(): number;
				
				framerate(): number;
				
				resolution_h(): number;
				
				resolution_v(): number;
				
				bitrate(): number;
				
				rotation(): number;
				
				uri(): string | Uint8Array | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: VIDEO_STREAM_INFORMATION) {
				
				dst.camera_id_(src.camera_id());
				
				dst.status_(src.status());
				
				dst.framerate_(src.framerate());
				
				dst.resolution_h_(src.resolution_h());
				
				dst.resolution_v_(src.resolution_v());
				
				dst.bitrate_(src.bitrate());
				
				dst.rotation_(src.rotation());
				
				
				{
					const item = src.uri();
					if (item !== null) dst.uri_(item);
				}
				
				
			}
			
		}
		
		export interface AHRS {
			omegaIx(): number;
			
			omegaIx_(src: number);
			
			omegaIy(): number;
			
			omegaIy_(src: number);
			
			omegaIz(): number;
			
			omegaIz_(src: number);
			
			accel_weight(): number;
			
			accel_weight_(src: number);
			
			renorm_val(): number;
			
			renorm_val_(src: number);
			
			error_rp(): number;
			
			error_rp_(src: number);
			
			error_yaw(): number;
			
			error_yaw_(src: number);
			
		}
		
		export namespace AHRS {
			
			export const meta_ = new _Pack.Meta(214, 0, 0, 0, 28, 224);
			
			
			class Impl_ extends _Cursor.View implements AHRS {
				
				public omegaIx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public omegaIx_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public omegaIy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public omegaIy_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public omegaIz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public omegaIz_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public accel_weight(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public accel_weight_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public renorm_val(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public renorm_val_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public error_rp(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public error_rp_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public error_yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public error_yaw_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				omegaIx_(src: number);
				
				omegaIy_(src: number);
				
				omegaIz_(src: number);
				
				accel_weight_(src: number);
				
				renorm_val_(src: number);
				
				error_rp_(src: number);
				
				error_yaw_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: AHRS, dst: DST) {
				
				dst.omegaIx_(src.omegaIx());
				
				dst.omegaIy_(src.omegaIy());
				
				dst.omegaIz_(src.omegaIz());
				
				dst.accel_weight_(src.accel_weight());
				
				dst.renorm_val_(src.renorm_val());
				
				dst.error_rp_(src.error_rp());
				
				dst.error_yaw_(src.error_yaw());
				
			}
			
			export interface SRC_ {
				omegaIx(): number;
				
				omegaIy(): number;
				
				omegaIz(): number;
				
				accel_weight(): number;
				
				renorm_val(): number;
				
				error_rp(): number;
				
				error_yaw(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: AHRS) {
				
				dst.omegaIx_(src.omegaIx());
				
				dst.omegaIy_(src.omegaIy());
				
				dst.omegaIz_(src.omegaIz());
				
				dst.accel_weight_(src.accel_weight());
				
				dst.renorm_val_(src.renorm_val());
				
				dst.error_rp_(src.error_rp());
				
				dst.error_yaw_(src.error_yaw());
				
			}
			
		}
		
		export interface DEBUG {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			ind(): number;
			
			ind_(src: number);
			
			value(): number;
			
			value_(src: number);
			
		}
		
		export namespace DEBUG {
			
			export const meta_ = new _Pack.Meta(126, 0, 1, 0, 9, 72);
			
			
			class Impl_ extends _Cursor.View implements DEBUG {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public ind(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public ind_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public value(): number { return this.data_.bytes.getFloat32(this.data_.origin + 5, true);}
				
				public value_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 5, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				ind_(src: number);
				
				value_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: DEBUG, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.ind_(src.ind());
				
				dst.value_(src.value());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				ind(): number;
				
				value(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DEBUG) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.ind_(src.ind());
				
				dst.value_(src.value());
				
			}
			
		}
		
		export interface CAMERA_IMAGE_CAPTURED {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			time_utc(): number;
			
			time_utc_(src: number);
			
			camera_id(): number;
			
			camera_id_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
			alt(): number;
			
			alt_(src: number);
			
			relative_alt(): number;
			
			relative_alt_(src: number);
			
			q(): CAMERA_IMAGE_CAPTURED.q;
			
			q_(src: CAMERA_IMAGE_CAPTURED.q | number[]);
			
			q$(src: Iterator<number>, len: number);
			
			image_index(): number;
			
			image_index_(src: number);
			
			capture_result(): number;
			
			capture_result_(src: number);
			
			file_url(): _Cursor.UTF8 | null;
			
			file_url_(src: string | Uint8Array): _Cursor.UTF8;
			
			file_url$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace CAMERA_IMAGE_CAPTURED {
			
			export const meta_ = new _Pack.Meta(10, 0, 1, 1, 51, 402, 2, 1);
			
			
			export interface q extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace q {
				export class Field extends _Cursor.View implements q, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 29 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 29, other.data_.bytes.buffer, other.data_.origin + 29, _Host.CAMERA_IMAGE_CAPTURED.q.item_len) === 0;
						for (let i = 0; i < _Host.CAMERA_IMAGE_CAPTURED.q.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.CAMERA_IMAGE_CAPTURED.q.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 29 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			export namespace file_url {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements CAMERA_IMAGE_CAPTURED {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public time_utc(): number { return this.data_.bytes.getUint32(this.data_.origin + 4, true) + this.data_.bytes.getInt32(this.data_.origin + 4 + 4, true) * _Lib.JS_HI;}
				
				public time_utc_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 4, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 4 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public camera_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 12);}
				
				public camera_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 12, src); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 13, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 13, src, true); }
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 17, true);}
				
				public lon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 17, src, true); }
				
				public alt(): number { return this.data_.bytes.getInt32(this.data_.origin + 21, true);}
				
				public alt_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 21, src, true); }
				
				public relative_alt(): number { return this.data_.bytes.getInt32(this.data_.origin + 25, true);}
				
				public relative_alt_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 25, src, true); }
				
				public q(): CAMERA_IMAGE_CAPTURED.q {
					
					return this.data_.as_field(CAMERA_IMAGE_CAPTURED.q.field);
				}
				
				public q_(src: CAMERA_IMAGE_CAPTURED.q | number[]): q {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.CAMERA_IMAGE_CAPTURED.q.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 29 + index * 4, src[index], true);
						return this.data_.as_field(q.field);
					}
					for (let index = 0; index < _Host.CAMERA_IMAGE_CAPTURED.q.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 29 + index * 4, src.get(index), true);
					
					return this.data_.as_field(q.field);
				}
				
				public q$(src: Iterator<number>, len: number): q {
					let len_ = Math.min(len, _Host.CAMERA_IMAGE_CAPTURED.q.item_len);
					
					len = Math.min(len, _Host.CAMERA_IMAGE_CAPTURED.q.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 29 + index * 4, v.value, true);
						}
					return this.data_.as_field(q.field);
				}
				
				public image_index(): number { return this.data_.bytes.getInt32(this.data_.origin + 45, true);}
				
				public image_index_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 45, src, true); }
				
				public capture_result(): number { return this.data_.bytes.getInt8(this.data_.origin + 49);}
				
				public capture_result_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 49, src); }
				
				
				file_url(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 402 && !this.data_.set_field(402, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				file_url_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -402 - 1);
					
					let len = Math.min(src.byteLength, _Host.CAMERA_IMAGE_CAPTURED.file_url.item_len_max);
					this.data_.set_field(402, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				file_url$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.CAMERA_IMAGE_CAPTURED.file_url.item_len_max)
					this.data_.set_field(402, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				time_utc_(src: number);
				
				camera_id_(src: number);
				
				lat_(src: number);
				
				lon_(src: number);
				
				alt_(src: number);
				
				relative_alt_(src: number);
				
				q_(src: _Host.CAMERA_IMAGE_CAPTURED.q);
				
				image_index_(src: number);
				
				capture_result_(src: number);
				
				file_url_(src: _Cursor.UTF8);
				
			}
			
			export function push_<DST extends DST_>(src: CAMERA_IMAGE_CAPTURED, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.time_utc_(src.time_utc());
				
				dst.camera_id_(src.camera_id());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.relative_alt_(src.relative_alt());
				dst.q_(src.q());
				
				dst.image_index_(src.image_index());
				
				dst.capture_result_(src.capture_result());
				
				{
					const item = src.file_url();
					if (item !== null) dst.file_url_(item);
					
				}
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				time_utc(): number;
				
				camera_id(): number;
				
				lat(): number;
				
				lon(): number;
				
				alt(): number;
				
				relative_alt(): number;
				
				q(dst: _Host.CAMERA_IMAGE_CAPTURED.q);
				
				image_index(): number;
				
				capture_result(): number;
				
				file_url(): string | Uint8Array | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: CAMERA_IMAGE_CAPTURED) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.time_utc_(src.time_utc());
				
				dst.camera_id_(src.camera_id());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.relative_alt_(src.relative_alt());
				src.q(dst.q());
				
				dst.image_index_(src.image_index());
				
				dst.capture_result_(src.capture_result());
				
				
				{
					const item = src.file_url();
					if (item !== null) dst.file_url_(item);
				}
				
				
			}
			
		}
		
		export interface LOG_ENTRY {
			id(): number;
			
			id_(src: number);
			
			num_logs(): number;
			
			num_logs_(src: number);
			
			last_log_num(): number;
			
			last_log_num_(src: number);
			
			time_utc(): number;
			
			time_utc_(src: number);
			
			size(): number;
			
			size_(src: number);
			
		}
		
		export namespace LOG_ENTRY {
			
			export const meta_ = new _Pack.Meta(161, 3, 2, 0, 14, 112);
			
			
			class Impl_ extends _Cursor.View implements LOG_ENTRY {
				
				public id(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public id_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public num_logs(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public num_logs_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public last_log_num(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public last_log_num_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public time_utc(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public time_utc_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public size(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public size_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				id_(src: number);
				
				num_logs_(src: number);
				
				last_log_num_(src: number);
				
				time_utc_(src: number);
				
				size_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: LOG_ENTRY, dst: DST) {
				
				dst.id_(src.id());
				
				dst.num_logs_(src.num_logs());
				
				dst.last_log_num_(src.last_log_num());
				
				dst.time_utc_(src.time_utc());
				
				dst.size_(src.size());
				
			}
			
			export interface SRC_ {
				id(): number;
				
				num_logs(): number;
				
				last_log_num(): number;
				
				time_utc(): number;
				
				size(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LOG_ENTRY) {
				
				dst.id_(src.id());
				
				dst.num_logs_(src.num_logs());
				
				dst.last_log_num_(src.last_log_num());
				
				dst.time_utc_(src.time_utc());
				
				dst.size_(src.size());
				
			}
			
		}
		
		export interface ACTUATOR_CONTROL_TARGET {
			time_usec(): number;
			
			time_usec_(src: number);
			
			group_mlx(): number;
			
			group_mlx_(src: number);
			
			controls(): ACTUATOR_CONTROL_TARGET.controls;
			
			controls_(src: ACTUATOR_CONTROL_TARGET.controls | number[]);
			
			controls$(src: Iterator<number>, len: number);
			
		}
		
		export namespace ACTUATOR_CONTROL_TARGET {
			
			export const meta_ = new _Pack.Meta(3, 0, 0, 1, 41, 328);
			
			
			export interface controls extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace controls {
				export class Field extends _Cursor.View implements controls, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 9 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 9, other.data_.bytes.buffer, other.data_.origin + 9, _Host.ACTUATOR_CONTROL_TARGET.controls.item_len) === 0;
						for (let i = 0; i < _Host.ACTUATOR_CONTROL_TARGET.controls.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.ACTUATOR_CONTROL_TARGET.controls.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 9 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 8;
				
			}
			
			
			class Impl_ extends _Cursor.View implements ACTUATOR_CONTROL_TARGET {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public group_mlx(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public group_mlx_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
				public controls(): ACTUATOR_CONTROL_TARGET.controls {
					
					return this.data_.as_field(ACTUATOR_CONTROL_TARGET.controls.field);
				}
				
				public controls_(src: ACTUATOR_CONTROL_TARGET.controls | number[]): controls {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.ACTUATOR_CONTROL_TARGET.controls.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 9 + index * 4, src[index], true);
						return this.data_.as_field(controls.field);
					}
					for (let index = 0; index < _Host.ACTUATOR_CONTROL_TARGET.controls.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 9 + index * 4, src.get(index), true);
					
					return this.data_.as_field(controls.field);
				}
				
				public controls$(src: Iterator<number>, len: number): controls {
					let len_ = Math.min(len, _Host.ACTUATOR_CONTROL_TARGET.controls.item_len);
					
					len = Math.min(len, _Host.ACTUATOR_CONTROL_TARGET.controls.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 9 + index * 4, v.value, true);
						}
					return this.data_.as_field(controls.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				group_mlx_(src: number);
				
				controls_(src: _Host.ACTUATOR_CONTROL_TARGET.controls);
				
			}
			
			export function push_<DST extends DST_>(src: ACTUATOR_CONTROL_TARGET, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.group_mlx_(src.group_mlx());
				dst.controls_(src.controls());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				group_mlx(): number;
				
				controls(dst: _Host.ACTUATOR_CONTROL_TARGET.controls);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: ACTUATOR_CONTROL_TARGET) {
				
				dst.time_usec_(src.time_usec());
				
				dst.group_mlx_(src.group_mlx());
				src.controls(dst.controls());
				
			}
			
		}
		
		export interface HIGH_LATENCY {
			heading(): number;
			
			heading_(src: number);
			
			wp_distance(): number;
			
			wp_distance_(src: number);
			
			custom_mode(): number;
			
			custom_mode_(src: number);
			
			roll(): number;
			
			roll_(src: number);
			
			pitch(): number;
			
			pitch_(src: number);
			
			throttle(): number;
			
			throttle_(src: number);
			
			heading_sp(): number;
			
			heading_sp_(src: number);
			
			latitude(): number;
			
			latitude_(src: number);
			
			longitude(): number;
			
			longitude_(src: number);
			
			altitude_amsl(): number;
			
			altitude_amsl_(src: number);
			
			altitude_sp(): number;
			
			altitude_sp_(src: number);
			
			airspeed(): number;
			
			airspeed_(src: number);
			
			airspeed_sp(): number;
			
			airspeed_sp_(src: number);
			
			groundspeed(): number;
			
			groundspeed_(src: number);
			
			climb_rate(): number;
			
			climb_rate_(src: number);
			
			gps_nsat(): number;
			
			gps_nsat_(src: number);
			
			battery_remaining(): number;
			
			battery_remaining_(src: number);
			
			temperature(): number;
			
			temperature_(src: number);
			
			temperature_air(): number;
			
			temperature_air_(src: number);
			
			failsafe(): number;
			
			failsafe_(src: number);
			
			wp_num(): number;
			
			wp_num_(src: number);
			
			base_mode(): MAV_MODE_FLAG | null;
			
			base_mode_(src: MAV_MODE_FLAG);
			
			landed_state(): MAV_LANDED_STATE | null;
			
			landed_state_(src: MAV_LANDED_STATE);
			
			gps_fix_type(): GPS_FIX_TYPE | null;
			
			gps_fix_type_(src: GPS_FIX_TYPE);
			
		}
		
		export namespace HIGH_LATENCY {
			
			export const meta_ = new _Pack.Meta(87, 2, 1, 0, 38, 298, 2, 3);
			
			
			class Impl_ extends _Cursor.View implements HIGH_LATENCY {
				
				public heading(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public heading_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public wp_distance(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public wp_distance_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public custom_mode(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				public custom_mode_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 4, src, true); }
				
				public roll(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				public roll_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 8, src, true); }
				
				public pitch(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				public pitch_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 10, src, true); }
				
				public throttle(): number { return this.data_.bytes.getInt8(this.data_.origin + 12);}
				
				public throttle_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 12, src); }
				
				public heading_sp(): number { return this.data_.bytes.getInt16(this.data_.origin + 13, true);}
				
				public heading_sp_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 13, src, true); }
				
				public latitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 15, true);}
				
				public latitude_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 15, src, true); }
				
				public longitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 19, true);}
				
				public longitude_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 19, src, true); }
				
				public altitude_amsl(): number { return this.data_.bytes.getInt16(this.data_.origin + 23, true);}
				
				public altitude_amsl_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 23, src, true); }
				
				public altitude_sp(): number { return this.data_.bytes.getInt16(this.data_.origin + 25, true);}
				
				public altitude_sp_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 25, src, true); }
				
				public airspeed(): number { return this.data_.bytes.getInt8(this.data_.origin + 27);}
				
				public airspeed_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 27, src); }
				
				public airspeed_sp(): number { return this.data_.bytes.getInt8(this.data_.origin + 28);}
				
				public airspeed_sp_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 28, src); }
				
				public groundspeed(): number { return this.data_.bytes.getInt8(this.data_.origin + 29);}
				
				public groundspeed_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 29, src); }
				
				public climb_rate(): number { return this.data_.bytes.getInt8(this.data_.origin + 30);}
				
				public climb_rate_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 30, src); }
				
				public gps_nsat(): number { return this.data_.bytes.getInt8(this.data_.origin + 31);}
				
				public gps_nsat_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 31, src); }
				
				public battery_remaining(): number { return this.data_.bytes.getInt8(this.data_.origin + 32);}
				
				public battery_remaining_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 32, src); }
				
				public temperature(): number { return this.data_.bytes.getInt8(this.data_.origin + 33);}
				
				public temperature_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 33, src); }
				
				public temperature_air(): number { return this.data_.bytes.getInt8(this.data_.origin + 34);}
				
				public temperature_air_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 34, src); }
				
				public failsafe(): number { return this.data_.bytes.getInt8(this.data_.origin + 35);}
				
				public failsafe_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 35, src); }
				
				public wp_num(): number { return this.data_.bytes.getInt8(this.data_.origin + 36);}
				
				public wp_num_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 36, src); }
				
				
				public base_mode(): MAV_MODE_FLAG | null {
					if (this.data_.field_bit != 298 && !this.data_.set_field(298, -1)) return null;
					
					return _Host.MAV_MODE_FLAG_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 4));
				}
				
				
				public base_mode_(src: MAV_MODE_FLAG) {
					if (this.data_.field_bit != 298) this.data_.set_field(298, 0);
					
					_Lib.set_bits(_Host.MAV_MODE_FLAG_.into(src), 4, this.data_.bytes, this.data_.BIT);
				}
				
				
				public landed_state(): MAV_LANDED_STATE | null {
					if (this.data_.field_bit != 299 && !this.data_.set_field(299, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public landed_state_(src: MAV_LANDED_STATE) {
					if (this.data_.field_bit != 299) this.data_.set_field(299, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				public gps_fix_type(): GPS_FIX_TYPE | null {
					if (this.data_.field_bit != 300 && !this.data_.set_field(300, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public gps_fix_type_(src: GPS_FIX_TYPE) {
					if (this.data_.field_bit != 300) this.data_.set_field(300, 0);
					
					_Lib.set_bits(src, 4, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				base_mode_(src: _Host.MAV_MODE_FLAG);
				
				custom_mode_(src: number);
				
				landed_state_(src: _Host.MAV_LANDED_STATE);
				
				roll_(src: number);
				
				pitch_(src: number);
				
				heading_(src: number);
				
				throttle_(src: number);
				
				heading_sp_(src: number);
				
				latitude_(src: number);
				
				longitude_(src: number);
				
				altitude_amsl_(src: number);
				
				altitude_sp_(src: number);
				
				airspeed_(src: number);
				
				airspeed_sp_(src: number);
				
				groundspeed_(src: number);
				
				climb_rate_(src: number);
				
				gps_nsat_(src: number);
				
				gps_fix_type_(src: _Host.GPS_FIX_TYPE);
				
				battery_remaining_(src: number);
				
				temperature_(src: number);
				
				temperature_air_(src: number);
				
				failsafe_(src: number);
				
				wp_num_(src: number);
				
				wp_distance_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HIGH_LATENCY, dst: DST) {
				
				{
					const item = src.base_mode();
					if (item !== null) dst.base_mode_(item);
					
				}
				
				dst.custom_mode_(src.custom_mode());
				
				{
					const item = src.landed_state();
					if (item !== null) dst.landed_state_(item);
					
				}
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.heading_(src.heading());
				
				dst.throttle_(src.throttle());
				
				dst.heading_sp_(src.heading_sp());
				
				dst.latitude_(src.latitude());
				
				dst.longitude_(src.longitude());
				
				dst.altitude_amsl_(src.altitude_amsl());
				
				dst.altitude_sp_(src.altitude_sp());
				
				dst.airspeed_(src.airspeed());
				
				dst.airspeed_sp_(src.airspeed_sp());
				
				dst.groundspeed_(src.groundspeed());
				
				dst.climb_rate_(src.climb_rate());
				
				dst.gps_nsat_(src.gps_nsat());
				
				{
					const item = src.gps_fix_type();
					if (item !== null) dst.gps_fix_type_(item);
					
				}
				
				dst.battery_remaining_(src.battery_remaining());
				
				dst.temperature_(src.temperature());
				
				dst.temperature_air_(src.temperature_air());
				
				dst.failsafe_(src.failsafe());
				
				dst.wp_num_(src.wp_num());
				
				dst.wp_distance_(src.wp_distance());
				
			}
			
			export interface SRC_ {
				base_mode(): _Host.MAV_MODE_FLAG | null;
				
				custom_mode(): number;
				
				landed_state(): _Host.MAV_LANDED_STATE | null;
				
				roll(): number;
				
				pitch(): number;
				
				heading(): number;
				
				throttle(): number;
				
				heading_sp(): number;
				
				latitude(): number;
				
				longitude(): number;
				
				altitude_amsl(): number;
				
				altitude_sp(): number;
				
				airspeed(): number;
				
				airspeed_sp(): number;
				
				groundspeed(): number;
				
				climb_rate(): number;
				
				gps_nsat(): number;
				
				gps_fix_type(): _Host.GPS_FIX_TYPE | null;
				
				battery_remaining(): number;
				
				temperature(): number;
				
				temperature_air(): number;
				
				failsafe(): number;
				
				wp_num(): number;
				
				wp_distance(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: HIGH_LATENCY) {
				{
					const item = src.base_mode();
					if (item !== null) dst.base_mode_(item);
					
				}
				
				dst.custom_mode_(src.custom_mode());
				{
					const item = src.landed_state();
					if (item !== null) dst.landed_state_(item);
					
				}
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.heading_(src.heading());
				
				dst.throttle_(src.throttle());
				
				dst.heading_sp_(src.heading_sp());
				
				dst.latitude_(src.latitude());
				
				dst.longitude_(src.longitude());
				
				dst.altitude_amsl_(src.altitude_amsl());
				
				dst.altitude_sp_(src.altitude_sp());
				
				dst.airspeed_(src.airspeed());
				
				dst.airspeed_sp_(src.airspeed_sp());
				
				dst.groundspeed_(src.groundspeed());
				
				dst.climb_rate_(src.climb_rate());
				
				dst.gps_nsat_(src.gps_nsat());
				{
					const item = src.gps_fix_type();
					if (item !== null) dst.gps_fix_type_(item);
					
				}
				
				dst.battery_remaining_(src.battery_remaining());
				
				dst.temperature_(src.temperature());
				
				dst.temperature_air_(src.temperature_air());
				
				dst.failsafe_(src.failsafe());
				
				dst.wp_num_(src.wp_num());
				
				dst.wp_distance_(src.wp_distance());
				
			}
			
		}
		
		export interface PARAM_REQUEST_READ {
			target_system(): number;
			
			target_component(): number;
			
			param_index(): number;
			
			param_id(): _Cursor.UTF8 | null;
			
		}
		
		export namespace PARAM_REQUEST_READ {
			
			export const meta_ = new _Pack.Meta(166, 0, 0, 0, 5, 34, 2, 1);
			
			
			export namespace param_id {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements PARAM_REQUEST_READ {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public param_index(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				param_id(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 34 && !this.data_.set_field(34, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				param_id_(src: _Cursor.UTF8);
				
				param_index_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: PARAM_REQUEST_READ, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
					
				}
				
				dst.param_index_(src.param_index());
				
			}
			
		}
		
		export interface SET_ATTITUDE_TARGET {
			time_boot_ms(): number;
			
			target_system(): number;
			
			target_component(): number;
			
			type_mask(): number;
			
			q(): SET_ATTITUDE_TARGET.q;
			
			body_roll_rate(): number;
			
			body_pitch_rate(): number;
			
			body_yaw_rate(): number;
			
			thrust(): number;
			
		}
		
		export namespace SET_ATTITUDE_TARGET {
			
			export const meta_ = new _Pack.Meta(74, 0, 1, 0, 39, 312);
			
			
			export interface q extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace q {
				export class Field extends _Cursor.View implements q, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 7 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 7, other.data_.bytes.buffer, other.data_.origin + 7, _Host.SET_ATTITUDE_TARGET.q.item_len) === 0;
						for (let i = 0; i < _Host.SET_ATTITUDE_TARGET.q.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.SET_ATTITUDE_TARGET.q.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			
			
			class Impl_ extends _Cursor.View implements SET_ATTITUDE_TARGET {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				
				public type_mask(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				
				public q(): SET_ATTITUDE_TARGET.q {
					
					return this.data_.as_field(SET_ATTITUDE_TARGET.q.field);
				}
				
				public body_roll_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 23, true);}
				
				
				public body_pitch_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 27, true);}
				
				
				public body_yaw_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 31, true);}
				
				
				public thrust(): number { return this.data_.bytes.getFloat32(this.data_.origin + 35, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				target_system_(src: number);
				
				target_component_(src: number);
				
				type_mask_(src: number);
				
				q_(src: _Host.SET_ATTITUDE_TARGET.q);
				
				body_roll_rate_(src: number);
				
				body_pitch_rate_(src: number);
				
				body_yaw_rate_(src: number);
				
				thrust_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SET_ATTITUDE_TARGET, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.type_mask_(src.type_mask());
				dst.q_(src.q());
				
				dst.body_roll_rate_(src.body_roll_rate());
				
				dst.body_pitch_rate_(src.body_pitch_rate());
				
				dst.body_yaw_rate_(src.body_yaw_rate());
				
				dst.thrust_(src.thrust());
				
			}
			
		}
		
		export interface FOLLOW_TARGET {
			timestamp(): number;
			
			timestamp_(src: number);
			
			custom_state(): number;
			
			custom_state_(src: number);
			
			est_capabilities(): number;
			
			est_capabilities_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
			alt(): number;
			
			alt_(src: number);
			
			vel(): FOLLOW_TARGET.vel;
			
			vel_(src: FOLLOW_TARGET.vel | number[]);
			
			vel$(src: Iterator<number>, len: number);
			
			acc(): FOLLOW_TARGET.acc;
			
			acc_(src: FOLLOW_TARGET.acc | number[]);
			
			acc$(src: Iterator<number>, len: number);
			
			attitude_q(): FOLLOW_TARGET.attitude_q;
			
			attitude_q_(src: FOLLOW_TARGET.attitude_q | number[]);
			
			attitude_q$(src: Iterator<number>, len: number);
			
			rates(): FOLLOW_TARGET.rates;
			
			rates_(src: FOLLOW_TARGET.rates | number[]);
			
			rates$(src: Iterator<number>, len: number);
			
			position_cov(): FOLLOW_TARGET.position_cov;
			
			position_cov_(src: FOLLOW_TARGET.position_cov | number[]);
			
			position_cov$(src: Iterator<number>, len: number);
			
		}
		
		export namespace FOLLOW_TARGET {
			
			export const meta_ = new _Pack.Meta(39, 0, 0, 2, 93, 744);
			
			
			export interface vel extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace vel {
				export class Field extends _Cursor.View implements vel, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 29 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 29, other.data_.bytes.buffer, other.data_.origin + 29, _Host.FOLLOW_TARGET.vel.item_len) === 0;
						for (let i = 0; i < _Host.FOLLOW_TARGET.vel.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.FOLLOW_TARGET.vel.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 29 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 3;
				
			}
			
			export interface acc extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace acc {
				export class Field extends _Cursor.View implements acc, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 41 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 41, other.data_.bytes.buffer, other.data_.origin + 41, _Host.FOLLOW_TARGET.acc.item_len) === 0;
						for (let i = 0; i < _Host.FOLLOW_TARGET.acc.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.FOLLOW_TARGET.acc.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 41 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 3;
				
			}
			
			export interface attitude_q extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace attitude_q {
				export class Field extends _Cursor.View implements attitude_q, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 53 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 53, other.data_.bytes.buffer, other.data_.origin + 53, _Host.FOLLOW_TARGET.attitude_q.item_len) === 0;
						for (let i = 0; i < _Host.FOLLOW_TARGET.attitude_q.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.FOLLOW_TARGET.attitude_q.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 53 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			
			export interface rates extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace rates {
				export class Field extends _Cursor.View implements rates, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 69 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 69, other.data_.bytes.buffer, other.data_.origin + 69, _Host.FOLLOW_TARGET.rates.item_len) === 0;
						for (let i = 0; i < _Host.FOLLOW_TARGET.rates.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.FOLLOW_TARGET.rates.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 69 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 3;
				
			}
			
			export interface position_cov extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace position_cov {
				export class Field extends _Cursor.View implements position_cov, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 81 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 81, other.data_.bytes.buffer, other.data_.origin + 81, _Host.FOLLOW_TARGET.position_cov.item_len) === 0;
						for (let i = 0; i < _Host.FOLLOW_TARGET.position_cov.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.FOLLOW_TARGET.position_cov.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 81 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 3;
				
			}
			
			
			class Impl_ extends _Cursor.View implements FOLLOW_TARGET {
				
				public timestamp(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public timestamp_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public custom_state(): number { return this.data_.bytes.getUint32(this.data_.origin + 8, true) + this.data_.bytes.getInt32(this.data_.origin + 8 + 4, true) * _Lib.JS_HI;}
				
				public custom_state_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 8, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 8 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public est_capabilities(): number { return this.data_.bytes.getInt8(this.data_.origin + 16);}
				
				public est_capabilities_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 16, src); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 17, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 17, src, true); }
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 21, true);}
				
				public lon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 21, src, true); }
				
				public alt(): number { return this.data_.bytes.getFloat32(this.data_.origin + 25, true);}
				
				public alt_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 25, src, true); }
				
				public vel(): FOLLOW_TARGET.vel {
					
					return this.data_.as_field(FOLLOW_TARGET.vel.field);
				}
				
				public vel_(src: FOLLOW_TARGET.vel | number[]): vel {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.FOLLOW_TARGET.vel.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 29 + index * 4, src[index], true);
						return this.data_.as_field(vel.field);
					}
					for (let index = 0; index < _Host.FOLLOW_TARGET.vel.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 29 + index * 4, src.get(index), true);
					
					return this.data_.as_field(vel.field);
				}
				
				public vel$(src: Iterator<number>, len: number): vel {
					let len_ = Math.min(len, _Host.FOLLOW_TARGET.vel.item_len);
					
					len = Math.min(len, _Host.FOLLOW_TARGET.vel.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 29 + index * 4, v.value, true);
						}
					return this.data_.as_field(vel.field);
				}
				
				public acc(): FOLLOW_TARGET.acc {
					
					return this.data_.as_field(FOLLOW_TARGET.acc.field);
				}
				
				public acc_(src: FOLLOW_TARGET.acc | number[]): acc {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.FOLLOW_TARGET.acc.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 41 + index * 4, src[index], true);
						return this.data_.as_field(acc.field);
					}
					for (let index = 0; index < _Host.FOLLOW_TARGET.acc.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 41 + index * 4, src.get(index), true);
					
					return this.data_.as_field(acc.field);
				}
				
				public acc$(src: Iterator<number>, len: number): acc {
					let len_ = Math.min(len, _Host.FOLLOW_TARGET.acc.item_len);
					
					len = Math.min(len, _Host.FOLLOW_TARGET.acc.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 41 + index * 4, v.value, true);
						}
					return this.data_.as_field(acc.field);
				}
				
				public attitude_q(): FOLLOW_TARGET.attitude_q {
					
					return this.data_.as_field(FOLLOW_TARGET.attitude_q.field);
				}
				
				public attitude_q_(src: FOLLOW_TARGET.attitude_q | number[]): attitude_q {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.FOLLOW_TARGET.attitude_q.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 53 + index * 4, src[index], true);
						return this.data_.as_field(attitude_q.field);
					}
					for (let index = 0; index < _Host.FOLLOW_TARGET.attitude_q.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 53 + index * 4, src.get(index), true);
					
					return this.data_.as_field(attitude_q.field);
				}
				
				public attitude_q$(src: Iterator<number>, len: number): attitude_q {
					let len_ = Math.min(len, _Host.FOLLOW_TARGET.attitude_q.item_len);
					
					len = Math.min(len, _Host.FOLLOW_TARGET.attitude_q.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 53 + index * 4, v.value, true);
						}
					return this.data_.as_field(attitude_q.field);
				}
				
				public rates(): FOLLOW_TARGET.rates {
					
					return this.data_.as_field(FOLLOW_TARGET.rates.field);
				}
				
				public rates_(src: FOLLOW_TARGET.rates | number[]): rates {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.FOLLOW_TARGET.rates.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 69 + index * 4, src[index], true);
						return this.data_.as_field(rates.field);
					}
					for (let index = 0; index < _Host.FOLLOW_TARGET.rates.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 69 + index * 4, src.get(index), true);
					
					return this.data_.as_field(rates.field);
				}
				
				public rates$(src: Iterator<number>, len: number): rates {
					let len_ = Math.min(len, _Host.FOLLOW_TARGET.rates.item_len);
					
					len = Math.min(len, _Host.FOLLOW_TARGET.rates.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 69 + index * 4, v.value, true);
						}
					return this.data_.as_field(rates.field);
				}
				
				public position_cov(): FOLLOW_TARGET.position_cov {
					
					return this.data_.as_field(FOLLOW_TARGET.position_cov.field);
				}
				
				public position_cov_(src: FOLLOW_TARGET.position_cov | number[]): position_cov {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.FOLLOW_TARGET.position_cov.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 81 + index * 4, src[index], true);
						return this.data_.as_field(position_cov.field);
					}
					for (let index = 0; index < _Host.FOLLOW_TARGET.position_cov.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 81 + index * 4, src.get(index), true);
					
					return this.data_.as_field(position_cov.field);
				}
				
				public position_cov$(src: Iterator<number>, len: number): position_cov {
					let len_ = Math.min(len, _Host.FOLLOW_TARGET.position_cov.item_len);
					
					len = Math.min(len, _Host.FOLLOW_TARGET.position_cov.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 81 + index * 4, v.value, true);
						}
					return this.data_.as_field(position_cov.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				timestamp_(src: number);
				
				est_capabilities_(src: number);
				
				lat_(src: number);
				
				lon_(src: number);
				
				alt_(src: number);
				
				vel_(src: _Host.FOLLOW_TARGET.vel);
				
				acc_(src: _Host.FOLLOW_TARGET.acc);
				
				attitude_q_(src: _Host.FOLLOW_TARGET.attitude_q);
				
				rates_(src: _Host.FOLLOW_TARGET.rates);
				
				position_cov_(src: _Host.FOLLOW_TARGET.position_cov);
				
				custom_state_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: FOLLOW_TARGET, dst: DST) {
				
				dst.timestamp_(src.timestamp());
				
				dst.est_capabilities_(src.est_capabilities());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				dst.vel_(src.vel());
				dst.acc_(src.acc());
				dst.attitude_q_(src.attitude_q());
				dst.rates_(src.rates());
				dst.position_cov_(src.position_cov());
				
				dst.custom_state_(src.custom_state());
				
			}
			
			export interface SRC_ {
				timestamp(): number;
				
				est_capabilities(): number;
				
				lat(): number;
				
				lon(): number;
				
				alt(): number;
				
				vel(dst: _Host.FOLLOW_TARGET.vel);
				
				acc(dst: _Host.FOLLOW_TARGET.acc);
				
				attitude_q(dst: _Host.FOLLOW_TARGET.attitude_q);
				
				rates(dst: _Host.FOLLOW_TARGET.rates);
				
				position_cov(dst: _Host.FOLLOW_TARGET.position_cov);
				
				custom_state(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: FOLLOW_TARGET) {
				
				dst.timestamp_(src.timestamp());
				
				dst.est_capabilities_(src.est_capabilities());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				src.vel(dst.vel());
				src.acc(dst.acc());
				src.attitude_q(dst.attitude_q());
				src.rates(dst.rates());
				src.position_cov(dst.position_cov());
				
				dst.custom_state_(src.custom_state());
				
			}
			
		}
		
		export interface HIL_STATE {
			time_usec(): number;
			
			roll(): number;
			
			pitch(): number;
			
			yaw(): number;
			
			rollspeed(): number;
			
			pitchspeed(): number;
			
			yawspeed(): number;
			
			lat(): number;
			
			lon(): number;
			
			alt(): number;
			
			vx(): number;
			
			vy(): number;
			
			vz(): number;
			
			xacc(): number;
			
			yacc(): number;
			
			zacc(): number;
			
		}
		
		export namespace HIL_STATE {
			
			export const meta_ = new _Pack.Meta(140, 0, 0, 1, 56, 448);
			
			
			class Impl_ extends _Cursor.View implements HIL_STATE {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public rollspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public pitchspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
				public yawspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 32, true);}
				
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 36, true);}
				
				
				public alt(): number { return this.data_.bytes.getInt32(this.data_.origin + 40, true);}
				
				
				public vx(): number { return this.data_.bytes.getInt16(this.data_.origin + 44, true);}
				
				
				public vy(): number { return this.data_.bytes.getInt16(this.data_.origin + 46, true);}
				
				
				public vz(): number { return this.data_.bytes.getInt16(this.data_.origin + 48, true);}
				
				
				public xacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 50, true);}
				
				
				public yacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 52, true);}
				
				
				public zacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 54, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
				rollspeed_(src: number);
				
				pitchspeed_(src: number);
				
				yawspeed_(src: number);
				
				lat_(src: number);
				
				lon_(src: number);
				
				alt_(src: number);
				
				vx_(src: number);
				
				vy_(src: number);
				
				vz_(src: number);
				
				xacc_(src: number);
				
				yacc_(src: number);
				
				zacc_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HIL_STATE, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.rollspeed_(src.rollspeed());
				
				dst.pitchspeed_(src.pitchspeed());
				
				dst.yawspeed_(src.yawspeed());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
			}
			
		}
		
		export interface HOME_POSITION {
			latitude(): number;
			
			latitude_(src: number);
			
			longitude(): number;
			
			longitude_(src: number);
			
			altitude(): number;
			
			altitude_(src: number);
			
			x(): number;
			
			x_(src: number);
			
			y(): number;
			
			y_(src: number);
			
			z(): number;
			
			z_(src: number);
			
			q(): HOME_POSITION.q;
			
			q_(src: HOME_POSITION.q | number[]);
			
			q$(src: Iterator<number>, len: number);
			
			approach_x(): number;
			
			approach_x_(src: number);
			
			approach_y(): number;
			
			approach_y_(src: number);
			
			approach_z(): number;
			
			approach_z_(src: number);
			
			time_usec(): number | null;
			
			time_usec_(src: number);
			
		}
		
		export namespace HOME_POSITION {
			
			export const meta_ = new _Pack.Meta(210, 0, 0, 0, 53, 416, 0, 1);
			
			
			export interface q extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace q {
				export class Field extends _Cursor.View implements q, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 24 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 24, other.data_.bytes.buffer, other.data_.origin + 24, _Host.HOME_POSITION.q.item_len) === 0;
						for (let i = 0; i < _Host.HOME_POSITION.q.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.HOME_POSITION.q.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 24 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			
			
			class Impl_ extends _Cursor.View implements HOME_POSITION {
				
				public latitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public latitude_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public longitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				public longitude_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 4, src, true); }
				
				public altitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 8, true);}
				
				public altitude_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 8, src, true); }
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public q(): HOME_POSITION.q {
					
					return this.data_.as_field(HOME_POSITION.q.field);
				}
				
				public q_(src: HOME_POSITION.q | number[]): q {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.HOME_POSITION.q.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 24 + index * 4, src[index], true);
						return this.data_.as_field(q.field);
					}
					for (let index = 0; index < _Host.HOME_POSITION.q.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 24 + index * 4, src.get(index), true);
					
					return this.data_.as_field(q.field);
				}
				
				public q$(src: Iterator<number>, len: number): q {
					let len_ = Math.min(len, _Host.HOME_POSITION.q.item_len);
					
					len = Math.min(len, _Host.HOME_POSITION.q.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 24 + index * 4, v.value, true);
						}
					return this.data_.as_field(q.field);
				}
				
				public approach_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				public approach_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 40, src, true); }
				
				public approach_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 44, true);}
				
				public approach_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 44, src, true); }
				
				public approach_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 48, true);}
				
				public approach_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 48, src, true); }
				
				
				public time_usec(): number | null {
					if (this.data_.field_bit != 416 && !this.data_.set_field(416, -1)) return null;
					
					return this.data_.bytes.getUint32(this.data_.BYTE, true) + this.data_.bytes.getInt32(this.data_.BYTE + 4, true) * _Lib.JS_HI;
				}
				
				
				public time_usec_(src: number) {
					if (this.data_.field_bit != 416) this.data_.set_field(416, 0);
					
					this.data_.bytes.setUint32(this.data_.BYTE, src, true);
					this.data_.bytes.setUint32(this.data_.BYTE + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				latitude_(src: number);
				
				longitude_(src: number);
				
				altitude_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				q_(src: _Host.HOME_POSITION.q);
				
				approach_x_(src: number);
				
				approach_y_(src: number);
				
				approach_z_(src: number);
				
				time_usec_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HOME_POSITION, dst: DST) {
				
				dst.latitude_(src.latitude());
				
				dst.longitude_(src.longitude());
				
				dst.altitude_(src.altitude());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				dst.q_(src.q());
				
				dst.approach_x_(src.approach_x());
				
				dst.approach_y_(src.approach_y());
				
				dst.approach_z_(src.approach_z());
				
				{
					const item = src.time_usec();
					if (item !== null) dst.time_usec_(item);
					
				}
				
			}
			
			export interface SRC_ {
				latitude(): number;
				
				longitude(): number;
				
				altitude(): number;
				
				x(): number;
				
				y(): number;
				
				z(): number;
				
				q(dst: _Host.HOME_POSITION.q);
				
				approach_x(): number;
				
				approach_y(): number;
				
				approach_z(): number;
				
				time_usec(): number | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: HOME_POSITION) {
				
				dst.latitude_(src.latitude());
				
				dst.longitude_(src.longitude());
				
				dst.altitude_(src.altitude());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				src.q(dst.q());
				
				dst.approach_x_(src.approach_x());
				
				dst.approach_y_(src.approach_y());
				
				dst.approach_z_(src.approach_z());
				{
					const item = src.time_usec();
					if (item !== null) dst.time_usec_(item);
					
				}
				
			}
			
		}
		
		export interface FENCE_STATUS {
			breach_count(): number;
			
			breach_count_(src: number);
			
			breach_time(): number;
			
			breach_time_(src: number);
			
			breach_status(): number;
			
			breach_status_(src: number);
			
			breach_type(): FENCE_BREACH | null;
			
			breach_type_(src: FENCE_BREACH);
			
		}
		
		export namespace FENCE_STATUS {
			
			export const meta_ = new _Pack.Meta(93, 1, 1, 0, 8, 56, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements FENCE_STATUS {
				
				public breach_count(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public breach_count_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public breach_time(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public breach_time_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public breach_status(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				public breach_status_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 6, src); }
				
				
				public breach_type(): FENCE_BREACH | null {
					if (this.data_.field_bit != 56 && !this.data_.set_field(56, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 2);
				}
				
				
				public breach_type_(src: FENCE_BREACH) {
					if (this.data_.field_bit != 56) this.data_.set_field(56, 0);
					
					_Lib.set_bits(src, 2, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				breach_status_(src: number);
				
				breach_count_(src: number);
				
				breach_type_(src: _Host.FENCE_BREACH);
				
				breach_time_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: FENCE_STATUS, dst: DST) {
				
				dst.breach_status_(src.breach_status());
				
				dst.breach_count_(src.breach_count());
				
				{
					const item = src.breach_type();
					if (item !== null) dst.breach_type_(item);
					
				}
				
				dst.breach_time_(src.breach_time());
				
			}
			
			export interface SRC_ {
				breach_status(): number;
				
				breach_count(): number;
				
				breach_type(): _Host.FENCE_BREACH | null;
				
				breach_time(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: FENCE_STATUS) {
				
				dst.breach_status_(src.breach_status());
				
				dst.breach_count_(src.breach_count());
				{
					const item = src.breach_type();
					if (item !== null) dst.breach_type_(item);
					
				}
				
				dst.breach_time_(src.breach_time());
				
			}
			
		}
		
		export interface REMOTE_LOG_BLOCK_STATUS {
			seqno(): number;
			
			seqno_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			status(): MAV_REMOTE_LOG_DATA_BLOCK_STATUSES | null;
			
			status_(src: MAV_REMOTE_LOG_DATA_BLOCK_STATUSES);
			
		}
		
		export namespace REMOTE_LOG_BLOCK_STATUS {
			
			export const meta_ = new _Pack.Meta(171, 0, 1, 0, 7, 48, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements REMOTE_LOG_BLOCK_STATUS {
				
				public seqno(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public seqno_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				
				public status(): MAV_REMOTE_LOG_DATA_BLOCK_STATUSES | null {
					if (this.data_.field_bit != 48 && !this.data_.set_field(48, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 1);
				}
				
				
				public status_(src: MAV_REMOTE_LOG_DATA_BLOCK_STATUSES) {
					if (this.data_.field_bit != 48) this.data_.set_field(48, 0);
					
					_Lib.set_bits(src, 1, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				seqno_(src: number);
				
				status_(src: _Host.MAV_REMOTE_LOG_DATA_BLOCK_STATUSES);
				
			}
			
			export function push_<DST extends DST_>(src: REMOTE_LOG_BLOCK_STATUS, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.seqno_(src.seqno());
				
				{
					const item = src.status();
					if (item !== null) dst.status_(item);
					
				}
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				seqno(): number;
				
				status(): _Host.MAV_REMOTE_LOG_DATA_BLOCK_STATUSES | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: REMOTE_LOG_BLOCK_STATUS) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.seqno_(src.seqno());
				{
					const item = src.status();
					if (item !== null) dst.status_(item);
					
				}
				
			}
			
		}
		
		export interface OBSTACLE_DISTANCE {
			distances(): OBSTACLE_DISTANCE.distances;
			
			distances_(src: OBSTACLE_DISTANCE.distances | number[]);
			
			distances$(src: Iterator<number>, len: number);
			
			min_distance(): number;
			
			min_distance_(src: number);
			
			max_distance(): number;
			
			max_distance_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			increment(): number;
			
			increment_(src: number);
			
			sensor_type(): MAV_DISTANCE_SENSOR | null;
			
			sensor_type_(src: MAV_DISTANCE_SENSOR);
			
		}
		
		export namespace OBSTACLE_DISTANCE {
			
			export const meta_ = new _Pack.Meta(66, 74, 0, 1, 158, 1256, 0, 1);
			
			
			export interface distances extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace distances {
				export class Field extends _Cursor.View implements distances, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt16(this.data_.origin + 0 + index * 2, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 0, other.data_.bytes.buffer, other.data_.origin + 0, _Host.OBSTACLE_DISTANCE.distances.item_len) === 0;
						for (let i = 0; i < _Host.OBSTACLE_DISTANCE.distances.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.OBSTACLE_DISTANCE.distances.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt16(this.data_.origin + 0 + index * 2, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 72;
				
			}
			
			
			class Impl_ extends _Cursor.View implements OBSTACLE_DISTANCE {
				
				public distances(): OBSTACLE_DISTANCE.distances {
					
					return this.data_.as_field(OBSTACLE_DISTANCE.distances.field);
				}
				
				public distances_(src: OBSTACLE_DISTANCE.distances | number[]): distances {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.OBSTACLE_DISTANCE.distances.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt16(this.data_.origin + 0 + index * 2, src[index], true);
						return this.data_.as_field(distances.field);
					}
					for (let index = 0; index < _Host.OBSTACLE_DISTANCE.distances.item_len; index++)
						this.data_.bytes.setInt16(this.data_.origin + 0 + index * 2, src.get(index), true);
					
					return this.data_.as_field(distances.field);
				}
				
				public distances$(src: Iterator<number>, len: number): distances {
					let len_ = Math.min(len, _Host.OBSTACLE_DISTANCE.distances.item_len);
					
					len = Math.min(len, _Host.OBSTACLE_DISTANCE.distances.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt16(this.data_.origin + 0 + index * 2, v.value, true);
						}
					return this.data_.as_field(distances.field);
				}
				
				public min_distance(): number { return this.data_.bytes.getInt16(this.data_.origin + 144, true);}
				
				public min_distance_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 144, src, true); }
				
				public max_distance(): number { return this.data_.bytes.getInt16(this.data_.origin + 146, true);}
				
				public max_distance_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 146, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 148, true) + this.data_.bytes.getInt32(this.data_.origin + 148 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 148, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 148 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public increment(): number { return this.data_.bytes.getInt8(this.data_.origin + 156);}
				
				public increment_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 156, src); }
				
				
				public sensor_type(): MAV_DISTANCE_SENSOR | null {
					if (this.data_.field_bit != 1256 && !this.data_.set_field(1256, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public sensor_type_(src: MAV_DISTANCE_SENSOR) {
					if (this.data_.field_bit != 1256) this.data_.set_field(1256, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				sensor_type_(src: _Host.MAV_DISTANCE_SENSOR);
				
				distances_(src: _Host.OBSTACLE_DISTANCE.distances);
				
				increment_(src: number);
				
				min_distance_(src: number);
				
				max_distance_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: OBSTACLE_DISTANCE, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				{
					const item = src.sensor_type();
					if (item !== null) dst.sensor_type_(item);
					
				}
				dst.distances_(src.distances());
				
				dst.increment_(src.increment());
				
				dst.min_distance_(src.min_distance());
				
				dst.max_distance_(src.max_distance());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				sensor_type(): _Host.MAV_DISTANCE_SENSOR | null;
				
				distances(dst: _Host.OBSTACLE_DISTANCE.distances);
				
				increment(): number;
				
				min_distance(): number;
				
				max_distance(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: OBSTACLE_DISTANCE) {
				
				dst.time_usec_(src.time_usec());
				{
					const item = src.sensor_type();
					if (item !== null) dst.sensor_type_(item);
					
				}
				src.distances(dst.distances());
				
				dst.increment_(src.increment());
				
				dst.min_distance_(src.min_distance());
				
				dst.max_distance_(src.max_distance());
				
			}
			
		}
		
		export interface GPS2_RAW {
			eph(): number;
			
			eph_(src: number);
			
			epv(): number;
			
			epv_(src: number);
			
			vel(): number;
			
			vel_(src: number);
			
			cog(): number;
			
			cog_(src: number);
			
			dgps_age(): number;
			
			dgps_age_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
			alt(): number;
			
			alt_(src: number);
			
			satellites_visible(): number;
			
			satellites_visible_(src: number);
			
			dgps_numch(): number;
			
			dgps_numch_(src: number);
			
			fix_type(): GPS_FIX_TYPE | null;
			
			fix_type_(src: GPS_FIX_TYPE);
			
		}
		
		export namespace GPS2_RAW {
			
			export const meta_ = new _Pack.Meta(213, 4, 1, 1, 35, 272, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements GPS2_RAW {
				
				public eph(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public eph_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public epv(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public epv_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public vel(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public vel_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public cog(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				public cog_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 6, src, true); }
				
				public dgps_age(): number { return this.data_.bytes.getInt32(this.data_.origin + 8, true);}
				
				public dgps_age_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 8, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 12, true) + this.data_.bytes.getInt32(this.data_.origin + 12 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 12, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 12 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 20, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 20, src, true); }
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 24, true);}
				
				public lon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 24, src, true); }
				
				public alt(): number { return this.data_.bytes.getInt32(this.data_.origin + 28, true);}
				
				public alt_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 28, src, true); }
				
				public satellites_visible(): number { return this.data_.bytes.getInt8(this.data_.origin + 32);}
				
				public satellites_visible_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 32, src); }
				
				public dgps_numch(): number { return this.data_.bytes.getInt8(this.data_.origin + 33);}
				
				public dgps_numch_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 33, src); }
				
				
				public fix_type(): GPS_FIX_TYPE | null {
					if (this.data_.field_bit != 272 && !this.data_.set_field(272, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public fix_type_(src: GPS_FIX_TYPE) {
					if (this.data_.field_bit != 272) this.data_.set_field(272, 0);
					
					_Lib.set_bits(src, 4, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				fix_type_(src: _Host.GPS_FIX_TYPE);
				
				lat_(src: number);
				
				lon_(src: number);
				
				alt_(src: number);
				
				eph_(src: number);
				
				epv_(src: number);
				
				vel_(src: number);
				
				cog_(src: number);
				
				satellites_visible_(src: number);
				
				dgps_numch_(src: number);
				
				dgps_age_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: GPS2_RAW, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				{
					const item = src.fix_type();
					if (item !== null) dst.fix_type_(item);
					
				}
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.eph_(src.eph());
				
				dst.epv_(src.epv());
				
				dst.vel_(src.vel());
				
				dst.cog_(src.cog());
				
				dst.satellites_visible_(src.satellites_visible());
				
				dst.dgps_numch_(src.dgps_numch());
				
				dst.dgps_age_(src.dgps_age());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				fix_type(): _Host.GPS_FIX_TYPE | null;
				
				lat(): number;
				
				lon(): number;
				
				alt(): number;
				
				eph(): number;
				
				epv(): number;
				
				vel(): number;
				
				cog(): number;
				
				satellites_visible(): number;
				
				dgps_numch(): number;
				
				dgps_age(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GPS2_RAW) {
				
				dst.time_usec_(src.time_usec());
				{
					const item = src.fix_type();
					if (item !== null) dst.fix_type_(item);
					
				}
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.eph_(src.eph());
				
				dst.epv_(src.epv());
				
				dst.vel_(src.vel());
				
				dst.cog_(src.cog());
				
				dst.satellites_visible_(src.satellites_visible());
				
				dst.dgps_numch_(src.dgps_numch());
				
				dst.dgps_age_(src.dgps_age());
				
			}
			
		}
		
		export interface REQUEST_DATA_STREAM {
			req_message_rate(): number;
			
			target_system(): number;
			
			target_component(): number;
			
			req_stream_id(): number;
			
			start_stop(): number;
			
		}
		
		export namespace REQUEST_DATA_STREAM {
			
			export const meta_ = new _Pack.Meta(98, 1, 0, 0, 6, 48);
			
			
			class Impl_ extends _Cursor.View implements REQUEST_DATA_STREAM {
				
				public req_message_rate(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				
				public req_stream_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				
				public start_stop(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				req_stream_id_(src: number);
				
				req_message_rate_(src: number);
				
				start_stop_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: REQUEST_DATA_STREAM, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.req_stream_id_(src.req_stream_id());
				
				dst.req_message_rate_(src.req_message_rate());
				
				dst.start_stop_(src.start_stop());
				
			}
			
		}
		
		export interface MEMORY_VECT {
			address(): number;
			
			address_(src: number);
			
			ver(): number;
			
			ver_(src: number);
			
			typE(): number;
			
			typE_(src: number);
			
			value(): MEMORY_VECT.value;
			
			value_(src: MEMORY_VECT.value | number[]);
			
			value$(src: Iterator<number>, len: number);
			
		}
		
		export namespace MEMORY_VECT {
			
			export const meta_ = new _Pack.Meta(30, 1, 0, 0, 36, 288);
			
			
			export interface value extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace value {
				export class Field extends _Cursor.View implements value, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 4 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 4, other.data_.bytes.buffer, other.data_.origin + 4, _Host.MEMORY_VECT.value.item_len) === 0;
						for (let i = 0; i < _Host.MEMORY_VECT.value.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.MEMORY_VECT.value.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 4 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 32;
				
			}
			
			
			class Impl_ extends _Cursor.View implements MEMORY_VECT {
				
				public address(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public address_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public ver(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public ver_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public typE(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public typE_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
				public value(): MEMORY_VECT.value {
					
					return this.data_.as_field(MEMORY_VECT.value.field);
				}
				
				public value_(src: MEMORY_VECT.value | number[]): value {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.MEMORY_VECT.value.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 4 + index, src[index]);
						return this.data_.as_field(value.field);
					}
					for (let index = 0; index < _Host.MEMORY_VECT.value.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 4 + index, src.get(index));
					
					return this.data_.as_field(value.field);
				}
				
				public value$(src: Iterator<number>, len: number): value {
					let len_ = Math.min(len, _Host.MEMORY_VECT.value.item_len);
					
					len = Math.min(len, _Host.MEMORY_VECT.value.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 4 + index, v.value);
						}
					return this.data_.as_field(value.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				address_(src: number);
				
				ver_(src: number);
				
				typE_(src: number);
				
				value_(src: _Host.MEMORY_VECT.value);
				
			}
			
			export function push_<DST extends DST_>(src: MEMORY_VECT, dst: DST) {
				
				dst.address_(src.address());
				
				dst.ver_(src.ver());
				
				dst.typE_(src.typE());
				dst.value_(src.value());
				
			}
			
			export interface SRC_ {
				address(): number;
				
				ver(): number;
				
				typE(): number;
				
				value(dst: _Host.MEMORY_VECT.value);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: MEMORY_VECT) {
				
				dst.address_(src.address());
				
				dst.ver_(src.ver());
				
				dst.typE_(src.typE());
				src.value(dst.value());
				
			}
			
		}
		
		export interface PARAM_EXT_REQUEST_READ {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			param_index(): number;
			
			param_index_(src: number);
			
			param_id(): _Cursor.UTF8 | null;
			
			param_id_(src: string | Uint8Array): _Cursor.UTF8;
			
			param_id$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace PARAM_EXT_REQUEST_READ {
			
			export const meta_ = new _Pack.Meta(90, 0, 0, 0, 5, 34, 2, 1);
			
			
			export namespace param_id {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements PARAM_EXT_REQUEST_READ {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public param_index(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public param_index_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				
				param_id(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 34 && !this.data_.set_field(34, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				param_id_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -34 - 1);
					
					let len = Math.min(src.byteLength, _Host.PARAM_EXT_REQUEST_READ.param_id.item_len_max);
					this.data_.set_field(34, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				param_id$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.PARAM_EXT_REQUEST_READ.param_id.item_len_max)
					this.data_.set_field(34, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				param_id_(src: _Cursor.UTF8);
				
				param_index_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: PARAM_EXT_REQUEST_READ, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
					
				}
				
				dst.param_index_(src.param_index());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				param_id(): string | Uint8Array | null;
				
				param_index(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: PARAM_EXT_REQUEST_READ) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
				}
				
				
				dst.param_index_(src.param_index());
				
			}
			
		}
		
		export interface HIL_CONTROLS {
			time_usec(): number;
			
			roll_ailerons(): number;
			
			pitch_elevator(): number;
			
			yaw_rudder(): number;
			
			throttle(): number;
			
			aux1(): number;
			
			aux2(): number;
			
			aux3(): number;
			
			aux4(): number;
			
			nav_mode(): number;
			
			mode(): MAV_MODE | null;
			
		}
		
		export namespace HIL_CONTROLS {
			
			export const meta_ = new _Pack.Meta(82, 0, 0, 1, 42, 328, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements HIL_CONTROLS {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				
				public roll_ailerons(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public pitch_elevator(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public yaw_rudder(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public throttle(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public aux1(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
				public aux2(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				
				public aux3(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				
				public aux4(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				
				public nav_mode(): number { return this.data_.bytes.getInt8(this.data_.origin + 40);}
				
				
				public mode(): MAV_MODE | null {
					if (this.data_.field_bit != 328 && !this.data_.set_field(328, -1)) return null;
					
					return _Host.MAV_MODE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 4));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				roll_ailerons_(src: number);
				
				pitch_elevator_(src: number);
				
				yaw_rudder_(src: number);
				
				throttle_(src: number);
				
				aux1_(src: number);
				
				aux2_(src: number);
				
				aux3_(src: number);
				
				aux4_(src: number);
				
				mode_(src: _Host.MAV_MODE);
				
				nav_mode_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HIL_CONTROLS, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.roll_ailerons_(src.roll_ailerons());
				
				dst.pitch_elevator_(src.pitch_elevator());
				
				dst.yaw_rudder_(src.yaw_rudder());
				
				dst.throttle_(src.throttle());
				
				dst.aux1_(src.aux1());
				
				dst.aux2_(src.aux2());
				
				dst.aux3_(src.aux3());
				
				dst.aux4_(src.aux4());
				
				{
					const item = src.mode();
					if (item !== null) dst.mode_(item);
					
				}
				
				dst.nav_mode_(src.nav_mode());
				
			}
			
		}
		
		export interface HIL_SENSOR {
			fields_updated(): number;
			
			fields_updated_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			xacc(): number;
			
			xacc_(src: number);
			
			yacc(): number;
			
			yacc_(src: number);
			
			zacc(): number;
			
			zacc_(src: number);
			
			xgyro(): number;
			
			xgyro_(src: number);
			
			ygyro(): number;
			
			ygyro_(src: number);
			
			zgyro(): number;
			
			zgyro_(src: number);
			
			xmag(): number;
			
			xmag_(src: number);
			
			ymag(): number;
			
			ymag_(src: number);
			
			zmag(): number;
			
			zmag_(src: number);
			
			abs_pressure(): number;
			
			abs_pressure_(src: number);
			
			diff_pressure(): number;
			
			diff_pressure_(src: number);
			
			pressure_alt(): number;
			
			pressure_alt_(src: number);
			
			temperature(): number;
			
			temperature_(src: number);
			
		}
		
		export namespace HIL_SENSOR {
			
			export const meta_ = new _Pack.Meta(169, 0, 1, 1, 64, 512);
			
			
			class Impl_ extends _Cursor.View implements HIL_SENSOR {
				
				public fields_updated(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public fields_updated_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 4, true) + this.data_.bytes.getInt32(this.data_.origin + 4 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 4, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 4 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public xacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public xacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public yacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public yacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public zacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public zacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public xgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public xgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public ygyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public ygyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public zgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public zgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public xmag(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				public xmag_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 36, src, true); }
				
				public ymag(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				public ymag_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 40, src, true); }
				
				public zmag(): number { return this.data_.bytes.getFloat32(this.data_.origin + 44, true);}
				
				public zmag_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 44, src, true); }
				
				public abs_pressure(): number { return this.data_.bytes.getFloat32(this.data_.origin + 48, true);}
				
				public abs_pressure_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 48, src, true); }
				
				public diff_pressure(): number { return this.data_.bytes.getFloat32(this.data_.origin + 52, true);}
				
				public diff_pressure_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 52, src, true); }
				
				public pressure_alt(): number { return this.data_.bytes.getFloat32(this.data_.origin + 56, true);}
				
				public pressure_alt_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 56, src, true); }
				
				public temperature(): number { return this.data_.bytes.getFloat32(this.data_.origin + 60, true);}
				
				public temperature_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 60, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				xacc_(src: number);
				
				yacc_(src: number);
				
				zacc_(src: number);
				
				xgyro_(src: number);
				
				ygyro_(src: number);
				
				zgyro_(src: number);
				
				xmag_(src: number);
				
				ymag_(src: number);
				
				zmag_(src: number);
				
				abs_pressure_(src: number);
				
				diff_pressure_(src: number);
				
				pressure_alt_(src: number);
				
				temperature_(src: number);
				
				fields_updated_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HIL_SENSOR, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.xmag_(src.xmag());
				
				dst.ymag_(src.ymag());
				
				dst.zmag_(src.zmag());
				
				dst.abs_pressure_(src.abs_pressure());
				
				dst.diff_pressure_(src.diff_pressure());
				
				dst.pressure_alt_(src.pressure_alt());
				
				dst.temperature_(src.temperature());
				
				dst.fields_updated_(src.fields_updated());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				xacc(): number;
				
				yacc(): number;
				
				zacc(): number;
				
				xgyro(): number;
				
				ygyro(): number;
				
				zgyro(): number;
				
				xmag(): number;
				
				ymag(): number;
				
				zmag(): number;
				
				abs_pressure(): number;
				
				diff_pressure(): number;
				
				pressure_alt(): number;
				
				temperature(): number;
				
				fields_updated(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: HIL_SENSOR) {
				
				dst.time_usec_(src.time_usec());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.xmag_(src.xmag());
				
				dst.ymag_(src.ymag());
				
				dst.zmag_(src.zmag());
				
				dst.abs_pressure_(src.abs_pressure());
				
				dst.diff_pressure_(src.diff_pressure());
				
				dst.pressure_alt_(src.pressure_alt());
				
				dst.temperature_(src.temperature());
				
				dst.fields_updated_(src.fields_updated());
				
			}
			
		}
		
		export interface SETUP_SIGNING {
			initial_timestamp(): number;
			
			initial_timestamp_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			secret_key(): SETUP_SIGNING.secret_key;
			
			secret_key_(src: SETUP_SIGNING.secret_key | number[]);
			
			secret_key$(src: Iterator<number>, len: number);
			
		}
		
		export namespace SETUP_SIGNING {
			
			export const meta_ = new _Pack.Meta(205, 0, 0, 1, 42, 336);
			
			
			export interface secret_key extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace secret_key {
				export class Field extends _Cursor.View implements secret_key, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 10 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 10, other.data_.bytes.buffer, other.data_.origin + 10, _Host.SETUP_SIGNING.secret_key.item_len) === 0;
						for (let i = 0; i < _Host.SETUP_SIGNING.secret_key.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.SETUP_SIGNING.secret_key.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 10 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 32;
				
			}
			
			
			class Impl_ extends _Cursor.View implements SETUP_SIGNING {
				
				public initial_timestamp(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public initial_timestamp_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 9);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 9, src); }
				
				public secret_key(): SETUP_SIGNING.secret_key {
					
					return this.data_.as_field(SETUP_SIGNING.secret_key.field);
				}
				
				public secret_key_(src: SETUP_SIGNING.secret_key | number[]): secret_key {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.SETUP_SIGNING.secret_key.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 10 + index, src[index]);
						return this.data_.as_field(secret_key.field);
					}
					for (let index = 0; index < _Host.SETUP_SIGNING.secret_key.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 10 + index, src.get(index));
					
					return this.data_.as_field(secret_key.field);
				}
				
				public secret_key$(src: Iterator<number>, len: number): secret_key {
					let len_ = Math.min(len, _Host.SETUP_SIGNING.secret_key.item_len);
					
					len = Math.min(len, _Host.SETUP_SIGNING.secret_key.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 10 + index, v.value);
						}
					return this.data_.as_field(secret_key.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				secret_key_(src: _Host.SETUP_SIGNING.secret_key);
				
				initial_timestamp_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SETUP_SIGNING, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				dst.secret_key_(src.secret_key());
				
				dst.initial_timestamp_(src.initial_timestamp());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				secret_key(dst: _Host.SETUP_SIGNING.secret_key);
				
				initial_timestamp(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SETUP_SIGNING) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				src.secret_key(dst.secret_key());
				
				dst.initial_timestamp_(src.initial_timestamp());
				
			}
			
		}
		
		export interface GPS_RTK {
			wn(): number;
			
			wn_(src: number);
			
			time_last_baseline_ms(): number;
			
			time_last_baseline_ms_(src: number);
			
			tow(): number;
			
			tow_(src: number);
			
			accuracy(): number;
			
			accuracy_(src: number);
			
			rtk_receiver_id(): number;
			
			rtk_receiver_id_(src: number);
			
			rtk_health(): number;
			
			rtk_health_(src: number);
			
			rtk_rate(): number;
			
			rtk_rate_(src: number);
			
			nsats(): number;
			
			nsats_(src: number);
			
			baseline_coords_type(): number;
			
			baseline_coords_type_(src: number);
			
			baseline_a_mm(): number;
			
			baseline_a_mm_(src: number);
			
			baseline_b_mm(): number;
			
			baseline_b_mm_(src: number);
			
			baseline_c_mm(): number;
			
			baseline_c_mm_(src: number);
			
			iar_num_hypotheses(): number;
			
			iar_num_hypotheses_(src: number);
			
		}
		
		export namespace GPS_RTK {
			
			export const meta_ = new _Pack.Meta(89, 1, 3, 0, 35, 280);
			
			
			class Impl_ extends _Cursor.View implements GPS_RTK {
				
				public wn(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public wn_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public time_last_baseline_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public time_last_baseline_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public tow(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public tow_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public accuracy(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public accuracy_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
				public rtk_receiver_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 14);}
				
				public rtk_receiver_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 14, src); }
				
				public rtk_health(): number { return this.data_.bytes.getInt8(this.data_.origin + 15);}
				
				public rtk_health_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 15, src); }
				
				public rtk_rate(): number { return this.data_.bytes.getInt8(this.data_.origin + 16);}
				
				public rtk_rate_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 16, src); }
				
				public nsats(): number { return this.data_.bytes.getInt8(this.data_.origin + 17);}
				
				public nsats_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 17, src); }
				
				public baseline_coords_type(): number { return this.data_.bytes.getInt8(this.data_.origin + 18);}
				
				public baseline_coords_type_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 18, src); }
				
				public baseline_a_mm(): number { return this.data_.bytes.getInt32(this.data_.origin + 19, true);}
				
				public baseline_a_mm_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 19, src, true); }
				
				public baseline_b_mm(): number { return this.data_.bytes.getInt32(this.data_.origin + 23, true);}
				
				public baseline_b_mm_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 23, src, true); }
				
				public baseline_c_mm(): number { return this.data_.bytes.getInt32(this.data_.origin + 27, true);}
				
				public baseline_c_mm_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 27, src, true); }
				
				public iar_num_hypotheses(): number { return this.data_.bytes.getInt32(this.data_.origin + 31, true);}
				
				public iar_num_hypotheses_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 31, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_last_baseline_ms_(src: number);
				
				rtk_receiver_id_(src: number);
				
				wn_(src: number);
				
				tow_(src: number);
				
				rtk_health_(src: number);
				
				rtk_rate_(src: number);
				
				nsats_(src: number);
				
				baseline_coords_type_(src: number);
				
				baseline_a_mm_(src: number);
				
				baseline_b_mm_(src: number);
				
				baseline_c_mm_(src: number);
				
				accuracy_(src: number);
				
				iar_num_hypotheses_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: GPS_RTK, dst: DST) {
				
				dst.time_last_baseline_ms_(src.time_last_baseline_ms());
				
				dst.rtk_receiver_id_(src.rtk_receiver_id());
				
				dst.wn_(src.wn());
				
				dst.tow_(src.tow());
				
				dst.rtk_health_(src.rtk_health());
				
				dst.rtk_rate_(src.rtk_rate());
				
				dst.nsats_(src.nsats());
				
				dst.baseline_coords_type_(src.baseline_coords_type());
				
				dst.baseline_a_mm_(src.baseline_a_mm());
				
				dst.baseline_b_mm_(src.baseline_b_mm());
				
				dst.baseline_c_mm_(src.baseline_c_mm());
				
				dst.accuracy_(src.accuracy());
				
				dst.iar_num_hypotheses_(src.iar_num_hypotheses());
				
			}
			
			export interface SRC_ {
				time_last_baseline_ms(): number;
				
				rtk_receiver_id(): number;
				
				wn(): number;
				
				tow(): number;
				
				rtk_health(): number;
				
				rtk_rate(): number;
				
				nsats(): number;
				
				baseline_coords_type(): number;
				
				baseline_a_mm(): number;
				
				baseline_b_mm(): number;
				
				baseline_c_mm(): number;
				
				accuracy(): number;
				
				iar_num_hypotheses(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GPS_RTK) {
				
				dst.time_last_baseline_ms_(src.time_last_baseline_ms());
				
				dst.rtk_receiver_id_(src.rtk_receiver_id());
				
				dst.wn_(src.wn());
				
				dst.tow_(src.tow());
				
				dst.rtk_health_(src.rtk_health());
				
				dst.rtk_rate_(src.rtk_rate());
				
				dst.nsats_(src.nsats());
				
				dst.baseline_coords_type_(src.baseline_coords_type());
				
				dst.baseline_a_mm_(src.baseline_a_mm());
				
				dst.baseline_b_mm_(src.baseline_b_mm());
				
				dst.baseline_c_mm_(src.baseline_c_mm());
				
				dst.accuracy_(src.accuracy());
				
				dst.iar_num_hypotheses_(src.iar_num_hypotheses());
				
			}
			
		}
		
		export interface PARAM_REQUEST_LIST {
			target_system(): number;
			
			target_component(): number;
			
		}
		
		export namespace PARAM_REQUEST_LIST {
			
			export const meta_ = new _Pack.Meta(47, 0, 0, 0, 2, 16);
			
			
			class Impl_ extends _Cursor.View implements PARAM_REQUEST_LIST {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: PARAM_REQUEST_LIST, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
			}
			
		}
		
		export interface UAVIONIX_ADSB_OUT_CFG {
			stallSpeed(): number;
			
			stallSpeed_(src: number);
			
			ICAO(): number;
			
			ICAO_(src: number);
			
			callsign(): _Cursor.UTF8 | null;
			
			callsign_(src: string | Uint8Array): _Cursor.UTF8;
			
			callsign$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
			emitterType(): ADSB_EMITTER_TYPE | null;
			
			emitterType_(src: ADSB_EMITTER_TYPE);
			
			aircraftSize(): UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE | null;
			
			aircraftSize_(src: UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE);
			
			gpsOffsetLat(): UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT | null;
			
			gpsOffsetLat_(src: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT);
			
			gpsOffsetLon(): UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON | null;
			
			gpsOffsetLon_(src: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON);
			
			rfSelect(): UAVIONIX_ADSB_OUT_RF_SELECT | null;
			
			rfSelect_(src: UAVIONIX_ADSB_OUT_RF_SELECT);
			
		}
		
		export namespace UAVIONIX_ADSB_OUT_CFG {
			
			export const meta_ = new _Pack.Meta(84, 1, 1, 0, 7, 51, 3, 6);
			
			
			export namespace callsign {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements UAVIONIX_ADSB_OUT_CFG {
				
				public stallSpeed(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public stallSpeed_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public ICAO(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public ICAO_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				
				callsign(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 51 && !this.data_.set_field(51, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				callsign_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -51 - 1);
					
					let len = Math.min(src.byteLength, _Host.UAVIONIX_ADSB_OUT_CFG.callsign.item_len_max);
					this.data_.set_field(51, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				callsign$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.UAVIONIX_ADSB_OUT_CFG.callsign.item_len_max)
					this.data_.set_field(51, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
				public emitterType(): ADSB_EMITTER_TYPE | null {
					if (this.data_.field_bit != 52 && !this.data_.set_field(52, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 5);
				}
				
				
				public emitterType_(src: ADSB_EMITTER_TYPE) {
					if (this.data_.field_bit != 52) this.data_.set_field(52, 0);
					
					_Lib.set_bits(src, 5, this.data_.bytes, this.data_.BIT);
				}
				
				
				public aircraftSize(): UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE | null {
					if (this.data_.field_bit != 53 && !this.data_.set_field(53, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public aircraftSize_(src: UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE) {
					if (this.data_.field_bit != 53) this.data_.set_field(53, 0);
					
					_Lib.set_bits(src, 4, this.data_.bytes, this.data_.BIT);
				}
				
				
				public gpsOffsetLat(): UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT | null {
					if (this.data_.field_bit != 54 && !this.data_.set_field(54, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public gpsOffsetLat_(src: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT) {
					if (this.data_.field_bit != 54) this.data_.set_field(54, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				public gpsOffsetLon(): UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON | null {
					if (this.data_.field_bit != 55 && !this.data_.set_field(55, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 1);
				}
				
				
				public gpsOffsetLon_(src: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON) {
					if (this.data_.field_bit != 55) this.data_.set_field(55, 0);
					
					_Lib.set_bits(src, 1, this.data_.bytes, this.data_.BIT);
				}
				
				
				public rfSelect(): UAVIONIX_ADSB_OUT_RF_SELECT | null {
					if (this.data_.field_bit != 56 && !this.data_.set_field(56, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 2);
				}
				
				
				public rfSelect_(src: UAVIONIX_ADSB_OUT_RF_SELECT) {
					if (this.data_.field_bit != 56) this.data_.set_field(56, 0);
					
					_Lib.set_bits(src, 2, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				ICAO_(src: number);
				
				callsign_(src: _Cursor.UTF8);
				
				emitterType_(src: _Host.ADSB_EMITTER_TYPE);
				
				aircraftSize_(src: _Host.UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE);
				
				gpsOffsetLat_(src: _Host.UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT);
				
				gpsOffsetLon_(src: _Host.UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON);
				
				stallSpeed_(src: number);
				
				rfSelect_(src: _Host.UAVIONIX_ADSB_OUT_RF_SELECT);
				
			}
			
			export function push_<DST extends DST_>(src: UAVIONIX_ADSB_OUT_CFG, dst: DST) {
				
				dst.ICAO_(src.ICAO());
				
				{
					const item = src.callsign();
					if (item !== null) dst.callsign_(item);
					
				}
				
				{
					const item = src.emitterType();
					if (item !== null) dst.emitterType_(item);
					
				}
				
				{
					const item = src.aircraftSize();
					if (item !== null) dst.aircraftSize_(item);
					
				}
				
				{
					const item = src.gpsOffsetLat();
					if (item !== null) dst.gpsOffsetLat_(item);
					
				}
				
				{
					const item = src.gpsOffsetLon();
					if (item !== null) dst.gpsOffsetLon_(item);
					
				}
				
				dst.stallSpeed_(src.stallSpeed());
				
				{
					const item = src.rfSelect();
					if (item !== null) dst.rfSelect_(item);
					
				}
				
			}
			
			export interface SRC_ {
				ICAO(): number;
				
				callsign(): string | Uint8Array | null;
				
				emitterType(): _Host.ADSB_EMITTER_TYPE | null;
				
				aircraftSize(): _Host.UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE | null;
				
				gpsOffsetLat(): _Host.UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT | null;
				
				gpsOffsetLon(): _Host.UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON | null;
				
				stallSpeed(): number;
				
				rfSelect(): _Host.UAVIONIX_ADSB_OUT_RF_SELECT | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: UAVIONIX_ADSB_OUT_CFG) {
				
				dst.ICAO_(src.ICAO());
				
				
				{
					const item = src.callsign();
					if (item !== null) dst.callsign_(item);
				}
				
				{
					const item = src.emitterType();
					if (item !== null) dst.emitterType_(item);
					
				}
				{
					const item = src.aircraftSize();
					if (item !== null) dst.aircraftSize_(item);
					
				}
				{
					const item = src.gpsOffsetLat();
					if (item !== null) dst.gpsOffsetLat_(item);
					
				}
				{
					const item = src.gpsOffsetLon();
					if (item !== null) dst.gpsOffsetLon_(item);
					
				}
				
				dst.stallSpeed_(src.stallSpeed());
				{
					const item = src.rfSelect();
					if (item !== null) dst.rfSelect_(item);
					
				}
				
			}
			
		}
		
		export interface LANDING_TARGET {
			time_usec(): number;
			
			time_usec_(src: number);
			
			target_num(): number;
			
			target_num_(src: number);
			
			angle_x(): number;
			
			angle_x_(src: number);
			
			angle_y(): number;
			
			angle_y_(src: number);
			
			distance(): number;
			
			distance_(src: number);
			
			size_x(): number;
			
			size_x_(src: number);
			
			size_y(): number;
			
			size_y_(src: number);
			
			frame(): MAV_FRAME | null;
			
			frame_(src: MAV_FRAME);
			
			x(): number | null;
			
			x_(src: number);
			
			y(): number | null;
			
			y_(src: number);
			
			z(): number | null;
			
			z_(src: number);
			
			q_(src: number, d0: number);
			
			q(): LANDING_TARGET.q | null;
			
			typE(): LANDING_TARGET_TYPE | null;
			
			typE_(src: LANDING_TARGET_TYPE);
			
			position_valid(): number | null;
			
			position_valid_(src: number);
			
		}
		
		export namespace LANDING_TARGET {
			
			export const meta_ = new _Pack.Meta(172, 0, 0, 1, 30, 235, 3, 7);
			
			
			export interface q {
				enumerate(dst: (item: number, d0?: number) => void);
				
				get(d0: number): number | null;
				
			}
			
			export namespace q {
				class Field extends _Cursor.View implements q {
					
					
					enumerate(dst: (item: number, d0?: number) => void) {
						for (let d0 = 0; d0 < _Host.LANDING_TARGET.q.d0; d0++)
							
							if (this.data_.set_item(d0, -1)) dst(this.data_.bytes.getFloat32(this.data_.BYTE, true), d0);
					}
					
					
					public get(d0: number): number | null {
						if (!this.data_.set_item(d0, -1)) return null;
						
						return this.data_.bytes.getFloat32(this.data_.BYTE, true);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0 = 4;
				
			}
			
			
			class Impl_ extends _Cursor.View implements LANDING_TARGET {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public target_num(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public target_num_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
				public angle_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 9, true);}
				
				public angle_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 9, src, true); }
				
				public angle_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 13, true);}
				
				public angle_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 13, src, true); }
				
				public distance(): number { return this.data_.bytes.getFloat32(this.data_.origin + 17, true);}
				
				public distance_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 17, src, true); }
				
				public size_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 21, true);}
				
				public size_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 21, src, true); }
				
				public size_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 25, true);}
				
				public size_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 25, src, true); }
				
				
				public frame(): MAV_FRAME | null {
					if (this.data_.field_bit != 235 && !this.data_.set_field(235, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public frame_(src: MAV_FRAME) {
					if (this.data_.field_bit != 235) this.data_.set_field(235, 0);
					
					_Lib.set_bits(src, 4, this.data_.bytes, this.data_.BIT);
				}
				
				
				public x(): number | null {
					if (this.data_.field_bit != 236 && !this.data_.set_field(236, -1)) return null;
					
					return this.data_.bytes.getFloat32(this.data_.BYTE, true);
				}
				
				
				public x_(src: number) {
					if (this.data_.field_bit != 236) this.data_.set_field(236, 0);
					
					this.data_.bytes.setFloat32(this.data_.BYTE, src, true);
				}
				
				
				public y(): number | null {
					if (this.data_.field_bit != 237 && !this.data_.set_field(237, -1)) return null;
					
					return this.data_.bytes.getFloat32(this.data_.BYTE, true);
				}
				
				
				public y_(src: number) {
					if (this.data_.field_bit != 237) this.data_.set_field(237, 0);
					
					this.data_.bytes.setFloat32(this.data_.BYTE, src, true);
				}
				
				
				public z(): number | null {
					if (this.data_.field_bit != 238 && !this.data_.set_field(238, -1)) return null;
					
					return this.data_.bytes.getFloat32(this.data_.BYTE, true);
				}
				
				
				public z_(src: number) {
					if (this.data_.field_bit != 238) this.data_.set_field(238, 0);
					
					this.data_.bytes.setFloat32(this.data_.BYTE, src, true);
				}
				
				
				public q_(src: number, d0: number) {
					if (this.data_.field_bit != 239) this.data_.set_field(239, 0);
					this.data_.set_item(d0, 0);
					this.data_.bytes.setFloat32(this.data_.BYTE, src, true);
				}
				
				q(): LANDING_TARGET.q | null {
					return (this.data_.field_bit == 239 || this.data_.set_field(239, -1)) ?
					       this.data_.as_field(LANDING_TARGET.q.field) : null;
				}
				
				
				public typE(): LANDING_TARGET_TYPE | null {
					if (this.data_.field_bit != 240 && !this.data_.set_field(240, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 2);
				}
				
				
				public typE_(src: LANDING_TARGET_TYPE) {
					if (this.data_.field_bit != 240) this.data_.set_field(240, 0);
					
					_Lib.set_bits(src, 2, this.data_.bytes, this.data_.BIT);
				}
				
				
				public position_valid(): number | null {
					if (this.data_.field_bit != 241 && !this.data_.set_field(241, -1)) return null;
					
					return this.data_.bytes.getInt8(this.data_.BYTE);
				}
				
				
				public position_valid_(src: number) {
					if (this.data_.field_bit != 241) this.data_.set_field(241, 0);
					
					this.data_.bytes.setInt8(this.data_.BYTE, src);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				target_num_(src: number);
				
				frame_(src: _Host.MAV_FRAME);
				
				angle_x_(src: number);
				
				angle_y_(src: number);
				
				distance_(src: number);
				
				size_x_(src: number);
				
				size_y_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				q_(src: number, d0: number);
				
				typE_(src: _Host.LANDING_TARGET_TYPE);
				
				position_valid_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: LANDING_TARGET, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.target_num_(src.target_num());
				
				{
					const item = src.frame();
					if (item !== null) dst.frame_(item);
					
				}
				
				dst.angle_x_(src.angle_x());
				
				dst.angle_y_(src.angle_y());
				
				dst.distance_(src.distance());
				
				dst.size_x_(src.size_x());
				
				dst.size_y_(src.size_y());
				
				{
					const item = src.x();
					if (item !== null) dst.x_(item);
					
				}
				
				{
					const item = src.y();
					if (item !== null) dst.y_(item);
					
				}
				
				{
					const item = src.z();
					if (item !== null) dst.z_(item);
					
				}
				
				{
					const fld = src.q();
					if (fld)
						for (let d0 = 0; d0 < _Host.LANDING_TARGET.q.d0; d0++) {
							const item = fld.get(d0);
							if (item !== null) dst.q_(item, d0);
							
						}
				}
				
				{
					const item = src.typE();
					if (item !== null) dst.typE_(item);
					
				}
				
				{
					const item = src.position_valid();
					if (item !== null) dst.position_valid_(item);
					
				}
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				target_num(): number;
				
				frame(): _Host.MAV_FRAME | null;
				
				angle_x(): number;
				
				angle_y(): number;
				
				distance(): number;
				
				size_x(): number;
				
				size_y(): number;
				
				x(): number | null;
				
				y(): number | null;
				
				z(): number | null;
				
				q_exist(): boolean;
				
				q(d0: number): number | null;
				
				typE(): _Host.LANDING_TARGET_TYPE | null;
				
				position_valid(): number | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LANDING_TARGET) {
				
				dst.time_usec_(src.time_usec());
				
				dst.target_num_(src.target_num());
				{
					const item = src.frame();
					if (item !== null) dst.frame_(item);
					
				}
				
				dst.angle_x_(src.angle_x());
				
				dst.angle_y_(src.angle_y());
				
				dst.distance_(src.distance());
				
				dst.size_x_(src.size_x());
				
				dst.size_y_(src.size_y());
				{
					const item = src.x();
					if (item !== null) dst.x_(item);
					
				}
				{
					const item = src.y();
					if (item !== null) dst.y_(item);
					
				}
				{
					const item = src.z();
					if (item !== null) dst.z_(item);
					
				}
				
				if (src.q_exist())
					for (let d0 = 0; d0 < _Host.LANDING_TARGET.q.d0; d0++) {
						const item = src.q(d0);
						if (item !== null) dst.q_(item, d0);
					}
				
				{
					const item = src.typE();
					if (item !== null) dst.typE_(item);
					
				}
				{
					const item = src.position_valid();
					if (item !== null) dst.position_valid_(item);
					
				}
				
			}
			
		}
		
		export interface SET_ACTUATOR_CONTROL_TARGET {
			time_usec(): number;
			
			time_usec_(src: number);
			
			group_mlx(): number;
			
			group_mlx_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			controls(): SET_ACTUATOR_CONTROL_TARGET.controls;
			
			controls_(src: SET_ACTUATOR_CONTROL_TARGET.controls | number[]);
			
			controls$(src: Iterator<number>, len: number);
			
		}
		
		export namespace SET_ACTUATOR_CONTROL_TARGET {
			
			export const meta_ = new _Pack.Meta(94, 0, 0, 1, 43, 344);
			
			
			export interface controls extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace controls {
				export class Field extends _Cursor.View implements controls, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 11 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 11, other.data_.bytes.buffer, other.data_.origin + 11, _Host.SET_ACTUATOR_CONTROL_TARGET.controls.item_len) === 0;
						for (let i = 0; i < _Host.SET_ACTUATOR_CONTROL_TARGET.controls.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.SET_ACTUATOR_CONTROL_TARGET.controls.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 11 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 8;
				
			}
			
			
			class Impl_ extends _Cursor.View implements SET_ACTUATOR_CONTROL_TARGET {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public group_mlx(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public group_mlx_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 9);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 9, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 10);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 10, src); }
				
				public controls(): SET_ACTUATOR_CONTROL_TARGET.controls {
					
					return this.data_.as_field(SET_ACTUATOR_CONTROL_TARGET.controls.field);
				}
				
				public controls_(src: SET_ACTUATOR_CONTROL_TARGET.controls | number[]): controls {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.SET_ACTUATOR_CONTROL_TARGET.controls.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 11 + index * 4, src[index], true);
						return this.data_.as_field(controls.field);
					}
					for (let index = 0; index < _Host.SET_ACTUATOR_CONTROL_TARGET.controls.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 11 + index * 4, src.get(index), true);
					
					return this.data_.as_field(controls.field);
				}
				
				public controls$(src: Iterator<number>, len: number): controls {
					let len_ = Math.min(len, _Host.SET_ACTUATOR_CONTROL_TARGET.controls.item_len);
					
					len = Math.min(len, _Host.SET_ACTUATOR_CONTROL_TARGET.controls.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 11 + index * 4, v.value, true);
						}
					return this.data_.as_field(controls.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				group_mlx_(src: number);
				
				target_system_(src: number);
				
				target_component_(src: number);
				
				controls_(src: _Host.SET_ACTUATOR_CONTROL_TARGET.controls);
				
			}
			
			export function push_<DST extends DST_>(src: SET_ACTUATOR_CONTROL_TARGET, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.group_mlx_(src.group_mlx());
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				dst.controls_(src.controls());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				group_mlx(): number;
				
				target_system(): number;
				
				target_component(): number;
				
				controls(dst: _Host.SET_ACTUATOR_CONTROL_TARGET.controls);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SET_ACTUATOR_CONTROL_TARGET) {
				
				dst.time_usec_(src.time_usec());
				
				dst.group_mlx_(src.group_mlx());
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				src.controls(dst.controls());
				
			}
			
		}
		
		export interface CONTROL_SYSTEM_STATE {
			time_usec(): number;
			
			time_usec_(src: number);
			
			x_acc(): number;
			
			x_acc_(src: number);
			
			y_acc(): number;
			
			y_acc_(src: number);
			
			z_acc(): number;
			
			z_acc_(src: number);
			
			x_vel(): number;
			
			x_vel_(src: number);
			
			y_vel(): number;
			
			y_vel_(src: number);
			
			z_vel(): number;
			
			z_vel_(src: number);
			
			x_pos(): number;
			
			x_pos_(src: number);
			
			y_pos(): number;
			
			y_pos_(src: number);
			
			z_pos(): number;
			
			z_pos_(src: number);
			
			airspeed(): number;
			
			airspeed_(src: number);
			
			vel_variance(): CONTROL_SYSTEM_STATE.vel_variance;
			
			vel_variance_(src: CONTROL_SYSTEM_STATE.vel_variance | number[]);
			
			vel_variance$(src: Iterator<number>, len: number);
			
			pos_variance(): CONTROL_SYSTEM_STATE.pos_variance;
			
			pos_variance_(src: CONTROL_SYSTEM_STATE.pos_variance | number[]);
			
			pos_variance$(src: Iterator<number>, len: number);
			
			q(): CONTROL_SYSTEM_STATE.q;
			
			q_(src: CONTROL_SYSTEM_STATE.q | number[]);
			
			q$(src: Iterator<number>, len: number);
			
			roll_rate(): number;
			
			roll_rate_(src: number);
			
			pitch_rate(): number;
			
			pitch_rate_(src: number);
			
			yaw_rate(): number;
			
			yaw_rate_(src: number);
			
		}
		
		export namespace CONTROL_SYSTEM_STATE {
			
			export const meta_ = new _Pack.Meta(207, 0, 0, 1, 100, 800);
			
			
			export interface vel_variance extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace vel_variance {
				export class Field extends _Cursor.View implements vel_variance, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 48 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 48, other.data_.bytes.buffer, other.data_.origin + 48, _Host.CONTROL_SYSTEM_STATE.vel_variance.item_len) === 0;
						for (let i = 0; i < _Host.CONTROL_SYSTEM_STATE.vel_variance.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.CONTROL_SYSTEM_STATE.vel_variance.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 48 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 3;
				
			}
			
			export interface pos_variance extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace pos_variance {
				export class Field extends _Cursor.View implements pos_variance, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 60 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 60, other.data_.bytes.buffer, other.data_.origin + 60, _Host.CONTROL_SYSTEM_STATE.pos_variance.item_len) === 0;
						for (let i = 0; i < _Host.CONTROL_SYSTEM_STATE.pos_variance.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.CONTROL_SYSTEM_STATE.pos_variance.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 60 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 3;
				
			}
			
			export interface q extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace q {
				export class Field extends _Cursor.View implements q, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 72 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 72, other.data_.bytes.buffer, other.data_.origin + 72, _Host.CONTROL_SYSTEM_STATE.q.item_len) === 0;
						for (let i = 0; i < _Host.CONTROL_SYSTEM_STATE.q.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.CONTROL_SYSTEM_STATE.q.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 72 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			
			
			class Impl_ extends _Cursor.View implements CONTROL_SYSTEM_STATE {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public x_acc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public x_acc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public y_acc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public y_acc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public z_acc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public z_acc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public x_vel(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public x_vel_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public y_vel(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public y_vel_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public z_vel(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public z_vel_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public x_pos(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public x_pos_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public y_pos(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				public y_pos_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 36, src, true); }
				
				public z_pos(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				public z_pos_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 40, src, true); }
				
				public airspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 44, true);}
				
				public airspeed_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 44, src, true); }
				
				public vel_variance(): CONTROL_SYSTEM_STATE.vel_variance {
					
					return this.data_.as_field(CONTROL_SYSTEM_STATE.vel_variance.field);
				}
				
				public vel_variance_(src: CONTROL_SYSTEM_STATE.vel_variance | number[]): vel_variance {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.CONTROL_SYSTEM_STATE.vel_variance.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 48 + index * 4, src[index], true);
						return this.data_.as_field(vel_variance.field);
					}
					for (let index = 0; index < _Host.CONTROL_SYSTEM_STATE.vel_variance.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 48 + index * 4, src.get(index), true);
					
					return this.data_.as_field(vel_variance.field);
				}
				
				public vel_variance$(src: Iterator<number>, len: number): vel_variance {
					let len_ = Math.min(len, _Host.CONTROL_SYSTEM_STATE.vel_variance.item_len);
					
					len = Math.min(len, _Host.CONTROL_SYSTEM_STATE.vel_variance.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 48 + index * 4, v.value, true);
						}
					return this.data_.as_field(vel_variance.field);
				}
				
				public pos_variance(): CONTROL_SYSTEM_STATE.pos_variance {
					
					return this.data_.as_field(CONTROL_SYSTEM_STATE.pos_variance.field);
				}
				
				public pos_variance_(src: CONTROL_SYSTEM_STATE.pos_variance | number[]): pos_variance {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.CONTROL_SYSTEM_STATE.pos_variance.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 60 + index * 4, src[index], true);
						return this.data_.as_field(pos_variance.field);
					}
					for (let index = 0; index < _Host.CONTROL_SYSTEM_STATE.pos_variance.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 60 + index * 4, src.get(index), true);
					
					return this.data_.as_field(pos_variance.field);
				}
				
				public pos_variance$(src: Iterator<number>, len: number): pos_variance {
					let len_ = Math.min(len, _Host.CONTROL_SYSTEM_STATE.pos_variance.item_len);
					
					len = Math.min(len, _Host.CONTROL_SYSTEM_STATE.pos_variance.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 60 + index * 4, v.value, true);
						}
					return this.data_.as_field(pos_variance.field);
				}
				
				public q(): CONTROL_SYSTEM_STATE.q {
					
					return this.data_.as_field(CONTROL_SYSTEM_STATE.q.field);
				}
				
				public q_(src: CONTROL_SYSTEM_STATE.q | number[]): q {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.CONTROL_SYSTEM_STATE.q.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 72 + index * 4, src[index], true);
						return this.data_.as_field(q.field);
					}
					for (let index = 0; index < _Host.CONTROL_SYSTEM_STATE.q.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 72 + index * 4, src.get(index), true);
					
					return this.data_.as_field(q.field);
				}
				
				public q$(src: Iterator<number>, len: number): q {
					let len_ = Math.min(len, _Host.CONTROL_SYSTEM_STATE.q.item_len);
					
					len = Math.min(len, _Host.CONTROL_SYSTEM_STATE.q.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 72 + index * 4, v.value, true);
						}
					return this.data_.as_field(q.field);
				}
				
				public roll_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 88, true);}
				
				public roll_rate_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 88, src, true); }
				
				public pitch_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 92, true);}
				
				public pitch_rate_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 92, src, true); }
				
				public yaw_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 96, true);}
				
				public yaw_rate_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 96, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				x_acc_(src: number);
				
				y_acc_(src: number);
				
				z_acc_(src: number);
				
				x_vel_(src: number);
				
				y_vel_(src: number);
				
				z_vel_(src: number);
				
				x_pos_(src: number);
				
				y_pos_(src: number);
				
				z_pos_(src: number);
				
				airspeed_(src: number);
				
				vel_variance_(src: _Host.CONTROL_SYSTEM_STATE.vel_variance);
				
				pos_variance_(src: _Host.CONTROL_SYSTEM_STATE.pos_variance);
				
				q_(src: _Host.CONTROL_SYSTEM_STATE.q);
				
				roll_rate_(src: number);
				
				pitch_rate_(src: number);
				
				yaw_rate_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: CONTROL_SYSTEM_STATE, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.x_acc_(src.x_acc());
				
				dst.y_acc_(src.y_acc());
				
				dst.z_acc_(src.z_acc());
				
				dst.x_vel_(src.x_vel());
				
				dst.y_vel_(src.y_vel());
				
				dst.z_vel_(src.z_vel());
				
				dst.x_pos_(src.x_pos());
				
				dst.y_pos_(src.y_pos());
				
				dst.z_pos_(src.z_pos());
				
				dst.airspeed_(src.airspeed());
				dst.vel_variance_(src.vel_variance());
				dst.pos_variance_(src.pos_variance());
				dst.q_(src.q());
				
				dst.roll_rate_(src.roll_rate());
				
				dst.pitch_rate_(src.pitch_rate());
				
				dst.yaw_rate_(src.yaw_rate());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				x_acc(): number;
				
				y_acc(): number;
				
				z_acc(): number;
				
				x_vel(): number;
				
				y_vel(): number;
				
				z_vel(): number;
				
				x_pos(): number;
				
				y_pos(): number;
				
				z_pos(): number;
				
				airspeed(): number;
				
				vel_variance(dst: _Host.CONTROL_SYSTEM_STATE.vel_variance);
				
				pos_variance(dst: _Host.CONTROL_SYSTEM_STATE.pos_variance);
				
				q(dst: _Host.CONTROL_SYSTEM_STATE.q);
				
				roll_rate(): number;
				
				pitch_rate(): number;
				
				yaw_rate(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: CONTROL_SYSTEM_STATE) {
				
				dst.time_usec_(src.time_usec());
				
				dst.x_acc_(src.x_acc());
				
				dst.y_acc_(src.y_acc());
				
				dst.z_acc_(src.z_acc());
				
				dst.x_vel_(src.x_vel());
				
				dst.y_vel_(src.y_vel());
				
				dst.z_vel_(src.z_vel());
				
				dst.x_pos_(src.x_pos());
				
				dst.y_pos_(src.y_pos());
				
				dst.z_pos_(src.z_pos());
				
				dst.airspeed_(src.airspeed());
				src.vel_variance(dst.vel_variance());
				src.pos_variance(dst.pos_variance());
				src.q(dst.q());
				
				dst.roll_rate_(src.roll_rate());
				
				dst.pitch_rate_(src.pitch_rate());
				
				dst.yaw_rate_(src.yaw_rate());
				
			}
			
		}
		
		export interface SET_POSITION_TARGET_GLOBAL_INT {
			type_mask(): number;
			
			time_boot_ms(): number;
			
			target_system(): number;
			
			target_component(): number;
			
			lat_int(): number;
			
			lon_int(): number;
			
			alt(): number;
			
			vx(): number;
			
			vy(): number;
			
			vz(): number;
			
			afx(): number;
			
			afy(): number;
			
			afz(): number;
			
			yaw(): number;
			
			yaw_rate(): number;
			
			coordinate_frame(): MAV_FRAME | null;
			
		}
		
		export namespace SET_POSITION_TARGET_GLOBAL_INT {
			
			export const meta_ = new _Pack.Meta(218, 1, 1, 0, 53, 416, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements SET_POSITION_TARGET_GLOBAL_INT {
				
				public type_mask(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 7);}
				
				
				public lat_int(): number { return this.data_.bytes.getInt32(this.data_.origin + 8, true);}
				
				
				public lon_int(): number { return this.data_.bytes.getInt32(this.data_.origin + 12, true);}
				
				
				public alt(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public vx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public vy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
				public vz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				
				public afx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				
				public afy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				
				public afz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 44, true);}
				
				
				public yaw_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 48, true);}
				
				
				public coordinate_frame(): MAV_FRAME | null {
					if (this.data_.field_bit != 416 && !this.data_.set_field(416, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				target_system_(src: number);
				
				target_component_(src: number);
				
				coordinate_frame_(src: _Host.MAV_FRAME);
				
				type_mask_(src: number);
				
				lat_int_(src: number);
				
				lon_int_(src: number);
				
				alt_(src: number);
				
				vx_(src: number);
				
				vy_(src: number);
				
				vz_(src: number);
				
				afx_(src: number);
				
				afy_(src: number);
				
				afz_(src: number);
				
				yaw_(src: number);
				
				yaw_rate_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SET_POSITION_TARGET_GLOBAL_INT, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.coordinate_frame();
					if (item !== null) dst.coordinate_frame_(item);
					
				}
				
				dst.type_mask_(src.type_mask());
				
				dst.lat_int_(src.lat_int());
				
				dst.lon_int_(src.lon_int());
				
				dst.alt_(src.alt());
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
				dst.afx_(src.afx());
				
				dst.afy_(src.afy());
				
				dst.afz_(src.afz());
				
				dst.yaw_(src.yaw());
				
				dst.yaw_rate_(src.yaw_rate());
				
			}
			
		}
		
		export interface DATA32 {
			typE(): number;
			
			typE_(src: number);
			
			len(): number;
			
			len_(src: number);
			
			daTa(): DATA32.daTa;
			
			daTa_(src: DATA32.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace DATA32 {
			
			export const meta_ = new _Pack.Meta(164, 0, 0, 0, 34, 272);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 2 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 2, other.data_.bytes.buffer, other.data_.origin + 2, _Host.DATA32.daTa.item_len) === 0;
						for (let i = 0; i < _Host.DATA32.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.DATA32.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 2 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 32;
				
			}
			
			
			class Impl_ extends _Cursor.View implements DATA32 {
				
				public typE(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public typE_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public len(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public len_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public daTa(): DATA32.daTa {
					
					return this.data_.as_field(DATA32.daTa.field);
				}
				
				public daTa_(src: DATA32.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.DATA32.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.DATA32.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 2 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.DATA32.daTa.item_len);
					
					len = Math.min(len, _Host.DATA32.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				typE_(src: number);
				
				len_(src: number);
				
				daTa_(src: _Host.DATA32.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: DATA32, dst: DST) {
				
				dst.typE_(src.typE());
				
				dst.len_(src.len());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				typE(): number;
				
				len(): number;
				
				daTa(dst: _Host.DATA32.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DATA32) {
				
				dst.typE_(src.typE());
				
				dst.len_(src.len());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface PING33 {
			TTTT(d0: number, d1: number, d2: number): number;
			
			TTTT_(src: number, d0: number, d1: number, d2: number);
			
			field(): number;
			
			field_(src: number);
			
			bit_field(): number;
			
			bit_field_(src: number);
			
			field6(d0: number, d1: number, d2: number): number;
			
			field6_(src: number, d0: number, d1: number, d2: number);
			
			testBOOL2(): boolean;
			
			testBOOL2_(src: boolean);
			
			testBOOL3(): boolean;
			
			testBOOL3_(src: boolean);
			
			testBOOL(): boolean | null;
			
			testBOOL_(src: boolean);
			
			seq(): number | null;
			
			seq_(src: number);
			
			field1(): PING33.field1 | PING33.field1.Initializer;
			
			field12_(src: number, d0: number, d1: number, d2: number);
			
			field12(): PING33.field12 | null;
			
			field13_(src: number, d0: number, d1: number, d2: number);
			
			field13(): PING33.field13 | null;
			
			WWWWWWWW(): number | null;
			
			WWWWWWWW_(src: number);
			
			bit_field2(): number | null;
			
			bit_field2_(src: number);
			
			Field_Bits_(src: number, d0: number, d1: number, d2: number);
			
			Field_Bits(): PING33.Field_Bits | null;
			
			SparseFixAllBits(): PING33.SparseFixAllBits | PING33.SparseFixAllBits.Initializer;
			
			FixAllBits(): PING33.FixAllBits | PING33.FixAllBits.Initializer;
			
			VarAllBits(): PING33.VarAllBits | PING33.VarAllBits.Initializer;
			
			SparseVarAllBits(): PING33.SparseVarAllBits | PING33.SparseVarAllBits.Initializer;
			
			VarEachBits(): PING33.VarEachBits | PING33.VarEachBits.Initializer;
			
			SparsVarEachBits(): PING33.SparsVarEachBits | PING33.SparsVarEachBits.Initializer;
			
			testBOOLX(): boolean | null;
			
			testBOOLX_(src: boolean);
			
			testBOOL2X(): boolean | null;
			
			testBOOL2X_(src: boolean);
			
			testBOOL3X(): boolean | null;
			
			testBOOL3X_(src: boolean);
			
			MMMMMM(): MAV_MODE | null;
			
			MMMMMM_(src: MAV_MODE);
			
			field44(): PING33.field44 | PING33.field44.Initializer;
			
			field634(): PING33.field634 | PING33.field634.Initializer;
			
			field33344(): PING33.field33344 | PING33.field33344.Initializer;
			
			field333634(): PING33.field333634 | PING33.field333634.Initializer;
			
			field___(src: number, d0: number, d1: number, d2: number);
			
			field__(): PING33.field__ | null;
			
			field63(): PING33.field63 | PING33.field63.Initializer;
			
			uid2_(src: number, d0: number);
			
			uid2(): PING33.uid2 | null;
			
			field2_(src: number, d0: number, d1: number, d2: number);
			
			field2(): PING33.field2 | null;
			
			field4_(src: number, d0: number, d1: number, d2: number);
			
			field4(): PING33.field4 | null;
			
			stringtest1(): _Cursor.UTF8 | null;
			
			stringtest1_(src: string | Uint8Array): _Cursor.UTF8;
			
			stringtest1$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
			stringtest2(): PING33.stringtest2 | PING33.stringtest2.Initializer;
			
			stringtest3(): _Cursor.UTF8 | null;
			
			stringtest3_(src: string | Uint8Array): _Cursor.UTF8;
			
			stringtest3$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
			stringtest4(): _Cursor.UTF8 | null;
			
			stringtest4_(src: string | Uint8Array): _Cursor.UTF8;
			
			stringtest4$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace PING33 {
			
			export const meta_                  = new _Pack.Meta(139, 0, 18, 0, 155, 1234, 8, 31);
			export const const3: number         = 56;//56
			export const stati_cconst1: number  = 1;//1
			export const stati_cconst1D: number = 1.456;//(float)1.456
			export const const3D: number        = 56.555;//(float)56.555
			
			
			export namespace TTTT {
				export const d0 = 3;
				export const d1 = 2;
				export const d2 = 3;
				
				export function
				enumerate(pack: PING33, dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
					const data = (<_Cursor.View><unknown>pack).data_;
					for (let d0 = 0; d0 < _Host.PING33.TTTT.d0; d0++)
						for (let d1 = 0; d1 < _Host.PING33.TTTT.d1; d1++)
							for (let d2 = 0; d2 < _Host.PING33.TTTT.d2; d2++)
								
								dst(data.bytes.getInt32(data.origin + 0 + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true), d0, d1, d2);
				}
				
			}
			export namespace bit_field {
				
				export const min_value: number = 4;
				export const max_value: number = 45;
				
				
			}
			export namespace field6 {
				export const d0 = 3;
				export const d1 = 2;
				export const d2 = 3;
				
				export function
				enumerate(pack: PING33, dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
					const data = (<_Cursor.View><unknown>pack).data_;
					for (let d0 = 0; d0 < _Host.PING33.field6.d0; d0++)
						for (let d1 = 0; d1 < _Host.PING33.field6.d1; d1++)
							for (let d2 = 0; d2 < _Host.PING33.field6.d2; d2++)
								
								dst(data.bytes.getInt32(data.origin + 81 + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true), d0, d1, d2);
				}
				
			}
			
			export interface field1 {
				d0(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace field1 {
				export class Field extends _Cursor.View implements field1 {
					d0(): number {return this.data_.D[0];}
					
					
					public get(d0: number, d1: number, d2: number): number {
						return this.data_.bytes.getInt32(this.data_.BYTE + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 2) * 4, true);
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						this.data_.bytes.setInt32(this.data_.BYTE + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 2) * 4, src, true);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < this.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.field1.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field1.d2; d2++)
									
									dst(this.data_.bytes.getInt32(this.data_.BYTE + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 2) * 4, true), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0_max = 7;
				export const d1     = 2;
				export const d2     = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d0: number): field1 | null {
						return (this.data_.set_field(1236, 0, d0)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface field12 {
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number;
				
			}
			
			export namespace field12 {
				class Field extends _Cursor.View implements field12 {
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.field12.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field12.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field12.d2; d2++)
									
									dst(this.data_.bytes.getInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true), d0, d1, d2);
					}
					
					
					public get(d0: number, d1: number, d2: number): number {
						return this.data_.bytes.getInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0 = 3;
				export const d1 = 2;
				export const d2 = 3;
				
			}
			
			export interface field13 {
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number | null;
				
			}
			
			export namespace field13 {
				class Field extends _Cursor.View implements field13 {
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.field13.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field13.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field13.d2; d2++)
									
									if (this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst(this.data_.bytes.getInt32(this.data_.BYTE, true), d0, d1, d2);
					}
					
					
					public get(d0: number, d1: number, d2: number): number | null {
						if (!this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) return null;
						
						return this.data_.bytes.getInt32(this.data_.BYTE, true);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0 = 3;
				export const d1 = 2;
				export const d2 = 3;
				
			}
			export namespace bit_field2 {
				
				export const min_value: number = 4;
				export const max_value: number = 45;
				
			}
			
			export interface Field_Bits {
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number;
				
			}
			
			export namespace Field_Bits {
				class Field extends _Cursor.View implements Field_Bits {
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.Field_Bits.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.Field_Bits.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.Field_Bits.d2; d2++)
									
									dst((4 + _Lib.get_bits(this.data_.bytes, this.data_.BIT + (d0 + d1 * 3 + d2 * 3 * 3) * 6, 6)), d0, d1, d2);
					}
					
					
					public get(d0: number, d1: number, d2: number): number {
						return (4 + _Lib.get_bits(this.data_.bytes, this.data_.BIT + (d0 + d1 * 3 + d2 * 3 * 3) * 6, 6));
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const min_value: number = 4;
				export const max_value: number = 45;
				export const d0                = 3;
				export const d1                = 3;
				export const d2                = 3;
				
			}
			
			export interface SparseFixAllBits {
				d0(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number | null;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace SparseFixAllBits {
				export class Field extends _Cursor.View implements SparseFixAllBits {
					d0(): number {return this.data_.D[0];}
					
					
					public get(d0: number, d1: number, d2: number): number | null {
						if (!this.data_.set_item(d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3, -1)) return null;
						
						return (4 + _Lib.get_bits(this.data_.bytes, this.data_.BIT, 6));
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						this.data_.set_item(d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3, 0);
						_Lib.set_bits(-4 + src, 6, this.data_.bytes, this.data_.BIT);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < this.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.SparseFixAllBits.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.SparseFixAllBits.d2; d2++)
									
									if (this.data_.set_item(d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3, -1)) dst((4 + _Lib.get_bits(this.data_.bytes, this.data_.BIT, 6)), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const min_value: number = 4;
				export const max_value: number = 45;
				export const d0_max            = 3;
				export const d1                = 3;
				export const d2                = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d0: number): SparseFixAllBits | null {
						return (this.data_.set_field(1242, 0, d0)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface FixAllBits {
				d0(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace FixAllBits {
				export class Field extends _Cursor.View implements FixAllBits {
					d0(): number {return this.data_.D[0];}
					
					
					public get(d0: number, d1: number, d2: number): number {
						return (14 + _Lib.get_bits(this.data_.bytes, this.data_.BIT + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3) * 5, 5));
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						_Lib.set_bits(-14 + src, 5, this.data_.bytes, this.data_.BIT + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3) * 5);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < this.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.FixAllBits.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.FixAllBits.d2; d2++)
									
									dst((14 + _Lib.get_bits(this.data_.bytes, this.data_.BIT + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3) * 5, 5)), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const min_value: number = 14;
				export const max_value: number = 45;
				export const d0_max            = 3;
				export const d1                = 3;
				export const d2                = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d0: number): FixAllBits | null {
						return (this.data_.set_field(1243, 0, d0)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface VarAllBits {
				d0(): number;
				
				d2(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace VarAllBits {
				export class Field extends _Cursor.View implements VarAllBits {
					d0(): number {return this.data_.D[0];}
					
					d2(): number {return this.data_.D[2];}
					
					
					public get(d0: number, d1: number, d2: number): number {
						return (14 + _Lib.get_bits(this.data_.bytes, this.data_.BIT + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3) * 5, 5));
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						_Lib.set_bits(-14 + src, 5, this.data_.bytes, this.data_.BIT + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3) * 5);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < this.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.VarAllBits.d1; d1++)
								for (let d2 = 0; d2 < this.d2(); d2++)
									
									dst((14 + _Lib.get_bits(this.data_.bytes, this.data_.BIT + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3) * 5, 5)), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const min_value: number = 14;
				export const max_value: number = 45;
				export const d0_max            = 3;
				export const d1                = 3;
				export const d2_max            = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d0: number, d2: number): VarAllBits | null {
						return (this.data_.set_field(1244, 0, d0, d2)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface SparseVarAllBits {
				d0(): number;
				
				d2(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number | null;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace SparseVarAllBits {
				export class Field extends _Cursor.View implements SparseVarAllBits {
					d0(): number {return this.data_.D[0];}
					
					d2(): number {return this.data_.D[2];}
					
					
					public get(d0: number, d1: number, d2: number): number | null {
						if (!this.data_.set_item(d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3, -1)) return null;
						
						return (14 + _Lib.get_bits(this.data_.bytes, this.data_.BIT, 5));
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						this.data_.set_item(d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3, 0);
						_Lib.set_bits(-14 + src, 5, this.data_.bytes, this.data_.BIT);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < this.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.SparseVarAllBits.d1; d1++)
								for (let d2 = 0; d2 < this.d2(); d2++)
									
									if (this.data_.set_item(d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3, -1)) dst((14 + _Lib.get_bits(this.data_.bytes, this.data_.BIT, 5)), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const min_value: number = 14;
				export const max_value: number = 45;
				export const d0_max            = 3;
				export const d1                = 3;
				export const d2_max            = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d0: number, d2: number): SparseVarAllBits | null {
						return (this.data_.set_field(1245, 0, d0, d2)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface VarEachBits {
				d0(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace VarEachBits {
				export class Field extends _Cursor.View implements VarEachBits {
					d0(): number {return this.data_.D[0];}
					
					
					public get(d0: number, d1: number, d2: number): number {
						return (-14 + _Lib.get_bits(this.data_.bytes, this.data_.BIT + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3) * 6, 6));
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						_Lib.set_bits(14 + src, 6, this.data_.bytes, this.data_.BIT + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3) * 6);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < this.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.VarEachBits.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.VarEachBits.d2; d2++)
									
									dst((-14 + _Lib.get_bits(this.data_.bytes, this.data_.BIT + (d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3) * 6, 6)), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const min_value: number = -14;
				export const max_value: number = 45;
				export const d0_max            = 3;
				export const d1                = 3;
				export const d2                = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d0: number): VarEachBits | null {
						return (this.data_.set_field(1246, 0, d0)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface SparsVarEachBits {
				d0(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number | null;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace SparsVarEachBits {
				export class Field extends _Cursor.View implements SparsVarEachBits {
					d0(): number {return this.data_.D[0];}
					
					
					public get(d0: number, d1: number, d2: number): number | null {
						if (!this.data_.set_item(d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3, -1)) return null;
						
						return (-14 + _Lib.get_bits(this.data_.bytes, this.data_.BIT, 9));
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						this.data_.set_item(d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3, 0);
						_Lib.set_bits(14 + src, 9, this.data_.bytes, this.data_.BIT);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < this.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.SparsVarEachBits.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.SparsVarEachBits.d2; d2++)
									
									if (this.data_.set_item(d0 + d1 * this.data_.var_dims[0] + d2 * this.data_.var_dims[0] * 3, -1)) dst((-14 + _Lib.get_bits(this.data_.bytes, this.data_.BIT, 9)), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const min_value: number = -14;
				export const max_value: number = 450;
				export const d0_max            = 3;
				export const d1                = 3;
				export const d2                = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d0: number): SparsVarEachBits | null {
						return (this.data_.set_field(1247, 0, d0)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface field44 {
				d2(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace field44 {
				export class Field extends _Cursor.View implements field44 {
					d2(): number {return this.data_.D[2];}
					
					
					public get(d0: number, d1: number, d2: number): number {
						return this.data_.bytes.getInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true);
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						this.data_.bytes.setInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, src, true);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.field44.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field44.d1; d1++)
								for (let d2 = 0; d2 < this.d2(); d2++)
									
									dst(this.data_.bytes.getInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0     = 3;
				export const d1     = 2;
				export const d2_max = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d2: number): field44 | null {
						return (this.data_.set_field(1252, 0, d2)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface field634 {
				d2(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace field634 {
				export class Field extends _Cursor.View implements field634 {
					d2(): number {return this.data_.D[2];}
					
					
					public get(d0: number, d1: number, d2: number): number {
						return this.data_.bytes.getInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true);
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						this.data_.bytes.setInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, src, true);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.field634.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field634.d1; d1++)
								for (let d2 = 0; d2 < this.d2(); d2++)
									
									dst(this.data_.bytes.getInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0     = 3;
				export const d1     = 2;
				export const d2_max = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d2: number): field634 | null {
						return (this.data_.set_field(1253, 0, d2)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface field33344 {
				d2(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number | null;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace field33344 {
				export class Field extends _Cursor.View implements field33344 {
					d2(): number {return this.data_.D[2];}
					
					
					public get(d0: number, d1: number, d2: number): number | null {
						if (!this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) return null;
						
						return this.data_.bytes.getInt32(this.data_.BYTE, true);
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0);
						this.data_.bytes.setInt32(this.data_.BYTE, src, true);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.field33344.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field33344.d1; d1++)
								for (let d2 = 0; d2 < this.d2(); d2++)
									
									if (this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst(this.data_.bytes.getInt32(this.data_.BYTE, true), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0     = 3;
				export const d1     = 2;
				export const d2_max = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d2: number): field33344 | null {
						return (this.data_.set_field(1254, 0, d2)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface field333634 {
				d2(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number | null;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace field333634 {
				export class Field extends _Cursor.View implements field333634 {
					d2(): number {return this.data_.D[2];}
					
					
					public get(d0: number, d1: number, d2: number): number | null {
						if (!this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) return null;
						
						return this.data_.bytes.getInt32(this.data_.BYTE, true);
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0);
						this.data_.bytes.setInt32(this.data_.BYTE, src, true);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.field333634.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field333634.d1; d1++)
								for (let d2 = 0; d2 < this.d2(); d2++)
									
									if (this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst(this.data_.bytes.getInt32(this.data_.BYTE, true), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0     = 3;
				export const d1     = 2;
				export const d2_max = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d2: number): field333634 | null {
						return (this.data_.set_field(1255, 0, d2)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface field__ {
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number | null;
				
			}
			
			export namespace field__ {
				class Field extends _Cursor.View implements field__ {
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.field__.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field__.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field__.d2; d2++)
									
									if (this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst(this.data_.bytes.getInt32(this.data_.BYTE, true), d0, d1, d2);
					}
					
					
					public get(d0: number, d1: number, d2: number): number | null {
						if (!this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) return null;
						
						return this.data_.bytes.getInt32(this.data_.BYTE, true);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0 = 3;
				export const d1 = 2;
				export const d2 = 3;
				
			}
			
			export interface field63 {
				d2(): number;
				
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number;
				
				set(src: number, d0: number, d1: number, d2: number);
				
			}
			
			export namespace field63 {
				export class Field extends _Cursor.View implements field63 {
					d2(): number {return this.data_.D[2];}
					
					
					public get(d0: number, d1: number, d2: number): number {
						return this.data_.bytes.getInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true);
					}
					
					
					public set(src: number, d0: number, d1: number, d2: number) {
						
						this.data_.bytes.setInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, src, true);
					}
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.field63.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field63.d1; d1++)
								for (let d2 = 0; d2 < this.d2(); d2++)
									
									dst(this.data_.bytes.getInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true), d0, d1, d2);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0     = 3;
				export const d1     = 2;
				export const d2_max = 3;
				
				export class Initializer extends _Cursor.View {
					public init(d2: number): field63 | null {
						return (this.data_.set_field(1257, 0, d2)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			
			export interface uid2 {
				enumerate(dst: (item: number, d0?: number) => void);
				
				get(d0: number): number | null;
				
			}
			
			export namespace uid2 {
				class Field extends _Cursor.View implements uid2 {
					
					
					enumerate(dst: (item: number, d0?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.uid2.d0; d0++)
							
							if (this.data_.set_item(d0, -1)) dst(this.data_.bytes.getInt8(this.data_.BYTE), d0);
					}
					
					
					public get(d0: number): number | null {
						if (!this.data_.set_item(d0, -1)) return null;
						
						return this.data_.bytes.getInt8(this.data_.BYTE);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0 = 18;
				
			}
			
			export interface field2 {
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number | null;
				
			}
			
			export namespace field2 {
				class Field extends _Cursor.View implements field2 {
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.field2.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field2.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field2.d2; d2++)
									
									if (this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst(this.data_.bytes.getInt32(this.data_.BYTE, true), d0, d1, d2);
					}
					
					
					public get(d0: number, d1: number, d2: number): number | null {
						if (!this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) return null;
						
						return this.data_.bytes.getInt32(this.data_.BYTE, true);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0 = 3;
				export const d1 = 2;
				export const d2 = 3;
				
			}
			
			export interface field4 {
				enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): number | null;
				
			}
			
			export namespace field4 {
				class Field extends _Cursor.View implements field4 {
					
					
					enumerate(dst: (item: number, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.field4.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field4.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field4.d2; d2++)
									
									if (this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) dst(this.data_.bytes.getInt32(this.data_.BYTE, true), d0, d1, d2);
					}
					
					
					public get(d0: number, d1: number, d2: number): number | null {
						if (!this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) return null;
						
						return this.data_.bytes.getInt32(this.data_.BYTE, true);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0 = 3;
				export const d1 = 2;
				export const d2 = 3;
				
			}
			export namespace stringtest1 {
				export const item_len_max = 255;
				
			}
			
			export interface stringtest2 {
				d2(): number;
				
				enumerate(dst: (item: _Cursor.UTF8, d0?: number, d1?: number, d2?: number) => void);
				
				get(d0: number, d1: number, d2: number): _Cursor.UTF8 | null;
				
				set(src: string | Uint8Array, d0: number, d1: number, d2: number): _Cursor.UTF8;
				
				set_(bytes: Iterator<number> | null, len: number, d0: number, d1: number, d2: number): _Cursor.UTF8;
				
			}
			
			export namespace stringtest2 {
				export class Field extends _Cursor.View implements stringtest2 {
					d2(): number {return this.data_.D[2];}
					
					
					get(d0: number, d1: number, d2: number): _Cursor.UTF8 | null {
						if (!this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, -1)) return null;
						
						return new _Cursor.UTF8(this.data_);
					}
					
					set(src: string | Uint8Array, d0: number, d1: number, d2: number): _Cursor.UTF8 {
						
						if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, d0 + d1 * 3 + d2 * 3 * 2);
						
						let len = Math.min(src.byteLength, _Host.PING33.stringtest2.item_len_max);
						
						this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, len);
						_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
						return new _Cursor.UTF8(this.data_);
						
					}
					
					set_(bytes: Iterator<number> | null, len: number, d0: number, d1: number, d2: number): _Cursor.UTF8 {
						
						len = Math.min(len, _Host.PING33.stringtest2.item_len_max)
						this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, len);
						if (bytes)
							for (let index = 0; index < len; index++) {
								let v = bytes.next();
								if (v.done) break;
								
							}
						return new _Cursor.UTF8(this.data_);
					}
					
					
					enumerate(dst: (item: _Cursor.UTF8, d0?: number, d1?: number, d2?: number) => void) {
						for (let d0 = 0; d0 < _Host.PING33.stringtest2.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.stringtest2.d1; d1++)
								for (let d2 = 0; d2 < this.d2(); d2++) {
									const item = this.get(d0, d1, d2);
									if (item !== null) dst(item, d0, d1, d2);
								}
						
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0           = 3;
				export const d1           = 2;
				export const d2_max       = 3;
				export const item_len_max = 255;
				
				export class Initializer extends _Cursor.View {
					public init(d2: number): stringtest2 | null {
						return (this.data_.set_field(1262, 0, d2)) ? this.data_.as_field(field) : null;
					}
				}
				
				export const init = Initializer.prototype;
			}
			export namespace stringtest3 {
				export const item_len_max = 255;
				
			}
			export namespace stringtest4 {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements PING33 {
				
				public TTTT(d0: number, d1: number, d2: number): number { return this.data_.bytes.getInt32(this.data_.origin + 0 + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true);}
				
				public TTTT_(src: number, d0: number, d1: number, d2: number) { this.data_.bytes.setInt32(this.data_.origin + 0 + (d0 + d1 * 3 + d2 * 3 * 2) * 4, src, true); }
				
				public field(): number { return this.data_.bytes.getUint32(this.data_.origin + 72, true) + this.data_.bytes.getInt32(this.data_.origin + 72 + 4, true) * _Lib.JS_HI;}
				
				public field_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 72, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 72 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public bit_field(): number { return 4 + this.data_.bytes.getInt8(this.data_.origin + 80);}
				
				public bit_field_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 80, -4 + src); }
				
				public field6(d0: number, d1: number, d2: number): number { return this.data_.bytes.getInt32(this.data_.origin + 81 + (d0 + d1 * 3 + d2 * 3 * 2) * 4, true);}
				
				public field6_(src: number, d0: number, d1: number, d2: number) { this.data_.bytes.setInt32(this.data_.origin + 81 + (d0 + d1 * 3 + d2 * 3 * 2) * 4, src, true); }
				
				public testBOOL2(): boolean { return (this.data_.bytes.getUint8((this.data_.origin * 8 + 1224) >> 3) & 1 << (this.data_.origin * 8 + 1224 & 7)) != 0;}
				
				public testBOOL2_(src: boolean) {
					if (src) this.data_.bytes.setUint8((this.data_.origin * 8 + 1224) >> 3, this.data_.bytes.getUint8((this.data_.origin * 8 + 1224) >> 3) | (1 << (this.data_.origin * 8 + 1224 & 7)));
					else this.data_.bytes.setUint8((this.data_.origin * 8 + 1224) >> 3, this.data_.bytes.getUint8((this.data_.origin * 8 + 1224) >> 3) & (~(1 << (this.data_.origin * 8 + 1224 & 7))));
				}
				
				public testBOOL3(): boolean { return (this.data_.bytes.getUint8((this.data_.origin * 8 + 1225) >> 3) & 1 << (this.data_.origin * 8 + 1225 & 7)) != 0;}
				
				public testBOOL3_(src: boolean) {
					if (src) this.data_.bytes.setUint8((this.data_.origin * 8 + 1225) >> 3, this.data_.bytes.getUint8((this.data_.origin * 8 + 1225) >> 3) | (1 << (this.data_.origin * 8 + 1225 & 7)));
					else this.data_.bytes.setUint8((this.data_.origin * 8 + 1225) >> 3, this.data_.bytes.getUint8((this.data_.origin * 8 + 1225) >> 3) & (~(1 << (this.data_.origin * 8 + 1225 & 7))));
				}
				
				
				public testBOOL(): boolean | null {
					if (this.data_.field_bit != 1234 && !this.data_.set_field(1234, -1)) return null;
					
					return (this.data_.bytes.getUint8((this.data_.BIT) >> 3) & 1 << (this.data_.BIT & 7)) != 0;
				}
				
				
				public testBOOL_(src: boolean) {
					if (this.data_.field_bit != 1234) this.data_.set_field(1234, 0);
					
					if (src) this.data_.bytes.setUint8((this.data_.BIT) >> 3, this.data_.bytes.getUint8((this.data_.BIT) >> 3) | (1 << (this.data_.BIT & 7)));
					else this.data_.bytes.setUint8((this.data_.BIT) >> 3, this.data_.bytes.getUint8((this.data_.BIT) >> 3) & (~(1 << (this.data_.BIT & 7))));
				}
				
				
				public seq(): number | null {
					if (this.data_.field_bit != 1235 && !this.data_.set_field(1235, -1)) return null;
					
					return -14 + this.data_.bytes.getUint32(this.data_.BYTE, true);
				}
				
				
				public seq_(src: number) {
					if (this.data_.field_bit != 1235) this.data_.set_field(1235, 0);
					
					this.data_.bytes.setUint32(this.data_.BYTE, 14 + src, true);
				}
				
				
				public field1(): PING33.field1 | PING33.field1.Initializer {
					return (this.data_.field_bit == 1236 || this.data_.set_field(1236, -1)) ?
					       this.data_.as_field(PING33.field1.field) : this.data_.as_field(PING33.field1.init)
				}
				
				
				public field12_(src: number, d0: number, d1: number, d2: number) {
					if (this.data_.field_bit != 1237) this.data_.set_field(1237, 0);
					this.data_.bytes.setInt32(this.data_.BYTE + (d0 + d1 * 3 + d2 * 3 * 2) * 4, src, true);
				}
				
				field12(): PING33.field12 | null {
					return (this.data_.field_bit == 1237 || this.data_.set_field(1237, -1)) ?
					       this.data_.as_field(PING33.field12.field) : null;
				}
				
				
				public field13_(src: number, d0: number, d1: number, d2: number) {
					if (this.data_.field_bit != 1238) this.data_.set_field(1238, 0);
					this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0);
					this.data_.bytes.setInt32(this.data_.BYTE, src, true);
				}
				
				field13(): PING33.field13 | null {
					return (this.data_.field_bit == 1238 || this.data_.set_field(1238, -1)) ?
					       this.data_.as_field(PING33.field13.field) : null;
				}
				
				
				public WWWWWWWW(): number | null {
					if (this.data_.field_bit != 1239 && !this.data_.set_field(1239, -1)) return null;
					
					return this.data_.bytes.getInt32(this.data_.BYTE, true);
				}
				
				
				public WWWWWWWW_(src: number) {
					if (this.data_.field_bit != 1239) this.data_.set_field(1239, 0);
					
					this.data_.bytes.setInt32(this.data_.BYTE, src, true);
				}
				
				
				public bit_field2(): number | null {
					if (this.data_.field_bit != 1240 && !this.data_.set_field(1240, -1)) return null;
					
					return 45 - this.data_.bytes.getInt8(this.data_.BYTE);
				}
				
				
				public bit_field2_(src: number) {
					if (this.data_.field_bit != 1240) this.data_.set_field(1240, 0);
					
					this.data_.bytes.setInt8(this.data_.BYTE, 45 - src);
				}
				
				
				public Field_Bits_(src: number, d0: number, d1: number, d2: number) {
					if (this.data_.field_bit != 1241) this.data_.set_field(1241, 0);
					_Lib.set_bits(-4 + src, 6, this.data_.bytes, this.data_.BIT + (d0 + d1 * 3 + d2 * 3 * 3) * 6);
				}
				
				Field_Bits(): PING33.Field_Bits | null {
					return (this.data_.field_bit == 1241 || this.data_.set_field(1241, -1)) ?
					       this.data_.as_field(PING33.Field_Bits.field) : null;
				}
				
				public SparseFixAllBits(): PING33.SparseFixAllBits | PING33.SparseFixAllBits.Initializer {
					return (this.data_.field_bit == 1242 || this.data_.set_field(1242, -1)) ?
					       this.data_.as_field(PING33.SparseFixAllBits.field) : this.data_.as_field(PING33.SparseFixAllBits.init)
				}
				
				public FixAllBits(): PING33.FixAllBits | PING33.FixAllBits.Initializer {
					return (this.data_.field_bit == 1243 || this.data_.set_field(1243, -1)) ?
					       this.data_.as_field(PING33.FixAllBits.field) : this.data_.as_field(PING33.FixAllBits.init)
				}
				
				public VarAllBits(): PING33.VarAllBits | PING33.VarAllBits.Initializer {
					return (this.data_.field_bit == 1244 || this.data_.set_field(1244, -1)) ?
					       this.data_.as_field(PING33.VarAllBits.field) : this.data_.as_field(PING33.VarAllBits.init)
				}
				
				public SparseVarAllBits(): PING33.SparseVarAllBits | PING33.SparseVarAllBits.Initializer {
					return (this.data_.field_bit == 1245 || this.data_.set_field(1245, -1)) ?
					       this.data_.as_field(PING33.SparseVarAllBits.field) : this.data_.as_field(PING33.SparseVarAllBits.init)
				}
				
				public VarEachBits(): PING33.VarEachBits | PING33.VarEachBits.Initializer {
					return (this.data_.field_bit == 1246 || this.data_.set_field(1246, -1)) ?
					       this.data_.as_field(PING33.VarEachBits.field) : this.data_.as_field(PING33.VarEachBits.init)
				}
				
				public SparsVarEachBits(): PING33.SparsVarEachBits | PING33.SparsVarEachBits.Initializer {
					return (this.data_.field_bit == 1247 || this.data_.set_field(1247, -1)) ?
					       this.data_.as_field(PING33.SparsVarEachBits.field) : this.data_.as_field(PING33.SparsVarEachBits.init)
				}
				
				
				public testBOOLX(): boolean | null {
					if (this.data_.field_bit != 1248 && !this.data_.set_field(1248, -1)) return null;
					
					return (this.data_.bytes.getUint8((this.data_.BIT) >> 3) & 1 << (this.data_.BIT & 7)) != 0;
				}
				
				
				public testBOOLX_(src: boolean) {
					if (this.data_.field_bit != 1248) this.data_.set_field(1248, 0);
					
					if (src) this.data_.bytes.setUint8((this.data_.BIT) >> 3, this.data_.bytes.getUint8((this.data_.BIT) >> 3) | (1 << (this.data_.BIT & 7)));
					else this.data_.bytes.setUint8((this.data_.BIT) >> 3, this.data_.bytes.getUint8((this.data_.BIT) >> 3) & (~(1 << (this.data_.BIT & 7))));
				}
				
				
				public testBOOL2X(): boolean | null {
					if (this.data_.field_bit != 1249 && !this.data_.set_field(1249, -1)) return null;
					
					return (this.data_.bytes.getUint8((this.data_.BIT) >> 3) & 1 << (this.data_.BIT & 7)) != 0;
				}
				
				
				public testBOOL2X_(src: boolean) {
					if (this.data_.field_bit != 1249) this.data_.set_field(1249, 0);
					
					if (src) this.data_.bytes.setUint8((this.data_.BIT) >> 3, this.data_.bytes.getUint8((this.data_.BIT) >> 3) | (1 << (this.data_.BIT & 7)));
					else this.data_.bytes.setUint8((this.data_.BIT) >> 3, this.data_.bytes.getUint8((this.data_.BIT) >> 3) & (~(1 << (this.data_.BIT & 7))));
				}
				
				
				public testBOOL3X(): boolean | null {
					if (this.data_.field_bit != 1250 && !this.data_.set_field(1250, -1)) return null;
					
					return (this.data_.bytes.getUint8((this.data_.BIT) >> 3) & 1 << (this.data_.BIT & 7)) != 0;
				}
				
				
				public testBOOL3X_(src: boolean) {
					if (this.data_.field_bit != 1250) this.data_.set_field(1250, 0);
					
					if (src) this.data_.bytes.setUint8((this.data_.BIT) >> 3, this.data_.bytes.getUint8((this.data_.BIT) >> 3) | (1 << (this.data_.BIT & 7)));
					else this.data_.bytes.setUint8((this.data_.BIT) >> 3, this.data_.bytes.getUint8((this.data_.BIT) >> 3) & (~(1 << (this.data_.BIT & 7))));
				}
				
				
				public MMMMMM(): MAV_MODE | null {
					if (this.data_.field_bit != 1251 && !this.data_.set_field(1251, -1)) return null;
					
					return _Host.MAV_MODE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 4));
				}
				
				
				public MMMMMM_(src: MAV_MODE) {
					if (this.data_.field_bit != 1251) this.data_.set_field(1251, 0);
					
					_Lib.set_bits(_Host.MAV_MODE_.into(src), 4, this.data_.bytes, this.data_.BIT);
				}
				
				
				public field44(): PING33.field44 | PING33.field44.Initializer {
					return (this.data_.field_bit == 1252 || this.data_.set_field(1252, -1)) ?
					       this.data_.as_field(PING33.field44.field) : this.data_.as_field(PING33.field44.init)
				}
				
				public field634(): PING33.field634 | PING33.field634.Initializer {
					return (this.data_.field_bit == 1253 || this.data_.set_field(1253, -1)) ?
					       this.data_.as_field(PING33.field634.field) : this.data_.as_field(PING33.field634.init)
				}
				
				public field33344(): PING33.field33344 | PING33.field33344.Initializer {
					return (this.data_.field_bit == 1254 || this.data_.set_field(1254, -1)) ?
					       this.data_.as_field(PING33.field33344.field) : this.data_.as_field(PING33.field33344.init)
				}
				
				public field333634(): PING33.field333634 | PING33.field333634.Initializer {
					return (this.data_.field_bit == 1255 || this.data_.set_field(1255, -1)) ?
					       this.data_.as_field(PING33.field333634.field) : this.data_.as_field(PING33.field333634.init)
				}
				
				
				public field___(src: number, d0: number, d1: number, d2: number) {
					if (this.data_.field_bit != 1256) this.data_.set_field(1256, 0);
					this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0);
					this.data_.bytes.setInt32(this.data_.BYTE, src, true);
				}
				
				field__(): PING33.field__ | null {
					return (this.data_.field_bit == 1256 || this.data_.set_field(1256, -1)) ?
					       this.data_.as_field(PING33.field__.field) : null;
				}
				
				public field63(): PING33.field63 | PING33.field63.Initializer {
					return (this.data_.field_bit == 1257 || this.data_.set_field(1257, -1)) ?
					       this.data_.as_field(PING33.field63.field) : this.data_.as_field(PING33.field63.init)
				}
				
				
				public uid2_(src: number, d0: number) {
					if (this.data_.field_bit != 1258) this.data_.set_field(1258, 0);
					this.data_.set_item(d0, 0);
					this.data_.bytes.setInt8(this.data_.BYTE, src);
				}
				
				uid2(): PING33.uid2 | null {
					return (this.data_.field_bit == 1258 || this.data_.set_field(1258, -1)) ?
					       this.data_.as_field(PING33.uid2.field) : null;
				}
				
				
				public field2_(src: number, d0: number, d1: number, d2: number) {
					if (this.data_.field_bit != 1259) this.data_.set_field(1259, 0);
					this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0);
					this.data_.bytes.setInt32(this.data_.BYTE, src, true);
				}
				
				field2(): PING33.field2 | null {
					return (this.data_.field_bit == 1259 || this.data_.set_field(1259, -1)) ?
					       this.data_.as_field(PING33.field2.field) : null;
				}
				
				
				public field4_(src: number, d0: number, d1: number, d2: number) {
					if (this.data_.field_bit != 1260) this.data_.set_field(1260, 0);
					this.data_.set_item(d0 + d1 * 3 + d2 * 3 * 2, 0);
					this.data_.bytes.setInt32(this.data_.BYTE, src, true);
				}
				
				field4(): PING33.field4 | null {
					return (this.data_.field_bit == 1260 || this.data_.set_field(1260, -1)) ?
					       this.data_.as_field(PING33.field4.field) : null;
				}
				
				
				stringtest1(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 1261 && !this.data_.set_field(1261, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				stringtest1_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -1261 - 1);
					
					let len = Math.min(src.byteLength, _Host.PING33.stringtest1.item_len_max);
					this.data_.set_field(1261, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				stringtest1$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.PING33.stringtest1.item_len_max)
					this.data_.set_field(1261, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
				public stringtest2(): PING33.stringtest2 | PING33.stringtest2.Initializer {
					return (this.data_.field_bit == 1262 || this.data_.set_field(1262, -1)) ?
					       this.data_.as_field(PING33.stringtest2.field) : this.data_.as_field(PING33.stringtest2.init)
				}
				
				
				stringtest3(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 1263 && !this.data_.set_field(1263, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				stringtest3_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -1263 - 1);
					
					let len = Math.min(src.byteLength, _Host.PING33.stringtest3.item_len_max);
					this.data_.set_field(1263, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				stringtest3$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.PING33.stringtest3.item_len_max)
					this.data_.set_field(1263, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
				stringtest4(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 1264 && !this.data_.set_field(1264, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				stringtest4_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -1264 - 1);
					
					let len = Math.min(src.byteLength, _Host.PING33.stringtest4.item_len_max);
					this.data_.set_field(1264, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				stringtest4$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.PING33.stringtest4.item_len_max)
					this.data_.set_field(1264, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				testBOOL_(src: boolean);
				
				seq_(src: number);
				
				field_(src: number);
				
				field1_init(d0: number);
				
				field1_(src: number, d0: number, d1: number, d2: number);
				
				field12_(src: number, d0: number, d1: number, d2: number);
				
				field13_(src: number, d0: number, d1: number, d2: number);
				
				TTTT_(src: number, d0: number, d1: number, d2: number);
				
				WWWWWWWW_(src: number);
				
				testBOOL2_(src: boolean);
				
				testBOOL3_(src: boolean);
				
				bit_field_(src: number);
				
				bit_field2_(src: number);
				
				Field_Bits_(src: number, d0: number, d1: number, d2: number);
				
				SparseFixAllBits_init(d0: number);
				
				SparseFixAllBits_(src: number, d0: number, d1: number, d2: number);
				
				FixAllBits_init(d0: number);
				
				FixAllBits_(src: number, d0: number, d1: number, d2: number);
				
				VarAllBits_init(d0: number, d2: number);
				
				VarAllBits_(src: number, d0: number, d1: number, d2: number);
				
				SparseVarAllBits_init(d0: number, d2: number);
				
				SparseVarAllBits_(src: number, d0: number, d1: number, d2: number);
				
				VarEachBits_init(d0: number);
				
				VarEachBits_(src: number, d0: number, d1: number, d2: number);
				
				SparsVarEachBits_init(d0: number);
				
				SparsVarEachBits_(src: number, d0: number, d1: number, d2: number);
				
				testBOOLX_(src: boolean);
				
				testBOOL2X_(src: boolean);
				
				testBOOL3X_(src: boolean);
				
				MMMMMM_(src: _Host.MAV_MODE);
				
				field44_init(d2: number);
				
				field44_(src: number, d0: number, d1: number, d2: number);
				
				field634_init(d2: number);
				
				field634_(src: number, d0: number, d1: number, d2: number);
				
				field33344_init(d2: number);
				
				field33344_(src: number, d0: number, d1: number, d2: number);
				
				field333634_init(d2: number);
				
				field333634_(src: number, d0: number, d1: number, d2: number);
				
				field___(src: number, d0: number, d1: number, d2: number);
				
				field6_(src: number, d0: number, d1: number, d2: number);
				
				field63_init(d2: number);
				
				field63_(src: number, d0: number, d1: number, d2: number);
				
				uid2_(src: number, d0: number);
				
				field2_(src: number, d0: number, d1: number, d2: number);
				
				field4_(src: number, d0: number, d1: number, d2: number);
				
				stringtest1_(src: _Cursor.UTF8);
				
				stringtest2_init(d2: number);
				
				stringtest2_(src: _Cursor.UTF8, d0: number, d1: number, d2: number);
				
				stringtest3_(src: _Cursor.UTF8);
				
				stringtest4_(src: _Cursor.UTF8);
				
			}
			
			export function push_<DST extends DST_>(src: PING33, dst: DST) {
				
				{
					const item = src.testBOOL();
					if (item !== null) dst.testBOOL_(item);
					
				}
				
				{
					const item = src.seq();
					if (item !== null) dst.seq_(item);
					
				}
				
				dst.field_(src.field());
				{
					const fld = src.field1();
					if (fld instanceof _Host.PING33.field1.Field) {
						dst.field1_init(fld.d0());
						for (let d0 = 0; d0 < fld.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.field1.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field1.d2; d2++) {
									const item = fld.get(d0, d1, d2);
									dst.field1_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const fld = src.field12();
					if (fld)
						for (let d0 = 0; d0 < _Host.PING33.field12.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field12.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field12.d2; d2++) {
									const item = fld.get(d0, d1, d2);
									dst.field12_(item, d0, d1, d2);
									
								}
				}
				
				{
					const fld = src.field13();
					if (fld)
						for (let d0 = 0; d0 < _Host.PING33.field13.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field13.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field13.d2; d2++) {
									const item = fld.get(d0, d1, d2);
									if (item !== null) dst.field13_(item, d0, d1, d2);
									
								}
				}
				
				{
					
					for (let d0 = 0; d0 < _Host.PING33.TTTT.d0; d0++)
						for (let d1 = 0; d1 < _Host.PING33.TTTT.d1; d1++)
							for (let d2 = 0; d2 < _Host.PING33.TTTT.d2; d2++)
								
								
								dst.TTTT_(src.TTTT(d0, d1, d2), d0, d1, d2);
					
				}
				
				{
					const item = src.WWWWWWWW();
					if (item !== null) dst.WWWWWWWW_(item);
					
				}
				
				dst.testBOOL2_(src.testBOOL2());
				
				dst.testBOOL3_(src.testBOOL3());
				
				dst.bit_field_(src.bit_field());
				
				{
					const item = src.bit_field2();
					if (item !== null) dst.bit_field2_(item);
					
				}
				
				{
					const fld = src.Field_Bits();
					if (fld)
						for (let d0 = 0; d0 < _Host.PING33.Field_Bits.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.Field_Bits.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.Field_Bits.d2; d2++) {
									const item = fld.get(d0, d1, d2);
									dst.Field_Bits_(item, d0, d1, d2);
									
								}
				}
				{
					const fld = src.SparseFixAllBits();
					if (fld instanceof _Host.PING33.SparseFixAllBits.Field) {
						dst.SparseFixAllBits_init(fld.d0());
						for (let d0 = 0; d0 < fld.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.SparseFixAllBits.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.SparseFixAllBits.d2; d2++) {
									const item = fld.get(d0, d1, d2);
									if (item !== null) dst.SparseFixAllBits_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const fld = src.FixAllBits();
					if (fld instanceof _Host.PING33.FixAllBits.Field) {
						dst.FixAllBits_init(fld.d0());
						for (let d0 = 0; d0 < fld.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.FixAllBits.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.FixAllBits.d2; d2++) {
									const item = fld.get(d0, d1, d2);
									dst.FixAllBits_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const fld = src.VarAllBits();
					if (fld instanceof _Host.PING33.VarAllBits.Field) {
						dst.VarAllBits_init(fld.d0(), fld.d2());
						for (let d0 = 0; d0 < fld.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.VarAllBits.d1; d1++)
								for (let d2 = 0; d2 < fld.d2(); d2++) {
									const item = fld.get(d0, d1, d2);
									dst.VarAllBits_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const fld = src.SparseVarAllBits();
					if (fld instanceof _Host.PING33.SparseVarAllBits.Field) {
						dst.SparseVarAllBits_init(fld.d0(), fld.d2());
						for (let d0 = 0; d0 < fld.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.SparseVarAllBits.d1; d1++)
								for (let d2 = 0; d2 < fld.d2(); d2++) {
									const item = fld.get(d0, d1, d2);
									if (item !== null) dst.SparseVarAllBits_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const fld = src.VarEachBits();
					if (fld instanceof _Host.PING33.VarEachBits.Field) {
						dst.VarEachBits_init(fld.d0());
						for (let d0 = 0; d0 < fld.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.VarEachBits.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.VarEachBits.d2; d2++) {
									const item = fld.get(d0, d1, d2);
									dst.VarEachBits_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const fld = src.SparsVarEachBits();
					if (fld instanceof _Host.PING33.SparsVarEachBits.Field) {
						dst.SparsVarEachBits_init(fld.d0());
						for (let d0 = 0; d0 < fld.d0(); d0++)
							for (let d1 = 0; d1 < _Host.PING33.SparsVarEachBits.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.SparsVarEachBits.d2; d2++) {
									const item = fld.get(d0, d1, d2);
									if (item !== null) dst.SparsVarEachBits_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const item = src.testBOOLX();
					if (item !== null) dst.testBOOLX_(item);
					
				}
				
				{
					const item = src.testBOOL2X();
					if (item !== null) dst.testBOOL2X_(item);
					
				}
				
				{
					const item = src.testBOOL3X();
					if (item !== null) dst.testBOOL3X_(item);
					
				}
				
				{
					const item = src.MMMMMM();
					if (item !== null) dst.MMMMMM_(item);
					
				}
				{
					const fld = src.field44();
					if (fld instanceof _Host.PING33.field44.Field) {
						dst.field44_init(fld.d2());
						for (let d0 = 0; d0 < _Host.PING33.field44.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field44.d1; d1++)
								for (let d2 = 0; d2 < fld.d2(); d2++) {
									const item = fld.get(d0, d1, d2);
									dst.field44_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const fld = src.field634();
					if (fld instanceof _Host.PING33.field634.Field) {
						dst.field634_init(fld.d2());
						for (let d0 = 0; d0 < _Host.PING33.field634.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field634.d1; d1++)
								for (let d2 = 0; d2 < fld.d2(); d2++) {
									const item = fld.get(d0, d1, d2);
									dst.field634_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const fld = src.field33344();
					if (fld instanceof _Host.PING33.field33344.Field) {
						dst.field33344_init(fld.d2());
						for (let d0 = 0; d0 < _Host.PING33.field33344.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field33344.d1; d1++)
								for (let d2 = 0; d2 < fld.d2(); d2++) {
									const item = fld.get(d0, d1, d2);
									if (item !== null) dst.field33344_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const fld = src.field333634();
					if (fld instanceof _Host.PING33.field333634.Field) {
						dst.field333634_init(fld.d2());
						for (let d0 = 0; d0 < _Host.PING33.field333634.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field333634.d1; d1++)
								for (let d2 = 0; d2 < fld.d2(); d2++) {
									const item = fld.get(d0, d1, d2);
									if (item !== null) dst.field333634_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const fld = src.field__();
					if (fld)
						for (let d0 = 0; d0 < _Host.PING33.field__.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field__.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field__.d2; d2++) {
									const item = fld.get(d0, d1, d2);
									if (item !== null) dst.field___(item, d0, d1, d2);
									
								}
				}
				
				{
					
					for (let d0 = 0; d0 < _Host.PING33.field6.d0; d0++)
						for (let d1 = 0; d1 < _Host.PING33.field6.d1; d1++)
							for (let d2 = 0; d2 < _Host.PING33.field6.d2; d2++)
								
								
								dst.field6_(src.field6(d0, d1, d2), d0, d1, d2);
					
				}
				{
					const fld = src.field63();
					if (fld instanceof _Host.PING33.field63.Field) {
						dst.field63_init(fld.d2());
						for (let d0 = 0; d0 < _Host.PING33.field63.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field63.d1; d1++)
								for (let d2 = 0; d2 < fld.d2(); d2++) {
									const item = fld.get(d0, d1, d2);
									dst.field63_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const fld = src.uid2();
					if (fld)
						for (let d0 = 0; d0 < _Host.PING33.uid2.d0; d0++) {
							const item = fld.get(d0);
							if (item !== null) dst.uid2_(item, d0);
							
						}
				}
				
				{
					const fld = src.field2();
					if (fld)
						for (let d0 = 0; d0 < _Host.PING33.field2.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field2.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field2.d2; d2++) {
									const item = fld.get(d0, d1, d2);
									if (item !== null) dst.field2_(item, d0, d1, d2);
									
								}
				}
				
				{
					const fld = src.field4();
					if (fld)
						for (let d0 = 0; d0 < _Host.PING33.field4.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.field4.d1; d1++)
								for (let d2 = 0; d2 < _Host.PING33.field4.d2; d2++) {
									const item = fld.get(d0, d1, d2);
									if (item !== null) dst.field4_(item, d0, d1, d2);
									
								}
				}
				
				{
					const item = src.stringtest1();
					if (item !== null) dst.stringtest1_(item);
					
				}
				{
					const fld = src.stringtest2();
					if (fld instanceof _Host.PING33.stringtest2.Field) {
						dst.stringtest2_init(fld.d2());
						for (let d0 = 0; d0 < _Host.PING33.stringtest2.d0; d0++)
							for (let d1 = 0; d1 < _Host.PING33.stringtest2.d1; d1++)
								for (let d2 = 0; d2 < fld.d2(); d2++) {
									const item = fld.get(d0, d1, d2);
									if (item !== null) dst.stringtest2_(item, d0, d1, d2);
									
								}
					}
				}
				{
					const item = src.stringtest3();
					if (item !== null) dst.stringtest3_(item);
					
				}
				
				{
					const item = src.stringtest4();
					if (item !== null) dst.stringtest4_(item);
					
				}
				
			}
			
			export interface SRC_ {
				testBOOL(): boolean | null;
				
				seq(): number | null;
				
				field(): number;
				
				field1_init(init_field: _Host.PING33.field1.Initializer);
				
				field1(d0: number, d1: number, d2: number): number;
				
				field12_exist(): boolean;
				
				field12(d0: number, d1: number, d2: number): number;
				
				field13_exist(): boolean;
				
				field13(d0: number, d1: number, d2: number): number | null;
				
				TTTT(d0: number, d1: number, d2: number): number;
				
				WWWWWWWW(): number | null;
				
				testBOOL2(): boolean;
				
				testBOOL3(): boolean;
				
				bit_field(): number;
				
				bit_field2(): number | null;
				
				Field_Bits_exist(): boolean;
				
				Field_Bits(d0: number, d1: number, d2: number): number;
				
				SparseFixAllBits_init(init_field: _Host.PING33.SparseFixAllBits.Initializer);
				
				SparseFixAllBits(d0: number, d1: number, d2: number): number | null;
				
				FixAllBits_init(init_field: _Host.PING33.FixAllBits.Initializer);
				
				FixAllBits(d0: number, d1: number, d2: number): number;
				
				VarAllBits_init(init_field: _Host.PING33.VarAllBits.Initializer);
				
				VarAllBits(d0: number, d1: number, d2: number): number;
				
				SparseVarAllBits_init(init_field: _Host.PING33.SparseVarAllBits.Initializer);
				
				SparseVarAllBits(d0: number, d1: number, d2: number): number | null;
				
				VarEachBits_init(init_field: _Host.PING33.VarEachBits.Initializer);
				
				VarEachBits(d0: number, d1: number, d2: number): number;
				
				SparsVarEachBits_init(init_field: _Host.PING33.SparsVarEachBits.Initializer);
				
				SparsVarEachBits(d0: number, d1: number, d2: number): number | null;
				
				testBOOLX(): boolean | null;
				
				testBOOL2X(): boolean | null;
				
				testBOOL3X(): boolean | null;
				
				MMMMMM(): _Host.MAV_MODE | null;
				
				field44_init(init_field: _Host.PING33.field44.Initializer);
				
				field44(d0: number, d1: number, d2: number): number;
				
				field634_init(init_field: _Host.PING33.field634.Initializer);
				
				field634(d0: number, d1: number, d2: number): number;
				
				field33344_init(init_field: _Host.PING33.field33344.Initializer);
				
				field33344(d0: number, d1: number, d2: number): number | null;
				
				field333634_init(init_field: _Host.PING33.field333634.Initializer);
				
				field333634(d0: number, d1: number, d2: number): number | null;
				
				field___exist(): boolean;
				
				field__(d0: number, d1: number, d2: number): number | null;
				
				field6(d0: number, d1: number, d2: number): number;
				
				field63_init(init_field: _Host.PING33.field63.Initializer);
				
				field63(d0: number, d1: number, d2: number): number;
				
				uid2_exist(): boolean;
				
				uid2(d0: number): number | null;
				
				field2_exist(): boolean;
				
				field2(d0: number, d1: number, d2: number): number | null;
				
				field4_exist(): boolean;
				
				field4(d0: number, d1: number, d2: number): number | null;
				
				stringtest1(): string | Uint8Array | null;
				
				stringtest2_init(init_field: _Host.PING33.stringtest2.Initializer);
				
				stringtest2(d0: number, d1: number, d2: number): string | Uint8Array | null;
				
				stringtest3(): string | Uint8Array | null;
				
				stringtest4(): string | Uint8Array | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: PING33) {
				{
					const item = src.testBOOL();
					if (item !== null) dst.testBOOL_(item);
					
				}
				{
					const item = src.seq();
					if (item !== null) dst.seq_(item);
					
				}
				
				dst.field_(src.field());
				
				{
					let fld = dst.field1();
					if (fld instanceof _Host.PING33.field1.Initializer) {
						src.field1_init(fld);
						fld = dst.field1();
						if (fld instanceof _Host.PING33.field1.Field)
							for (let d0 = 0; d0 < fld.d0(); d0++)
								for (let d1 = 0; d1 < _Host.PING33.field1.d1; d1++)
									for (let d2 = 0; d2 < _Host.PING33.field1.d2; d2++) {
										fld.set(src.field1(d0, d1, d2), d0, d1, d2);
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				if (src.field12_exist())
					for (let d0 = 0; d0 < _Host.PING33.field12.d0; d0++)
						for (let d1 = 0; d1 < _Host.PING33.field12.d1; d1++)
							for (let d2 = 0; d2 < _Host.PING33.field12.d2; d2++)
								
								dst.field12_(src.field12(d0, d1, d2), d0, d1, d2);
				
				
				if (src.field13_exist())
					for (let d0 = 0; d0 < _Host.PING33.field13.d0; d0++)
						for (let d1 = 0; d1 < _Host.PING33.field13.d1; d1++)
							for (let d2 = 0; d2 < _Host.PING33.field13.d2; d2++) {
								const item = src.field13(d0, d1, d2);
								if (item !== null) dst.field13_(item, d0, d1, d2);
							}
				
				for (let d0 = 0; d0 < _Host.PING33.TTTT.d0; d0++)
					for (let d1 = 0; d1 < _Host.PING33.TTTT.d1; d1++)
						for (let d2 = 0; d2 < _Host.PING33.TTTT.d2; d2++) {
							
							dst.TTTT_(src.TTTT(d0, d1, d2), d0, d1, d2);
							
						}
				{
					const item = src.WWWWWWWW();
					if (item !== null) dst.WWWWWWWW_(item);
					
				}
				
				dst.testBOOL2_(src.testBOOL2());
				
				dst.testBOOL3_(src.testBOOL3());
				
				dst.bit_field_(src.bit_field());
				{
					const item = src.bit_field2();
					if (item !== null) dst.bit_field2_(item);
					
				}
				
				if (src.Field_Bits_exist())
					for (let d0 = 0; d0 < _Host.PING33.Field_Bits.d0; d0++)
						for (let d1 = 0; d1 < _Host.PING33.Field_Bits.d1; d1++)
							for (let d2 = 0; d2 < _Host.PING33.Field_Bits.d2; d2++)
								
								dst.Field_Bits_(src.Field_Bits(d0, d1, d2), d0, d1, d2);
				
				
				{
					let fld = dst.SparseFixAllBits();
					if (fld instanceof _Host.PING33.SparseFixAllBits.Initializer) {
						src.SparseFixAllBits_init(fld);
						fld = dst.SparseFixAllBits();
						if (fld instanceof _Host.PING33.SparseFixAllBits.Field)
							for (let d0 = 0; d0 < fld.d0(); d0++)
								for (let d1 = 0; d1 < _Host.PING33.SparseFixAllBits.d1; d1++)
									for (let d2 = 0; d2 < _Host.PING33.SparseFixAllBits.d2; d2++) {
										{
											const item = src.SparseFixAllBits(d0, d1, d2);
											if (item !== null) fld.set(item, d0, d1, d2);
										}
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				{
					let fld = dst.FixAllBits();
					if (fld instanceof _Host.PING33.FixAllBits.Initializer) {
						src.FixAllBits_init(fld);
						fld = dst.FixAllBits();
						if (fld instanceof _Host.PING33.FixAllBits.Field)
							for (let d0 = 0; d0 < fld.d0(); d0++)
								for (let d1 = 0; d1 < _Host.PING33.FixAllBits.d1; d1++)
									for (let d2 = 0; d2 < _Host.PING33.FixAllBits.d2; d2++) {
										fld.set(src.FixAllBits(d0, d1, d2), d0, d1, d2);
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				{
					let fld = dst.VarAllBits();
					if (fld instanceof _Host.PING33.VarAllBits.Initializer) {
						src.VarAllBits_init(fld);
						fld = dst.VarAllBits();
						if (fld instanceof _Host.PING33.VarAllBits.Field)
							for (let d0 = 0; d0 < fld.d0(); d0++)
								for (let d1 = 0; d1 < _Host.PING33.VarAllBits.d1; d1++)
									for (let d2 = 0; d2 < fld.d2(); d2++) {
										fld.set(src.VarAllBits(d0, d1, d2), d0, d1, d2);
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				{
					let fld = dst.SparseVarAllBits();
					if (fld instanceof _Host.PING33.SparseVarAllBits.Initializer) {
						src.SparseVarAllBits_init(fld);
						fld = dst.SparseVarAllBits();
						if (fld instanceof _Host.PING33.SparseVarAllBits.Field)
							for (let d0 = 0; d0 < fld.d0(); d0++)
								for (let d1 = 0; d1 < _Host.PING33.SparseVarAllBits.d1; d1++)
									for (let d2 = 0; d2 < fld.d2(); d2++) {
										{
											const item = src.SparseVarAllBits(d0, d1, d2);
											if (item !== null) fld.set(item, d0, d1, d2);
										}
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				{
					let fld = dst.VarEachBits();
					if (fld instanceof _Host.PING33.VarEachBits.Initializer) {
						src.VarEachBits_init(fld);
						fld = dst.VarEachBits();
						if (fld instanceof _Host.PING33.VarEachBits.Field)
							for (let d0 = 0; d0 < fld.d0(); d0++)
								for (let d1 = 0; d1 < _Host.PING33.VarEachBits.d1; d1++)
									for (let d2 = 0; d2 < _Host.PING33.VarEachBits.d2; d2++) {
										fld.set(src.VarEachBits(d0, d1, d2), d0, d1, d2);
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				{
					let fld = dst.SparsVarEachBits();
					if (fld instanceof _Host.PING33.SparsVarEachBits.Initializer) {
						src.SparsVarEachBits_init(fld);
						fld = dst.SparsVarEachBits();
						if (fld instanceof _Host.PING33.SparsVarEachBits.Field)
							for (let d0 = 0; d0 < fld.d0(); d0++)
								for (let d1 = 0; d1 < _Host.PING33.SparsVarEachBits.d1; d1++)
									for (let d2 = 0; d2 < _Host.PING33.SparsVarEachBits.d2; d2++) {
										{
											const item = src.SparsVarEachBits(d0, d1, d2);
											if (item !== null) fld.set(item, d0, d1, d2);
										}
										
									}
					}
					else throw new Error("dst already has data")
				}
				{
					const item = src.testBOOLX();
					if (item !== null) dst.testBOOLX_(item);
					
				}
				{
					const item = src.testBOOL2X();
					if (item !== null) dst.testBOOL2X_(item);
					
				}
				{
					const item = src.testBOOL3X();
					if (item !== null) dst.testBOOL3X_(item);
					
				}
				{
					const item = src.MMMMMM();
					if (item !== null) dst.MMMMMM_(item);
					
				}
				
				{
					let fld = dst.field44();
					if (fld instanceof _Host.PING33.field44.Initializer) {
						src.field44_init(fld);
						fld = dst.field44();
						if (fld instanceof _Host.PING33.field44.Field)
							for (let d0 = 0; d0 < _Host.PING33.field44.d0; d0++)
								for (let d1 = 0; d1 < _Host.PING33.field44.d1; d1++)
									for (let d2 = 0; d2 < fld.d2(); d2++) {
										fld.set(src.field44(d0, d1, d2), d0, d1, d2);
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				{
					let fld = dst.field634();
					if (fld instanceof _Host.PING33.field634.Initializer) {
						src.field634_init(fld);
						fld = dst.field634();
						if (fld instanceof _Host.PING33.field634.Field)
							for (let d0 = 0; d0 < _Host.PING33.field634.d0; d0++)
								for (let d1 = 0; d1 < _Host.PING33.field634.d1; d1++)
									for (let d2 = 0; d2 < fld.d2(); d2++) {
										fld.set(src.field634(d0, d1, d2), d0, d1, d2);
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				{
					let fld = dst.field33344();
					if (fld instanceof _Host.PING33.field33344.Initializer) {
						src.field33344_init(fld);
						fld = dst.field33344();
						if (fld instanceof _Host.PING33.field33344.Field)
							for (let d0 = 0; d0 < _Host.PING33.field33344.d0; d0++)
								for (let d1 = 0; d1 < _Host.PING33.field33344.d1; d1++)
									for (let d2 = 0; d2 < fld.d2(); d2++) {
										{
											const item = src.field33344(d0, d1, d2);
											if (item !== null) fld.set(item, d0, d1, d2);
										}
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				{
					let fld = dst.field333634();
					if (fld instanceof _Host.PING33.field333634.Initializer) {
						src.field333634_init(fld);
						fld = dst.field333634();
						if (fld instanceof _Host.PING33.field333634.Field)
							for (let d0 = 0; d0 < _Host.PING33.field333634.d0; d0++)
								for (let d1 = 0; d1 < _Host.PING33.field333634.d1; d1++)
									for (let d2 = 0; d2 < fld.d2(); d2++) {
										{
											const item = src.field333634(d0, d1, d2);
											if (item !== null) fld.set(item, d0, d1, d2);
										}
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				if (src.field___exist())
					for (let d0 = 0; d0 < _Host.PING33.field__.d0; d0++)
						for (let d1 = 0; d1 < _Host.PING33.field__.d1; d1++)
							for (let d2 = 0; d2 < _Host.PING33.field__.d2; d2++) {
								const item = src.field__(d0, d1, d2);
								if (item !== null) dst.field___(item, d0, d1, d2);
							}
				
				for (let d0 = 0; d0 < _Host.PING33.field6.d0; d0++)
					for (let d1 = 0; d1 < _Host.PING33.field6.d1; d1++)
						for (let d2 = 0; d2 < _Host.PING33.field6.d2; d2++) {
							
							dst.field6_(src.field6(d0, d1, d2), d0, d1, d2);
							
						}
				
				{
					let fld = dst.field63();
					if (fld instanceof _Host.PING33.field63.Initializer) {
						src.field63_init(fld);
						fld = dst.field63();
						if (fld instanceof _Host.PING33.field63.Field)
							for (let d0 = 0; d0 < _Host.PING33.field63.d0; d0++)
								for (let d1 = 0; d1 < _Host.PING33.field63.d1; d1++)
									for (let d2 = 0; d2 < fld.d2(); d2++) {
										fld.set(src.field63(d0, d1, d2), d0, d1, d2);
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				if (src.uid2_exist())
					for (let d0 = 0; d0 < _Host.PING33.uid2.d0; d0++) {
						const item = src.uid2(d0);
						if (item !== null) dst.uid2_(item, d0);
					}
				
				
				if (src.field2_exist())
					for (let d0 = 0; d0 < _Host.PING33.field2.d0; d0++)
						for (let d1 = 0; d1 < _Host.PING33.field2.d1; d1++)
							for (let d2 = 0; d2 < _Host.PING33.field2.d2; d2++) {
								const item = src.field2(d0, d1, d2);
								if (item !== null) dst.field2_(item, d0, d1, d2);
							}
				
				
				if (src.field4_exist())
					for (let d0 = 0; d0 < _Host.PING33.field4.d0; d0++)
						for (let d1 = 0; d1 < _Host.PING33.field4.d1; d1++)
							for (let d2 = 0; d2 < _Host.PING33.field4.d2; d2++) {
								const item = src.field4(d0, d1, d2);
								if (item !== null) dst.field4_(item, d0, d1, d2);
							}
				
				
				{
					const item = src.stringtest1();
					if (item !== null) dst.stringtest1_(item);
				}
				
				
				{
					let fld = dst.stringtest2();
					if (fld instanceof _Host.PING33.stringtest2.Initializer) {
						src.stringtest2_init(fld);
						fld = dst.stringtest2();
						if (fld instanceof _Host.PING33.stringtest2.Field)
							for (let d0 = 0; d0 < _Host.PING33.stringtest2.d0; d0++)
								for (let d1 = 0; d1 < _Host.PING33.stringtest2.d1; d1++)
									for (let d2 = 0; d2 < fld.d2(); d2++) {
										
										{
											const item = src.stringtest2(d0, d1, d2);
											if (item !== null) fld.set(item, d0, d1, d2);
										}
										
									}
					}
					else throw new Error("dst already has data")
				}
				
				
				{
					const item = src.stringtest3();
					if (item !== null) dst.stringtest3_(item);
				}
				
				
				{
					const item = src.stringtest4();
					if (item !== null) dst.stringtest4_(item);
				}
				
				
			}
			
		}
		
		export interface VFR_HUD {
			throttle(): number;
			
			airspeed(): number;
			
			groundspeed(): number;
			
			heading(): number;
			
			alt(): number;
			
			climb(): number;
			
		}
		
		export namespace VFR_HUD {
			
			export const meta_ = new _Pack.Meta(15, 1, 0, 0, 20, 160);
			
			
			class Impl_ extends _Cursor.View implements VFR_HUD {
				
				public throttle(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public airspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 2, true);}
				
				
				public groundspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 6, true);}
				
				
				public heading(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				
				public alt(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public climb(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				airspeed_(src: number);
				
				groundspeed_(src: number);
				
				heading_(src: number);
				
				throttle_(src: number);
				
				alt_(src: number);
				
				climb_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: VFR_HUD, dst: DST) {
				
				dst.airspeed_(src.airspeed());
				
				dst.groundspeed_(src.groundspeed());
				
				dst.heading_(src.heading());
				
				dst.throttle_(src.throttle());
				
				dst.alt_(src.alt());
				
				dst.climb_(src.climb());
				
			}
			
		}
		
		export interface RALLY_POINT {
			land_dir(): number;
			
			land_dir_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			idx(): number;
			
			idx_(src: number);
			
			count(): number;
			
			count_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lng(): number;
			
			lng_(src: number);
			
			alt(): number;
			
			alt_(src: number);
			
			break_alt(): number;
			
			break_alt_(src: number);
			
			flags(): RALLY_FLAGS | null;
			
			flags_(src: RALLY_FLAGS);
			
		}
		
		export namespace RALLY_POINT {
			
			export const meta_ = new _Pack.Meta(197, 1, 0, 0, 19, 144, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements RALLY_POINT {
				
				public land_dir(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public land_dir_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
				public idx(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public idx_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public count(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public count_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public lng(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public lng_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
				public alt(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				public alt_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 14, src, true); }
				
				public break_alt(): number { return this.data_.bytes.getInt16(this.data_.origin + 16, true);}
				
				public break_alt_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 16, src, true); }
				
				
				public flags(): RALLY_FLAGS | null {
					if (this.data_.field_bit != 144 && !this.data_.set_field(144, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 1);
				}
				
				
				public flags_(src: RALLY_FLAGS) {
					if (this.data_.field_bit != 144) this.data_.set_field(144, 0);
					
					_Lib.set_bits(src, 1, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				idx_(src: number);
				
				count_(src: number);
				
				lat_(src: number);
				
				lng_(src: number);
				
				alt_(src: number);
				
				break_alt_(src: number);
				
				land_dir_(src: number);
				
				flags_(src: _Host.RALLY_FLAGS);
				
			}
			
			export function push_<DST extends DST_>(src: RALLY_POINT, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.idx_(src.idx());
				
				dst.count_(src.count());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
				dst.alt_(src.alt());
				
				dst.break_alt_(src.break_alt());
				
				dst.land_dir_(src.land_dir());
				
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				idx(): number;
				
				count(): number;
				
				lat(): number;
				
				lng(): number;
				
				alt(): number;
				
				break_alt(): number;
				
				land_dir(): number;
				
				flags(): _Host.RALLY_FLAGS | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: RALLY_POINT) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.idx_(src.idx());
				
				dst.count_(src.count());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
				dst.alt_(src.alt());
				
				dst.break_alt_(src.break_alt());
				
				dst.land_dir_(src.land_dir());
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
			}
			
		}
		
		export interface MISSION_SET_CURRENT {
			seq(): number;
			
			target_system(): number;
			
			target_component(): number;
			
		}
		
		export namespace MISSION_SET_CURRENT {
			
			export const meta_ = new _Pack.Meta(212, 1, 0, 0, 4, 32);
			
			
			class Impl_ extends _Cursor.View implements MISSION_SET_CURRENT {
				
				public seq(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				seq_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_SET_CURRENT, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.seq_(src.seq());
				
			}
			
		}
		
		export interface ADAP_TUNING {
			desired(): number;
			
			desired_(src: number);
			
			achieved(): number;
			
			achieved_(src: number);
			
			error(): number;
			
			error_(src: number);
			
			theta(): number;
			
			theta_(src: number);
			
			omega(): number;
			
			omega_(src: number);
			
			sigma(): number;
			
			sigma_(src: number);
			
			theta_dot(): number;
			
			theta_dot_(src: number);
			
			omega_dot(): number;
			
			omega_dot_(src: number);
			
			sigma_dot(): number;
			
			sigma_dot_(src: number);
			
			f(): number;
			
			f_(src: number);
			
			f_dot(): number;
			
			f_dot_(src: number);
			
			u(): number;
			
			u_(src: number);
			
			axis(): PID_TUNING_AXIS | null;
			
			axis_(src: PID_TUNING_AXIS);
			
		}
		
		export namespace ADAP_TUNING {
			
			export const meta_ = new _Pack.Meta(115, 0, 0, 0, 49, 384, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements ADAP_TUNING {
				
				public desired(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public desired_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public achieved(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public achieved_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public error(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public error_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public theta(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public theta_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public omega(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public omega_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public sigma(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public sigma_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public theta_dot(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public theta_dot_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public omega_dot(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public omega_dot_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public sigma_dot(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public sigma_dot_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public f(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				public f_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 36, src, true); }
				
				public f_dot(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				public f_dot_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 40, src, true); }
				
				public u(): number { return this.data_.bytes.getFloat32(this.data_.origin + 44, true);}
				
				public u_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 44, src, true); }
				
				
				public axis(): PID_TUNING_AXIS | null {
					if (this.data_.field_bit != 384 && !this.data_.set_field(384, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public axis_(src: PID_TUNING_AXIS) {
					if (this.data_.field_bit != 384) this.data_.set_field(384, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				axis_(src: _Host.PID_TUNING_AXIS);
				
				desired_(src: number);
				
				achieved_(src: number);
				
				error_(src: number);
				
				theta_(src: number);
				
				omega_(src: number);
				
				sigma_(src: number);
				
				theta_dot_(src: number);
				
				omega_dot_(src: number);
				
				sigma_dot_(src: number);
				
				f_(src: number);
				
				f_dot_(src: number);
				
				u_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: ADAP_TUNING, dst: DST) {
				
				{
					const item = src.axis();
					if (item !== null) dst.axis_(item);
					
				}
				
				dst.desired_(src.desired());
				
				dst.achieved_(src.achieved());
				
				dst.error_(src.error());
				
				dst.theta_(src.theta());
				
				dst.omega_(src.omega());
				
				dst.sigma_(src.sigma());
				
				dst.theta_dot_(src.theta_dot());
				
				dst.omega_dot_(src.omega_dot());
				
				dst.sigma_dot_(src.sigma_dot());
				
				dst.f_(src.f());
				
				dst.f_dot_(src.f_dot());
				
				dst.u_(src.u());
				
			}
			
			export interface SRC_ {
				axis(): _Host.PID_TUNING_AXIS | null;
				
				desired(): number;
				
				achieved(): number;
				
				error(): number;
				
				theta(): number;
				
				omega(): number;
				
				sigma(): number;
				
				theta_dot(): number;
				
				omega_dot(): number;
				
				sigma_dot(): number;
				
				f(): number;
				
				f_dot(): number;
				
				u(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: ADAP_TUNING) {
				{
					const item = src.axis();
					if (item !== null) dst.axis_(item);
					
				}
				
				dst.desired_(src.desired());
				
				dst.achieved_(src.achieved());
				
				dst.error_(src.error());
				
				dst.theta_(src.theta());
				
				dst.omega_(src.omega());
				
				dst.sigma_(src.sigma());
				
				dst.theta_dot_(src.theta_dot());
				
				dst.omega_dot_(src.omega_dot());
				
				dst.sigma_dot_(src.sigma_dot());
				
				dst.f_(src.f());
				
				dst.f_dot_(src.f_dot());
				
				dst.u_(src.u());
				
			}
			
		}
		
		export interface VIBRATION {
			clipping_0(): number;
			
			clipping_0_(src: number);
			
			clipping_1(): number;
			
			clipping_1_(src: number);
			
			clipping_2(): number;
			
			clipping_2_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			vibration_x(): number;
			
			vibration_x_(src: number);
			
			vibration_y(): number;
			
			vibration_y_(src: number);
			
			vibration_z(): number;
			
			vibration_z_(src: number);
			
		}
		
		export namespace VIBRATION {
			
			export const meta_ = new _Pack.Meta(103, 0, 3, 1, 32, 256);
			
			
			class Impl_ extends _Cursor.View implements VIBRATION {
				
				public clipping_0(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public clipping_0_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public clipping_1(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				public clipping_1_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 4, src, true); }
				
				public clipping_2(): number { return this.data_.bytes.getInt32(this.data_.origin + 8, true);}
				
				public clipping_2_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 8, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 12, true) + this.data_.bytes.getInt32(this.data_.origin + 12 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 12, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 12 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public vibration_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public vibration_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public vibration_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public vibration_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public vibration_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public vibration_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				vibration_x_(src: number);
				
				vibration_y_(src: number);
				
				vibration_z_(src: number);
				
				clipping_0_(src: number);
				
				clipping_1_(src: number);
				
				clipping_2_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: VIBRATION, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.vibration_x_(src.vibration_x());
				
				dst.vibration_y_(src.vibration_y());
				
				dst.vibration_z_(src.vibration_z());
				
				dst.clipping_0_(src.clipping_0());
				
				dst.clipping_1_(src.clipping_1());
				
				dst.clipping_2_(src.clipping_2());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				vibration_x(): number;
				
				vibration_y(): number;
				
				vibration_z(): number;
				
				clipping_0(): number;
				
				clipping_1(): number;
				
				clipping_2(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: VIBRATION) {
				
				dst.time_usec_(src.time_usec());
				
				dst.vibration_x_(src.vibration_x());
				
				dst.vibration_y_(src.vibration_y());
				
				dst.vibration_z_(src.vibration_z());
				
				dst.clipping_0_(src.clipping_0());
				
				dst.clipping_1_(src.clipping_1());
				
				dst.clipping_2_(src.clipping_2());
				
			}
			
		}
		
		export interface PARAM_EXT_VALUE {
			param_count(): number;
			
			param_count_(src: number);
			
			param_index(): number;
			
			param_index_(src: number);
			
			param_id(): _Cursor.UTF8 | null;
			
			param_id_(src: string | Uint8Array): _Cursor.UTF8;
			
			param_id$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
			param_value(): _Cursor.UTF8 | null;
			
			param_value_(src: string | Uint8Array): _Cursor.UTF8;
			
			param_value$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
			param_type(): MAV_PARAM_EXT_TYPE | null;
			
			param_type_(src: MAV_PARAM_EXT_TYPE);
			
		}
		
		export namespace PARAM_EXT_VALUE {
			
			export const meta_ = new _Pack.Meta(14, 2, 0, 0, 5, 35, 3, 3);
			
			
			export namespace param_id {
				export const item_len_max = 255;
				
			}
			export namespace param_value {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements PARAM_EXT_VALUE {
				
				public param_count(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public param_count_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public param_index(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public param_index_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				
				param_id(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 35 && !this.data_.set_field(35, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				param_id_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -35 - 1);
					
					let len = Math.min(src.byteLength, _Host.PARAM_EXT_VALUE.param_id.item_len_max);
					this.data_.set_field(35, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				param_id$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.PARAM_EXT_VALUE.param_id.item_len_max)
					this.data_.set_field(35, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
				param_value(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 36 && !this.data_.set_field(36, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				param_value_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -36 - 1);
					
					let len = Math.min(src.byteLength, _Host.PARAM_EXT_VALUE.param_value.item_len_max);
					this.data_.set_field(36, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				param_value$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.PARAM_EXT_VALUE.param_value.item_len_max)
					this.data_.set_field(36, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
				public param_type(): MAV_PARAM_EXT_TYPE | null {
					if (this.data_.field_bit != 37 && !this.data_.set_field(37, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public param_type_(src: MAV_PARAM_EXT_TYPE) {
					if (this.data_.field_bit != 37) this.data_.set_field(37, 0);
					
					_Lib.set_bits(src, 4, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				param_id_(src: _Cursor.UTF8);
				
				param_value_(src: _Cursor.UTF8);
				
				param_type_(src: _Host.MAV_PARAM_EXT_TYPE);
				
				param_count_(src: number);
				
				param_index_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: PARAM_EXT_VALUE, dst: DST) {
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
					
				}
				
				{
					const item = src.param_value();
					if (item !== null) dst.param_value_(item);
					
				}
				
				{
					const item = src.param_type();
					if (item !== null) dst.param_type_(item);
					
				}
				
				dst.param_count_(src.param_count());
				
				dst.param_index_(src.param_index());
				
			}
			
			export interface SRC_ {
				param_id(): string | Uint8Array | null;
				
				param_value(): string | Uint8Array | null;
				
				param_type(): _Host.MAV_PARAM_EXT_TYPE | null;
				
				param_count(): number;
				
				param_index(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: PARAM_EXT_VALUE) {
				
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
				}
				
				
				{
					const item = src.param_value();
					if (item !== null) dst.param_value_(item);
				}
				
				{
					const item = src.param_type();
					if (item !== null) dst.param_type_(item);
					
				}
				
				dst.param_count_(src.param_count());
				
				dst.param_index_(src.param_index());
				
			}
			
		}
		
		export interface BATTERY2 {
			voltage(): number;
			
			voltage_(src: number);
			
			current_battery(): number;
			
			current_battery_(src: number);
			
		}
		
		export namespace BATTERY2 {
			
			export const meta_ = new _Pack.Meta(190, 1, 0, 0, 4, 32);
			
			
			class Impl_ extends _Cursor.View implements BATTERY2 {
				
				public voltage(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public voltage_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public current_battery(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public current_battery_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				voltage_(src: number);
				
				current_battery_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: BATTERY2, dst: DST) {
				
				dst.voltage_(src.voltage());
				
				dst.current_battery_(src.current_battery());
				
			}
			
			export interface SRC_ {
				voltage(): number;
				
				current_battery(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: BATTERY2) {
				
				dst.voltage_(src.voltage());
				
				dst.current_battery_(src.current_battery());
				
			}
			
		}
		
		export interface LIMITS_STATUS {
			breach_count(): number;
			
			breach_count_(src: number);
			
			last_trigger(): number;
			
			last_trigger_(src: number);
			
			last_action(): number;
			
			last_action_(src: number);
			
			last_recovery(): number;
			
			last_recovery_(src: number);
			
			last_clear(): number;
			
			last_clear_(src: number);
			
			limits_state(): LIMITS_STATE | null;
			
			limits_state_(src: LIMITS_STATE);
			
			mods_enabled(): LIMIT_MODULE | null;
			
			mods_enabled_(src: LIMIT_MODULE);
			
			mods_required(): LIMIT_MODULE | null;
			
			mods_required_(src: LIMIT_MODULE);
			
			mods_triggered(): LIMIT_MODULE | null;
			
			mods_triggered_(src: LIMIT_MODULE);
			
		}
		
		export namespace LIMITS_STATUS {
			
			export const meta_ = new _Pack.Meta(186, 1, 4, 0, 19, 146, 2, 4);
			
			
			class Impl_ extends _Cursor.View implements LIMITS_STATUS {
				
				public breach_count(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public breach_count_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public last_trigger(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public last_trigger_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public last_action(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public last_action_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public last_recovery(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public last_recovery_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
				public last_clear(): number { return this.data_.bytes.getInt32(this.data_.origin + 14, true);}
				
				public last_clear_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 14, src, true); }
				
				
				public limits_state(): LIMITS_STATE | null {
					if (this.data_.field_bit != 146 && !this.data_.set_field(146, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public limits_state_(src: LIMITS_STATE) {
					if (this.data_.field_bit != 146) this.data_.set_field(146, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				public mods_enabled(): LIMIT_MODULE | null {
					if (this.data_.field_bit != 147 && !this.data_.set_field(147, -1)) return null;
					
					return _Host.LIMIT_MODULE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 2));
				}
				
				
				public mods_enabled_(src: LIMIT_MODULE) {
					if (this.data_.field_bit != 147) this.data_.set_field(147, 0);
					
					_Lib.set_bits(_Host.LIMIT_MODULE_.into(src), 2, this.data_.bytes, this.data_.BIT);
				}
				
				
				public mods_required(): LIMIT_MODULE | null {
					if (this.data_.field_bit != 148 && !this.data_.set_field(148, -1)) return null;
					
					return _Host.LIMIT_MODULE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 2));
				}
				
				
				public mods_required_(src: LIMIT_MODULE) {
					if (this.data_.field_bit != 148) this.data_.set_field(148, 0);
					
					_Lib.set_bits(_Host.LIMIT_MODULE_.into(src), 2, this.data_.bytes, this.data_.BIT);
				}
				
				
				public mods_triggered(): LIMIT_MODULE | null {
					if (this.data_.field_bit != 149 && !this.data_.set_field(149, -1)) return null;
					
					return _Host.LIMIT_MODULE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 2));
				}
				
				
				public mods_triggered_(src: LIMIT_MODULE) {
					if (this.data_.field_bit != 149) this.data_.set_field(149, 0);
					
					_Lib.set_bits(_Host.LIMIT_MODULE_.into(src), 2, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				limits_state_(src: _Host.LIMITS_STATE);
				
				last_trigger_(src: number);
				
				last_action_(src: number);
				
				last_recovery_(src: number);
				
				last_clear_(src: number);
				
				breach_count_(src: number);
				
				mods_enabled_(src: _Host.LIMIT_MODULE);
				
				mods_required_(src: _Host.LIMIT_MODULE);
				
				mods_triggered_(src: _Host.LIMIT_MODULE);
				
			}
			
			export function push_<DST extends DST_>(src: LIMITS_STATUS, dst: DST) {
				
				{
					const item = src.limits_state();
					if (item !== null) dst.limits_state_(item);
					
				}
				
				dst.last_trigger_(src.last_trigger());
				
				dst.last_action_(src.last_action());
				
				dst.last_recovery_(src.last_recovery());
				
				dst.last_clear_(src.last_clear());
				
				dst.breach_count_(src.breach_count());
				
				{
					const item = src.mods_enabled();
					if (item !== null) dst.mods_enabled_(item);
					
				}
				
				{
					const item = src.mods_required();
					if (item !== null) dst.mods_required_(item);
					
				}
				
				{
					const item = src.mods_triggered();
					if (item !== null) dst.mods_triggered_(item);
					
				}
				
			}
			
			export interface SRC_ {
				limits_state(): _Host.LIMITS_STATE | null;
				
				last_trigger(): number;
				
				last_action(): number;
				
				last_recovery(): number;
				
				last_clear(): number;
				
				breach_count(): number;
				
				mods_enabled(): _Host.LIMIT_MODULE | null;
				
				mods_required(): _Host.LIMIT_MODULE | null;
				
				mods_triggered(): _Host.LIMIT_MODULE | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LIMITS_STATUS) {
				{
					const item = src.limits_state();
					if (item !== null) dst.limits_state_(item);
					
				}
				
				dst.last_trigger_(src.last_trigger());
				
				dst.last_action_(src.last_action());
				
				dst.last_recovery_(src.last_recovery());
				
				dst.last_clear_(src.last_clear());
				
				dst.breach_count_(src.breach_count());
				{
					const item = src.mods_enabled();
					if (item !== null) dst.mods_enabled_(item);
					
				}
				{
					const item = src.mods_required();
					if (item !== null) dst.mods_required_(item);
					
				}
				{
					const item = src.mods_triggered();
					if (item !== null) dst.mods_triggered_(item);
					
				}
				
			}
			
		}
		
		export interface CAMERA_FEEDBACK {
			img_idx(): number;
			
			img_idx_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			cam_idx(): number;
			
			cam_idx_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lng(): number;
			
			lng_(src: number);
			
			alt_msl(): number;
			
			alt_msl_(src: number);
			
			alt_rel(): number;
			
			alt_rel_(src: number);
			
			roll(): number;
			
			roll_(src: number);
			
			pitch(): number;
			
			pitch_(src: number);
			
			yaw(): number;
			
			yaw_(src: number);
			
			foc_len(): number;
			
			foc_len_(src: number);
			
			flags(): CAMERA_FEEDBACK_FLAGS | null;
			
			flags_(src: CAMERA_FEEDBACK_FLAGS);
			
		}
		
		export namespace CAMERA_FEEDBACK {
			
			export const meta_ = new _Pack.Meta(0, 1, 0, 1, 45, 352, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements CAMERA_FEEDBACK {
				
				public img_idx(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public img_idx_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 2, true) + this.data_.bytes.getInt32(this.data_.origin + 2 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 2, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 2 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 10);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 10, src); }
				
				public cam_idx(): number { return this.data_.bytes.getInt8(this.data_.origin + 11);}
				
				public cam_idx_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 11, src); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 12, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 12, src, true); }
				
				public lng(): number { return this.data_.bytes.getInt32(this.data_.origin + 16, true);}
				
				public lng_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 16, src, true); }
				
				public alt_msl(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public alt_msl_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public alt_rel(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public alt_rel_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public roll_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public pitch_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				public yaw_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 36, src, true); }
				
				public foc_len(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				public foc_len_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 40, src, true); }
				
				
				public flags(): CAMERA_FEEDBACK_FLAGS | null {
					if (this.data_.field_bit != 352 && !this.data_.set_field(352, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public flags_(src: CAMERA_FEEDBACK_FLAGS) {
					if (this.data_.field_bit != 352) this.data_.set_field(352, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				target_system_(src: number);
				
				cam_idx_(src: number);
				
				img_idx_(src: number);
				
				lat_(src: number);
				
				lng_(src: number);
				
				alt_msl_(src: number);
				
				alt_rel_(src: number);
				
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
				foc_len_(src: number);
				
				flags_(src: _Host.CAMERA_FEEDBACK_FLAGS);
				
			}
			
			export function push_<DST extends DST_>(src: CAMERA_FEEDBACK, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.target_system_(src.target_system());
				
				dst.cam_idx_(src.cam_idx());
				
				dst.img_idx_(src.img_idx());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
				dst.alt_msl_(src.alt_msl());
				
				dst.alt_rel_(src.alt_rel());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.foc_len_(src.foc_len());
				
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				target_system(): number;
				
				cam_idx(): number;
				
				img_idx(): number;
				
				lat(): number;
				
				lng(): number;
				
				alt_msl(): number;
				
				alt_rel(): number;
				
				roll(): number;
				
				pitch(): number;
				
				yaw(): number;
				
				foc_len(): number;
				
				flags(): _Host.CAMERA_FEEDBACK_FLAGS | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: CAMERA_FEEDBACK) {
				
				dst.time_usec_(src.time_usec());
				
				dst.target_system_(src.target_system());
				
				dst.cam_idx_(src.cam_idx());
				
				dst.img_idx_(src.img_idx());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
				dst.alt_msl_(src.alt_msl());
				
				dst.alt_rel_(src.alt_rel());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.foc_len_(src.foc_len());
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
			}
			
		}
		
		export interface HIL_GPS {
			eph(): number;
			
			eph_(src: number);
			
			epv(): number;
			
			epv_(src: number);
			
			vel(): number;
			
			vel_(src: number);
			
			cog(): number;
			
			cog_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			fix_type(): number;
			
			fix_type_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
			alt(): number;
			
			alt_(src: number);
			
			vn(): number;
			
			vn_(src: number);
			
			ve(): number;
			
			ve_(src: number);
			
			vd(): number;
			
			vd_(src: number);
			
			satellites_visible(): number;
			
			satellites_visible_(src: number);
			
		}
		
		export namespace HIL_GPS {
			
			export const meta_ = new _Pack.Meta(168, 4, 0, 1, 36, 288);
			
			
			class Impl_ extends _Cursor.View implements HIL_GPS {
				
				public eph(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public eph_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public epv(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public epv_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public vel(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public vel_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public cog(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				public cog_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 6, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 8, true) + this.data_.bytes.getInt32(this.data_.origin + 8 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 8, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 8 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public fix_type(): number { return this.data_.bytes.getInt8(this.data_.origin + 16);}
				
				public fix_type_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 16, src); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 17, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 17, src, true); }
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 21, true);}
				
				public lon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 21, src, true); }
				
				public alt(): number { return this.data_.bytes.getInt32(this.data_.origin + 25, true);}
				
				public alt_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 25, src, true); }
				
				public vn(): number { return this.data_.bytes.getInt16(this.data_.origin + 29, true);}
				
				public vn_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 29, src, true); }
				
				public ve(): number { return this.data_.bytes.getInt16(this.data_.origin + 31, true);}
				
				public ve_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 31, src, true); }
				
				public vd(): number { return this.data_.bytes.getInt16(this.data_.origin + 33, true);}
				
				public vd_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 33, src, true); }
				
				public satellites_visible(): number { return this.data_.bytes.getInt8(this.data_.origin + 35);}
				
				public satellites_visible_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 35, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				fix_type_(src: number);
				
				lat_(src: number);
				
				lon_(src: number);
				
				alt_(src: number);
				
				eph_(src: number);
				
				epv_(src: number);
				
				vel_(src: number);
				
				vn_(src: number);
				
				ve_(src: number);
				
				vd_(src: number);
				
				cog_(src: number);
				
				satellites_visible_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HIL_GPS, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.fix_type_(src.fix_type());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.eph_(src.eph());
				
				dst.epv_(src.epv());
				
				dst.vel_(src.vel());
				
				dst.vn_(src.vn());
				
				dst.ve_(src.ve());
				
				dst.vd_(src.vd());
				
				dst.cog_(src.cog());
				
				dst.satellites_visible_(src.satellites_visible());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				fix_type(): number;
				
				lat(): number;
				
				lon(): number;
				
				alt(): number;
				
				eph(): number;
				
				epv(): number;
				
				vel(): number;
				
				vn(): number;
				
				ve(): number;
				
				vd(): number;
				
				cog(): number;
				
				satellites_visible(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: HIL_GPS) {
				
				dst.time_usec_(src.time_usec());
				
				dst.fix_type_(src.fix_type());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.eph_(src.eph());
				
				dst.epv_(src.epv());
				
				dst.vel_(src.vel());
				
				dst.vn_(src.vn());
				
				dst.ve_(src.ve());
				
				dst.vd_(src.vd());
				
				dst.cog_(src.cog());
				
				dst.satellites_visible_(src.satellites_visible());
				
			}
			
		}
		
		export interface NAV_CONTROLLER_OUTPUT {
			wp_dist(): number;
			
			nav_roll(): number;
			
			nav_pitch(): number;
			
			nav_bearing(): number;
			
			target_bearing(): number;
			
			alt_error(): number;
			
			aspd_error(): number;
			
			xtrack_error(): number;
			
		}
		
		export namespace NAV_CONTROLLER_OUTPUT {
			
			export const meta_ = new _Pack.Meta(201, 1, 0, 0, 26, 208);
			
			
			class Impl_ extends _Cursor.View implements NAV_CONTROLLER_OUTPUT {
				
				public wp_dist(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public nav_roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 2, true);}
				
				
				public nav_pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 6, true);}
				
				
				public nav_bearing(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				
				public target_bearing(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				
				public alt_error(): number { return this.data_.bytes.getFloat32(this.data_.origin + 14, true);}
				
				
				public aspd_error(): number { return this.data_.bytes.getFloat32(this.data_.origin + 18, true);}
				
				
				public xtrack_error(): number { return this.data_.bytes.getFloat32(this.data_.origin + 22, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				nav_roll_(src: number);
				
				nav_pitch_(src: number);
				
				nav_bearing_(src: number);
				
				target_bearing_(src: number);
				
				wp_dist_(src: number);
				
				alt_error_(src: number);
				
				aspd_error_(src: number);
				
				xtrack_error_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: NAV_CONTROLLER_OUTPUT, dst: DST) {
				
				dst.nav_roll_(src.nav_roll());
				
				dst.nav_pitch_(src.nav_pitch());
				
				dst.nav_bearing_(src.nav_bearing());
				
				dst.target_bearing_(src.target_bearing());
				
				dst.wp_dist_(src.wp_dist());
				
				dst.alt_error_(src.alt_error());
				
				dst.aspd_error_(src.aspd_error());
				
				dst.xtrack_error_(src.xtrack_error());
				
			}
			
		}
		
		export interface AUTH_KEY {
			key(): _Cursor.UTF8 | null;
			
		}
		
		export namespace AUTH_KEY {
			
			export const meta_ = new _Pack.Meta(95, 0, 0, 0, 1, 2, 2, 1);
			
			
			export namespace key {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements AUTH_KEY {
				
				
				key(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 2 && !this.data_.set_field(2, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				key_(src: _Cursor.UTF8);
				
			}
			
			export function push_<DST extends DST_>(src: AUTH_KEY, dst: DST) {
				
				{
					const item = src.key();
					if (item !== null) dst.key_(item);
					
				}
				
			}
			
		}
		
		export interface FENCE_FETCH_POINT {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			idx(): number;
			
			idx_(src: number);
			
		}
		
		export namespace FENCE_FETCH_POINT {
			
			export const meta_ = new _Pack.Meta(119, 0, 0, 0, 3, 24);
			
			
			class Impl_ extends _Cursor.View implements FENCE_FETCH_POINT {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public idx(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public idx_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				idx_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: FENCE_FETCH_POINT, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.idx_(src.idx());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				idx(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: FENCE_FETCH_POINT) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.idx_(src.idx());
				
			}
			
		}
		
		export interface RADIO {
			rxerrors(): number;
			
			rxerrors_(src: number);
			
			fixeD(): number;
			
			fixeD_(src: number);
			
			rssi(): number;
			
			rssi_(src: number);
			
			remrssi(): number;
			
			remrssi_(src: number);
			
			txbuf(): number;
			
			txbuf_(src: number);
			
			noise(): number;
			
			noise_(src: number);
			
			remnoise(): number;
			
			remnoise_(src: number);
			
		}
		
		export namespace RADIO {
			
			export const meta_ = new _Pack.Meta(32, 2, 0, 0, 9, 72);
			
			
			class Impl_ extends _Cursor.View implements RADIO {
				
				public rxerrors(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public rxerrors_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public fixeD(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public fixeD_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public rssi(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public rssi_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public remrssi(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public remrssi_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				public txbuf(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				public txbuf_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 6, src); }
				
				public noise(): number { return this.data_.bytes.getInt8(this.data_.origin + 7);}
				
				public noise_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 7, src); }
				
				public remnoise(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public remnoise_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				rssi_(src: number);
				
				remrssi_(src: number);
				
				txbuf_(src: number);
				
				noise_(src: number);
				
				remnoise_(src: number);
				
				rxerrors_(src: number);
				
				fixeD_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: RADIO, dst: DST) {
				
				dst.rssi_(src.rssi());
				
				dst.remrssi_(src.remrssi());
				
				dst.txbuf_(src.txbuf());
				
				dst.noise_(src.noise());
				
				dst.remnoise_(src.remnoise());
				
				dst.rxerrors_(src.rxerrors());
				
				dst.fixeD_(src.fixeD());
				
			}
			
			export interface SRC_ {
				rssi(): number;
				
				remrssi(): number;
				
				txbuf(): number;
				
				noise(): number;
				
				remnoise(): number;
				
				rxerrors(): number;
				
				fixeD(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: RADIO) {
				
				dst.rssi_(src.rssi());
				
				dst.remrssi_(src.remrssi());
				
				dst.txbuf_(src.txbuf());
				
				dst.noise_(src.noise());
				
				dst.remnoise_(src.remnoise());
				
				dst.rxerrors_(src.rxerrors());
				
				dst.fixeD_(src.fixeD());
				
			}
			
		}
		
		export interface LOCAL_POSITION_NED_COV {
			time_usec(): number;
			
			x(): number;
			
			y(): number;
			
			z(): number;
			
			vx(): number;
			
			vy(): number;
			
			vz(): number;
			
			ax(): number;
			
			ay(): number;
			
			az(): number;
			
			covariance(): LOCAL_POSITION_NED_COV.covariance;
			
			estimator_type(): MAV_ESTIMATOR_TYPE | null;
			
		}
		
		export namespace LOCAL_POSITION_NED_COV {
			
			export const meta_ = new _Pack.Meta(180, 0, 0, 1, 225, 1792, 0, 1);
			
			
			export interface covariance extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace covariance {
				export class Field extends _Cursor.View implements covariance, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 44 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 44, other.data_.bytes.buffer, other.data_.origin + 44, _Host.LOCAL_POSITION_NED_COV.covariance.item_len) === 0;
						for (let i = 0; i < _Host.LOCAL_POSITION_NED_COV.covariance.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.LOCAL_POSITION_NED_COV.covariance.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 45;
				
			}
			
			
			class Impl_ extends _Cursor.View implements LOCAL_POSITION_NED_COV {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public vx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public vy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
				public vz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				
				public ax(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				
				public ay(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				
				public az(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				
				public covariance(): LOCAL_POSITION_NED_COV.covariance {
					
					return this.data_.as_field(LOCAL_POSITION_NED_COV.covariance.field);
				}
				
				
				public estimator_type(): MAV_ESTIMATOR_TYPE | null {
					if (this.data_.field_bit != 1792 && !this.data_.set_field(1792, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				estimator_type_(src: _Host.MAV_ESTIMATOR_TYPE);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				vx_(src: number);
				
				vy_(src: number);
				
				vz_(src: number);
				
				ax_(src: number);
				
				ay_(src: number);
				
				az_(src: number);
				
				covariance_(src: _Host.LOCAL_POSITION_NED_COV.covariance);
				
			}
			
			export function push_<DST extends DST_>(src: LOCAL_POSITION_NED_COV, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				{
					const item = src.estimator_type();
					if (item !== null) dst.estimator_type_(item);
					
				}
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
				dst.ax_(src.ax());
				
				dst.ay_(src.ay());
				
				dst.az_(src.az());
				dst.covariance_(src.covariance());
				
			}
			
		}
		
		export interface AIRSPEED_AUTOCAL {
			vx(): number;
			
			vx_(src: number);
			
			vy(): number;
			
			vy_(src: number);
			
			vz(): number;
			
			vz_(src: number);
			
			diff_pressure(): number;
			
			diff_pressure_(src: number);
			
			EAS2TAS(): number;
			
			EAS2TAS_(src: number);
			
			ratio(): number;
			
			ratio_(src: number);
			
			state_x(): number;
			
			state_x_(src: number);
			
			state_y(): number;
			
			state_y_(src: number);
			
			state_z(): number;
			
			state_z_(src: number);
			
			Pax(): number;
			
			Pax_(src: number);
			
			Pby(): number;
			
			Pby_(src: number);
			
			Pcz(): number;
			
			Pcz_(src: number);
			
		}
		
		export namespace AIRSPEED_AUTOCAL {
			
			export const meta_ = new _Pack.Meta(69, 0, 0, 0, 48, 384);
			
			
			class Impl_ extends _Cursor.View implements AIRSPEED_AUTOCAL {
				
				public vx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public vx_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public vy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public vy_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public vz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public vz_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public diff_pressure(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public diff_pressure_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public EAS2TAS(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public EAS2TAS_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public ratio(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public ratio_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public state_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public state_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public state_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public state_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public state_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public state_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public Pax(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				public Pax_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 36, src, true); }
				
				public Pby(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				public Pby_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 40, src, true); }
				
				public Pcz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 44, true);}
				
				public Pcz_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 44, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				vx_(src: number);
				
				vy_(src: number);
				
				vz_(src: number);
				
				diff_pressure_(src: number);
				
				EAS2TAS_(src: number);
				
				ratio_(src: number);
				
				state_x_(src: number);
				
				state_y_(src: number);
				
				state_z_(src: number);
				
				Pax_(src: number);
				
				Pby_(src: number);
				
				Pcz_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: AIRSPEED_AUTOCAL, dst: DST) {
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
				dst.diff_pressure_(src.diff_pressure());
				
				dst.EAS2TAS_(src.EAS2TAS());
				
				dst.ratio_(src.ratio());
				
				dst.state_x_(src.state_x());
				
				dst.state_y_(src.state_y());
				
				dst.state_z_(src.state_z());
				
				dst.Pax_(src.Pax());
				
				dst.Pby_(src.Pby());
				
				dst.Pcz_(src.Pcz());
				
			}
			
			export interface SRC_ {
				vx(): number;
				
				vy(): number;
				
				vz(): number;
				
				diff_pressure(): number;
				
				EAS2TAS(): number;
				
				ratio(): number;
				
				state_x(): number;
				
				state_y(): number;
				
				state_z(): number;
				
				Pax(): number;
				
				Pby(): number;
				
				Pcz(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: AIRSPEED_AUTOCAL) {
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
				dst.diff_pressure_(src.diff_pressure());
				
				dst.EAS2TAS_(src.EAS2TAS());
				
				dst.ratio_(src.ratio());
				
				dst.state_x_(src.state_x());
				
				dst.state_y_(src.state_y());
				
				dst.state_z_(src.state_z());
				
				dst.Pax_(src.Pax());
				
				dst.Pby_(src.Pby());
				
				dst.Pcz_(src.Pcz());
				
			}
			
		}
		
		export interface ATT_POS_MOCAP {
			time_usec(): number;
			
			time_usec_(src: number);
			
			q(): ATT_POS_MOCAP.q;
			
			q_(src: ATT_POS_MOCAP.q | number[]);
			
			q$(src: Iterator<number>, len: number);
			
			x(): number;
			
			x_(src: number);
			
			y(): number;
			
			y_(src: number);
			
			z(): number;
			
			z_(src: number);
			
		}
		
		export namespace ATT_POS_MOCAP {
			
			export const meta_ = new _Pack.Meta(200, 0, 0, 1, 36, 288);
			
			
			export interface q extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace q {
				export class Field extends _Cursor.View implements q, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 8 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 8, other.data_.bytes.buffer, other.data_.origin + 8, _Host.ATT_POS_MOCAP.q.item_len) === 0;
						for (let i = 0; i < _Host.ATT_POS_MOCAP.q.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.ATT_POS_MOCAP.q.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 8 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			
			
			class Impl_ extends _Cursor.View implements ATT_POS_MOCAP {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public q(): ATT_POS_MOCAP.q {
					
					return this.data_.as_field(ATT_POS_MOCAP.q.field);
				}
				
				public q_(src: ATT_POS_MOCAP.q | number[]): q {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.ATT_POS_MOCAP.q.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 8 + index * 4, src[index], true);
						return this.data_.as_field(q.field);
					}
					for (let index = 0; index < _Host.ATT_POS_MOCAP.q.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 8 + index * 4, src.get(index), true);
					
					return this.data_.as_field(q.field);
				}
				
				public q$(src: Iterator<number>, len: number): q {
					let len_ = Math.min(len, _Host.ATT_POS_MOCAP.q.item_len);
					
					len = Math.min(len, _Host.ATT_POS_MOCAP.q.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 8 + index * 4, v.value, true);
						}
					return this.data_.as_field(q.field);
				}
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				q_(src: _Host.ATT_POS_MOCAP.q);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: ATT_POS_MOCAP, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				dst.q_(src.q());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				q(dst: _Host.ATT_POS_MOCAP.q);
				
				x(): number;
				
				y(): number;
				
				z(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: ATT_POS_MOCAP) {
				
				dst.time_usec_(src.time_usec());
				src.q(dst.q());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
			}
			
		}
		
		export interface STATUSTEXT {
			severity(): MAV_SEVERITY | null;
			
			severity_(src: MAV_SEVERITY);
			
			text(): _Cursor.UTF8 | null;
			
			text_(src: string | Uint8Array): _Cursor.UTF8;
			
			text$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace STATUSTEXT {
			
			export const meta_ = new _Pack.Meta(124, 0, 0, 0, 1, 2, 2, 2);
			
			
			export namespace text {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements STATUSTEXT {
				
				
				public severity(): MAV_SEVERITY | null {
					if (this.data_.field_bit != 2 && !this.data_.set_field(2, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public severity_(src: MAV_SEVERITY) {
					if (this.data_.field_bit != 2) this.data_.set_field(2, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				text(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 3 && !this.data_.set_field(3, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				text_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -3 - 1);
					
					let len = Math.min(src.byteLength, _Host.STATUSTEXT.text.item_len_max);
					this.data_.set_field(3, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				text$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.STATUSTEXT.text.item_len_max)
					this.data_.set_field(3, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				severity_(src: _Host.MAV_SEVERITY);
				
				text_(src: _Cursor.UTF8);
				
			}
			
			export function push_<DST extends DST_>(src: STATUSTEXT, dst: DST) {
				
				{
					const item = src.severity();
					if (item !== null) dst.severity_(item);
					
				}
				
				{
					const item = src.text();
					if (item !== null) dst.text_(item);
					
				}
				
			}
			
			export interface SRC_ {
				severity(): _Host.MAV_SEVERITY | null;
				
				text(): string | Uint8Array | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: STATUSTEXT) {
				{
					const item = src.severity();
					if (item !== null) dst.severity_(item);
					
				}
				
				
				{
					const item = src.text();
					if (item !== null) dst.text_(item);
				}
				
				
			}
			
		}
		
		export interface PING {
			seq(): number;
			
			time_usec(): number;
			
			target_system(): number;
			
			target_component(): number;
			
		}
		
		export namespace PING {
			
			export const meta_ = new _Pack.Meta(122, 0, 1, 1, 14, 112);
			
			
			class Impl_ extends _Cursor.View implements PING {
				
				public seq(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 4, true) + this.data_.bytes.getInt32(this.data_.origin + 4 + 4, true) * _Lib.JS_HI;}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 12);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 13);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				seq_(src: number);
				
				target_system_(src: number);
				
				target_component_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: PING, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.seq_(src.seq());
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
			}
			
		}
		
		export interface GOPRO_GET_REQUEST {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			cmd_id(): GOPRO_COMMAND | null;
			
			cmd_id_(src: GOPRO_COMMAND);
			
		}
		
		export namespace GOPRO_GET_REQUEST {
			
			export const meta_ = new _Pack.Meta(138, 0, 0, 0, 3, 16, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements GOPRO_GET_REQUEST {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				
				public cmd_id(): GOPRO_COMMAND | null {
					if (this.data_.field_bit != 16 && !this.data_.set_field(16, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 5);
				}
				
				
				public cmd_id_(src: GOPRO_COMMAND) {
					if (this.data_.field_bit != 16) this.data_.set_field(16, 0);
					
					_Lib.set_bits(src, 5, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				cmd_id_(src: _Host.GOPRO_COMMAND);
				
			}
			
			export function push_<DST extends DST_>(src: GOPRO_GET_REQUEST, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.cmd_id();
					if (item !== null) dst.cmd_id_(item);
					
				}
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				cmd_id(): _Host.GOPRO_COMMAND | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GOPRO_GET_REQUEST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				{
					const item = src.cmd_id();
					if (item !== null) dst.cmd_id_(item);
					
				}
				
			}
			
		}
		
		export interface CAMERA_CAPTURE_STATUS {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			recording_time_ms(): number;
			
			recording_time_ms_(src: number);
			
			image_status(): number;
			
			image_status_(src: number);
			
			video_status(): number;
			
			video_status_(src: number);
			
			image_interval(): number;
			
			image_interval_(src: number);
			
			available_capacity(): number;
			
			available_capacity_(src: number);
			
		}
		
		export namespace CAMERA_CAPTURE_STATUS {
			
			export const meta_ = new _Pack.Meta(216, 0, 2, 0, 18, 144);
			
			
			class Impl_ extends _Cursor.View implements CAMERA_CAPTURE_STATUS {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public recording_time_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				public recording_time_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 4, src, true); }
				
				public image_status(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public image_status_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
				public video_status(): number { return this.data_.bytes.getInt8(this.data_.origin + 9);}
				
				public video_status_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 9, src); }
				
				public image_interval(): number { return this.data_.bytes.getFloat32(this.data_.origin + 10, true);}
				
				public image_interval_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 10, src, true); }
				
				public available_capacity(): number { return this.data_.bytes.getFloat32(this.data_.origin + 14, true);}
				
				public available_capacity_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 14, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				image_status_(src: number);
				
				video_status_(src: number);
				
				image_interval_(src: number);
				
				recording_time_ms_(src: number);
				
				available_capacity_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: CAMERA_CAPTURE_STATUS, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.image_status_(src.image_status());
				
				dst.video_status_(src.video_status());
				
				dst.image_interval_(src.image_interval());
				
				dst.recording_time_ms_(src.recording_time_ms());
				
				dst.available_capacity_(src.available_capacity());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				image_status(): number;
				
				video_status(): number;
				
				image_interval(): number;
				
				recording_time_ms(): number;
				
				available_capacity(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: CAMERA_CAPTURE_STATUS) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.image_status_(src.image_status());
				
				dst.video_status_(src.video_status());
				
				dst.image_interval_(src.image_interval());
				
				dst.recording_time_ms_(src.recording_time_ms());
				
				dst.available_capacity_(src.available_capacity());
				
			}
			
		}
		
		export interface GLOBAL_POSITION_INT {
			hdg(): number;
			
			time_boot_ms(): number;
			
			lat(): number;
			
			lon(): number;
			
			alt(): number;
			
			relative_alt(): number;
			
			vx(): number;
			
			vy(): number;
			
			vz(): number;
			
		}
		
		export namespace GLOBAL_POSITION_INT {
			
			export const meta_ = new _Pack.Meta(162, 1, 1, 0, 28, 224);
			
			
			class Impl_ extends _Cursor.View implements GLOBAL_POSITION_INT {
				
				public hdg(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				
				public alt(): number { return this.data_.bytes.getInt32(this.data_.origin + 14, true);}
				
				
				public relative_alt(): number { return this.data_.bytes.getInt32(this.data_.origin + 18, true);}
				
				
				public vx(): number { return this.data_.bytes.getInt16(this.data_.origin + 22, true);}
				
				
				public vy(): number { return this.data_.bytes.getInt16(this.data_.origin + 24, true);}
				
				
				public vz(): number { return this.data_.bytes.getInt16(this.data_.origin + 26, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				lat_(src: number);
				
				lon_(src: number);
				
				alt_(src: number);
				
				relative_alt_(src: number);
				
				vx_(src: number);
				
				vy_(src: number);
				
				vz_(src: number);
				
				hdg_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: GLOBAL_POSITION_INT, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.relative_alt_(src.relative_alt());
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
				dst.hdg_(src.hdg());
				
			}
			
		}
		
		export interface ENCAPSULATED_DATA {
			seqnr(): number;
			
			seqnr_(src: number);
			
			daTa(): ENCAPSULATED_DATA.daTa;
			
			daTa_(src: ENCAPSULATED_DATA.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace ENCAPSULATED_DATA {
			
			export const meta_ = new _Pack.Meta(170, 1, 0, 0, 255, 2040);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 2 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 2, other.data_.bytes.buffer, other.data_.origin + 2, _Host.ENCAPSULATED_DATA.daTa.item_len) === 0;
						for (let i = 0; i < _Host.ENCAPSULATED_DATA.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.ENCAPSULATED_DATA.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 2 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 253;
				
			}
			
			
			class Impl_ extends _Cursor.View implements ENCAPSULATED_DATA {
				
				public seqnr(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public seqnr_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public daTa(): ENCAPSULATED_DATA.daTa {
					
					return this.data_.as_field(ENCAPSULATED_DATA.daTa.field);
				}
				
				public daTa_(src: ENCAPSULATED_DATA.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.ENCAPSULATED_DATA.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.ENCAPSULATED_DATA.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 2 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.ENCAPSULATED_DATA.daTa.item_len);
					
					len = Math.min(len, _Host.ENCAPSULATED_DATA.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				seqnr_(src: number);
				
				daTa_(src: _Host.ENCAPSULATED_DATA.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: ENCAPSULATED_DATA, dst: DST) {
				
				dst.seqnr_(src.seqnr());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				seqnr(): number;
				
				daTa(dst: _Host.ENCAPSULATED_DATA.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: ENCAPSULATED_DATA) {
				
				dst.seqnr_(src.seqnr());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface GPS_INPUT {
			time_week(): number;
			
			time_week_(src: number);
			
			time_week_ms(): number;
			
			time_week_ms_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			gps_id(): number;
			
			gps_id_(src: number);
			
			fix_type(): number;
			
			fix_type_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
			alt(): number;
			
			alt_(src: number);
			
			hdop(): number;
			
			hdop_(src: number);
			
			vdop(): number;
			
			vdop_(src: number);
			
			vn(): number;
			
			vn_(src: number);
			
			ve(): number;
			
			ve_(src: number);
			
			vd(): number;
			
			vd_(src: number);
			
			speed_accuracy(): number;
			
			speed_accuracy_(src: number);
			
			horiz_accuracy(): number;
			
			horiz_accuracy_(src: number);
			
			vert_accuracy(): number;
			
			vert_accuracy_(src: number);
			
			satellites_visible(): number;
			
			satellites_visible_(src: number);
			
			ignore_flags(): GPS_INPUT_IGNORE_FLAGS | null;
			
			ignore_flags_(src: GPS_INPUT_IGNORE_FLAGS);
			
		}
		
		export namespace GPS_INPUT {
			
			export const meta_ = new _Pack.Meta(73, 1, 1, 1, 62, 488, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements GPS_INPUT {
				
				public time_week(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public time_week_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public time_week_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public time_week_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 6, true) + this.data_.bytes.getInt32(this.data_.origin + 6 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 6, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 6 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public gps_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 14);}
				
				public gps_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 14, src); }
				
				public fix_type(): number { return this.data_.bytes.getInt8(this.data_.origin + 15);}
				
				public fix_type_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 15, src); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 16, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 16, src, true); }
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 20, true);}
				
				public lon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 20, src, true); }
				
				public alt(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public alt_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public hdop(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public hdop_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public vdop(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public vdop_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public vn(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				public vn_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 36, src, true); }
				
				public ve(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				public ve_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 40, src, true); }
				
				public vd(): number { return this.data_.bytes.getFloat32(this.data_.origin + 44, true);}
				
				public vd_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 44, src, true); }
				
				public speed_accuracy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 48, true);}
				
				public speed_accuracy_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 48, src, true); }
				
				public horiz_accuracy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 52, true);}
				
				public horiz_accuracy_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 52, src, true); }
				
				public vert_accuracy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 56, true);}
				
				public vert_accuracy_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 56, src, true); }
				
				public satellites_visible(): number { return this.data_.bytes.getInt8(this.data_.origin + 60);}
				
				public satellites_visible_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 60, src); }
				
				
				public ignore_flags(): GPS_INPUT_IGNORE_FLAGS | null {
					if (this.data_.field_bit != 488 && !this.data_.set_field(488, -1)) return null;
					
					return _Host.GPS_INPUT_IGNORE_FLAGS_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 4));
				}
				
				
				public ignore_flags_(src: GPS_INPUT_IGNORE_FLAGS) {
					if (this.data_.field_bit != 488) this.data_.set_field(488, 0);
					
					_Lib.set_bits(_Host.GPS_INPUT_IGNORE_FLAGS_.into(src), 4, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				gps_id_(src: number);
				
				ignore_flags_(src: _Host.GPS_INPUT_IGNORE_FLAGS);
				
				time_week_ms_(src: number);
				
				time_week_(src: number);
				
				fix_type_(src: number);
				
				lat_(src: number);
				
				lon_(src: number);
				
				alt_(src: number);
				
				hdop_(src: number);
				
				vdop_(src: number);
				
				vn_(src: number);
				
				ve_(src: number);
				
				vd_(src: number);
				
				speed_accuracy_(src: number);
				
				horiz_accuracy_(src: number);
				
				vert_accuracy_(src: number);
				
				satellites_visible_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: GPS_INPUT, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.gps_id_(src.gps_id());
				
				{
					const item = src.ignore_flags();
					if (item !== null) dst.ignore_flags_(item);
					
				}
				
				dst.time_week_ms_(src.time_week_ms());
				
				dst.time_week_(src.time_week());
				
				dst.fix_type_(src.fix_type());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.hdop_(src.hdop());
				
				dst.vdop_(src.vdop());
				
				dst.vn_(src.vn());
				
				dst.ve_(src.ve());
				
				dst.vd_(src.vd());
				
				dst.speed_accuracy_(src.speed_accuracy());
				
				dst.horiz_accuracy_(src.horiz_accuracy());
				
				dst.vert_accuracy_(src.vert_accuracy());
				
				dst.satellites_visible_(src.satellites_visible());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				gps_id(): number;
				
				ignore_flags(): _Host.GPS_INPUT_IGNORE_FLAGS | null;
				
				time_week_ms(): number;
				
				time_week(): number;
				
				fix_type(): number;
				
				lat(): number;
				
				lon(): number;
				
				alt(): number;
				
				hdop(): number;
				
				vdop(): number;
				
				vn(): number;
				
				ve(): number;
				
				vd(): number;
				
				speed_accuracy(): number;
				
				horiz_accuracy(): number;
				
				vert_accuracy(): number;
				
				satellites_visible(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GPS_INPUT) {
				
				dst.time_usec_(src.time_usec());
				
				dst.gps_id_(src.gps_id());
				{
					const item = src.ignore_flags();
					if (item !== null) dst.ignore_flags_(item);
					
				}
				
				dst.time_week_ms_(src.time_week_ms());
				
				dst.time_week_(src.time_week());
				
				dst.fix_type_(src.fix_type());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.hdop_(src.hdop());
				
				dst.vdop_(src.vdop());
				
				dst.vn_(src.vn());
				
				dst.ve_(src.ve());
				
				dst.vd_(src.vd());
				
				dst.speed_accuracy_(src.speed_accuracy());
				
				dst.horiz_accuracy_(src.horiz_accuracy());
				
				dst.vert_accuracy_(src.vert_accuracy());
				
				dst.satellites_visible_(src.satellites_visible());
				
			}
			
		}
		
		export interface COMMAND_LONG {
			target_system(): number;
			
			target_component(): number;
			
			confirmation(): number;
			
			param1(): number;
			
			param2(): number;
			
			param3(): number;
			
			param4(): number;
			
			param5(): number;
			
			param6(): number;
			
			param7(): number;
			
			command(): MAV_CMD | null;
			
		}
		
		export namespace COMMAND_LONG {
			
			export const meta_ = new _Pack.Meta(101, 0, 0, 0, 32, 250, 2, 1);
			
			
			class Impl_ extends _Cursor.View implements COMMAND_LONG {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public confirmation(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				public param1(): number { return this.data_.bytes.getFloat32(this.data_.origin + 3, true);}
				
				
				public param2(): number { return this.data_.bytes.getFloat32(this.data_.origin + 7, true);}
				
				
				public param3(): number { return this.data_.bytes.getFloat32(this.data_.origin + 11, true);}
				
				
				public param4(): number { return this.data_.bytes.getFloat32(this.data_.origin + 15, true);}
				
				
				public param5(): number { return this.data_.bytes.getFloat32(this.data_.origin + 19, true);}
				
				
				public param6(): number { return this.data_.bytes.getFloat32(this.data_.origin + 23, true);}
				
				
				public param7(): number { return this.data_.bytes.getFloat32(this.data_.origin + 27, true);}
				
				
				public command(): MAV_CMD | null {
					if (this.data_.field_bit != 250 && !this.data_.set_field(250, -1)) return null;
					
					return _Host.MAV_CMD_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 8));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				command_(src: _Host.MAV_CMD);
				
				confirmation_(src: number);
				
				param1_(src: number);
				
				param2_(src: number);
				
				param3_(src: number);
				
				param4_(src: number);
				
				param5_(src: number);
				
				param6_(src: number);
				
				param7_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: COMMAND_LONG, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.command();
					if (item !== null) dst.command_(item);
					
				}
				
				dst.confirmation_(src.confirmation());
				
				dst.param1_(src.param1());
				
				dst.param2_(src.param2());
				
				dst.param3_(src.param3());
				
				dst.param4_(src.param4());
				
				dst.param5_(src.param5());
				
				dst.param6_(src.param6());
				
				dst.param7_(src.param7());
				
			}
			
		}
		
		export interface COMPASSMOT_STATUS {
			throttle(): number;
			
			throttle_(src: number);
			
			interference(): number;
			
			interference_(src: number);
			
			current(): number;
			
			current_(src: number);
			
			CompensationX(): number;
			
			CompensationX_(src: number);
			
			CompensationY(): number;
			
			CompensationY_(src: number);
			
			CompensationZ(): number;
			
			CompensationZ_(src: number);
			
		}
		
		export namespace COMPASSMOT_STATUS {
			
			export const meta_ = new _Pack.Meta(43, 2, 0, 0, 20, 160);
			
			
			class Impl_ extends _Cursor.View implements COMPASSMOT_STATUS {
				
				public throttle(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public throttle_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public interference(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public interference_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public current(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public current_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public CompensationX(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public CompensationX_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public CompensationY(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public CompensationY_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public CompensationZ(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public CompensationZ_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				throttle_(src: number);
				
				current_(src: number);
				
				interference_(src: number);
				
				CompensationX_(src: number);
				
				CompensationY_(src: number);
				
				CompensationZ_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: COMPASSMOT_STATUS, dst: DST) {
				
				dst.throttle_(src.throttle());
				
				dst.current_(src.current());
				
				dst.interference_(src.interference());
				
				dst.CompensationX_(src.CompensationX());
				
				dst.CompensationY_(src.CompensationY());
				
				dst.CompensationZ_(src.CompensationZ());
				
			}
			
			export interface SRC_ {
				throttle(): number;
				
				current(): number;
				
				interference(): number;
				
				CompensationX(): number;
				
				CompensationY(): number;
				
				CompensationZ(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: COMPASSMOT_STATUS) {
				
				dst.throttle_(src.throttle());
				
				dst.current_(src.current());
				
				dst.interference_(src.interference());
				
				dst.CompensationX_(src.CompensationX());
				
				dst.CompensationY_(src.CompensationY());
				
				dst.CompensationZ_(src.CompensationZ());
				
			}
			
		}
		
		export interface LOG_REQUEST_DATA {
			id(): number;
			
			id_(src: number);
			
			ofs(): number;
			
			ofs_(src: number);
			
			count(): number;
			
			count_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
		}
		
		export namespace LOG_REQUEST_DATA {
			
			export const meta_ = new _Pack.Meta(72, 1, 2, 0, 12, 96);
			
			
			class Impl_ extends _Cursor.View implements LOG_REQUEST_DATA {
				
				public id(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public id_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public ofs(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public ofs_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public count(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public count_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 10);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 10, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 11);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 11, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				id_(src: number);
				
				ofs_(src: number);
				
				count_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: LOG_REQUEST_DATA, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.id_(src.id());
				
				dst.ofs_(src.ofs());
				
				dst.count_(src.count());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				id(): number;
				
				ofs(): number;
				
				count(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LOG_REQUEST_DATA) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.id_(src.id());
				
				dst.ofs_(src.ofs());
				
				dst.count_(src.count());
				
			}
			
		}
		
		export interface GPS_RAW_INT {
			eph(): number;
			
			epv(): number;
			
			vel(): number;
			
			cog(): number;
			
			time_usec(): number;
			
			lat(): number;
			
			lon(): number;
			
			alt(): number;
			
			satellites_visible(): number;
			
			fix_type(): GPS_FIX_TYPE | null;
			
			alt_ellipsoid(): number | null;
			
			h_acc(): number | null;
			
			v_acc(): number | null;
			
			vel_acc(): number | null;
			
			hdg_acc(): number | null;
			
		}
		
		export namespace GPS_RAW_INT {
			
			export const meta_ = new _Pack.Meta(56, 4, 0, 1, 30, 234, 2, 6);
			
			
			class Impl_ extends _Cursor.View implements GPS_RAW_INT {
				
				public eph(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public epv(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				public vel(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				
				public cog(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 8, true) + this.data_.bytes.getInt32(this.data_.origin + 8 + 4, true) * _Lib.JS_HI;}
				
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 16, true);}
				
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 20, true);}
				
				
				public alt(): number { return this.data_.bytes.getInt32(this.data_.origin + 24, true);}
				
				
				public satellites_visible(): number { return this.data_.bytes.getInt8(this.data_.origin + 28);}
				
				
				public fix_type(): GPS_FIX_TYPE | null {
					if (this.data_.field_bit != 234 && !this.data_.set_field(234, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public alt_ellipsoid(): number | null {
					if (this.data_.field_bit != 235 && !this.data_.set_field(235, -1)) return null;
					
					return this.data_.bytes.getInt32(this.data_.BYTE, true);
				}
				
				
				public h_acc(): number | null {
					if (this.data_.field_bit != 236 && !this.data_.set_field(236, -1)) return null;
					
					return this.data_.bytes.getInt32(this.data_.BYTE, true);
				}
				
				
				public v_acc(): number | null {
					if (this.data_.field_bit != 237 && !this.data_.set_field(237, -1)) return null;
					
					return this.data_.bytes.getInt32(this.data_.BYTE, true);
				}
				
				
				public vel_acc(): number | null {
					if (this.data_.field_bit != 238 && !this.data_.set_field(238, -1)) return null;
					
					return this.data_.bytes.getInt32(this.data_.BYTE, true);
				}
				
				
				public hdg_acc(): number | null {
					if (this.data_.field_bit != 239 && !this.data_.set_field(239, -1)) return null;
					
					return this.data_.bytes.getInt32(this.data_.BYTE, true);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				fix_type_(src: _Host.GPS_FIX_TYPE);
				
				lat_(src: number);
				
				lon_(src: number);
				
				alt_(src: number);
				
				eph_(src: number);
				
				epv_(src: number);
				
				vel_(src: number);
				
				cog_(src: number);
				
				satellites_visible_(src: number);
				
				alt_ellipsoid_(src: number);
				
				h_acc_(src: number);
				
				v_acc_(src: number);
				
				vel_acc_(src: number);
				
				hdg_acc_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: GPS_RAW_INT, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				{
					const item = src.fix_type();
					if (item !== null) dst.fix_type_(item);
					
				}
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.eph_(src.eph());
				
				dst.epv_(src.epv());
				
				dst.vel_(src.vel());
				
				dst.cog_(src.cog());
				
				dst.satellites_visible_(src.satellites_visible());
				
				{
					const item = src.alt_ellipsoid();
					if (item !== null) dst.alt_ellipsoid_(item);
					
				}
				
				{
					const item = src.h_acc();
					if (item !== null) dst.h_acc_(item);
					
				}
				
				{
					const item = src.v_acc();
					if (item !== null) dst.v_acc_(item);
					
				}
				
				{
					const item = src.vel_acc();
					if (item !== null) dst.vel_acc_(item);
					
				}
				
				{
					const item = src.hdg_acc();
					if (item !== null) dst.hdg_acc_(item);
					
				}
				
			}
			
		}
		
		export interface CAMERA_STATUS {
			img_idx(): number;
			
			img_idx_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			cam_idx(): number;
			
			cam_idx_(src: number);
			
			p1(): number;
			
			p1_(src: number);
			
			p2(): number;
			
			p2_(src: number);
			
			p3(): number;
			
			p3_(src: number);
			
			p4(): number;
			
			p4_(src: number);
			
			event_id(): CAMERA_STATUS_TYPES | null;
			
			event_id_(src: CAMERA_STATUS_TYPES);
			
		}
		
		export namespace CAMERA_STATUS {
			
			export const meta_ = new _Pack.Meta(211, 1, 0, 1, 29, 224, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements CAMERA_STATUS {
				
				public img_idx(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public img_idx_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 2, true) + this.data_.bytes.getInt32(this.data_.origin + 2 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 2, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 2 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 10);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 10, src); }
				
				public cam_idx(): number { return this.data_.bytes.getInt8(this.data_.origin + 11);}
				
				public cam_idx_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 11, src); }
				
				public p1(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public p1_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public p2(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public p2_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public p3(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public p3_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public p4(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public p4_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				
				public event_id(): CAMERA_STATUS_TYPES | null {
					if (this.data_.field_bit != 224 && !this.data_.set_field(224, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public event_id_(src: CAMERA_STATUS_TYPES) {
					if (this.data_.field_bit != 224) this.data_.set_field(224, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				target_system_(src: number);
				
				cam_idx_(src: number);
				
				img_idx_(src: number);
				
				event_id_(src: _Host.CAMERA_STATUS_TYPES);
				
				p1_(src: number);
				
				p2_(src: number);
				
				p3_(src: number);
				
				p4_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: CAMERA_STATUS, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.target_system_(src.target_system());
				
				dst.cam_idx_(src.cam_idx());
				
				dst.img_idx_(src.img_idx());
				
				{
					const item = src.event_id();
					if (item !== null) dst.event_id_(item);
					
				}
				
				dst.p1_(src.p1());
				
				dst.p2_(src.p2());
				
				dst.p3_(src.p3());
				
				dst.p4_(src.p4());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				target_system(): number;
				
				cam_idx(): number;
				
				img_idx(): number;
				
				event_id(): _Host.CAMERA_STATUS_TYPES | null;
				
				p1(): number;
				
				p2(): number;
				
				p3(): number;
				
				p4(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: CAMERA_STATUS) {
				
				dst.time_usec_(src.time_usec());
				
				dst.target_system_(src.target_system());
				
				dst.cam_idx_(src.cam_idx());
				
				dst.img_idx_(src.img_idx());
				{
					const item = src.event_id();
					if (item !== null) dst.event_id_(item);
					
				}
				
				dst.p1_(src.p1());
				
				dst.p2_(src.p2());
				
				dst.p3_(src.p3());
				
				dst.p4_(src.p4());
				
			}
			
		}
		
		export interface RC_CHANNELS_SCALED {
			time_boot_ms(): number;
			
			port(): number;
			
			chan1_scaled(): number;
			
			chan2_scaled(): number;
			
			chan3_scaled(): number;
			
			chan4_scaled(): number;
			
			chan5_scaled(): number;
			
			chan6_scaled(): number;
			
			chan7_scaled(): number;
			
			chan8_scaled(): number;
			
			rssi(): number;
			
		}
		
		export namespace RC_CHANNELS_SCALED {
			
			export const meta_ = new _Pack.Meta(120, 0, 1, 0, 22, 176);
			
			
			class Impl_ extends _Cursor.View implements RC_CHANNELS_SCALED {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public port(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				
				public chan1_scaled(): number { return this.data_.bytes.getInt16(this.data_.origin + 5, true);}
				
				
				public chan2_scaled(): number { return this.data_.bytes.getInt16(this.data_.origin + 7, true);}
				
				
				public chan3_scaled(): number { return this.data_.bytes.getInt16(this.data_.origin + 9, true);}
				
				
				public chan4_scaled(): number { return this.data_.bytes.getInt16(this.data_.origin + 11, true);}
				
				
				public chan5_scaled(): number { return this.data_.bytes.getInt16(this.data_.origin + 13, true);}
				
				
				public chan6_scaled(): number { return this.data_.bytes.getInt16(this.data_.origin + 15, true);}
				
				
				public chan7_scaled(): number { return this.data_.bytes.getInt16(this.data_.origin + 17, true);}
				
				
				public chan8_scaled(): number { return this.data_.bytes.getInt16(this.data_.origin + 19, true);}
				
				
				public rssi(): number { return this.data_.bytes.getInt8(this.data_.origin + 21);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				port_(src: number);
				
				chan1_scaled_(src: number);
				
				chan2_scaled_(src: number);
				
				chan3_scaled_(src: number);
				
				chan4_scaled_(src: number);
				
				chan5_scaled_(src: number);
				
				chan6_scaled_(src: number);
				
				chan7_scaled_(src: number);
				
				chan8_scaled_(src: number);
				
				rssi_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: RC_CHANNELS_SCALED, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.port_(src.port());
				
				dst.chan1_scaled_(src.chan1_scaled());
				
				dst.chan2_scaled_(src.chan2_scaled());
				
				dst.chan3_scaled_(src.chan3_scaled());
				
				dst.chan4_scaled_(src.chan4_scaled());
				
				dst.chan5_scaled_(src.chan5_scaled());
				
				dst.chan6_scaled_(src.chan6_scaled());
				
				dst.chan7_scaled_(src.chan7_scaled());
				
				dst.chan8_scaled_(src.chan8_scaled());
				
				dst.rssi_(src.rssi());
				
			}
			
		}
		
		export interface CAMERA_SETTINGS {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			mode_id(): CAMERA_MODE | null;
			
			mode_id_(src: CAMERA_MODE);
			
		}
		
		export namespace CAMERA_SETTINGS {
			
			export const meta_ = new _Pack.Meta(181, 0, 1, 0, 5, 32, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements CAMERA_SETTINGS {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				
				public mode_id(): CAMERA_MODE | null {
					if (this.data_.field_bit != 32 && !this.data_.set_field(32, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 2);
				}
				
				
				public mode_id_(src: CAMERA_MODE) {
					if (this.data_.field_bit != 32) this.data_.set_field(32, 0);
					
					_Lib.set_bits(src, 2, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				mode_id_(src: _Host.CAMERA_MODE);
				
			}
			
			export function push_<DST extends DST_>(src: CAMERA_SETTINGS, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				{
					const item = src.mode_id();
					if (item !== null) dst.mode_id_(item);
					
				}
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				mode_id(): _Host.CAMERA_MODE | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: CAMERA_SETTINGS) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				{
					const item = src.mode_id();
					if (item !== null) dst.mode_id_(item);
					
				}
				
			}
			
		}
		
		export interface DEVICE_OP_READ_REPLY {
			request_id(): number;
			
			request_id_(src: number);
			
			result(): number;
			
			result_(src: number);
			
			regstart(): number;
			
			regstart_(src: number);
			
			count(): number;
			
			count_(src: number);
			
			daTa(): DEVICE_OP_READ_REPLY.daTa;
			
			daTa_(src: DEVICE_OP_READ_REPLY.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace DEVICE_OP_READ_REPLY {
			
			export const meta_ = new _Pack.Meta(165, 0, 1, 0, 135, 1080);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 7 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 7, other.data_.bytes.buffer, other.data_.origin + 7, _Host.DEVICE_OP_READ_REPLY.daTa.item_len) === 0;
						for (let i = 0; i < _Host.DEVICE_OP_READ_REPLY.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.DEVICE_OP_READ_REPLY.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 7 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 128;
				
			}
			
			
			class Impl_ extends _Cursor.View implements DEVICE_OP_READ_REPLY {
				
				public request_id(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public request_id_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public result(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public result_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public regstart(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public regstart_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				public count(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				public count_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 6, src); }
				
				public daTa(): DEVICE_OP_READ_REPLY.daTa {
					
					return this.data_.as_field(DEVICE_OP_READ_REPLY.daTa.field);
				}
				
				public daTa_(src: DEVICE_OP_READ_REPLY.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.DEVICE_OP_READ_REPLY.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 7 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.DEVICE_OP_READ_REPLY.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 7 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.DEVICE_OP_READ_REPLY.daTa.item_len);
					
					len = Math.min(len, _Host.DEVICE_OP_READ_REPLY.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 7 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				request_id_(src: number);
				
				result_(src: number);
				
				regstart_(src: number);
				
				count_(src: number);
				
				daTa_(src: _Host.DEVICE_OP_READ_REPLY.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: DEVICE_OP_READ_REPLY, dst: DST) {
				
				dst.request_id_(src.request_id());
				
				dst.result_(src.result());
				
				dst.regstart_(src.regstart());
				
				dst.count_(src.count());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				request_id(): number;
				
				result(): number;
				
				regstart(): number;
				
				count(): number;
				
				daTa(dst: _Host.DEVICE_OP_READ_REPLY.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DEVICE_OP_READ_REPLY) {
				
				dst.request_id_(src.request_id());
				
				dst.result_(src.result());
				
				dst.regstart_(src.regstart());
				
				dst.count_(src.count());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface RAW_PRESSURE {
			time_usec(): number;
			
			press_abs(): number;
			
			press_diff1(): number;
			
			press_diff2(): number;
			
			temperature(): number;
			
		}
		
		export namespace RAW_PRESSURE {
			
			export const meta_ = new _Pack.Meta(19, 0, 0, 1, 16, 128);
			
			
			class Impl_ extends _Cursor.View implements RAW_PRESSURE {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				
				public press_abs(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				
				public press_diff1(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				
				public press_diff2(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				
				public temperature(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				press_abs_(src: number);
				
				press_diff1_(src: number);
				
				press_diff2_(src: number);
				
				temperature_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: RAW_PRESSURE, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.press_abs_(src.press_abs());
				
				dst.press_diff1_(src.press_diff1());
				
				dst.press_diff2_(src.press_diff2());
				
				dst.temperature_(src.temperature());
				
			}
			
		}
		
		export interface DIGICAM_CONTROL {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			session(): number;
			
			session_(src: number);
			
			zoom_pos(): number;
			
			zoom_pos_(src: number);
			
			zoom_step(): number;
			
			zoom_step_(src: number);
			
			focus_lock(): number;
			
			focus_lock_(src: number);
			
			shot(): number;
			
			shot_(src: number);
			
			command_id(): number;
			
			command_id_(src: number);
			
			extra_param(): number;
			
			extra_param_(src: number);
			
			extra_value(): number;
			
			extra_value_(src: number);
			
		}
		
		export namespace DIGICAM_CONTROL {
			
			export const meta_ = new _Pack.Meta(49, 0, 0, 0, 13, 104);
			
			
			class Impl_ extends _Cursor.View implements DIGICAM_CONTROL {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public session(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public session_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public zoom_pos(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public zoom_pos_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
				public zoom_step(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public zoom_step_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public focus_lock(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public focus_lock_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				public shot(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				public shot_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 6, src); }
				
				public command_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 7);}
				
				public command_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 7, src); }
				
				public extra_param(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public extra_param_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
				public extra_value(): number { return this.data_.bytes.getFloat32(this.data_.origin + 9, true);}
				
				public extra_value_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 9, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				session_(src: number);
				
				zoom_pos_(src: number);
				
				zoom_step_(src: number);
				
				focus_lock_(src: number);
				
				shot_(src: number);
				
				command_id_(src: number);
				
				extra_param_(src: number);
				
				extra_value_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: DIGICAM_CONTROL, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.session_(src.session());
				
				dst.zoom_pos_(src.zoom_pos());
				
				dst.zoom_step_(src.zoom_step());
				
				dst.focus_lock_(src.focus_lock());
				
				dst.shot_(src.shot());
				
				dst.command_id_(src.command_id());
				
				dst.extra_param_(src.extra_param());
				
				dst.extra_value_(src.extra_value());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				session(): number;
				
				zoom_pos(): number;
				
				zoom_step(): number;
				
				focus_lock(): number;
				
				shot(): number;
				
				command_id(): number;
				
				extra_param(): number;
				
				extra_value(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DIGICAM_CONTROL) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.session_(src.session());
				
				dst.zoom_pos_(src.zoom_pos());
				
				dst.zoom_step_(src.zoom_step());
				
				dst.focus_lock_(src.focus_lock());
				
				dst.shot_(src.shot());
				
				dst.command_id_(src.command_id());
				
				dst.extra_param_(src.extra_param());
				
				dst.extra_value_(src.extra_value());
				
			}
			
		}
		
		export interface NAMED_VALUE_FLOAT {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			value(): number;
			
			value_(src: number);
			
			name(): _Cursor.UTF8 | null;
			
			name_(src: string | Uint8Array): _Cursor.UTF8;
			
			name$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace NAMED_VALUE_FLOAT {
			
			export const meta_ = new _Pack.Meta(8, 0, 1, 0, 9, 66, 2, 1);
			
			
			export namespace name {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements NAMED_VALUE_FLOAT {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public value(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public value_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				
				name(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 66 && !this.data_.set_field(66, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				name_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -66 - 1);
					
					let len = Math.min(src.byteLength, _Host.NAMED_VALUE_FLOAT.name.item_len_max);
					this.data_.set_field(66, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				name$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.NAMED_VALUE_FLOAT.name.item_len_max)
					this.data_.set_field(66, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				name_(src: _Cursor.UTF8);
				
				value_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: NAMED_VALUE_FLOAT, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				{
					const item = src.name();
					if (item !== null) dst.name_(item);
					
				}
				
				dst.value_(src.value());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				name(): string | Uint8Array | null;
				
				value(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: NAMED_VALUE_FLOAT) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				
				{
					const item = src.name();
					if (item !== null) dst.name_(item);
				}
				
				
				dst.value_(src.value());
				
			}
			
		}
		
		export interface GOPRO_HEARTBEAT {
			status(): GOPRO_HEARTBEAT_STATUS | null;
			
			status_(src: GOPRO_HEARTBEAT_STATUS);
			
			capture_mode(): GOPRO_CAPTURE_MODE | null;
			
			capture_mode_(src: GOPRO_CAPTURE_MODE);
			
			flags(): GOPRO_HEARTBEAT_FLAGS | null;
			
			flags_(src: GOPRO_HEARTBEAT_FLAGS);
			
		}
		
		export namespace GOPRO_HEARTBEAT {
			
			export const meta_ = new _Pack.Meta(175, 0, 0, 0, 1, 2, 2, 3);
			
			
			class Impl_ extends _Cursor.View implements GOPRO_HEARTBEAT {
				
				
				public status(): GOPRO_HEARTBEAT_STATUS | null {
					if (this.data_.field_bit != 2 && !this.data_.set_field(2, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 2);
				}
				
				
				public status_(src: GOPRO_HEARTBEAT_STATUS) {
					if (this.data_.field_bit != 2) this.data_.set_field(2, 0);
					
					_Lib.set_bits(src, 2, this.data_.bytes, this.data_.BIT);
				}
				
				
				public capture_mode(): GOPRO_CAPTURE_MODE | null {
					if (this.data_.field_bit != 3 && !this.data_.set_field(3, -1)) return null;
					
					return _Host.GOPRO_CAPTURE_MODE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 4));
				}
				
				
				public capture_mode_(src: GOPRO_CAPTURE_MODE) {
					if (this.data_.field_bit != 3) this.data_.set_field(3, 0);
					
					_Lib.set_bits(_Host.GOPRO_CAPTURE_MODE_.into(src), 4, this.data_.bytes, this.data_.BIT);
				}
				
				
				public flags(): GOPRO_HEARTBEAT_FLAGS | null {
					if (this.data_.field_bit != 4 && !this.data_.set_field(4, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 1);
				}
				
				
				public flags_(src: GOPRO_HEARTBEAT_FLAGS) {
					if (this.data_.field_bit != 4) this.data_.set_field(4, 0);
					
					_Lib.set_bits(src, 1, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				status_(src: _Host.GOPRO_HEARTBEAT_STATUS);
				
				capture_mode_(src: _Host.GOPRO_CAPTURE_MODE);
				
				flags_(src: _Host.GOPRO_HEARTBEAT_FLAGS);
				
			}
			
			export function push_<DST extends DST_>(src: GOPRO_HEARTBEAT, dst: DST) {
				
				{
					const item = src.status();
					if (item !== null) dst.status_(item);
					
				}
				
				{
					const item = src.capture_mode();
					if (item !== null) dst.capture_mode_(item);
					
				}
				
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
			}
			
			export interface SRC_ {
				status(): _Host.GOPRO_HEARTBEAT_STATUS | null;
				
				capture_mode(): _Host.GOPRO_CAPTURE_MODE | null;
				
				flags(): _Host.GOPRO_HEARTBEAT_FLAGS | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GOPRO_HEARTBEAT) {
				{
					const item = src.status();
					if (item !== null) dst.status_(item);
					
				}
				{
					const item = src.capture_mode();
					if (item !== null) dst.capture_mode_(item);
					
				}
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
			}
			
		}
		
		export interface ATTITUDE {
			time_boot_ms(): number;
			
			roll(): number;
			
			pitch(): number;
			
			yaw(): number;
			
			rollspeed(): number;
			
			pitchspeed(): number;
			
			yawspeed(): number;
			
		}
		
		export namespace ATTITUDE {
			
			export const meta_ = new _Pack.Meta(134, 0, 1, 0, 28, 224);
			
			
			class Impl_ extends _Cursor.View implements ATTITUDE {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public rollspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public pitchspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public yawspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
				rollspeed_(src: number);
				
				pitchspeed_(src: number);
				
				yawspeed_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: ATTITUDE, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.rollspeed_(src.rollspeed());
				
				dst.pitchspeed_(src.pitchspeed());
				
				dst.yawspeed_(src.yawspeed());
				
			}
			
		}
		
		export interface MISSION_WRITE_PARTIAL_LIST {
			target_system(): number;
			
			target_component(): number;
			
			start_index(): number;
			
			end_index(): number;
			
			mission_type(): MAV_MISSION_TYPE | null;
			
		}
		
		export namespace MISSION_WRITE_PARTIAL_LIST {
			
			export const meta_ = new _Pack.Meta(145, 0, 0, 0, 7, 48, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements MISSION_WRITE_PARTIAL_LIST {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public start_index(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				public end_index(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				
				public mission_type(): MAV_MISSION_TYPE | null {
					if (this.data_.field_bit != 48 && !this.data_.set_field(48, -1)) return null;
					
					return _Host.MAV_MISSION_TYPE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				start_index_(src: number);
				
				end_index_(src: number);
				
				mission_type_(src: _Host.MAV_MISSION_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_WRITE_PARTIAL_LIST, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.start_index_(src.start_index());
				
				dst.end_index_(src.end_index());
				
				{
					const item = src.mission_type();
					if (item !== null) dst.mission_type_(item);
					
				}
				
			}
			
		}
		
		export interface AHRS2 {
			roll(): number;
			
			roll_(src: number);
			
			pitch(): number;
			
			pitch_(src: number);
			
			yaw(): number;
			
			yaw_(src: number);
			
			altitude(): number;
			
			altitude_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lng(): number;
			
			lng_(src: number);
			
		}
		
		export namespace AHRS2 {
			
			export const meta_ = new _Pack.Meta(17, 0, 0, 0, 24, 192);
			
			
			class Impl_ extends _Cursor.View implements AHRS2 {
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public roll_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public pitch_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public yaw_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public altitude(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public altitude_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 16, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 16, src, true); }
				
				public lng(): number { return this.data_.bytes.getInt32(this.data_.origin + 20, true);}
				
				public lng_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 20, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
				altitude_(src: number);
				
				lat_(src: number);
				
				lng_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: AHRS2, dst: DST) {
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.altitude_(src.altitude());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
			}
			
			export interface SRC_ {
				roll(): number;
				
				pitch(): number;
				
				yaw(): number;
				
				altitude(): number;
				
				lat(): number;
				
				lng(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: AHRS2) {
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.altitude_(src.altitude());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
			}
			
		}
		
		export interface LOG_ERASE {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
		}
		
		export namespace LOG_ERASE {
			
			export const meta_ = new _Pack.Meta(4, 0, 0, 0, 2, 16);
			
			
			class Impl_ extends _Cursor.View implements LOG_ERASE {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: LOG_ERASE, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LOG_ERASE) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
			}
			
		}
		
		export interface TERRAIN_REQUEST {
			grid_spacing(): number;
			
			grid_spacing_(src: number);
			
			mask(): number;
			
			mask_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
		}
		
		export namespace TERRAIN_REQUEST {
			
			export const meta_ = new _Pack.Meta(92, 1, 0, 1, 18, 144);
			
			
			class Impl_ extends _Cursor.View implements TERRAIN_REQUEST {
				
				public grid_spacing(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public grid_spacing_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public mask(): number { return this.data_.bytes.getUint32(this.data_.origin + 2, true) + this.data_.bytes.getInt32(this.data_.origin + 2 + 4, true) * _Lib.JS_HI;}
				
				public mask_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 2, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 2 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 14, true);}
				
				public lon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 14, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				lat_(src: number);
				
				lon_(src: number);
				
				grid_spacing_(src: number);
				
				mask_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: TERRAIN_REQUEST, dst: DST) {
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.grid_spacing_(src.grid_spacing());
				
				dst.mask_(src.mask());
				
			}
			
			export interface SRC_ {
				lat(): number;
				
				lon(): number;
				
				grid_spacing(): number;
				
				mask(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: TERRAIN_REQUEST) {
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.grid_spacing_(src.grid_spacing());
				
				dst.mask_(src.mask());
				
			}
			
		}
		
		export interface MOUNT_STATUS {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			pointing_a(): number;
			
			pointing_a_(src: number);
			
			pointing_b(): number;
			
			pointing_b_(src: number);
			
			pointing_c(): number;
			
			pointing_c_(src: number);
			
		}
		
		export namespace MOUNT_STATUS {
			
			export const meta_ = new _Pack.Meta(44, 0, 0, 0, 14, 112);
			
			
			class Impl_ extends _Cursor.View implements MOUNT_STATUS {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public pointing_a(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public pointing_a_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public pointing_b(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public pointing_b_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public pointing_c(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public pointing_c_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				pointing_a_(src: number);
				
				pointing_b_(src: number);
				
				pointing_c_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MOUNT_STATUS, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.pointing_a_(src.pointing_a());
				
				dst.pointing_b_(src.pointing_b());
				
				dst.pointing_c_(src.pointing_c());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				pointing_a(): number;
				
				pointing_b(): number;
				
				pointing_c(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: MOUNT_STATUS) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.pointing_a_(src.pointing_a());
				
				dst.pointing_b_(src.pointing_b());
				
				dst.pointing_c_(src.pointing_c());
				
			}
			
		}
		
		export interface MANUAL_SETPOINT {
			time_boot_ms(): number;
			
			roll(): number;
			
			pitch(): number;
			
			yaw(): number;
			
			thrust(): number;
			
			mode_switch(): number;
			
			manual_override_switch(): number;
			
		}
		
		export namespace MANUAL_SETPOINT {
			
			export const meta_ = new _Pack.Meta(219, 0, 1, 0, 22, 176);
			
			
			class Impl_ extends _Cursor.View implements MANUAL_SETPOINT {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public thrust(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public mode_switch(): number { return this.data_.bytes.getInt8(this.data_.origin + 20);}
				
				
				public manual_override_switch(): number { return this.data_.bytes.getInt8(this.data_.origin + 21);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
				thrust_(src: number);
				
				mode_switch_(src: number);
				
				manual_override_switch_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MANUAL_SETPOINT, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.thrust_(src.thrust());
				
				dst.mode_switch_(src.mode_switch());
				
				dst.manual_override_switch_(src.manual_override_switch());
				
			}
			
		}
		
		export interface PID_TUNING {
			desired(): number;
			
			desired_(src: number);
			
			achieved(): number;
			
			achieved_(src: number);
			
			FF(): number;
			
			FF_(src: number);
			
			P(): number;
			
			P_(src: number);
			
			I(): number;
			
			I_(src: number);
			
			D(): number;
			
			D_(src: number);
			
			axis(): PID_TUNING_AXIS | null;
			
			axis_(src: PID_TUNING_AXIS);
			
		}
		
		export namespace PID_TUNING {
			
			export const meta_ = new _Pack.Meta(64, 0, 0, 0, 25, 192, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements PID_TUNING {
				
				public desired(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public desired_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public achieved(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public achieved_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public FF(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public FF_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public P(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public P_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public I(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public I_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public D(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public D_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				
				public axis(): PID_TUNING_AXIS | null {
					if (this.data_.field_bit != 192 && !this.data_.set_field(192, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public axis_(src: PID_TUNING_AXIS) {
					if (this.data_.field_bit != 192) this.data_.set_field(192, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				axis_(src: _Host.PID_TUNING_AXIS);
				
				desired_(src: number);
				
				achieved_(src: number);
				
				FF_(src: number);
				
				P_(src: number);
				
				I_(src: number);
				
				D_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: PID_TUNING, dst: DST) {
				
				{
					const item = src.axis();
					if (item !== null) dst.axis_(item);
					
				}
				
				dst.desired_(src.desired());
				
				dst.achieved_(src.achieved());
				
				dst.FF_(src.FF());
				
				dst.P_(src.P());
				
				dst.I_(src.I());
				
				dst.D_(src.D());
				
			}
			
			export interface SRC_ {
				axis(): _Host.PID_TUNING_AXIS | null;
				
				desired(): number;
				
				achieved(): number;
				
				FF(): number;
				
				P(): number;
				
				I(): number;
				
				D(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: PID_TUNING) {
				{
					const item = src.axis();
					if (item !== null) dst.axis_(item);
					
				}
				
				dst.desired_(src.desired());
				
				dst.achieved_(src.achieved());
				
				dst.FF_(src.FF());
				
				dst.P_(src.P());
				
				dst.I_(src.I());
				
				dst.D_(src.D());
				
			}
			
		}
		
		export interface SAFETY_ALLOWED_AREA {
			p1x(): number;
			
			p1y(): number;
			
			p1z(): number;
			
			p2x(): number;
			
			p2y(): number;
			
			p2z(): number;
			
			frame(): MAV_FRAME | null;
			
		}
		
		export namespace SAFETY_ALLOWED_AREA {
			
			export const meta_ = new _Pack.Meta(179, 0, 0, 0, 25, 192, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements SAFETY_ALLOWED_AREA {
				
				public p1x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				
				public p1y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				
				public p1z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public p2x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public p2y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public p2z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public frame(): MAV_FRAME | null {
					if (this.data_.field_bit != 192 && !this.data_.set_field(192, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				frame_(src: _Host.MAV_FRAME);
				
				p1x_(src: number);
				
				p1y_(src: number);
				
				p1z_(src: number);
				
				p2x_(src: number);
				
				p2y_(src: number);
				
				p2z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SAFETY_ALLOWED_AREA, dst: DST) {
				
				{
					const item = src.frame();
					if (item !== null) dst.frame_(item);
					
				}
				
				dst.p1x_(src.p1x());
				
				dst.p1y_(src.p1y());
				
				dst.p1z_(src.p1z());
				
				dst.p2x_(src.p2x());
				
				dst.p2y_(src.p2y());
				
				dst.p2z_(src.p2z());
				
			}
			
		}
		
		export interface OPTICAL_FLOW_RAD {
			integration_time_us(): number;
			
			integration_time_us_(src: number);
			
			time_delta_distance_us(): number;
			
			time_delta_distance_us_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			sensor_id(): number;
			
			sensor_id_(src: number);
			
			integrated_x(): number;
			
			integrated_x_(src: number);
			
			integrated_y(): number;
			
			integrated_y_(src: number);
			
			integrated_xgyro(): number;
			
			integrated_xgyro_(src: number);
			
			integrated_ygyro(): number;
			
			integrated_ygyro_(src: number);
			
			integrated_zgyro(): number;
			
			integrated_zgyro_(src: number);
			
			temperature(): number;
			
			temperature_(src: number);
			
			quality(): number;
			
			quality_(src: number);
			
			distance(): number;
			
			distance_(src: number);
			
		}
		
		export namespace OPTICAL_FLOW_RAD {
			
			export const meta_ = new _Pack.Meta(202, 0, 2, 1, 44, 352);
			
			
			class Impl_ extends _Cursor.View implements OPTICAL_FLOW_RAD {
				
				public integration_time_us(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public integration_time_us_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public time_delta_distance_us(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				public time_delta_distance_us_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 4, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 8, true) + this.data_.bytes.getInt32(this.data_.origin + 8 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 8, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 8 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public sensor_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 16);}
				
				public sensor_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 16, src); }
				
				public integrated_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 17, true);}
				
				public integrated_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 17, src, true); }
				
				public integrated_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 21, true);}
				
				public integrated_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 21, src, true); }
				
				public integrated_xgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 25, true);}
				
				public integrated_xgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 25, src, true); }
				
				public integrated_ygyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 29, true);}
				
				public integrated_ygyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 29, src, true); }
				
				public integrated_zgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 33, true);}
				
				public integrated_zgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 33, src, true); }
				
				public temperature(): number { return this.data_.bytes.getInt16(this.data_.origin + 37, true);}
				
				public temperature_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 37, src, true); }
				
				public quality(): number { return this.data_.bytes.getInt8(this.data_.origin + 39);}
				
				public quality_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 39, src); }
				
				public distance(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				public distance_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 40, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				sensor_id_(src: number);
				
				integration_time_us_(src: number);
				
				integrated_x_(src: number);
				
				integrated_y_(src: number);
				
				integrated_xgyro_(src: number);
				
				integrated_ygyro_(src: number);
				
				integrated_zgyro_(src: number);
				
				temperature_(src: number);
				
				quality_(src: number);
				
				time_delta_distance_us_(src: number);
				
				distance_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: OPTICAL_FLOW_RAD, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.sensor_id_(src.sensor_id());
				
				dst.integration_time_us_(src.integration_time_us());
				
				dst.integrated_x_(src.integrated_x());
				
				dst.integrated_y_(src.integrated_y());
				
				dst.integrated_xgyro_(src.integrated_xgyro());
				
				dst.integrated_ygyro_(src.integrated_ygyro());
				
				dst.integrated_zgyro_(src.integrated_zgyro());
				
				dst.temperature_(src.temperature());
				
				dst.quality_(src.quality());
				
				dst.time_delta_distance_us_(src.time_delta_distance_us());
				
				dst.distance_(src.distance());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				sensor_id(): number;
				
				integration_time_us(): number;
				
				integrated_x(): number;
				
				integrated_y(): number;
				
				integrated_xgyro(): number;
				
				integrated_ygyro(): number;
				
				integrated_zgyro(): number;
				
				temperature(): number;
				
				quality(): number;
				
				time_delta_distance_us(): number;
				
				distance(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: OPTICAL_FLOW_RAD) {
				
				dst.time_usec_(src.time_usec());
				
				dst.sensor_id_(src.sensor_id());
				
				dst.integration_time_us_(src.integration_time_us());
				
				dst.integrated_x_(src.integrated_x());
				
				dst.integrated_y_(src.integrated_y());
				
				dst.integrated_xgyro_(src.integrated_xgyro());
				
				dst.integrated_ygyro_(src.integrated_ygyro());
				
				dst.integrated_zgyro_(src.integrated_zgyro());
				
				dst.temperature_(src.temperature());
				
				dst.quality_(src.quality());
				
				dst.time_delta_distance_us_(src.time_delta_distance_us());
				
				dst.distance_(src.distance());
				
			}
			
		}
		
		export interface LOG_DATA {
			id(): number;
			
			id_(src: number);
			
			ofs(): number;
			
			ofs_(src: number);
			
			count(): number;
			
			count_(src: number);
			
			daTa(): LOG_DATA.daTa;
			
			daTa_(src: LOG_DATA.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace LOG_DATA {
			
			export const meta_ = new _Pack.Meta(204, 1, 1, 0, 97, 776);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 7 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 7, other.data_.bytes.buffer, other.data_.origin + 7, _Host.LOG_DATA.daTa.item_len) === 0;
						for (let i = 0; i < _Host.LOG_DATA.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.LOG_DATA.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 7 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 90;
				
			}
			
			
			class Impl_ extends _Cursor.View implements LOG_DATA {
				
				public id(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public id_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public ofs(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public ofs_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public count(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				public count_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 6, src); }
				
				public daTa(): LOG_DATA.daTa {
					
					return this.data_.as_field(LOG_DATA.daTa.field);
				}
				
				public daTa_(src: LOG_DATA.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.LOG_DATA.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 7 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.LOG_DATA.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 7 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.LOG_DATA.daTa.item_len);
					
					len = Math.min(len, _Host.LOG_DATA.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 7 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				id_(src: number);
				
				ofs_(src: number);
				
				count_(src: number);
				
				daTa_(src: _Host.LOG_DATA.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: LOG_DATA, dst: DST) {
				
				dst.id_(src.id());
				
				dst.ofs_(src.ofs());
				
				dst.count_(src.count());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				id(): number;
				
				ofs(): number;
				
				count(): number;
				
				daTa(dst: _Host.LOG_DATA.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LOG_DATA) {
				
				dst.id_(src.id());
				
				dst.ofs_(src.ofs());
				
				dst.count_(src.count());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface MISSION_CLEAR_ALL {
			target_system(): number;
			
			target_component(): number;
			
			mission_type(): MAV_MISSION_TYPE | null;
			
		}
		
		export namespace MISSION_CLEAR_ALL {
			
			export const meta_ = new _Pack.Meta(193, 0, 0, 0, 3, 16, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements MISSION_CLEAR_ALL {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public mission_type(): MAV_MISSION_TYPE | null {
					if (this.data_.field_bit != 16 && !this.data_.set_field(16, -1)) return null;
					
					return _Host.MAV_MISSION_TYPE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				mission_type_(src: _Host.MAV_MISSION_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_CLEAR_ALL, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.mission_type();
					if (item !== null) dst.mission_type_(item);
					
				}
				
			}
			
		}
		
		export interface AHRS3 {
			roll(): number;
			
			roll_(src: number);
			
			pitch(): number;
			
			pitch_(src: number);
			
			yaw(): number;
			
			yaw_(src: number);
			
			altitude(): number;
			
			altitude_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lng(): number;
			
			lng_(src: number);
			
			v1(): number;
			
			v1_(src: number);
			
			v2(): number;
			
			v2_(src: number);
			
			v3(): number;
			
			v3_(src: number);
			
			v4(): number;
			
			v4_(src: number);
			
		}
		
		export namespace AHRS3 {
			
			export const meta_ = new _Pack.Meta(65, 0, 0, 0, 40, 320);
			
			
			class Impl_ extends _Cursor.View implements AHRS3 {
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public roll_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public pitch_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public yaw_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public altitude(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public altitude_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 16, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 16, src, true); }
				
				public lng(): number { return this.data_.bytes.getInt32(this.data_.origin + 20, true);}
				
				public lng_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 20, src, true); }
				
				public v1(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public v1_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public v2(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public v2_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public v3(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public v3_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public v4(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				public v4_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 36, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
				altitude_(src: number);
				
				lat_(src: number);
				
				lng_(src: number);
				
				v1_(src: number);
				
				v2_(src: number);
				
				v3_(src: number);
				
				v4_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: AHRS3, dst: DST) {
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.altitude_(src.altitude());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
				dst.v1_(src.v1());
				
				dst.v2_(src.v2());
				
				dst.v3_(src.v3());
				
				dst.v4_(src.v4());
				
			}
			
			export interface SRC_ {
				roll(): number;
				
				pitch(): number;
				
				yaw(): number;
				
				altitude(): number;
				
				lat(): number;
				
				lng(): number;
				
				v1(): number;
				
				v2(): number;
				
				v3(): number;
				
				v4(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: AHRS3) {
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.altitude_(src.altitude());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
				dst.v1_(src.v1());
				
				dst.v2_(src.v2());
				
				dst.v3_(src.v3());
				
				dst.v4_(src.v4());
				
			}
			
		}
		
		export interface VICON_POSITION_ESTIMATE {
			usec(): number;
			
			usec_(src: number);
			
			x(): number;
			
			x_(src: number);
			
			y(): number;
			
			y_(src: number);
			
			z(): number;
			
			z_(src: number);
			
			roll(): number;
			
			roll_(src: number);
			
			pitch(): number;
			
			pitch_(src: number);
			
			yaw(): number;
			
			yaw_(src: number);
			
		}
		
		export namespace VICON_POSITION_ESTIMATE {
			
			export const meta_ = new _Pack.Meta(135, 0, 0, 1, 32, 256);
			
			
			class Impl_ extends _Cursor.View implements VICON_POSITION_ESTIMATE {
				
				public usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public roll_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public pitch_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public yaw_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				usec_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: VICON_POSITION_ESTIMATE, dst: DST) {
				
				dst.usec_(src.usec());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
			}
			
			export interface SRC_ {
				usec(): number;
				
				x(): number;
				
				y(): number;
				
				z(): number;
				
				roll(): number;
				
				pitch(): number;
				
				yaw(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: VICON_POSITION_ESTIMATE) {
				
				dst.usec_(src.usec());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
			}
			
		}
		
		export interface GPS2_RTK {
			wn(): number;
			
			wn_(src: number);
			
			time_last_baseline_ms(): number;
			
			time_last_baseline_ms_(src: number);
			
			tow(): number;
			
			tow_(src: number);
			
			accuracy(): number;
			
			accuracy_(src: number);
			
			rtk_receiver_id(): number;
			
			rtk_receiver_id_(src: number);
			
			rtk_health(): number;
			
			rtk_health_(src: number);
			
			rtk_rate(): number;
			
			rtk_rate_(src: number);
			
			nsats(): number;
			
			nsats_(src: number);
			
			baseline_coords_type(): number;
			
			baseline_coords_type_(src: number);
			
			baseline_a_mm(): number;
			
			baseline_a_mm_(src: number);
			
			baseline_b_mm(): number;
			
			baseline_b_mm_(src: number);
			
			baseline_c_mm(): number;
			
			baseline_c_mm_(src: number);
			
			iar_num_hypotheses(): number;
			
			iar_num_hypotheses_(src: number);
			
		}
		
		export namespace GPS2_RTK {
			
			export const meta_ = new _Pack.Meta(91, 1, 3, 0, 35, 280);
			
			
			class Impl_ extends _Cursor.View implements GPS2_RTK {
				
				public wn(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public wn_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public time_last_baseline_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public time_last_baseline_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public tow(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public tow_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public accuracy(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public accuracy_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
				public rtk_receiver_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 14);}
				
				public rtk_receiver_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 14, src); }
				
				public rtk_health(): number { return this.data_.bytes.getInt8(this.data_.origin + 15);}
				
				public rtk_health_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 15, src); }
				
				public rtk_rate(): number { return this.data_.bytes.getInt8(this.data_.origin + 16);}
				
				public rtk_rate_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 16, src); }
				
				public nsats(): number { return this.data_.bytes.getInt8(this.data_.origin + 17);}
				
				public nsats_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 17, src); }
				
				public baseline_coords_type(): number { return this.data_.bytes.getInt8(this.data_.origin + 18);}
				
				public baseline_coords_type_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 18, src); }
				
				public baseline_a_mm(): number { return this.data_.bytes.getInt32(this.data_.origin + 19, true);}
				
				public baseline_a_mm_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 19, src, true); }
				
				public baseline_b_mm(): number { return this.data_.bytes.getInt32(this.data_.origin + 23, true);}
				
				public baseline_b_mm_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 23, src, true); }
				
				public baseline_c_mm(): number { return this.data_.bytes.getInt32(this.data_.origin + 27, true);}
				
				public baseline_c_mm_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 27, src, true); }
				
				public iar_num_hypotheses(): number { return this.data_.bytes.getInt32(this.data_.origin + 31, true);}
				
				public iar_num_hypotheses_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 31, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_last_baseline_ms_(src: number);
				
				rtk_receiver_id_(src: number);
				
				wn_(src: number);
				
				tow_(src: number);
				
				rtk_health_(src: number);
				
				rtk_rate_(src: number);
				
				nsats_(src: number);
				
				baseline_coords_type_(src: number);
				
				baseline_a_mm_(src: number);
				
				baseline_b_mm_(src: number);
				
				baseline_c_mm_(src: number);
				
				accuracy_(src: number);
				
				iar_num_hypotheses_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: GPS2_RTK, dst: DST) {
				
				dst.time_last_baseline_ms_(src.time_last_baseline_ms());
				
				dst.rtk_receiver_id_(src.rtk_receiver_id());
				
				dst.wn_(src.wn());
				
				dst.tow_(src.tow());
				
				dst.rtk_health_(src.rtk_health());
				
				dst.rtk_rate_(src.rtk_rate());
				
				dst.nsats_(src.nsats());
				
				dst.baseline_coords_type_(src.baseline_coords_type());
				
				dst.baseline_a_mm_(src.baseline_a_mm());
				
				dst.baseline_b_mm_(src.baseline_b_mm());
				
				dst.baseline_c_mm_(src.baseline_c_mm());
				
				dst.accuracy_(src.accuracy());
				
				dst.iar_num_hypotheses_(src.iar_num_hypotheses());
				
			}
			
			export interface SRC_ {
				time_last_baseline_ms(): number;
				
				rtk_receiver_id(): number;
				
				wn(): number;
				
				tow(): number;
				
				rtk_health(): number;
				
				rtk_rate(): number;
				
				nsats(): number;
				
				baseline_coords_type(): number;
				
				baseline_a_mm(): number;
				
				baseline_b_mm(): number;
				
				baseline_c_mm(): number;
				
				accuracy(): number;
				
				iar_num_hypotheses(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GPS2_RTK) {
				
				dst.time_last_baseline_ms_(src.time_last_baseline_ms());
				
				dst.rtk_receiver_id_(src.rtk_receiver_id());
				
				dst.wn_(src.wn());
				
				dst.tow_(src.tow());
				
				dst.rtk_health_(src.rtk_health());
				
				dst.rtk_rate_(src.rtk_rate());
				
				dst.nsats_(src.nsats());
				
				dst.baseline_coords_type_(src.baseline_coords_type());
				
				dst.baseline_a_mm_(src.baseline_a_mm());
				
				dst.baseline_b_mm_(src.baseline_b_mm());
				
				dst.baseline_c_mm_(src.baseline_c_mm());
				
				dst.accuracy_(src.accuracy());
				
				dst.iar_num_hypotheses_(src.iar_num_hypotheses());
				
			}
			
		}
		
		export interface MAG_CAL_REPORT {
			compass_id(): number;
			
			compass_id_(src: number);
			
			cal_mask(): number;
			
			cal_mask_(src: number);
			
			autosaved(): number;
			
			autosaved_(src: number);
			
			fitness(): number;
			
			fitness_(src: number);
			
			ofs_x(): number;
			
			ofs_x_(src: number);
			
			ofs_y(): number;
			
			ofs_y_(src: number);
			
			ofs_z(): number;
			
			ofs_z_(src: number);
			
			diag_x(): number;
			
			diag_x_(src: number);
			
			diag_y(): number;
			
			diag_y_(src: number);
			
			diag_z(): number;
			
			diag_z_(src: number);
			
			offdiag_x(): number;
			
			offdiag_x_(src: number);
			
			offdiag_y(): number;
			
			offdiag_y_(src: number);
			
			offdiag_z(): number;
			
			offdiag_z_(src: number);
			
			cal_status(): MAG_CAL_STATUS | null;
			
			cal_status_(src: MAG_CAL_STATUS);
			
		}
		
		export namespace MAG_CAL_REPORT {
			
			export const meta_ = new _Pack.Meta(63, 0, 0, 0, 44, 344, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements MAG_CAL_REPORT {
				
				public compass_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public compass_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public cal_mask(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public cal_mask_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public autosaved(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public autosaved_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public fitness(): number { return this.data_.bytes.getFloat32(this.data_.origin + 3, true);}
				
				public fitness_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 3, src, true); }
				
				public ofs_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 7, true);}
				
				public ofs_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 7, src, true); }
				
				public ofs_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 11, true);}
				
				public ofs_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 11, src, true); }
				
				public ofs_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 15, true);}
				
				public ofs_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 15, src, true); }
				
				public diag_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 19, true);}
				
				public diag_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 19, src, true); }
				
				public diag_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 23, true);}
				
				public diag_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 23, src, true); }
				
				public diag_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 27, true);}
				
				public diag_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 27, src, true); }
				
				public offdiag_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 31, true);}
				
				public offdiag_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 31, src, true); }
				
				public offdiag_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 35, true);}
				
				public offdiag_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 35, src, true); }
				
				public offdiag_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 39, true);}
				
				public offdiag_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 39, src, true); }
				
				
				public cal_status(): MAG_CAL_STATUS | null {
					if (this.data_.field_bit != 344 && !this.data_.set_field(344, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public cal_status_(src: MAG_CAL_STATUS) {
					if (this.data_.field_bit != 344) this.data_.set_field(344, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				compass_id_(src: number);
				
				cal_mask_(src: number);
				
				cal_status_(src: _Host.MAG_CAL_STATUS);
				
				autosaved_(src: number);
				
				fitness_(src: number);
				
				ofs_x_(src: number);
				
				ofs_y_(src: number);
				
				ofs_z_(src: number);
				
				diag_x_(src: number);
				
				diag_y_(src: number);
				
				diag_z_(src: number);
				
				offdiag_x_(src: number);
				
				offdiag_y_(src: number);
				
				offdiag_z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MAG_CAL_REPORT, dst: DST) {
				
				dst.compass_id_(src.compass_id());
				
				dst.cal_mask_(src.cal_mask());
				
				{
					const item = src.cal_status();
					if (item !== null) dst.cal_status_(item);
					
				}
				
				dst.autosaved_(src.autosaved());
				
				dst.fitness_(src.fitness());
				
				dst.ofs_x_(src.ofs_x());
				
				dst.ofs_y_(src.ofs_y());
				
				dst.ofs_z_(src.ofs_z());
				
				dst.diag_x_(src.diag_x());
				
				dst.diag_y_(src.diag_y());
				
				dst.diag_z_(src.diag_z());
				
				dst.offdiag_x_(src.offdiag_x());
				
				dst.offdiag_y_(src.offdiag_y());
				
				dst.offdiag_z_(src.offdiag_z());
				
			}
			
			export interface SRC_ {
				compass_id(): number;
				
				cal_mask(): number;
				
				cal_status(): _Host.MAG_CAL_STATUS | null;
				
				autosaved(): number;
				
				fitness(): number;
				
				ofs_x(): number;
				
				ofs_y(): number;
				
				ofs_z(): number;
				
				diag_x(): number;
				
				diag_y(): number;
				
				diag_z(): number;
				
				offdiag_x(): number;
				
				offdiag_y(): number;
				
				offdiag_z(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: MAG_CAL_REPORT) {
				
				dst.compass_id_(src.compass_id());
				
				dst.cal_mask_(src.cal_mask());
				{
					const item = src.cal_status();
					if (item !== null) dst.cal_status_(item);
					
				}
				
				dst.autosaved_(src.autosaved());
				
				dst.fitness_(src.fitness());
				
				dst.ofs_x_(src.ofs_x());
				
				dst.ofs_y_(src.ofs_y());
				
				dst.ofs_z_(src.ofs_z());
				
				dst.diag_x_(src.diag_x());
				
				dst.diag_y_(src.diag_y());
				
				dst.diag_z_(src.diag_z());
				
				dst.offdiag_x_(src.offdiag_x());
				
				dst.offdiag_y_(src.offdiag_y());
				
				dst.offdiag_z_(src.offdiag_z());
				
			}
			
		}
		
		export interface LOG_REQUEST_LIST {
			start(): number;
			
			start_(src: number);
			
			end(): number;
			
			end_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
		}
		
		export namespace LOG_REQUEST_LIST {
			
			export const meta_ = new _Pack.Meta(37, 2, 0, 0, 6, 48);
			
			
			class Impl_ extends _Cursor.View implements LOG_REQUEST_LIST {
				
				public start(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public start_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public end(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public end_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				start_(src: number);
				
				end_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: LOG_REQUEST_LIST, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.start_(src.start());
				
				dst.end_(src.end());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				start(): number;
				
				end(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LOG_REQUEST_LIST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.start_(src.start());
				
				dst.end_(src.end());
				
			}
			
		}
		
		export interface SCALED_PRESSURE {
			time_boot_ms(): number;
			
			press_abs(): number;
			
			press_diff(): number;
			
			temperature(): number;
			
		}
		
		export namespace SCALED_PRESSURE {
			
			export const meta_ = new _Pack.Meta(18, 0, 1, 0, 14, 112);
			
			
			class Impl_ extends _Cursor.View implements SCALED_PRESSURE {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public press_abs(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				
				public press_diff(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public temperature(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				press_abs_(src: number);
				
				press_diff_(src: number);
				
				temperature_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SCALED_PRESSURE, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.press_abs_(src.press_abs());
				
				dst.press_diff_(src.press_diff());
				
				dst.temperature_(src.temperature());
				
			}
			
		}
		
		export interface V2_EXTENSION {
			message_type(): number;
			
			message_type_(src: number);
			
			target_network(): number;
			
			target_network_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			payload(): V2_EXTENSION.payload;
			
			payload_(src: V2_EXTENSION.payload | number[]);
			
			payload$(src: Iterator<number>, len: number);
			
		}
		
		export namespace V2_EXTENSION {
			
			export const meta_ = new _Pack.Meta(174, 1, 0, 0, 254, 2032);
			
			
			export interface payload extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace payload {
				export class Field extends _Cursor.View implements payload, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 5 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 5, other.data_.bytes.buffer, other.data_.origin + 5, _Host.V2_EXTENSION.payload.item_len) === 0;
						for (let i = 0; i < _Host.V2_EXTENSION.payload.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.V2_EXTENSION.payload.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 5 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 249;
				
			}
			
			
			class Impl_ extends _Cursor.View implements V2_EXTENSION {
				
				public message_type(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public message_type_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public target_network(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public target_network_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public payload(): V2_EXTENSION.payload {
					
					return this.data_.as_field(V2_EXTENSION.payload.field);
				}
				
				public payload_(src: V2_EXTENSION.payload | number[]): payload {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.V2_EXTENSION.payload.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 5 + index, src[index]);
						return this.data_.as_field(payload.field);
					}
					for (let index = 0; index < _Host.V2_EXTENSION.payload.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 5 + index, src.get(index));
					
					return this.data_.as_field(payload.field);
				}
				
				public payload$(src: Iterator<number>, len: number): payload {
					let len_ = Math.min(len, _Host.V2_EXTENSION.payload.item_len);
					
					len = Math.min(len, _Host.V2_EXTENSION.payload.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 5 + index, v.value);
						}
					return this.data_.as_field(payload.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_network_(src: number);
				
				target_system_(src: number);
				
				target_component_(src: number);
				
				message_type_(src: number);
				
				payload_(src: _Host.V2_EXTENSION.payload);
				
			}
			
			export function push_<DST extends DST_>(src: V2_EXTENSION, dst: DST) {
				
				dst.target_network_(src.target_network());
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.message_type_(src.message_type());
				dst.payload_(src.payload());
				
			}
			
			export interface SRC_ {
				target_network(): number;
				
				target_system(): number;
				
				target_component(): number;
				
				message_type(): number;
				
				payload(dst: _Host.V2_EXTENSION.payload);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: V2_EXTENSION) {
				
				dst.target_network_(src.target_network());
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.message_type_(src.message_type());
				src.payload(dst.payload());
				
			}
			
		}
		
		export interface HEARTBEAT {
			custom_mode(): number;
			
			mavlink_version(): number;
			
			typE(): MAV_TYPE | null;
			
			autopilot(): MAV_AUTOPILOT | null;
			
			base_mode(): MAV_MODE_FLAG | null;
			
			system_status(): MAV_STATE | null;
			
		}
		
		export namespace HEARTBEAT {
			
			export const meta_ = new _Pack.Meta(125, 0, 1, 0, 6, 42, 2, 4);
			
			
			class Impl_ extends _Cursor.View implements HEARTBEAT {
				
				public custom_mode(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public mavlink_version(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				
				public typE(): MAV_TYPE | null {
					if (this.data_.field_bit != 42 && !this.data_.set_field(42, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 5);
				}
				
				
				public autopilot(): MAV_AUTOPILOT | null {
					if (this.data_.field_bit != 43 && !this.data_.set_field(43, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 5);
				}
				
				
				public base_mode(): MAV_MODE_FLAG | null {
					if (this.data_.field_bit != 44 && !this.data_.set_field(44, -1)) return null;
					
					return _Host.MAV_MODE_FLAG_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 4));
				}
				
				
				public system_status(): MAV_STATE | null {
					if (this.data_.field_bit != 45 && !this.data_.set_field(45, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				typE_(src: _Host.MAV_TYPE);
				
				autopilot_(src: _Host.MAV_AUTOPILOT);
				
				base_mode_(src: _Host.MAV_MODE_FLAG);
				
				custom_mode_(src: number);
				
				system_status_(src: _Host.MAV_STATE);
				
				mavlink_version_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HEARTBEAT, dst: DST) {
				
				{
					const item = src.typE();
					if (item !== null) dst.typE_(item);
					
				}
				
				{
					const item = src.autopilot();
					if (item !== null) dst.autopilot_(item);
					
				}
				
				{
					const item = src.base_mode();
					if (item !== null) dst.base_mode_(item);
					
				}
				
				dst.custom_mode_(src.custom_mode());
				
				{
					const item = src.system_status();
					if (item !== null) dst.system_status_(item);
					
				}
				
				dst.mavlink_version_(src.mavlink_version());
				
			}
			
		}
		
		export interface PARAM_MAP_RC {
			target_system(): number;
			
			target_component(): number;
			
			param_index(): number;
			
			parameter_rc_channel_index(): number;
			
			param_value0(): number;
			
			scale(): number;
			
			param_value_min(): number;
			
			param_value_max(): number;
			
			param_id(): _Cursor.UTF8 | null;
			
		}
		
		export namespace PARAM_MAP_RC {
			
			export const meta_ = new _Pack.Meta(29, 0, 0, 0, 22, 170, 2, 1);
			
			
			export namespace param_id {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements PARAM_MAP_RC {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public param_index(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				public parameter_rc_channel_index(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				
				public param_value0(): number { return this.data_.bytes.getFloat32(this.data_.origin + 5, true);}
				
				
				public scale(): number { return this.data_.bytes.getFloat32(this.data_.origin + 9, true);}
				
				
				public param_value_min(): number { return this.data_.bytes.getFloat32(this.data_.origin + 13, true);}
				
				
				public param_value_max(): number { return this.data_.bytes.getFloat32(this.data_.origin + 17, true);}
				
				
				param_id(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 170 && !this.data_.set_field(170, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				param_id_(src: _Cursor.UTF8);
				
				param_index_(src: number);
				
				parameter_rc_channel_index_(src: number);
				
				param_value0_(src: number);
				
				scale_(src: number);
				
				param_value_min_(src: number);
				
				param_value_max_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: PARAM_MAP_RC, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
					
				}
				
				dst.param_index_(src.param_index());
				
				dst.parameter_rc_channel_index_(src.parameter_rc_channel_index());
				
				dst.param_value0_(src.param_value0());
				
				dst.scale_(src.scale());
				
				dst.param_value_min_(src.param_value_min());
				
				dst.param_value_max_(src.param_value_max());
				
			}
			
		}
		
		export interface POWER_STATUS {
			Vcc(): number;
			
			Vcc_(src: number);
			
			Vservo(): number;
			
			Vservo_(src: number);
			
			flags(): MAV_POWER_STATUS | null;
			
			flags_(src: MAV_POWER_STATUS);
			
		}
		
		export namespace POWER_STATUS {
			
			export const meta_ = new _Pack.Meta(156, 2, 0, 0, 5, 32, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements POWER_STATUS {
				
				public Vcc(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public Vcc_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public Vservo(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public Vservo_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				
				public flags(): MAV_POWER_STATUS | null {
					if (this.data_.field_bit != 32 && !this.data_.set_field(32, -1)) return null;
					
					return _Host.MAV_POWER_STATUS_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
				public flags_(src: MAV_POWER_STATUS) {
					if (this.data_.field_bit != 32) this.data_.set_field(32, 0);
					
					_Lib.set_bits(_Host.MAV_POWER_STATUS_.into(src), 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				Vcc_(src: number);
				
				Vservo_(src: number);
				
				flags_(src: _Host.MAV_POWER_STATUS);
				
			}
			
			export function push_<DST extends DST_>(src: POWER_STATUS, dst: DST) {
				
				dst.Vcc_(src.Vcc());
				
				dst.Vservo_(src.Vservo());
				
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
			}
			
			export interface SRC_ {
				Vcc(): number;
				
				Vservo(): number;
				
				flags(): _Host.MAV_POWER_STATUS | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: POWER_STATUS) {
				
				dst.Vcc_(src.Vcc());
				
				dst.Vservo_(src.Vservo());
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
			}
			
		}
		
		export interface REMOTE_LOG_DATA_BLOCK {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			daTa(): REMOTE_LOG_DATA_BLOCK.daTa;
			
			daTa_(src: REMOTE_LOG_DATA_BLOCK.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
			seqno(): MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS | null;
			
			seqno_(src: MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS);
			
		}
		
		export namespace REMOTE_LOG_DATA_BLOCK {
			
			export const meta_ = new _Pack.Meta(144, 0, 0, 0, 203, 1616, 0, 1);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 2 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 2, other.data_.bytes.buffer, other.data_.origin + 2, _Host.REMOTE_LOG_DATA_BLOCK.daTa.item_len) === 0;
						for (let i = 0; i < _Host.REMOTE_LOG_DATA_BLOCK.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.REMOTE_LOG_DATA_BLOCK.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 2 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 200;
				
			}
			
			
			class Impl_ extends _Cursor.View implements REMOTE_LOG_DATA_BLOCK {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public daTa(): REMOTE_LOG_DATA_BLOCK.daTa {
					
					return this.data_.as_field(REMOTE_LOG_DATA_BLOCK.daTa.field);
				}
				
				public daTa_(src: REMOTE_LOG_DATA_BLOCK.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.REMOTE_LOG_DATA_BLOCK.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.REMOTE_LOG_DATA_BLOCK.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 2 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.REMOTE_LOG_DATA_BLOCK.daTa.item_len);
					
					len = Math.min(len, _Host.REMOTE_LOG_DATA_BLOCK.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
				
				public seqno(): MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS | null {
					if (this.data_.field_bit != 1616 && !this.data_.set_field(1616, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 1);
				}
				
				
				public seqno_(src: MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS) {
					if (this.data_.field_bit != 1616) this.data_.set_field(1616, 0);
					
					_Lib.set_bits(src, 1, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				seqno_(src: _Host.MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS);
				
				daTa_(src: _Host.REMOTE_LOG_DATA_BLOCK.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: REMOTE_LOG_DATA_BLOCK, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.seqno();
					if (item !== null) dst.seqno_(item);
					
				}
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				seqno(): _Host.MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS | null;
				
				daTa(dst: _Host.REMOTE_LOG_DATA_BLOCK.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: REMOTE_LOG_DATA_BLOCK) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				{
					const item = src.seqno();
					if (item !== null) dst.seqno_(item);
					
				}
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface LOGGING_DATA_ACKED {
			sequence(): number;
			
			sequence_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			length(): number;
			
			length_(src: number);
			
			first_message_offset(): number;
			
			first_message_offset_(src: number);
			
			daTa(): LOGGING_DATA_ACKED.daTa;
			
			daTa_(src: LOGGING_DATA_ACKED.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace LOGGING_DATA_ACKED {
			
			export const meta_ = new _Pack.Meta(217, 1, 0, 0, 255, 2040);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 6 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 6, other.data_.bytes.buffer, other.data_.origin + 6, _Host.LOGGING_DATA_ACKED.daTa.item_len) === 0;
						for (let i = 0; i < _Host.LOGGING_DATA_ACKED.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.LOGGING_DATA_ACKED.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 6 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 249;
				
			}
			
			
			class Impl_ extends _Cursor.View implements LOGGING_DATA_ACKED {
				
				public sequence(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public sequence_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
				public length(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public length_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public first_message_offset(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public first_message_offset_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				public daTa(): LOGGING_DATA_ACKED.daTa {
					
					return this.data_.as_field(LOGGING_DATA_ACKED.daTa.field);
				}
				
				public daTa_(src: LOGGING_DATA_ACKED.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.LOGGING_DATA_ACKED.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 6 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.LOGGING_DATA_ACKED.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 6 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.LOGGING_DATA_ACKED.daTa.item_len);
					
					len = Math.min(len, _Host.LOGGING_DATA_ACKED.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 6 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				sequence_(src: number);
				
				length_(src: number);
				
				first_message_offset_(src: number);
				
				daTa_(src: _Host.LOGGING_DATA_ACKED.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: LOGGING_DATA_ACKED, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.sequence_(src.sequence());
				
				dst.length_(src.length());
				
				dst.first_message_offset_(src.first_message_offset());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				sequence(): number;
				
				length(): number;
				
				first_message_offset(): number;
				
				daTa(dst: _Host.LOGGING_DATA_ACKED.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LOGGING_DATA_ACKED) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.sequence_(src.sequence());
				
				dst.length_(src.length());
				
				dst.first_message_offset_(src.first_message_offset());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface TERRAIN_CHECK {
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
		}
		
		export namespace TERRAIN_CHECK {
			
			export const meta_ = new _Pack.Meta(152, 0, 0, 0, 8, 64);
			
			
			class Impl_ extends _Cursor.View implements TERRAIN_CHECK {
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				public lon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 4, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				lat_(src: number);
				
				lon_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: TERRAIN_CHECK, dst: DST) {
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
			}
			
			export interface SRC_ {
				lat(): number;
				
				lon(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: TERRAIN_CHECK) {
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
			}
			
		}
		
		export interface MOUNT_CONFIGURE {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			stab_roll(): number;
			
			stab_roll_(src: number);
			
			stab_pitch(): number;
			
			stab_pitch_(src: number);
			
			stab_yaw(): number;
			
			stab_yaw_(src: number);
			
			mount_mode(): MAV_MOUNT_MODE | null;
			
			mount_mode_(src: MAV_MOUNT_MODE);
			
		}
		
		export namespace MOUNT_CONFIGURE {
			
			export const meta_ = new _Pack.Meta(40, 0, 0, 0, 6, 40, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements MOUNT_CONFIGURE {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public stab_roll(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public stab_roll_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public stab_pitch(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public stab_pitch_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
				public stab_yaw(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public stab_yaw_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				
				public mount_mode(): MAV_MOUNT_MODE | null {
					if (this.data_.field_bit != 40 && !this.data_.set_field(40, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public mount_mode_(src: MAV_MOUNT_MODE) {
					if (this.data_.field_bit != 40) this.data_.set_field(40, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				mount_mode_(src: _Host.MAV_MOUNT_MODE);
				
				stab_roll_(src: number);
				
				stab_pitch_(src: number);
				
				stab_yaw_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MOUNT_CONFIGURE, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.mount_mode();
					if (item !== null) dst.mount_mode_(item);
					
				}
				
				dst.stab_roll_(src.stab_roll());
				
				dst.stab_pitch_(src.stab_pitch());
				
				dst.stab_yaw_(src.stab_yaw());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				mount_mode(): _Host.MAV_MOUNT_MODE | null;
				
				stab_roll(): number;
				
				stab_pitch(): number;
				
				stab_yaw(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: MOUNT_CONFIGURE) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				{
					const item = src.mount_mode();
					if (item !== null) dst.mount_mode_(item);
					
				}
				
				dst.stab_roll_(src.stab_roll());
				
				dst.stab_pitch_(src.stab_pitch());
				
				dst.stab_yaw_(src.stab_yaw());
				
			}
			
		}
		
		export interface MISSION_REQUEST_INT {
			seq(): number;
			
			target_system(): number;
			
			target_component(): number;
			
			mission_type(): MAV_MISSION_TYPE | null;
			
		}
		
		export namespace MISSION_REQUEST_INT {
			
			export const meta_ = new _Pack.Meta(188, 1, 0, 0, 5, 32, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements MISSION_REQUEST_INT {
				
				public seq(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				
				public mission_type(): MAV_MISSION_TYPE | null {
					if (this.data_.field_bit != 32 && !this.data_.set_field(32, -1)) return null;
					
					return _Host.MAV_MISSION_TYPE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				seq_(src: number);
				
				mission_type_(src: _Host.MAV_MISSION_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_REQUEST_INT, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.seq_(src.seq());
				
				{
					const item = src.mission_type();
					if (item !== null) dst.mission_type_(item);
					
				}
				
			}
			
		}
		
		export interface LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET {
			time_boot_ms(): number;
			
			x(): number;
			
			y(): number;
			
			z(): number;
			
			roll(): number;
			
			pitch(): number;
			
			yaw(): number;
			
		}
		
		export namespace LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET {
			
			export const meta_ = new _Pack.Meta(158, 0, 1, 0, 28, 224);
			
			
			class Impl_ extends _Cursor.View implements LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
			}
			
		}
		
		export interface COMMAND_ACK {
			command(): MAV_CMD | null;
			
			result(): MAV_RESULT | null;
			
			progress(): number | null;
			
			result_param2(): number | null;
			
			target_system(): number | null;
			
			target_component(): number | null;
			
		}
		
		export namespace COMMAND_ACK {
			
			export const meta_ = new _Pack.Meta(121, 0, 0, 0, 1, 2, 2, 6);
			
			
			class Impl_ extends _Cursor.View implements COMMAND_ACK {
				
				
				public command(): MAV_CMD | null {
					if (this.data_.field_bit != 2 && !this.data_.set_field(2, -1)) return null;
					
					return _Host.MAV_CMD_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 8));
				}
				
				
				public result(): MAV_RESULT | null {
					if (this.data_.field_bit != 3 && !this.data_.set_field(3, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public progress(): number | null {
					if (this.data_.field_bit != 4 && !this.data_.set_field(4, -1)) return null;
					
					return this.data_.bytes.getInt8(this.data_.BYTE);
				}
				
				
				public result_param2(): number | null {
					if (this.data_.field_bit != 5 && !this.data_.set_field(5, -1)) return null;
					
					return this.data_.bytes.getInt32(this.data_.BYTE, true);
				}
				
				
				public target_system(): number | null {
					if (this.data_.field_bit != 6 && !this.data_.set_field(6, -1)) return null;
					
					return this.data_.bytes.getInt8(this.data_.BYTE);
				}
				
				
				public target_component(): number | null {
					if (this.data_.field_bit != 7 && !this.data_.set_field(7, -1)) return null;
					
					return this.data_.bytes.getInt8(this.data_.BYTE);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				command_(src: _Host.MAV_CMD);
				
				result_(src: _Host.MAV_RESULT);
				
				progress_(src: number);
				
				result_param2_(src: number);
				
				target_system_(src: number);
				
				target_component_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: COMMAND_ACK, dst: DST) {
				
				{
					const item = src.command();
					if (item !== null) dst.command_(item);
					
				}
				
				{
					const item = src.result();
					if (item !== null) dst.result_(item);
					
				}
				
				{
					const item = src.progress();
					if (item !== null) dst.progress_(item);
					
				}
				
				{
					const item = src.result_param2();
					if (item !== null) dst.result_param2_(item);
					
				}
				
				{
					const item = src.target_system();
					if (item !== null) dst.target_system_(item);
					
				}
				
				{
					const item = src.target_component();
					if (item !== null) dst.target_component_(item);
					
				}
				
			}
			
		}
		
		export interface DATA_STREAM {
			message_rate(): number;
			
			stream_id(): number;
			
			on_off(): number;
			
		}
		
		export namespace DATA_STREAM {
			
			export const meta_ = new _Pack.Meta(31, 1, 0, 0, 4, 32);
			
			
			class Impl_ extends _Cursor.View implements DATA_STREAM {
				
				public message_rate(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public stream_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				public on_off(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				stream_id_(src: number);
				
				message_rate_(src: number);
				
				on_off_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: DATA_STREAM, dst: DST) {
				
				dst.stream_id_(src.stream_id());
				
				dst.message_rate_(src.message_rate());
				
				dst.on_off_(src.on_off());
				
			}
			
		}
		
		export interface MISSION_REQUEST {
			seq(): number;
			
			target_system(): number;
			
			target_component(): number;
			
			mission_type(): MAV_MISSION_TYPE | null;
			
		}
		
		export namespace MISSION_REQUEST {
			
			export const meta_ = new _Pack.Meta(147, 1, 0, 0, 5, 32, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements MISSION_REQUEST {
				
				public seq(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				
				public mission_type(): MAV_MISSION_TYPE | null {
					if (this.data_.field_bit != 32 && !this.data_.set_field(32, -1)) return null;
					
					return _Host.MAV_MISSION_TYPE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				seq_(src: number);
				
				mission_type_(src: _Host.MAV_MISSION_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_REQUEST, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.seq_(src.seq());
				
				{
					const item = src.mission_type();
					if (item !== null) dst.mission_type_(item);
					
				}
				
			}
			
		}
		
		export interface TERRAIN_REPORT {
			spacing(): number;
			
			spacing_(src: number);
			
			pending(): number;
			
			pending_(src: number);
			
			loaded(): number;
			
			loaded_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
			terrain_height(): number;
			
			terrain_height_(src: number);
			
			current_height(): number;
			
			current_height_(src: number);
			
		}
		
		export namespace TERRAIN_REPORT {
			
			export const meta_ = new _Pack.Meta(86, 3, 0, 0, 22, 176);
			
			
			class Impl_ extends _Cursor.View implements TERRAIN_REPORT {
				
				public spacing(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public spacing_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public pending(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public pending_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public loaded(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public loaded_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public lon(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public lon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
				public terrain_height(): number { return this.data_.bytes.getFloat32(this.data_.origin + 14, true);}
				
				public terrain_height_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 14, src, true); }
				
				public current_height(): number { return this.data_.bytes.getFloat32(this.data_.origin + 18, true);}
				
				public current_height_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 18, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				lat_(src: number);
				
				lon_(src: number);
				
				spacing_(src: number);
				
				terrain_height_(src: number);
				
				current_height_(src: number);
				
				pending_(src: number);
				
				loaded_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: TERRAIN_REPORT, dst: DST) {
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.spacing_(src.spacing());
				
				dst.terrain_height_(src.terrain_height());
				
				dst.current_height_(src.current_height());
				
				dst.pending_(src.pending());
				
				dst.loaded_(src.loaded());
				
			}
			
			export interface SRC_ {
				lat(): number;
				
				lon(): number;
				
				spacing(): number;
				
				terrain_height(): number;
				
				current_height(): number;
				
				pending(): number;
				
				loaded(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: TERRAIN_REPORT) {
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.spacing_(src.spacing());
				
				dst.terrain_height_(src.terrain_height());
				
				dst.current_height_(src.current_height());
				
				dst.pending_(src.pending());
				
				dst.loaded_(src.loaded());
				
			}
			
		}
		
		export interface SET_HOME_POSITION {
			target_system(): number;
			
			target_system_(src: number);
			
			latitude(): number;
			
			latitude_(src: number);
			
			longitude(): number;
			
			longitude_(src: number);
			
			altitude(): number;
			
			altitude_(src: number);
			
			x(): number;
			
			x_(src: number);
			
			y(): number;
			
			y_(src: number);
			
			z(): number;
			
			z_(src: number);
			
			q(): SET_HOME_POSITION.q;
			
			q_(src: SET_HOME_POSITION.q | number[]);
			
			q$(src: Iterator<number>, len: number);
			
			approach_x(): number;
			
			approach_x_(src: number);
			
			approach_y(): number;
			
			approach_y_(src: number);
			
			approach_z(): number;
			
			approach_z_(src: number);
			
			time_usec(): number | null;
			
			time_usec_(src: number);
			
		}
		
		export namespace SET_HOME_POSITION {
			
			export const meta_ = new _Pack.Meta(77, 0, 0, 0, 54, 424, 0, 1);
			
			
			export interface q extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace q {
				export class Field extends _Cursor.View implements q, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 25 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 25, other.data_.bytes.buffer, other.data_.origin + 25, _Host.SET_HOME_POSITION.q.item_len) === 0;
						for (let i = 0; i < _Host.SET_HOME_POSITION.q.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.SET_HOME_POSITION.q.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 25 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			
			
			class Impl_ extends _Cursor.View implements SET_HOME_POSITION {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public latitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 1, true);}
				
				public latitude_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 1, src, true); }
				
				public longitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 5, true);}
				
				public longitude_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 5, src, true); }
				
				public altitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 9, true);}
				
				public altitude_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 9, src, true); }
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 13, true);}
				
				public x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 13, src, true); }
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 17, true);}
				
				public y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 17, src, true); }
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 21, true);}
				
				public z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 21, src, true); }
				
				public q(): SET_HOME_POSITION.q {
					
					return this.data_.as_field(SET_HOME_POSITION.q.field);
				}
				
				public q_(src: SET_HOME_POSITION.q | number[]): q {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.SET_HOME_POSITION.q.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 25 + index * 4, src[index], true);
						return this.data_.as_field(q.field);
					}
					for (let index = 0; index < _Host.SET_HOME_POSITION.q.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 25 + index * 4, src.get(index), true);
					
					return this.data_.as_field(q.field);
				}
				
				public q$(src: Iterator<number>, len: number): q {
					let len_ = Math.min(len, _Host.SET_HOME_POSITION.q.item_len);
					
					len = Math.min(len, _Host.SET_HOME_POSITION.q.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 25 + index * 4, v.value, true);
						}
					return this.data_.as_field(q.field);
				}
				
				public approach_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 41, true);}
				
				public approach_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 41, src, true); }
				
				public approach_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 45, true);}
				
				public approach_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 45, src, true); }
				
				public approach_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 49, true);}
				
				public approach_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 49, src, true); }
				
				
				public time_usec(): number | null {
					if (this.data_.field_bit != 424 && !this.data_.set_field(424, -1)) return null;
					
					return this.data_.bytes.getUint32(this.data_.BYTE, true) + this.data_.bytes.getInt32(this.data_.BYTE + 4, true) * _Lib.JS_HI;
				}
				
				
				public time_usec_(src: number) {
					if (this.data_.field_bit != 424) this.data_.set_field(424, 0);
					
					this.data_.bytes.setUint32(this.data_.BYTE, src, true);
					this.data_.bytes.setUint32(this.data_.BYTE + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				latitude_(src: number);
				
				longitude_(src: number);
				
				altitude_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				q_(src: _Host.SET_HOME_POSITION.q);
				
				approach_x_(src: number);
				
				approach_y_(src: number);
				
				approach_z_(src: number);
				
				time_usec_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SET_HOME_POSITION, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.latitude_(src.latitude());
				
				dst.longitude_(src.longitude());
				
				dst.altitude_(src.altitude());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				dst.q_(src.q());
				
				dst.approach_x_(src.approach_x());
				
				dst.approach_y_(src.approach_y());
				
				dst.approach_z_(src.approach_z());
				
				{
					const item = src.time_usec();
					if (item !== null) dst.time_usec_(item);
					
				}
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				latitude(): number;
				
				longitude(): number;
				
				altitude(): number;
				
				x(): number;
				
				y(): number;
				
				z(): number;
				
				q(dst: _Host.SET_HOME_POSITION.q);
				
				approach_x(): number;
				
				approach_y(): number;
				
				approach_z(): number;
				
				time_usec(): number | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SET_HOME_POSITION) {
				
				dst.target_system_(src.target_system());
				
				dst.latitude_(src.latitude());
				
				dst.longitude_(src.longitude());
				
				dst.altitude_(src.altitude());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				src.q(dst.q());
				
				dst.approach_x_(src.approach_x());
				
				dst.approach_y_(src.approach_y());
				
				dst.approach_z_(src.approach_z());
				{
					const item = src.time_usec();
					if (item !== null) dst.time_usec_(item);
					
				}
				
			}
			
		}
		export namespace SwitchModeCommand {
			export const pack_ = new _Pack(new _Pack.Meta(28));
		}
		
		export interface HIL_RC_INPUTS_RAW {
			chan1_raw(): number;
			
			chan2_raw(): number;
			
			chan3_raw(): number;
			
			chan4_raw(): number;
			
			chan5_raw(): number;
			
			chan6_raw(): number;
			
			chan7_raw(): number;
			
			chan8_raw(): number;
			
			chan9_raw(): number;
			
			chan10_raw(): number;
			
			chan11_raw(): number;
			
			chan12_raw(): number;
			
			time_usec(): number;
			
			rssi(): number;
			
		}
		
		export namespace HIL_RC_INPUTS_RAW {
			
			export const meta_ = new _Pack.Meta(184, 12, 0, 1, 33, 264);
			
			
			class Impl_ extends _Cursor.View implements HIL_RC_INPUTS_RAW {
				
				public chan1_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public chan2_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				public chan3_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				
				public chan4_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				
				public chan5_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				
				public chan6_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				
				public chan7_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				
				public chan8_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				
				public chan9_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 16, true);}
				
				
				public chan10_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 18, true);}
				
				
				public chan11_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 20, true);}
				
				
				public chan12_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 22, true);}
				
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 24, true) + this.data_.bytes.getInt32(this.data_.origin + 24 + 4, true) * _Lib.JS_HI;}
				
				
				public rssi(): number { return this.data_.bytes.getInt8(this.data_.origin + 32);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				chan1_raw_(src: number);
				
				chan2_raw_(src: number);
				
				chan3_raw_(src: number);
				
				chan4_raw_(src: number);
				
				chan5_raw_(src: number);
				
				chan6_raw_(src: number);
				
				chan7_raw_(src: number);
				
				chan8_raw_(src: number);
				
				chan9_raw_(src: number);
				
				chan10_raw_(src: number);
				
				chan11_raw_(src: number);
				
				chan12_raw_(src: number);
				
				rssi_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HIL_RC_INPUTS_RAW, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.chan1_raw_(src.chan1_raw());
				
				dst.chan2_raw_(src.chan2_raw());
				
				dst.chan3_raw_(src.chan3_raw());
				
				dst.chan4_raw_(src.chan4_raw());
				
				dst.chan5_raw_(src.chan5_raw());
				
				dst.chan6_raw_(src.chan6_raw());
				
				dst.chan7_raw_(src.chan7_raw());
				
				dst.chan8_raw_(src.chan8_raw());
				
				dst.chan9_raw_(src.chan9_raw());
				
				dst.chan10_raw_(src.chan10_raw());
				
				dst.chan11_raw_(src.chan11_raw());
				
				dst.chan12_raw_(src.chan12_raw());
				
				dst.rssi_(src.rssi());
				
			}
			
		}
		
		export interface SCALED_IMU3 {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			xacc(): number;
			
			xacc_(src: number);
			
			yacc(): number;
			
			yacc_(src: number);
			
			zacc(): number;
			
			zacc_(src: number);
			
			xgyro(): number;
			
			xgyro_(src: number);
			
			ygyro(): number;
			
			ygyro_(src: number);
			
			zgyro(): number;
			
			zgyro_(src: number);
			
			xmag(): number;
			
			xmag_(src: number);
			
			ymag(): number;
			
			ymag_(src: number);
			
			zmag(): number;
			
			zmag_(src: number);
			
		}
		
		export namespace SCALED_IMU3 {
			
			export const meta_ = new _Pack.Meta(2, 0, 1, 0, 22, 176);
			
			
			class Impl_ extends _Cursor.View implements SCALED_IMU3 {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public xacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public xacc_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public yacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				public yacc_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 6, src, true); }
				
				public zacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				public zacc_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 8, src, true); }
				
				public xgyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				public xgyro_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 10, src, true); }
				
				public ygyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				public ygyro_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 12, src, true); }
				
				public zgyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				public zgyro_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 14, src, true); }
				
				public xmag(): number { return this.data_.bytes.getInt16(this.data_.origin + 16, true);}
				
				public xmag_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 16, src, true); }
				
				public ymag(): number { return this.data_.bytes.getInt16(this.data_.origin + 18, true);}
				
				public ymag_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 18, src, true); }
				
				public zmag(): number { return this.data_.bytes.getInt16(this.data_.origin + 20, true);}
				
				public zmag_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 20, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				xacc_(src: number);
				
				yacc_(src: number);
				
				zacc_(src: number);
				
				xgyro_(src: number);
				
				ygyro_(src: number);
				
				zgyro_(src: number);
				
				xmag_(src: number);
				
				ymag_(src: number);
				
				zmag_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SCALED_IMU3, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.xmag_(src.xmag());
				
				dst.ymag_(src.ymag());
				
				dst.zmag_(src.zmag());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				xacc(): number;
				
				yacc(): number;
				
				zacc(): number;
				
				xgyro(): number;
				
				ygyro(): number;
				
				zgyro(): number;
				
				xmag(): number;
				
				ymag(): number;
				
				zmag(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SCALED_IMU3) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.xmag_(src.xmag());
				
				dst.ymag_(src.ymag());
				
				dst.zmag_(src.zmag());
				
			}
			
		}
		
		export interface SET_MODE {
			custom_mode(): number;
			
			target_system(): number;
			
			base_mode(): MAV_MODE | null;
			
		}
		
		export namespace SET_MODE {
			
			export const meta_ = new _Pack.Meta(7, 0, 1, 0, 6, 40, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements SET_MODE {
				
				public custom_mode(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				
				public base_mode(): MAV_MODE | null {
					if (this.data_.field_bit != 40 && !this.data_.set_field(40, -1)) return null;
					
					return _Host.MAV_MODE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 4));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				base_mode_(src: _Host.MAV_MODE);
				
				custom_mode_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SET_MODE, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				{
					const item = src.base_mode();
					if (item !== null) dst.base_mode_(item);
					
				}
				
				dst.custom_mode_(src.custom_mode());
				
			}
			
		}
		
		export interface MOUNT_CONTROL {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			input_a(): number;
			
			input_a_(src: number);
			
			input_b(): number;
			
			input_b_(src: number);
			
			input_c(): number;
			
			input_c_(src: number);
			
			save_position(): number;
			
			save_position_(src: number);
			
		}
		
		export namespace MOUNT_CONTROL {
			
			export const meta_ = new _Pack.Meta(113, 0, 0, 0, 15, 120);
			
			
			class Impl_ extends _Cursor.View implements MOUNT_CONTROL {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public input_a(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public input_a_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public input_b(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public input_b_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public input_c(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public input_c_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
				public save_position(): number { return this.data_.bytes.getInt8(this.data_.origin + 14);}
				
				public save_position_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 14, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				input_a_(src: number);
				
				input_b_(src: number);
				
				input_c_(src: number);
				
				save_position_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MOUNT_CONTROL, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.input_a_(src.input_a());
				
				dst.input_b_(src.input_b());
				
				dst.input_c_(src.input_c());
				
				dst.save_position_(src.save_position());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				input_a(): number;
				
				input_b(): number;
				
				input_c(): number;
				
				save_position(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: MOUNT_CONTROL) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.input_a_(src.input_a());
				
				dst.input_b_(src.input_b());
				
				dst.input_c_(src.input_c());
				
				dst.save_position_(src.save_position());
				
			}
			
		}
		
		export interface POSITION_TARGET_GLOBAL_INT {
			type_mask(): number;
			
			time_boot_ms(): number;
			
			lat_int(): number;
			
			lon_int(): number;
			
			alt(): number;
			
			vx(): number;
			
			vy(): number;
			
			vz(): number;
			
			afx(): number;
			
			afy(): number;
			
			afz(): number;
			
			yaw(): number;
			
			yaw_rate(): number;
			
			coordinate_frame(): MAV_FRAME | null;
			
		}
		
		export namespace POSITION_TARGET_GLOBAL_INT {
			
			export const meta_ = new _Pack.Meta(133, 1, 1, 0, 51, 400, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements POSITION_TARGET_GLOBAL_INT {
				
				public type_mask(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				
				public lat_int(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				
				public lon_int(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				
				public alt(): number { return this.data_.bytes.getFloat32(this.data_.origin + 14, true);}
				
				
				public vx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 18, true);}
				
				
				public vy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 22, true);}
				
				
				public vz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 26, true);}
				
				
				public afx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 30, true);}
				
				
				public afy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 34, true);}
				
				
				public afz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 38, true);}
				
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 42, true);}
				
				
				public yaw_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 46, true);}
				
				
				public coordinate_frame(): MAV_FRAME | null {
					if (this.data_.field_bit != 400 && !this.data_.set_field(400, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				coordinate_frame_(src: _Host.MAV_FRAME);
				
				type_mask_(src: number);
				
				lat_int_(src: number);
				
				lon_int_(src: number);
				
				alt_(src: number);
				
				vx_(src: number);
				
				vy_(src: number);
				
				vz_(src: number);
				
				afx_(src: number);
				
				afy_(src: number);
				
				afz_(src: number);
				
				yaw_(src: number);
				
				yaw_rate_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: POSITION_TARGET_GLOBAL_INT, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				{
					const item = src.coordinate_frame();
					if (item !== null) dst.coordinate_frame_(item);
					
				}
				
				dst.type_mask_(src.type_mask());
				
				dst.lat_int_(src.lat_int());
				
				dst.lon_int_(src.lon_int());
				
				dst.alt_(src.alt());
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
				dst.afx_(src.afx());
				
				dst.afy_(src.afy());
				
				dst.afz_(src.afz());
				
				dst.yaw_(src.yaw());
				
				dst.yaw_rate_(src.yaw_rate());
				
			}
			
		}
		
		export interface LED_CONTROL {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			instance(): number;
			
			instance_(src: number);
			
			pattern(): number;
			
			pattern_(src: number);
			
			custom_len(): number;
			
			custom_len_(src: number);
			
			custom_bytes(): LED_CONTROL.custom_bytes;
			
			custom_bytes_(src: LED_CONTROL.custom_bytes | number[]);
			
			custom_bytes$(src: Iterator<number>, len: number);
			
		}
		
		export namespace LED_CONTROL {
			
			export const meta_ = new _Pack.Meta(177, 0, 0, 0, 29, 232);
			
			
			export interface custom_bytes extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace custom_bytes {
				export class Field extends _Cursor.View implements custom_bytes, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 5 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 5, other.data_.bytes.buffer, other.data_.origin + 5, _Host.LED_CONTROL.custom_bytes.item_len) === 0;
						for (let i = 0; i < _Host.LED_CONTROL.custom_bytes.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.LED_CONTROL.custom_bytes.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 5 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 24;
				
			}
			
			
			class Impl_ extends _Cursor.View implements LED_CONTROL {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public instance(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public instance_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public pattern(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public pattern_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
				public custom_len(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public custom_len_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public custom_bytes(): LED_CONTROL.custom_bytes {
					
					return this.data_.as_field(LED_CONTROL.custom_bytes.field);
				}
				
				public custom_bytes_(src: LED_CONTROL.custom_bytes | number[]): custom_bytes {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.LED_CONTROL.custom_bytes.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 5 + index, src[index]);
						return this.data_.as_field(custom_bytes.field);
					}
					for (let index = 0; index < _Host.LED_CONTROL.custom_bytes.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 5 + index, src.get(index));
					
					return this.data_.as_field(custom_bytes.field);
				}
				
				public custom_bytes$(src: Iterator<number>, len: number): custom_bytes {
					let len_ = Math.min(len, _Host.LED_CONTROL.custom_bytes.item_len);
					
					len = Math.min(len, _Host.LED_CONTROL.custom_bytes.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 5 + index, v.value);
						}
					return this.data_.as_field(custom_bytes.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				instance_(src: number);
				
				pattern_(src: number);
				
				custom_len_(src: number);
				
				custom_bytes_(src: _Host.LED_CONTROL.custom_bytes);
				
			}
			
			export function push_<DST extends DST_>(src: LED_CONTROL, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.instance_(src.instance());
				
				dst.pattern_(src.pattern());
				
				dst.custom_len_(src.custom_len());
				dst.custom_bytes_(src.custom_bytes());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				instance(): number;
				
				pattern(): number;
				
				custom_len(): number;
				
				custom_bytes(dst: _Host.LED_CONTROL.custom_bytes);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LED_CONTROL) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.instance_(src.instance());
				
				dst.pattern_(src.pattern());
				
				dst.custom_len_(src.custom_len());
				src.custom_bytes(dst.custom_bytes());
				
			}
			
		}
		
		export interface SIM_STATE {
			q1(): number;
			
			q1_(src: number);
			
			q2(): number;
			
			q2_(src: number);
			
			q3(): number;
			
			q3_(src: number);
			
			q4(): number;
			
			q4_(src: number);
			
			roll(): number;
			
			roll_(src: number);
			
			pitch(): number;
			
			pitch_(src: number);
			
			yaw(): number;
			
			yaw_(src: number);
			
			xacc(): number;
			
			xacc_(src: number);
			
			yacc(): number;
			
			yacc_(src: number);
			
			zacc(): number;
			
			zacc_(src: number);
			
			xgyro(): number;
			
			xgyro_(src: number);
			
			ygyro(): number;
			
			ygyro_(src: number);
			
			zgyro(): number;
			
			zgyro_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lon(): number;
			
			lon_(src: number);
			
			alt(): number;
			
			alt_(src: number);
			
			std_dev_horz(): number;
			
			std_dev_horz_(src: number);
			
			std_dev_vert(): number;
			
			std_dev_vert_(src: number);
			
			vn(): number;
			
			vn_(src: number);
			
			ve(): number;
			
			ve_(src: number);
			
			vd(): number;
			
			vd_(src: number);
			
		}
		
		export namespace SIM_STATE {
			
			export const meta_ = new _Pack.Meta(108, 0, 0, 0, 84, 672);
			
			
			class Impl_ extends _Cursor.View implements SIM_STATE {
				
				public q1(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public q1_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public q2(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public q2_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public q3(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public q3_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public q4(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public q4_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public roll_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public pitch_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public yaw_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public xacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public xacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public yacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public yacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public zacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				public zacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 36, src, true); }
				
				public xgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				public xgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 40, src, true); }
				
				public ygyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 44, true);}
				
				public ygyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 44, src, true); }
				
				public zgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 48, true);}
				
				public zgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 48, src, true); }
				
				public lat(): number { return this.data_.bytes.getFloat32(this.data_.origin + 52, true);}
				
				public lat_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 52, src, true); }
				
				public lon(): number { return this.data_.bytes.getFloat32(this.data_.origin + 56, true);}
				
				public lon_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 56, src, true); }
				
				public alt(): number { return this.data_.bytes.getFloat32(this.data_.origin + 60, true);}
				
				public alt_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 60, src, true); }
				
				public std_dev_horz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 64, true);}
				
				public std_dev_horz_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 64, src, true); }
				
				public std_dev_vert(): number { return this.data_.bytes.getFloat32(this.data_.origin + 68, true);}
				
				public std_dev_vert_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 68, src, true); }
				
				public vn(): number { return this.data_.bytes.getFloat32(this.data_.origin + 72, true);}
				
				public vn_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 72, src, true); }
				
				public ve(): number { return this.data_.bytes.getFloat32(this.data_.origin + 76, true);}
				
				public ve_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 76, src, true); }
				
				public vd(): number { return this.data_.bytes.getFloat32(this.data_.origin + 80, true);}
				
				public vd_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 80, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				q1_(src: number);
				
				q2_(src: number);
				
				q3_(src: number);
				
				q4_(src: number);
				
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
				xacc_(src: number);
				
				yacc_(src: number);
				
				zacc_(src: number);
				
				xgyro_(src: number);
				
				ygyro_(src: number);
				
				zgyro_(src: number);
				
				lat_(src: number);
				
				lon_(src: number);
				
				alt_(src: number);
				
				std_dev_horz_(src: number);
				
				std_dev_vert_(src: number);
				
				vn_(src: number);
				
				ve_(src: number);
				
				vd_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SIM_STATE, dst: DST) {
				
				dst.q1_(src.q1());
				
				dst.q2_(src.q2());
				
				dst.q3_(src.q3());
				
				dst.q4_(src.q4());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.std_dev_horz_(src.std_dev_horz());
				
				dst.std_dev_vert_(src.std_dev_vert());
				
				dst.vn_(src.vn());
				
				dst.ve_(src.ve());
				
				dst.vd_(src.vd());
				
			}
			
			export interface SRC_ {
				q1(): number;
				
				q2(): number;
				
				q3(): number;
				
				q4(): number;
				
				roll(): number;
				
				pitch(): number;
				
				yaw(): number;
				
				xacc(): number;
				
				yacc(): number;
				
				zacc(): number;
				
				xgyro(): number;
				
				ygyro(): number;
				
				zgyro(): number;
				
				lat(): number;
				
				lon(): number;
				
				alt(): number;
				
				std_dev_horz(): number;
				
				std_dev_vert(): number;
				
				vn(): number;
				
				ve(): number;
				
				vd(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SIM_STATE) {
				
				dst.q1_(src.q1());
				
				dst.q2_(src.q2());
				
				dst.q3_(src.q3());
				
				dst.q4_(src.q4());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.lat_(src.lat());
				
				dst.lon_(src.lon());
				
				dst.alt_(src.alt());
				
				dst.std_dev_horz_(src.std_dev_horz());
				
				dst.std_dev_vert_(src.std_dev_vert());
				
				dst.vn_(src.vn());
				
				dst.ve_(src.ve());
				
				dst.vd_(src.vd());
				
			}
			
		}
		
		export interface WIFI_CONFIG_AP {
			ssid(): _Cursor.UTF8 | null;
			
			ssid_(src: string | Uint8Array): _Cursor.UTF8;
			
			ssid$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
			password(): _Cursor.UTF8 | null;
			
			password_(src: string | Uint8Array): _Cursor.UTF8;
			
			password$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace WIFI_CONFIG_AP {
			
			export const meta_ = new _Pack.Meta(194, 0, 0, 0, 1, 2, 2, 2);
			
			
			export namespace ssid {
				export const item_len_max = 255;
				
			}
			export namespace password {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements WIFI_CONFIG_AP {
				
				
				ssid(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 2 && !this.data_.set_field(2, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				ssid_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -2 - 1);
					
					let len = Math.min(src.byteLength, _Host.WIFI_CONFIG_AP.ssid.item_len_max);
					this.data_.set_field(2, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				ssid$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.WIFI_CONFIG_AP.ssid.item_len_max)
					this.data_.set_field(2, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
				password(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 3 && !this.data_.set_field(3, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				password_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -3 - 1);
					
					let len = Math.min(src.byteLength, _Host.WIFI_CONFIG_AP.password.item_len_max);
					this.data_.set_field(3, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				password$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.WIFI_CONFIG_AP.password.item_len_max)
					this.data_.set_field(3, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				ssid_(src: _Cursor.UTF8);
				
				password_(src: _Cursor.UTF8);
				
			}
			
			export function push_<DST extends DST_>(src: WIFI_CONFIG_AP, dst: DST) {
				
				{
					const item = src.ssid();
					if (item !== null) dst.ssid_(item);
					
				}
				
				{
					const item = src.password();
					if (item !== null) dst.password_(item);
					
				}
				
			}
			
			export interface SRC_ {
				ssid(): string | Uint8Array | null;
				
				password(): string | Uint8Array | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: WIFI_CONFIG_AP) {
				
				
				{
					const item = src.ssid();
					if (item !== null) dst.ssid_(item);
				}
				
				
				{
					const item = src.password();
					if (item !== null) dst.password_(item);
				}
				
				
			}
			
		}
		
		export interface DATA96 {
			typE(): number;
			
			typE_(src: number);
			
			len(): number;
			
			len_(src: number);
			
			daTa(): DATA96.daTa;
			
			daTa_(src: DATA96.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace DATA96 {
			
			export const meta_ = new _Pack.Meta(83, 0, 0, 0, 98, 784);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 2 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 2, other.data_.bytes.buffer, other.data_.origin + 2, _Host.DATA96.daTa.item_len) === 0;
						for (let i = 0; i < _Host.DATA96.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.DATA96.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 2 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 96;
				
			}
			
			
			class Impl_ extends _Cursor.View implements DATA96 {
				
				public typE(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public typE_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public len(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public len_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public daTa(): DATA96.daTa {
					
					return this.data_.as_field(DATA96.daTa.field);
				}
				
				public daTa_(src: DATA96.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.DATA96.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.DATA96.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 2 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.DATA96.daTa.item_len);
					
					len = Math.min(len, _Host.DATA96.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				typE_(src: number);
				
				len_(src: number);
				
				daTa_(src: _Host.DATA96.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: DATA96, dst: DST) {
				
				dst.typE_(src.typE());
				
				dst.len_(src.len());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				typE(): number;
				
				len(): number;
				
				daTa(dst: _Host.DATA96.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DATA96) {
				
				dst.typE_(src.typE());
				
				dst.len_(src.len());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface FLIGHT_INFORMATION {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			arming_time_utc(): number;
			
			arming_time_utc_(src: number);
			
			takeoff_time_utc(): number;
			
			takeoff_time_utc_(src: number);
			
			flight_uuid(): number;
			
			flight_uuid_(src: number);
			
		}
		
		export namespace FLIGHT_INFORMATION {
			
			export const meta_ = new _Pack.Meta(215, 0, 1, 3, 28, 224);
			
			
			class Impl_ extends _Cursor.View implements FLIGHT_INFORMATION {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public arming_time_utc(): number { return this.data_.bytes.getUint32(this.data_.origin + 4, true) + this.data_.bytes.getInt32(this.data_.origin + 4 + 4, true) * _Lib.JS_HI;}
				
				public arming_time_utc_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 4, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 4 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public takeoff_time_utc(): number { return this.data_.bytes.getUint32(this.data_.origin + 12, true) + this.data_.bytes.getInt32(this.data_.origin + 12 + 4, true) * _Lib.JS_HI;}
				
				public takeoff_time_utc_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 12, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 12 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public flight_uuid(): number { return this.data_.bytes.getUint32(this.data_.origin + 20, true) + this.data_.bytes.getInt32(this.data_.origin + 20 + 4, true) * _Lib.JS_HI;}
				
				public flight_uuid_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 20, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 20 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				arming_time_utc_(src: number);
				
				takeoff_time_utc_(src: number);
				
				flight_uuid_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: FLIGHT_INFORMATION, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.arming_time_utc_(src.arming_time_utc());
				
				dst.takeoff_time_utc_(src.takeoff_time_utc());
				
				dst.flight_uuid_(src.flight_uuid());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				arming_time_utc(): number;
				
				takeoff_time_utc(): number;
				
				flight_uuid(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: FLIGHT_INFORMATION) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.arming_time_utc_(src.arming_time_utc());
				
				dst.takeoff_time_utc_(src.takeoff_time_utc());
				
				dst.flight_uuid_(src.flight_uuid());
				
			}
			
		}
		
		export interface RC_CHANNELS_RAW {
			chan1_raw(): number;
			
			chan2_raw(): number;
			
			chan3_raw(): number;
			
			chan4_raw(): number;
			
			chan5_raw(): number;
			
			chan6_raw(): number;
			
			chan7_raw(): number;
			
			chan8_raw(): number;
			
			time_boot_ms(): number;
			
			port(): number;
			
			rssi(): number;
			
		}
		
		export namespace RC_CHANNELS_RAW {
			
			export const meta_ = new _Pack.Meta(148, 8, 1, 0, 22, 176);
			
			
			class Impl_ extends _Cursor.View implements RC_CHANNELS_RAW {
				
				public chan1_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public chan2_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				public chan3_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				
				public chan4_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				
				public chan5_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				
				public chan6_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				
				public chan7_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				
				public chan8_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 16, true);}
				
				
				public port(): number { return this.data_.bytes.getInt8(this.data_.origin + 20);}
				
				
				public rssi(): number { return this.data_.bytes.getInt8(this.data_.origin + 21);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				port_(src: number);
				
				chan1_raw_(src: number);
				
				chan2_raw_(src: number);
				
				chan3_raw_(src: number);
				
				chan4_raw_(src: number);
				
				chan5_raw_(src: number);
				
				chan6_raw_(src: number);
				
				chan7_raw_(src: number);
				
				chan8_raw_(src: number);
				
				rssi_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: RC_CHANNELS_RAW, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.port_(src.port());
				
				dst.chan1_raw_(src.chan1_raw());
				
				dst.chan2_raw_(src.chan2_raw());
				
				dst.chan3_raw_(src.chan3_raw());
				
				dst.chan4_raw_(src.chan4_raw());
				
				dst.chan5_raw_(src.chan5_raw());
				
				dst.chan6_raw_(src.chan6_raw());
				
				dst.chan7_raw_(src.chan7_raw());
				
				dst.chan8_raw_(src.chan8_raw());
				
				dst.rssi_(src.rssi());
				
			}
			
		}
		
		export interface SERVO_OUTPUT_RAW {
			servo1_raw(): number;
			
			servo2_raw(): number;
			
			servo3_raw(): number;
			
			servo4_raw(): number;
			
			servo5_raw(): number;
			
			servo6_raw(): number;
			
			servo7_raw(): number;
			
			servo8_raw(): number;
			
			time_usec(): number;
			
			port(): number;
			
			servo9_raw(): number | null;
			
			servo10_raw(): number | null;
			
			servo11_raw(): number | null;
			
			servo12_raw(): number | null;
			
			servo13_raw(): number | null;
			
			servo14_raw(): number | null;
			
			servo15_raw(): number | null;
			
			servo16_raw(): number | null;
			
		}
		
		export namespace SERVO_OUTPUT_RAW {
			
			export const meta_ = new _Pack.Meta(79, 8, 1, 0, 22, 168, 0, 8);
			
			
			class Impl_ extends _Cursor.View implements SERVO_OUTPUT_RAW {
				
				public servo1_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public servo2_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				public servo3_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				
				public servo4_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				
				public servo5_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				
				public servo6_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				
				public servo7_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				
				public servo8_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				
				public time_usec(): number { return this.data_.bytes.getInt32(this.data_.origin + 16, true);}
				
				
				public port(): number { return this.data_.bytes.getInt8(this.data_.origin + 20);}
				
				
				public servo9_raw(): number | null {
					if (this.data_.field_bit != 168 && !this.data_.set_field(168, -1)) return null;
					
					return this.data_.bytes.getInt16(this.data_.BYTE, true);
				}
				
				
				public servo10_raw(): number | null {
					if (this.data_.field_bit != 169 && !this.data_.set_field(169, -1)) return null;
					
					return this.data_.bytes.getInt16(this.data_.BYTE, true);
				}
				
				
				public servo11_raw(): number | null {
					if (this.data_.field_bit != 170 && !this.data_.set_field(170, -1)) return null;
					
					return this.data_.bytes.getInt16(this.data_.BYTE, true);
				}
				
				
				public servo12_raw(): number | null {
					if (this.data_.field_bit != 171 && !this.data_.set_field(171, -1)) return null;
					
					return this.data_.bytes.getInt16(this.data_.BYTE, true);
				}
				
				
				public servo13_raw(): number | null {
					if (this.data_.field_bit != 172 && !this.data_.set_field(172, -1)) return null;
					
					return this.data_.bytes.getInt16(this.data_.BYTE, true);
				}
				
				
				public servo14_raw(): number | null {
					if (this.data_.field_bit != 173 && !this.data_.set_field(173, -1)) return null;
					
					return this.data_.bytes.getInt16(this.data_.BYTE, true);
				}
				
				
				public servo15_raw(): number | null {
					if (this.data_.field_bit != 174 && !this.data_.set_field(174, -1)) return null;
					
					return this.data_.bytes.getInt16(this.data_.BYTE, true);
				}
				
				
				public servo16_raw(): number | null {
					if (this.data_.field_bit != 175 && !this.data_.set_field(175, -1)) return null;
					
					return this.data_.bytes.getInt16(this.data_.BYTE, true);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				port_(src: number);
				
				servo1_raw_(src: number);
				
				servo2_raw_(src: number);
				
				servo3_raw_(src: number);
				
				servo4_raw_(src: number);
				
				servo5_raw_(src: number);
				
				servo6_raw_(src: number);
				
				servo7_raw_(src: number);
				
				servo8_raw_(src: number);
				
				servo9_raw_(src: number);
				
				servo10_raw_(src: number);
				
				servo11_raw_(src: number);
				
				servo12_raw_(src: number);
				
				servo13_raw_(src: number);
				
				servo14_raw_(src: number);
				
				servo15_raw_(src: number);
				
				servo16_raw_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SERVO_OUTPUT_RAW, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.port_(src.port());
				
				dst.servo1_raw_(src.servo1_raw());
				
				dst.servo2_raw_(src.servo2_raw());
				
				dst.servo3_raw_(src.servo3_raw());
				
				dst.servo4_raw_(src.servo4_raw());
				
				dst.servo5_raw_(src.servo5_raw());
				
				dst.servo6_raw_(src.servo6_raw());
				
				dst.servo7_raw_(src.servo7_raw());
				
				dst.servo8_raw_(src.servo8_raw());
				
				{
					const item = src.servo9_raw();
					if (item !== null) dst.servo9_raw_(item);
					
				}
				
				{
					const item = src.servo10_raw();
					if (item !== null) dst.servo10_raw_(item);
					
				}
				
				{
					const item = src.servo11_raw();
					if (item !== null) dst.servo11_raw_(item);
					
				}
				
				{
					const item = src.servo12_raw();
					if (item !== null) dst.servo12_raw_(item);
					
				}
				
				{
					const item = src.servo13_raw();
					if (item !== null) dst.servo13_raw_(item);
					
				}
				
				{
					const item = src.servo14_raw();
					if (item !== null) dst.servo14_raw_(item);
					
				}
				
				{
					const item = src.servo15_raw();
					if (item !== null) dst.servo15_raw_(item);
					
				}
				
				{
					const item = src.servo16_raw();
					if (item !== null) dst.servo16_raw_(item);
					
				}
				
			}
			
		}
		
		export interface MEMINFO {
			brkval(): number;
			
			brkval_(src: number);
			
			freemem(): number;
			
			freemem_(src: number);
			
			freemem32(): number | null;
			
			freemem32_(src: number);
			
		}
		
		export namespace MEMINFO {
			
			export const meta_ = new _Pack.Meta(159, 2, 0, 0, 5, 32, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements MEMINFO {
				
				public brkval(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public brkval_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public freemem(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public freemem_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				
				public freemem32(): number | null {
					if (this.data_.field_bit != 32 && !this.data_.set_field(32, -1)) return null;
					
					return this.data_.bytes.getInt32(this.data_.BYTE, true);
				}
				
				
				public freemem32_(src: number) {
					if (this.data_.field_bit != 32) this.data_.set_field(32, 0);
					
					this.data_.bytes.setInt32(this.data_.BYTE, src, true);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				brkval_(src: number);
				
				freemem_(src: number);
				
				freemem32_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MEMINFO, dst: DST) {
				
				dst.brkval_(src.brkval());
				
				dst.freemem_(src.freemem());
				
				{
					const item = src.freemem32();
					if (item !== null) dst.freemem32_(item);
					
				}
				
			}
			
			export interface SRC_ {
				brkval(): number;
				
				freemem(): number;
				
				freemem32(): number | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: MEMINFO) {
				
				dst.brkval_(src.brkval());
				
				dst.freemem_(src.freemem());
				{
					const item = src.freemem32();
					if (item !== null) dst.freemem32_(item);
					
				}
				
			}
			
		}
		
		export interface MISSION_ITEM_REACHED {
			seq(): number;
			
		}
		
		export namespace MISSION_ITEM_REACHED {
			
			export const meta_ = new _Pack.Meta(81, 1, 0, 0, 2, 16);
			
			
			class Impl_ extends _Cursor.View implements MISSION_ITEM_REACHED {
				
				public seq(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				seq_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_ITEM_REACHED, dst: DST) {
				
				dst.seq_(src.seq());
				
			}
			
		}
		
		export interface LOGGING_ACK {
			sequence(): number;
			
			sequence_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
		}
		
		export namespace LOGGING_ACK {
			
			export const meta_ = new _Pack.Meta(220, 1, 0, 0, 4, 32);
			
			
			class Impl_ extends _Cursor.View implements LOGGING_ACK {
				
				public sequence(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public sequence_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				sequence_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: LOGGING_ACK, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.sequence_(src.sequence());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				sequence(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LOGGING_ACK) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.sequence_(src.sequence());
				
			}
			
		}
		
		export interface VISION_SPEED_ESTIMATE {
			usec(): number;
			
			usec_(src: number);
			
			x(): number;
			
			x_(src: number);
			
			y(): number;
			
			y_(src: number);
			
			z(): number;
			
			z_(src: number);
			
		}
		
		export namespace VISION_SPEED_ESTIMATE {
			
			export const meta_ = new _Pack.Meta(42, 0, 0, 1, 20, 160);
			
			
			class Impl_ extends _Cursor.View implements VISION_SPEED_ESTIMATE {
				
				public usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				usec_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: VISION_SPEED_ESTIMATE, dst: DST) {
				
				dst.usec_(src.usec());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
			}
			
			export interface SRC_ {
				usec(): number;
				
				x(): number;
				
				y(): number;
				
				z(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: VISION_SPEED_ESTIMATE) {
				
				dst.usec_(src.usec());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
			}
			
		}
		
		export interface DEBUG_VECT {
			time_usec(): number;
			
			time_usec_(src: number);
			
			x(): number;
			
			x_(src: number);
			
			y(): number;
			
			y_(src: number);
			
			z(): number;
			
			z_(src: number);
			
			name(): _Cursor.UTF8 | null;
			
			name_(src: string | Uint8Array): _Cursor.UTF8;
			
			name$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace DEBUG_VECT {
			
			export const meta_ = new _Pack.Meta(187, 0, 0, 1, 21, 162, 2, 1);
			
			
			export namespace name {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements DEBUG_VECT {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				
				name(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 162 && !this.data_.set_field(162, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				name_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -162 - 1);
					
					let len = Math.min(src.byteLength, _Host.DEBUG_VECT.name.item_len_max);
					this.data_.set_field(162, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				name$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.DEBUG_VECT.name.item_len_max)
					this.data_.set_field(162, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				name_(src: _Cursor.UTF8);
				
				time_usec_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: DEBUG_VECT, dst: DST) {
				
				{
					const item = src.name();
					if (item !== null) dst.name_(item);
					
				}
				
				dst.time_usec_(src.time_usec());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
			}
			
			export interface SRC_ {
				name(): string | Uint8Array | null;
				
				time_usec(): number;
				
				x(): number;
				
				y(): number;
				
				z(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DEBUG_VECT) {
				
				
				{
					const item = src.name();
					if (item !== null) dst.name_(item);
				}
				
				
				dst.time_usec_(src.time_usec());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
			}
			
		}
		
		export interface LOG_REQUEST_END {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
		}
		
		export namespace LOG_REQUEST_END {
			
			export const meta_ = new _Pack.Meta(102, 0, 0, 0, 2, 16);
			
			
			class Impl_ extends _Cursor.View implements LOG_REQUEST_END {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: LOG_REQUEST_END, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LOG_REQUEST_END) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
			}
			
		}
		
		export interface MISSION_ACK {
			target_system(): number;
			
			target_component(): number;
			
			typE(): MAV_MISSION_RESULT | null;
			
			mission_type(): MAV_MISSION_TYPE | null;
			
		}
		
		export namespace MISSION_ACK {
			
			export const meta_ = new _Pack.Meta(85, 0, 0, 0, 3, 18, 2, 2);
			
			
			class Impl_ extends _Cursor.View implements MISSION_ACK {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public typE(): MAV_MISSION_RESULT | null {
					if (this.data_.field_bit != 18 && !this.data_.set_field(18, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public mission_type(): MAV_MISSION_TYPE | null {
					if (this.data_.field_bit != 19 && !this.data_.set_field(19, -1)) return null;
					
					return _Host.MAV_MISSION_TYPE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				typE_(src: _Host.MAV_MISSION_RESULT);
				
				mission_type_(src: _Host.MAV_MISSION_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_ACK, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.typE();
					if (item !== null) dst.typE_(item);
					
				}
				
				{
					const item = src.mission_type();
					if (item !== null) dst.mission_type_(item);
					
				}
				
			}
			
		}
		
		export interface CHANGE_OPERATOR_CONTROL_ACK {
			gcs_system_id(): number;
			
			control_request(): number;
			
			ack(): number;
			
		}
		
		export namespace CHANGE_OPERATOR_CONTROL_ACK {
			
			export const meta_ = new _Pack.Meta(62, 0, 0, 0, 3, 24);
			
			
			class Impl_ extends _Cursor.View implements CHANGE_OPERATOR_CONTROL_ACK {
				
				public gcs_system_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public control_request(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public ack(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				gcs_system_id_(src: number);
				
				control_request_(src: number);
				
				ack_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: CHANGE_OPERATOR_CONTROL_ACK, dst: DST) {
				
				dst.gcs_system_id_(src.gcs_system_id());
				
				dst.control_request_(src.control_request());
				
				dst.ack_(src.ack());
				
			}
			
		}
		
		export interface MISSION_CURRENT {
			seq(): number;
			
		}
		
		export namespace MISSION_CURRENT {
			
			export const meta_ = new _Pack.Meta(189, 1, 0, 0, 2, 16);
			
			
			class Impl_ extends _Cursor.View implements MISSION_CURRENT {
				
				public seq(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				seq_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_CURRENT, dst: DST) {
				
				dst.seq_(src.seq());
				
			}
			
		}
		
		export interface SYSTEM_TIME {
			time_boot_ms(): number;
			
			time_unix_usec(): number;
			
		}
		
		export namespace SYSTEM_TIME {
			
			export const meta_ = new _Pack.Meta(9, 0, 1, 1, 12, 96);
			
			
			class Impl_ extends _Cursor.View implements SYSTEM_TIME {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public time_unix_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 4, true) + this.data_.bytes.getInt32(this.data_.origin + 4 + 4, true) * _Lib.JS_HI;}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_unix_usec_(src: number);
				
				time_boot_ms_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SYSTEM_TIME, dst: DST) {
				
				dst.time_unix_usec_(src.time_unix_usec());
				
				dst.time_boot_ms_(src.time_boot_ms());
				
			}
			
		}
		
		export interface CAMERA_TRIGGER {
			seq(): number;
			
			seq_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
		}
		
		export namespace CAMERA_TRIGGER {
			
			export const meta_ = new _Pack.Meta(191, 0, 1, 1, 12, 96);
			
			
			class Impl_ extends _Cursor.View implements CAMERA_TRIGGER {
				
				public seq(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public seq_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 4, true) + this.data_.bytes.getInt32(this.data_.origin + 4 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 4, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 4 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				seq_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: CAMERA_TRIGGER, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.seq_(src.seq());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				seq(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: CAMERA_TRIGGER) {
				
				dst.time_usec_(src.time_usec());
				
				dst.seq_(src.seq());
				
			}
			
		}
		
		export interface GOPRO_SET_RESPONSE {
			cmd_id(): GOPRO_COMMAND | null;
			
			cmd_id_(src: GOPRO_COMMAND);
			
			status(): GOPRO_REQUEST_STATUS | null;
			
			status_(src: GOPRO_REQUEST_STATUS);
			
		}
		
		export namespace GOPRO_SET_RESPONSE {
			
			export const meta_ = new _Pack.Meta(192, 0, 0, 0, 1, 0, 0, 2);
			
			
			class Impl_ extends _Cursor.View implements GOPRO_SET_RESPONSE {
				
				
				public cmd_id(): GOPRO_COMMAND | null {
					if (this.data_.field_bit != 0 && !this.data_.set_field(0, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 5);
				}
				
				
				public cmd_id_(src: GOPRO_COMMAND) {
					if (this.data_.field_bit != 0) this.data_.set_field(0, 0);
					
					_Lib.set_bits(src, 5, this.data_.bytes, this.data_.BIT);
				}
				
				
				public status(): GOPRO_REQUEST_STATUS | null {
					if (this.data_.field_bit != 1 && !this.data_.set_field(1, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 1);
				}
				
				
				public status_(src: GOPRO_REQUEST_STATUS) {
					if (this.data_.field_bit != 1) this.data_.set_field(1, 0);
					
					_Lib.set_bits(src, 1, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				cmd_id_(src: _Host.GOPRO_COMMAND);
				
				status_(src: _Host.GOPRO_REQUEST_STATUS);
				
			}
			
			export function push_<DST extends DST_>(src: GOPRO_SET_RESPONSE, dst: DST) {
				
				{
					const item = src.cmd_id();
					if (item !== null) dst.cmd_id_(item);
					
				}
				
				{
					const item = src.status();
					if (item !== null) dst.status_(item);
					
				}
				
			}
			
			export interface SRC_ {
				cmd_id(): _Host.GOPRO_COMMAND | null;
				
				status(): _Host.GOPRO_REQUEST_STATUS | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GOPRO_SET_RESPONSE) {
				{
					const item = src.cmd_id();
					if (item !== null) dst.cmd_id_(item);
					
				}
				{
					const item = src.status();
					if (item !== null) dst.status_(item);
					
				}
				
			}
			
		}
		
		export interface VISION_POSITION_ESTIMATE {
			usec(): number;
			
			x(): number;
			
			y(): number;
			
			z(): number;
			
			roll(): number;
			
			pitch(): number;
			
			yaw(): number;
			
		}
		
		export namespace VISION_POSITION_ESTIMATE {
			
			export const meta_ = new _Pack.Meta(16, 0, 0, 1, 32, 256);
			
			
			class Impl_ extends _Cursor.View implements VISION_POSITION_ESTIMATE {
				
				public usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				usec_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: VISION_POSITION_ESTIMATE, dst: DST) {
				
				dst.usec_(src.usec());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
			}
			
		}
		
		export interface MANUAL_CONTROL {
			buttons(): number;
			
			target(): number;
			
			x(): number;
			
			y(): number;
			
			z(): number;
			
			r(): number;
			
		}
		
		export namespace MANUAL_CONTROL {
			
			export const meta_ = new _Pack.Meta(54, 1, 0, 0, 11, 88);
			
			
			class Impl_ extends _Cursor.View implements MANUAL_CONTROL {
				
				public buttons(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public target(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				public x(): number { return this.data_.bytes.getInt16(this.data_.origin + 3, true);}
				
				
				public y(): number { return this.data_.bytes.getInt16(this.data_.origin + 5, true);}
				
				
				public z(): number { return this.data_.bytes.getInt16(this.data_.origin + 7, true);}
				
				
				public r(): number { return this.data_.bytes.getInt16(this.data_.origin + 9, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				r_(src: number);
				
				buttons_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MANUAL_CONTROL, dst: DST) {
				
				dst.target_(src.target());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				dst.r_(src.r());
				
				dst.buttons_(src.buttons());
				
			}
			
		}
		
		export interface RC_CHANNELS {
			chan1_raw(): number;
			
			chan2_raw(): number;
			
			chan3_raw(): number;
			
			chan4_raw(): number;
			
			chan5_raw(): number;
			
			chan6_raw(): number;
			
			chan7_raw(): number;
			
			chan8_raw(): number;
			
			chan9_raw(): number;
			
			chan10_raw(): number;
			
			chan11_raw(): number;
			
			chan12_raw(): number;
			
			chan13_raw(): number;
			
			chan14_raw(): number;
			
			chan15_raw(): number;
			
			chan16_raw(): number;
			
			chan17_raw(): number;
			
			chan18_raw(): number;
			
			time_boot_ms(): number;
			
			chancount(): number;
			
			rssi(): number;
			
		}
		
		export namespace RC_CHANNELS {
			
			export const meta_ = new _Pack.Meta(23, 18, 1, 0, 42, 336);
			
			
			class Impl_ extends _Cursor.View implements RC_CHANNELS {
				
				public chan1_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public chan2_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				public chan3_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				
				public chan4_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				
				public chan5_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				
				public chan6_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				
				public chan7_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				
				public chan8_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				
				public chan9_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 16, true);}
				
				
				public chan10_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 18, true);}
				
				
				public chan11_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 20, true);}
				
				
				public chan12_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 22, true);}
				
				
				public chan13_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 24, true);}
				
				
				public chan14_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 26, true);}
				
				
				public chan15_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 28, true);}
				
				
				public chan16_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 30, true);}
				
				
				public chan17_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 32, true);}
				
				
				public chan18_raw(): number { return this.data_.bytes.getInt16(this.data_.origin + 34, true);}
				
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 36, true);}
				
				
				public chancount(): number { return this.data_.bytes.getInt8(this.data_.origin + 40);}
				
				
				public rssi(): number { return this.data_.bytes.getInt8(this.data_.origin + 41);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				chancount_(src: number);
				
				chan1_raw_(src: number);
				
				chan2_raw_(src: number);
				
				chan3_raw_(src: number);
				
				chan4_raw_(src: number);
				
				chan5_raw_(src: number);
				
				chan6_raw_(src: number);
				
				chan7_raw_(src: number);
				
				chan8_raw_(src: number);
				
				chan9_raw_(src: number);
				
				chan10_raw_(src: number);
				
				chan11_raw_(src: number);
				
				chan12_raw_(src: number);
				
				chan13_raw_(src: number);
				
				chan14_raw_(src: number);
				
				chan15_raw_(src: number);
				
				chan16_raw_(src: number);
				
				chan17_raw_(src: number);
				
				chan18_raw_(src: number);
				
				rssi_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: RC_CHANNELS, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.chancount_(src.chancount());
				
				dst.chan1_raw_(src.chan1_raw());
				
				dst.chan2_raw_(src.chan2_raw());
				
				dst.chan3_raw_(src.chan3_raw());
				
				dst.chan4_raw_(src.chan4_raw());
				
				dst.chan5_raw_(src.chan5_raw());
				
				dst.chan6_raw_(src.chan6_raw());
				
				dst.chan7_raw_(src.chan7_raw());
				
				dst.chan8_raw_(src.chan8_raw());
				
				dst.chan9_raw_(src.chan9_raw());
				
				dst.chan10_raw_(src.chan10_raw());
				
				dst.chan11_raw_(src.chan11_raw());
				
				dst.chan12_raw_(src.chan12_raw());
				
				dst.chan13_raw_(src.chan13_raw());
				
				dst.chan14_raw_(src.chan14_raw());
				
				dst.chan15_raw_(src.chan15_raw());
				
				dst.chan16_raw_(src.chan16_raw());
				
				dst.chan17_raw_(src.chan17_raw());
				
				dst.chan18_raw_(src.chan18_raw());
				
				dst.rssi_(src.rssi());
				
			}
			
		}
		
		export interface PROTOCOL_VERSION {
			version(): number;
			
			version_(src: number);
			
			min_version(): number;
			
			min_version_(src: number);
			
			max_version(): number;
			
			max_version_(src: number);
			
			spec_version_hash(): PROTOCOL_VERSION.spec_version_hash;
			
			spec_version_hash_(src: PROTOCOL_VERSION.spec_version_hash | number[]);
			
			spec_version_hash$(src: Iterator<number>, len: number);
			
			library_version_hash(): PROTOCOL_VERSION.library_version_hash;
			
			library_version_hash_(src: PROTOCOL_VERSION.library_version_hash | number[]);
			
			library_version_hash$(src: Iterator<number>, len: number);
			
		}
		
		export namespace PROTOCOL_VERSION {
			
			export const meta_ = new _Pack.Meta(150, 3, 0, 0, 22, 176);
			
			
			export interface spec_version_hash extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace spec_version_hash {
				export class Field extends _Cursor.View implements spec_version_hash, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 6 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 6, other.data_.bytes.buffer, other.data_.origin + 6, _Host.PROTOCOL_VERSION.spec_version_hash.item_len) === 0;
						for (let i = 0; i < _Host.PROTOCOL_VERSION.spec_version_hash.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.PROTOCOL_VERSION.spec_version_hash.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 6 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 8;
				
			}
			
			export interface library_version_hash extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace library_version_hash {
				export class Field extends _Cursor.View implements library_version_hash, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 14 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 14, other.data_.bytes.buffer, other.data_.origin + 14, _Host.PROTOCOL_VERSION.library_version_hash.item_len) === 0;
						for (let i = 0; i < _Host.PROTOCOL_VERSION.library_version_hash.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.PROTOCOL_VERSION.library_version_hash.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 14 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 8;
				
			}
			
			
			class Impl_ extends _Cursor.View implements PROTOCOL_VERSION {
				
				public version(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public version_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public min_version(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public min_version_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public max_version(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public max_version_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public spec_version_hash(): PROTOCOL_VERSION.spec_version_hash {
					
					return this.data_.as_field(PROTOCOL_VERSION.spec_version_hash.field);
				}
				
				public spec_version_hash_(src: PROTOCOL_VERSION.spec_version_hash | number[]): spec_version_hash {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.PROTOCOL_VERSION.spec_version_hash.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 6 + index, src[index]);
						return this.data_.as_field(spec_version_hash.field);
					}
					for (let index = 0; index < _Host.PROTOCOL_VERSION.spec_version_hash.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 6 + index, src.get(index));
					
					return this.data_.as_field(spec_version_hash.field);
				}
				
				public spec_version_hash$(src: Iterator<number>, len: number): spec_version_hash {
					let len_ = Math.min(len, _Host.PROTOCOL_VERSION.spec_version_hash.item_len);
					
					len = Math.min(len, _Host.PROTOCOL_VERSION.spec_version_hash.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 6 + index, v.value);
						}
					return this.data_.as_field(spec_version_hash.field);
				}
				
				public library_version_hash(): PROTOCOL_VERSION.library_version_hash {
					
					return this.data_.as_field(PROTOCOL_VERSION.library_version_hash.field);
				}
				
				public library_version_hash_(src: PROTOCOL_VERSION.library_version_hash | number[]): library_version_hash {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.PROTOCOL_VERSION.library_version_hash.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 14 + index, src[index]);
						return this.data_.as_field(library_version_hash.field);
					}
					for (let index = 0; index < _Host.PROTOCOL_VERSION.library_version_hash.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 14 + index, src.get(index));
					
					return this.data_.as_field(library_version_hash.field);
				}
				
				public library_version_hash$(src: Iterator<number>, len: number): library_version_hash {
					let len_ = Math.min(len, _Host.PROTOCOL_VERSION.library_version_hash.item_len);
					
					len = Math.min(len, _Host.PROTOCOL_VERSION.library_version_hash.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 14 + index, v.value);
						}
					return this.data_.as_field(library_version_hash.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				version_(src: number);
				
				min_version_(src: number);
				
				max_version_(src: number);
				
				spec_version_hash_(src: _Host.PROTOCOL_VERSION.spec_version_hash);
				
				library_version_hash_(src: _Host.PROTOCOL_VERSION.library_version_hash);
				
			}
			
			export function push_<DST extends DST_>(src: PROTOCOL_VERSION, dst: DST) {
				
				dst.version_(src.version());
				
				dst.min_version_(src.min_version());
				
				dst.max_version_(src.max_version());
				dst.spec_version_hash_(src.spec_version_hash());
				dst.library_version_hash_(src.library_version_hash());
				
			}
			
			export interface SRC_ {
				version(): number;
				
				min_version(): number;
				
				max_version(): number;
				
				spec_version_hash(dst: _Host.PROTOCOL_VERSION.spec_version_hash);
				
				library_version_hash(dst: _Host.PROTOCOL_VERSION.library_version_hash);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: PROTOCOL_VERSION) {
				
				dst.version_(src.version());
				
				dst.min_version_(src.min_version());
				
				dst.max_version_(src.max_version());
				src.spec_version_hash(dst.spec_version_hash());
				src.library_version_hash(dst.library_version_hash());
				
			}
			
		}
		
		export interface RALLY_FETCH_POINT {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			idx(): number;
			
			idx_(src: number);
			
		}
		
		export namespace RALLY_FETCH_POINT {
			
			export const meta_ = new _Pack.Meta(5, 0, 0, 0, 3, 24);
			
			
			class Impl_ extends _Cursor.View implements RALLY_FETCH_POINT {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public idx(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public idx_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				idx_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: RALLY_FETCH_POINT, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.idx_(src.idx());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				idx(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: RALLY_FETCH_POINT) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.idx_(src.idx());
				
			}
			
		}
		
		export interface PARAM_VALUE {
			param_count(): number;
			
			param_index(): number;
			
			param_value(): number;
			
			param_id(): _Cursor.UTF8 | null;
			
			param_type(): MAV_PARAM_TYPE | null;
			
		}
		
		export namespace PARAM_VALUE {
			
			export const meta_ = new _Pack.Meta(136, 2, 0, 0, 9, 66, 2, 2);
			
			
			export namespace param_id {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements PARAM_VALUE {
				
				public param_count(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public param_index(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				public param_value(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				
				param_id(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 66 && !this.data_.set_field(66, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				
				public param_type(): MAV_PARAM_TYPE | null {
					if (this.data_.field_bit != 67 && !this.data_.set_field(67, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				param_id_(src: _Cursor.UTF8);
				
				param_value_(src: number);
				
				param_type_(src: _Host.MAV_PARAM_TYPE);
				
				param_count_(src: number);
				
				param_index_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: PARAM_VALUE, dst: DST) {
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
					
				}
				
				dst.param_value_(src.param_value());
				
				{
					const item = src.param_type();
					if (item !== null) dst.param_type_(item);
					
				}
				
				dst.param_count_(src.param_count());
				
				dst.param_index_(src.param_index());
				
			}
			
		}
		
		export interface BATTERY_STATUS {
			voltages(): BATTERY_STATUS.voltages;
			
			voltages_(src: BATTERY_STATUS.voltages | number[]);
			
			voltages$(src: Iterator<number>, len: number);
			
			id(): number;
			
			id_(src: number);
			
			temperature(): number;
			
			temperature_(src: number);
			
			current_battery(): number;
			
			current_battery_(src: number);
			
			current_consumed(): number;
			
			current_consumed_(src: number);
			
			energy_consumed(): number;
			
			energy_consumed_(src: number);
			
			battery_remaining(): number;
			
			battery_remaining_(src: number);
			
			battery_function(): MAV_BATTERY_FUNCTION | null;
			
			battery_function_(src: MAV_BATTERY_FUNCTION);
			
			typE(): MAV_BATTERY_TYPE | null;
			
			typE_(src: MAV_BATTERY_TYPE);
			
		}
		
		export namespace BATTERY_STATUS {
			
			export const meta_ = new _Pack.Meta(111, 10, 0, 0, 35, 272, 0, 2);
			
			
			export interface voltages extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace voltages {
				export class Field extends _Cursor.View implements voltages, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt16(this.data_.origin + 0 + index * 2, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 0, other.data_.bytes.buffer, other.data_.origin + 0, _Host.BATTERY_STATUS.voltages.item_len) === 0;
						for (let i = 0; i < _Host.BATTERY_STATUS.voltages.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.BATTERY_STATUS.voltages.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt16(this.data_.origin + 0 + index * 2, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 10;
				
			}
			
			
			class Impl_ extends _Cursor.View implements BATTERY_STATUS {
				
				public voltages(): BATTERY_STATUS.voltages {
					
					return this.data_.as_field(BATTERY_STATUS.voltages.field);
				}
				
				public voltages_(src: BATTERY_STATUS.voltages | number[]): voltages {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.BATTERY_STATUS.voltages.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt16(this.data_.origin + 0 + index * 2, src[index], true);
						return this.data_.as_field(voltages.field);
					}
					for (let index = 0; index < _Host.BATTERY_STATUS.voltages.item_len; index++)
						this.data_.bytes.setInt16(this.data_.origin + 0 + index * 2, src.get(index), true);
					
					return this.data_.as_field(voltages.field);
				}
				
				public voltages$(src: Iterator<number>, len: number): voltages {
					let len_ = Math.min(len, _Host.BATTERY_STATUS.voltages.item_len);
					
					len = Math.min(len, _Host.BATTERY_STATUS.voltages.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt16(this.data_.origin + 0 + index * 2, v.value, true);
						}
					return this.data_.as_field(voltages.field);
				}
				
				public id(): number { return this.data_.bytes.getInt8(this.data_.origin + 20);}
				
				public id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 20, src); }
				
				public temperature(): number { return this.data_.bytes.getInt16(this.data_.origin + 21, true);}
				
				public temperature_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 21, src, true); }
				
				public current_battery(): number { return this.data_.bytes.getInt16(this.data_.origin + 23, true);}
				
				public current_battery_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 23, src, true); }
				
				public current_consumed(): number { return this.data_.bytes.getInt32(this.data_.origin + 25, true);}
				
				public current_consumed_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 25, src, true); }
				
				public energy_consumed(): number { return this.data_.bytes.getInt32(this.data_.origin + 29, true);}
				
				public energy_consumed_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 29, src, true); }
				
				public battery_remaining(): number { return this.data_.bytes.getInt8(this.data_.origin + 33);}
				
				public battery_remaining_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 33, src); }
				
				
				public battery_function(): MAV_BATTERY_FUNCTION | null {
					if (this.data_.field_bit != 272 && !this.data_.set_field(272, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public battery_function_(src: MAV_BATTERY_FUNCTION) {
					if (this.data_.field_bit != 272) this.data_.set_field(272, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				public typE(): MAV_BATTERY_TYPE | null {
					if (this.data_.field_bit != 273 && !this.data_.set_field(273, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public typE_(src: MAV_BATTERY_TYPE) {
					if (this.data_.field_bit != 273) this.data_.set_field(273, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				id_(src: number);
				
				battery_function_(src: _Host.MAV_BATTERY_FUNCTION);
				
				typE_(src: _Host.MAV_BATTERY_TYPE);
				
				temperature_(src: number);
				
				voltages_(src: _Host.BATTERY_STATUS.voltages);
				
				current_battery_(src: number);
				
				current_consumed_(src: number);
				
				energy_consumed_(src: number);
				
				battery_remaining_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: BATTERY_STATUS, dst: DST) {
				
				dst.id_(src.id());
				
				{
					const item = src.battery_function();
					if (item !== null) dst.battery_function_(item);
					
				}
				
				{
					const item = src.typE();
					if (item !== null) dst.typE_(item);
					
				}
				
				dst.temperature_(src.temperature());
				dst.voltages_(src.voltages());
				
				dst.current_battery_(src.current_battery());
				
				dst.current_consumed_(src.current_consumed());
				
				dst.energy_consumed_(src.energy_consumed());
				
				dst.battery_remaining_(src.battery_remaining());
				
			}
			
			export interface SRC_ {
				id(): number;
				
				battery_function(): _Host.MAV_BATTERY_FUNCTION | null;
				
				typE(): _Host.MAV_BATTERY_TYPE | null;
				
				temperature(): number;
				
				voltages(dst: _Host.BATTERY_STATUS.voltages);
				
				current_battery(): number;
				
				current_consumed(): number;
				
				energy_consumed(): number;
				
				battery_remaining(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: BATTERY_STATUS) {
				
				dst.id_(src.id());
				{
					const item = src.battery_function();
					if (item !== null) dst.battery_function_(item);
					
				}
				{
					const item = src.typE();
					if (item !== null) dst.typE_(item);
					
				}
				
				dst.temperature_(src.temperature());
				src.voltages(dst.voltages());
				
				dst.current_battery_(src.current_battery());
				
				dst.current_consumed_(src.current_consumed());
				
				dst.energy_consumed_(src.energy_consumed());
				
				dst.battery_remaining_(src.battery_remaining());
				
			}
			
		}
		
		export interface SERIAL_CONTROL {
			timeout(): number;
			
			timeout_(src: number);
			
			baudrate(): number;
			
			baudrate_(src: number);
			
			count(): number;
			
			count_(src: number);
			
			daTa(): SERIAL_CONTROL.daTa;
			
			daTa_(src: SERIAL_CONTROL.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
			device(): SERIAL_CONTROL_DEV | null;
			
			device_(src: SERIAL_CONTROL_DEV);
			
			flags(): SERIAL_CONTROL_FLAG | null;
			
			flags_(src: SERIAL_CONTROL_FLAG);
			
		}
		
		export namespace SERIAL_CONTROL {
			
			export const meta_ = new _Pack.Meta(99, 1, 1, 0, 78, 616, 0, 2);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 7 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 7, other.data_.bytes.buffer, other.data_.origin + 7, _Host.SERIAL_CONTROL.daTa.item_len) === 0;
						for (let i = 0; i < _Host.SERIAL_CONTROL.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.SERIAL_CONTROL.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 7 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 70;
				
			}
			
			
			class Impl_ extends _Cursor.View implements SERIAL_CONTROL {
				
				public timeout(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public timeout_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public baudrate(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				public baudrate_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 2, src, true); }
				
				public count(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				public count_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 6, src); }
				
				public daTa(): SERIAL_CONTROL.daTa {
					
					return this.data_.as_field(SERIAL_CONTROL.daTa.field);
				}
				
				public daTa_(src: SERIAL_CONTROL.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.SERIAL_CONTROL.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 7 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.SERIAL_CONTROL.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 7 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.SERIAL_CONTROL.daTa.item_len);
					
					len = Math.min(len, _Host.SERIAL_CONTROL.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 7 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
				
				public device(): SERIAL_CONTROL_DEV | null {
					if (this.data_.field_bit != 616 && !this.data_.set_field(616, -1)) return null;
					
					return _Host.SERIAL_CONTROL_DEV_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
				public device_(src: SERIAL_CONTROL_DEV) {
					if (this.data_.field_bit != 616) this.data_.set_field(616, 0);
					
					_Lib.set_bits(_Host.SERIAL_CONTROL_DEV_.into(src), 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				public flags(): SERIAL_CONTROL_FLAG | null {
					if (this.data_.field_bit != 617 && !this.data_.set_field(617, -1)) return null;
					
					return _Host.SERIAL_CONTROL_FLAG_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
				public flags_(src: SERIAL_CONTROL_FLAG) {
					if (this.data_.field_bit != 617) this.data_.set_field(617, 0);
					
					_Lib.set_bits(_Host.SERIAL_CONTROL_FLAG_.into(src), 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				device_(src: _Host.SERIAL_CONTROL_DEV);
				
				flags_(src: _Host.SERIAL_CONTROL_FLAG);
				
				timeout_(src: number);
				
				baudrate_(src: number);
				
				count_(src: number);
				
				daTa_(src: _Host.SERIAL_CONTROL.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: SERIAL_CONTROL, dst: DST) {
				
				{
					const item = src.device();
					if (item !== null) dst.device_(item);
					
				}
				
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
				dst.timeout_(src.timeout());
				
				dst.baudrate_(src.baudrate());
				
				dst.count_(src.count());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				device(): _Host.SERIAL_CONTROL_DEV | null;
				
				flags(): _Host.SERIAL_CONTROL_FLAG | null;
				
				timeout(): number;
				
				baudrate(): number;
				
				count(): number;
				
				daTa(dst: _Host.SERIAL_CONTROL.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SERIAL_CONTROL) {
				{
					const item = src.device();
					if (item !== null) dst.device_(item);
					
				}
				{
					const item = src.flags();
					if (item !== null) dst.flags_(item);
					
				}
				
				dst.timeout_(src.timeout());
				
				dst.baudrate_(src.baudrate());
				
				dst.count_(src.count());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface SET_POSITION_TARGET_LOCAL_NED {
			type_mask(): number;
			
			time_boot_ms(): number;
			
			target_system(): number;
			
			target_component(): number;
			
			x(): number;
			
			y(): number;
			
			z(): number;
			
			vx(): number;
			
			vy(): number;
			
			vz(): number;
			
			afx(): number;
			
			afy(): number;
			
			afz(): number;
			
			yaw(): number;
			
			yaw_rate(): number;
			
			coordinate_frame(): MAV_FRAME | null;
			
		}
		
		export namespace SET_POSITION_TARGET_LOCAL_NED {
			
			export const meta_ = new _Pack.Meta(209, 1, 1, 0, 53, 416, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements SET_POSITION_TARGET_LOCAL_NED {
				
				public type_mask(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 7);}
				
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public vx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public vy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
				public vz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				
				public afx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				
				public afy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				
				public afz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 44, true);}
				
				
				public yaw_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 48, true);}
				
				
				public coordinate_frame(): MAV_FRAME | null {
					if (this.data_.field_bit != 416 && !this.data_.set_field(416, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				target_system_(src: number);
				
				target_component_(src: number);
				
				coordinate_frame_(src: _Host.MAV_FRAME);
				
				type_mask_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				vx_(src: number);
				
				vy_(src: number);
				
				vz_(src: number);
				
				afx_(src: number);
				
				afy_(src: number);
				
				afz_(src: number);
				
				yaw_(src: number);
				
				yaw_rate_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SET_POSITION_TARGET_LOCAL_NED, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.coordinate_frame();
					if (item !== null) dst.coordinate_frame_(item);
					
				}
				
				dst.type_mask_(src.type_mask());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
				dst.afx_(src.afx());
				
				dst.afy_(src.afy());
				
				dst.afz_(src.afz());
				
				dst.yaw_(src.yaw());
				
				dst.yaw_rate_(src.yaw_rate());
				
			}
			
		}
		
		export interface MOUNT_ORIENTATION {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			roll(): number;
			
			roll_(src: number);
			
			pitch(): number;
			
			pitch_(src: number);
			
			yaw(): number;
			
			yaw_(src: number);
			
		}
		
		export namespace MOUNT_ORIENTATION {
			
			export const meta_ = new _Pack.Meta(76, 0, 1, 0, 16, 128);
			
			
			class Impl_ extends _Cursor.View implements MOUNT_ORIENTATION {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public roll_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public pitch_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public yaw_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MOUNT_ORIENTATION, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				roll(): number;
				
				pitch(): number;
				
				yaw(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: MOUNT_ORIENTATION) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
			}
			
		}
		
		export interface SET_GPS_GLOBAL_ORIGIN {
			target_system(): number;
			
			latitude(): number;
			
			longitude(): number;
			
			altitude(): number;
			
			time_usec(): number | null;
			
		}
		
		export namespace SET_GPS_GLOBAL_ORIGIN {
			
			export const meta_ = new _Pack.Meta(53, 0, 0, 0, 14, 104, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements SET_GPS_GLOBAL_ORIGIN {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public latitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 1, true);}
				
				
				public longitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 5, true);}
				
				
				public altitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 9, true);}
				
				
				public time_usec(): number | null {
					if (this.data_.field_bit != 104 && !this.data_.set_field(104, -1)) return null;
					
					return this.data_.bytes.getUint32(this.data_.BYTE, true) + this.data_.bytes.getInt32(this.data_.BYTE + 4, true) * _Lib.JS_HI;
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				latitude_(src: number);
				
				longitude_(src: number);
				
				altitude_(src: number);
				
				time_usec_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SET_GPS_GLOBAL_ORIGIN, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.latitude_(src.latitude());
				
				dst.longitude_(src.longitude());
				
				dst.altitude_(src.altitude());
				
				{
					const item = src.time_usec();
					if (item !== null) dst.time_usec_(item);
					
				}
				
			}
			
		}
		
		export interface PARAM_EXT_SET {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			param_id(): _Cursor.UTF8 | null;
			
			param_id_(src: string | Uint8Array): _Cursor.UTF8;
			
			param_id$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
			param_value(): _Cursor.UTF8 | null;
			
			param_value_(src: string | Uint8Array): _Cursor.UTF8;
			
			param_value$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
			param_type(): MAV_PARAM_EXT_TYPE | null;
			
			param_type_(src: MAV_PARAM_EXT_TYPE);
			
		}
		
		export namespace PARAM_EXT_SET {
			
			export const meta_ = new _Pack.Meta(109, 0, 0, 0, 3, 19, 3, 3);
			
			
			export namespace param_id {
				export const item_len_max = 255;
				
			}
			export namespace param_value {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements PARAM_EXT_SET {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				
				param_id(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 19 && !this.data_.set_field(19, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				param_id_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -19 - 1);
					
					let len = Math.min(src.byteLength, _Host.PARAM_EXT_SET.param_id.item_len_max);
					this.data_.set_field(19, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				param_id$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.PARAM_EXT_SET.param_id.item_len_max)
					this.data_.set_field(19, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
				param_value(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 20 && !this.data_.set_field(20, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				param_value_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -20 - 1);
					
					let len = Math.min(src.byteLength, _Host.PARAM_EXT_SET.param_value.item_len_max);
					this.data_.set_field(20, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				param_value$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.PARAM_EXT_SET.param_value.item_len_max)
					this.data_.set_field(20, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
				public param_type(): MAV_PARAM_EXT_TYPE | null {
					if (this.data_.field_bit != 21 && !this.data_.set_field(21, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public param_type_(src: MAV_PARAM_EXT_TYPE) {
					if (this.data_.field_bit != 21) this.data_.set_field(21, 0);
					
					_Lib.set_bits(src, 4, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				param_id_(src: _Cursor.UTF8);
				
				param_value_(src: _Cursor.UTF8);
				
				param_type_(src: _Host.MAV_PARAM_EXT_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: PARAM_EXT_SET, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
					
				}
				
				{
					const item = src.param_value();
					if (item !== null) dst.param_value_(item);
					
				}
				
				{
					const item = src.param_type();
					if (item !== null) dst.param_type_(item);
					
				}
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				param_id(): string | Uint8Array | null;
				
				param_value(): string | Uint8Array | null;
				
				param_type(): _Host.MAV_PARAM_EXT_TYPE | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: PARAM_EXT_SET) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
				}
				
				
				{
					const item = src.param_value();
					if (item !== null) dst.param_value_(item);
				}
				
				{
					const item = src.param_type();
					if (item !== null) dst.param_type_(item);
					
				}
				
			}
			
		}
		
		export interface AUTOPILOT_VERSION {
			vendor_id(): number;
			
			vendor_id_(src: number);
			
			product_id(): number;
			
			product_id_(src: number);
			
			flight_sw_version(): number;
			
			flight_sw_version_(src: number);
			
			middleware_sw_version(): number;
			
			middleware_sw_version_(src: number);
			
			os_sw_version(): number;
			
			os_sw_version_(src: number);
			
			board_version(): number;
			
			board_version_(src: number);
			
			uid(): number;
			
			uid_(src: number);
			
			flight_custom_version(): AUTOPILOT_VERSION.flight_custom_version;
			
			flight_custom_version_(src: AUTOPILOT_VERSION.flight_custom_version | number[]);
			
			flight_custom_version$(src: Iterator<number>, len: number);
			
			middleware_custom_version(): AUTOPILOT_VERSION.middleware_custom_version;
			
			middleware_custom_version_(src: AUTOPILOT_VERSION.middleware_custom_version | number[]);
			
			middleware_custom_version$(src: Iterator<number>, len: number);
			
			os_custom_version(): AUTOPILOT_VERSION.os_custom_version;
			
			os_custom_version_(src: AUTOPILOT_VERSION.os_custom_version | number[]);
			
			os_custom_version$(src: Iterator<number>, len: number);
			
			capabilities(): MAV_PROTOCOL_CAPABILITY | null;
			
			capabilities_(src: MAV_PROTOCOL_CAPABILITY);
			
			uid2_(src: number, d0: number);
			
			uid2(): AUTOPILOT_VERSION.uid2 | null;
			
		}
		
		export namespace AUTOPILOT_VERSION {
			
			export const meta_ = new _Pack.Meta(60, 2, 4, 1, 53, 419, 3, 2);
			
			
			export interface flight_custom_version extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace flight_custom_version {
				export class Field extends _Cursor.View implements flight_custom_version, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 28 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 28, other.data_.bytes.buffer, other.data_.origin + 28, _Host.AUTOPILOT_VERSION.flight_custom_version.item_len) === 0;
						for (let i = 0; i < _Host.AUTOPILOT_VERSION.flight_custom_version.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.AUTOPILOT_VERSION.flight_custom_version.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 28 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 8;
				
			}
			
			export interface middleware_custom_version extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace middleware_custom_version {
				export class Field extends _Cursor.View implements middleware_custom_version, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 36 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 36, other.data_.bytes.buffer, other.data_.origin + 36, _Host.AUTOPILOT_VERSION.middleware_custom_version.item_len) === 0;
						for (let i = 0; i < _Host.AUTOPILOT_VERSION.middleware_custom_version.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.AUTOPILOT_VERSION.middleware_custom_version.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 36 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 8;
				
			}
			
			export interface os_custom_version extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace os_custom_version {
				export class Field extends _Cursor.View implements os_custom_version, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 44 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 44, other.data_.bytes.buffer, other.data_.origin + 44, _Host.AUTOPILOT_VERSION.os_custom_version.item_len) === 0;
						for (let i = 0; i < _Host.AUTOPILOT_VERSION.os_custom_version.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.AUTOPILOT_VERSION.os_custom_version.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 44 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 8;
				
			}
			
			export interface uid2 {
				enumerate(dst: (item: number, d0?: number) => void);
				
				get(d0: number): number | null;
				
			}
			
			export namespace uid2 {
				class Field extends _Cursor.View implements uid2 {
					
					
					enumerate(dst: (item: number, d0?: number) => void) {
						for (let d0 = 0; d0 < _Host.AUTOPILOT_VERSION.uid2.d0; d0++)
							
							if (this.data_.set_item(d0, -1)) dst(this.data_.bytes.getInt8(this.data_.BYTE), d0);
					}
					
					
					public get(d0: number): number | null {
						if (!this.data_.set_item(d0, -1)) return null;
						
						return this.data_.bytes.getInt8(this.data_.BYTE);
					}
					
				}
				
				export const field = Field.prototype;
				
				
				export const d0 = 18;
				
			}
			
			
			class Impl_ extends _Cursor.View implements AUTOPILOT_VERSION {
				
				public vendor_id(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public vendor_id_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public product_id(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public product_id_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public flight_sw_version(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				public flight_sw_version_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 4, src, true); }
				
				public middleware_sw_version(): number { return this.data_.bytes.getInt32(this.data_.origin + 8, true);}
				
				public middleware_sw_version_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 8, src, true); }
				
				public os_sw_version(): number { return this.data_.bytes.getInt32(this.data_.origin + 12, true);}
				
				public os_sw_version_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 12, src, true); }
				
				public board_version(): number { return this.data_.bytes.getInt32(this.data_.origin + 16, true);}
				
				public board_version_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 16, src, true); }
				
				public uid(): number { return this.data_.bytes.getUint32(this.data_.origin + 20, true) + this.data_.bytes.getInt32(this.data_.origin + 20 + 4, true) * _Lib.JS_HI;}
				
				public uid_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 20, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 20 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public flight_custom_version(): AUTOPILOT_VERSION.flight_custom_version {
					
					return this.data_.as_field(AUTOPILOT_VERSION.flight_custom_version.field);
				}
				
				public flight_custom_version_(src: AUTOPILOT_VERSION.flight_custom_version | number[]): flight_custom_version {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.AUTOPILOT_VERSION.flight_custom_version.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 28 + index, src[index]);
						return this.data_.as_field(flight_custom_version.field);
					}
					for (let index = 0; index < _Host.AUTOPILOT_VERSION.flight_custom_version.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 28 + index, src.get(index));
					
					return this.data_.as_field(flight_custom_version.field);
				}
				
				public flight_custom_version$(src: Iterator<number>, len: number): flight_custom_version {
					let len_ = Math.min(len, _Host.AUTOPILOT_VERSION.flight_custom_version.item_len);
					
					len = Math.min(len, _Host.AUTOPILOT_VERSION.flight_custom_version.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 28 + index, v.value);
						}
					return this.data_.as_field(flight_custom_version.field);
				}
				
				public middleware_custom_version(): AUTOPILOT_VERSION.middleware_custom_version {
					
					return this.data_.as_field(AUTOPILOT_VERSION.middleware_custom_version.field);
				}
				
				public middleware_custom_version_(src: AUTOPILOT_VERSION.middleware_custom_version | number[]): middleware_custom_version {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.AUTOPILOT_VERSION.middleware_custom_version.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 36 + index, src[index]);
						return this.data_.as_field(middleware_custom_version.field);
					}
					for (let index = 0; index < _Host.AUTOPILOT_VERSION.middleware_custom_version.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 36 + index, src.get(index));
					
					return this.data_.as_field(middleware_custom_version.field);
				}
				
				public middleware_custom_version$(src: Iterator<number>, len: number): middleware_custom_version {
					let len_ = Math.min(len, _Host.AUTOPILOT_VERSION.middleware_custom_version.item_len);
					
					len = Math.min(len, _Host.AUTOPILOT_VERSION.middleware_custom_version.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 36 + index, v.value);
						}
					return this.data_.as_field(middleware_custom_version.field);
				}
				
				public os_custom_version(): AUTOPILOT_VERSION.os_custom_version {
					
					return this.data_.as_field(AUTOPILOT_VERSION.os_custom_version.field);
				}
				
				public os_custom_version_(src: AUTOPILOT_VERSION.os_custom_version | number[]): os_custom_version {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.AUTOPILOT_VERSION.os_custom_version.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 44 + index, src[index]);
						return this.data_.as_field(os_custom_version.field);
					}
					for (let index = 0; index < _Host.AUTOPILOT_VERSION.os_custom_version.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 44 + index, src.get(index));
					
					return this.data_.as_field(os_custom_version.field);
				}
				
				public os_custom_version$(src: Iterator<number>, len: number): os_custom_version {
					let len_ = Math.min(len, _Host.AUTOPILOT_VERSION.os_custom_version.item_len);
					
					len = Math.min(len, _Host.AUTOPILOT_VERSION.os_custom_version.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 44 + index, v.value);
						}
					return this.data_.as_field(os_custom_version.field);
				}
				
				
				public capabilities(): MAV_PROTOCOL_CAPABILITY | null {
					if (this.data_.field_bit != 419 && !this.data_.set_field(419, -1)) return null;
					
					return _Host.MAV_PROTOCOL_CAPABILITY_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 5));
				}
				
				
				public capabilities_(src: MAV_PROTOCOL_CAPABILITY) {
					if (this.data_.field_bit != 419) this.data_.set_field(419, 0);
					
					_Lib.set_bits(_Host.MAV_PROTOCOL_CAPABILITY_.into(src), 5, this.data_.bytes, this.data_.BIT);
				}
				
				
				public uid2_(src: number, d0: number) {
					if (this.data_.field_bit != 420) this.data_.set_field(420, 0);
					this.data_.set_item(d0, 0);
					this.data_.bytes.setInt8(this.data_.BYTE, src);
				}
				
				uid2(): AUTOPILOT_VERSION.uid2 | null {
					return (this.data_.field_bit == 420 || this.data_.set_field(420, -1)) ?
					       this.data_.as_field(AUTOPILOT_VERSION.uid2.field) : null;
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				capabilities_(src: _Host.MAV_PROTOCOL_CAPABILITY);
				
				flight_sw_version_(src: number);
				
				middleware_sw_version_(src: number);
				
				os_sw_version_(src: number);
				
				board_version_(src: number);
				
				flight_custom_version_(src: _Host.AUTOPILOT_VERSION.flight_custom_version);
				
				middleware_custom_version_(src: _Host.AUTOPILOT_VERSION.middleware_custom_version);
				
				os_custom_version_(src: _Host.AUTOPILOT_VERSION.os_custom_version);
				
				vendor_id_(src: number);
				
				product_id_(src: number);
				
				uid_(src: number);
				
				uid2_(src: number, d0: number);
				
			}
			
			export function push_<DST extends DST_>(src: AUTOPILOT_VERSION, dst: DST) {
				
				{
					const item = src.capabilities();
					if (item !== null) dst.capabilities_(item);
					
				}
				
				dst.flight_sw_version_(src.flight_sw_version());
				
				dst.middleware_sw_version_(src.middleware_sw_version());
				
				dst.os_sw_version_(src.os_sw_version());
				
				dst.board_version_(src.board_version());
				dst.flight_custom_version_(src.flight_custom_version());
				dst.middleware_custom_version_(src.middleware_custom_version());
				dst.os_custom_version_(src.os_custom_version());
				
				dst.vendor_id_(src.vendor_id());
				
				dst.product_id_(src.product_id());
				
				dst.uid_(src.uid());
				
				{
					const fld = src.uid2();
					if (fld)
						for (let d0 = 0; d0 < _Host.AUTOPILOT_VERSION.uid2.d0; d0++) {
							const item = fld.get(d0);
							if (item !== null) dst.uid2_(item, d0);
							
						}
				}
				
			}
			
			export interface SRC_ {
				capabilities(): _Host.MAV_PROTOCOL_CAPABILITY | null;
				
				flight_sw_version(): number;
				
				middleware_sw_version(): number;
				
				os_sw_version(): number;
				
				board_version(): number;
				
				flight_custom_version(dst: _Host.AUTOPILOT_VERSION.flight_custom_version);
				
				middleware_custom_version(dst: _Host.AUTOPILOT_VERSION.middleware_custom_version);
				
				os_custom_version(dst: _Host.AUTOPILOT_VERSION.os_custom_version);
				
				vendor_id(): number;
				
				product_id(): number;
				
				uid(): number;
				
				uid2_exist(): boolean;
				
				uid2(d0: number): number | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: AUTOPILOT_VERSION) {
				{
					const item = src.capabilities();
					if (item !== null) dst.capabilities_(item);
					
				}
				
				dst.flight_sw_version_(src.flight_sw_version());
				
				dst.middleware_sw_version_(src.middleware_sw_version());
				
				dst.os_sw_version_(src.os_sw_version());
				
				dst.board_version_(src.board_version());
				src.flight_custom_version(dst.flight_custom_version());
				src.middleware_custom_version(dst.middleware_custom_version());
				src.os_custom_version(dst.os_custom_version());
				
				dst.vendor_id_(src.vendor_id());
				
				dst.product_id_(src.product_id());
				
				dst.uid_(src.uid());
				
				if (src.uid2_exist())
					for (let d0 = 0; d0 < _Host.AUTOPILOT_VERSION.uid2.d0; d0++) {
						const item = src.uid2(d0);
						if (item !== null) dst.uid2_(item, d0);
					}
				
				
			}
			
		}
		
		export interface MISSION_REQUEST_LIST {
			target_system(): number;
			
			target_component(): number;
			
			mission_type(): MAV_MISSION_TYPE | null;
			
		}
		
		export namespace MISSION_REQUEST_LIST {
			
			export const meta_ = new _Pack.Meta(25, 0, 0, 0, 3, 16, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements MISSION_REQUEST_LIST {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public mission_type(): MAV_MISSION_TYPE | null {
					if (this.data_.field_bit != 16 && !this.data_.set_field(16, -1)) return null;
					
					return _Host.MAV_MISSION_TYPE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				mission_type_(src: _Host.MAV_MISSION_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_REQUEST_LIST, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.mission_type();
					if (item !== null) dst.mission_type_(item);
					
				}
				
			}
			
		}
		
		export interface SIMSTATE {
			roll(): number;
			
			roll_(src: number);
			
			pitch(): number;
			
			pitch_(src: number);
			
			yaw(): number;
			
			yaw_(src: number);
			
			xacc(): number;
			
			xacc_(src: number);
			
			yacc(): number;
			
			yacc_(src: number);
			
			zacc(): number;
			
			zacc_(src: number);
			
			xgyro(): number;
			
			xgyro_(src: number);
			
			ygyro(): number;
			
			ygyro_(src: number);
			
			zgyro(): number;
			
			zgyro_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lng(): number;
			
			lng_(src: number);
			
		}
		
		export namespace SIMSTATE {
			
			export const meta_ = new _Pack.Meta(112, 0, 0, 0, 44, 352);
			
			
			class Impl_ extends _Cursor.View implements SIMSTATE {
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public roll_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public pitch_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public yaw_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public xacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public xacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public yacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public yacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public zacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public zacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public xgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public xgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public ygyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public ygyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public zgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public zgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public lat(): number { return this.data_.bytes.getInt32(this.data_.origin + 36, true);}
				
				public lat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 36, src, true); }
				
				public lng(): number { return this.data_.bytes.getInt32(this.data_.origin + 40, true);}
				
				public lng_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 40, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
				xacc_(src: number);
				
				yacc_(src: number);
				
				zacc_(src: number);
				
				xgyro_(src: number);
				
				ygyro_(src: number);
				
				zgyro_(src: number);
				
				lat_(src: number);
				
				lng_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SIMSTATE, dst: DST) {
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
			}
			
			export interface SRC_ {
				roll(): number;
				
				pitch(): number;
				
				yaw(): number;
				
				xacc(): number;
				
				yacc(): number;
				
				zacc(): number;
				
				xgyro(): number;
				
				ygyro(): number;
				
				zgyro(): number;
				
				lat(): number;
				
				lng(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SIMSTATE) {
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
			}
			
		}
		
		export interface SET_VIDEO_STREAM_SETTINGS {
			resolution_h(): number;
			
			resolution_h_(src: number);
			
			resolution_v(): number;
			
			resolution_v_(src: number);
			
			rotation(): number;
			
			rotation_(src: number);
			
			bitrate(): number;
			
			bitrate_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			camera_id(): number;
			
			camera_id_(src: number);
			
			framerate(): number;
			
			framerate_(src: number);
			
			uri(): _Cursor.UTF8 | null;
			
			uri_(src: string | Uint8Array): _Cursor.UTF8;
			
			uri$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace SET_VIDEO_STREAM_SETTINGS {
			
			export const meta_ = new _Pack.Meta(22, 3, 1, 0, 18, 138, 2, 1);
			
			
			export namespace uri {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements SET_VIDEO_STREAM_SETTINGS {
				
				public resolution_h(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public resolution_h_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public resolution_v(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public resolution_v_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public rotation(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public rotation_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public bitrate(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public bitrate_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 10);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 10, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 11);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 11, src); }
				
				public camera_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 12);}
				
				public camera_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 12, src); }
				
				public framerate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 13, true);}
				
				public framerate_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 13, src, true); }
				
				
				uri(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 138 && !this.data_.set_field(138, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				uri_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -138 - 1);
					
					let len = Math.min(src.byteLength, _Host.SET_VIDEO_STREAM_SETTINGS.uri.item_len_max);
					this.data_.set_field(138, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				uri$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.SET_VIDEO_STREAM_SETTINGS.uri.item_len_max)
					this.data_.set_field(138, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				camera_id_(src: number);
				
				framerate_(src: number);
				
				resolution_h_(src: number);
				
				resolution_v_(src: number);
				
				bitrate_(src: number);
				
				rotation_(src: number);
				
				uri_(src: _Cursor.UTF8);
				
			}
			
			export function push_<DST extends DST_>(src: SET_VIDEO_STREAM_SETTINGS, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.camera_id_(src.camera_id());
				
				dst.framerate_(src.framerate());
				
				dst.resolution_h_(src.resolution_h());
				
				dst.resolution_v_(src.resolution_v());
				
				dst.bitrate_(src.bitrate());
				
				dst.rotation_(src.rotation());
				
				{
					const item = src.uri();
					if (item !== null) dst.uri_(item);
					
				}
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				camera_id(): number;
				
				framerate(): number;
				
				resolution_h(): number;
				
				resolution_v(): number;
				
				bitrate(): number;
				
				rotation(): number;
				
				uri(): string | Uint8Array | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SET_VIDEO_STREAM_SETTINGS) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.camera_id_(src.camera_id());
				
				dst.framerate_(src.framerate());
				
				dst.resolution_h_(src.resolution_h());
				
				dst.resolution_v_(src.resolution_v());
				
				dst.bitrate_(src.bitrate());
				
				dst.rotation_(src.rotation());
				
				
				{
					const item = src.uri();
					if (item !== null) dst.uri_(item);
				}
				
				
			}
			
		}
		
		export interface PLAY_TUNE {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			tune(): _Cursor.UTF8 | null;
			
			tune_(src: string | Uint8Array): _Cursor.UTF8;
			
			tune$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace PLAY_TUNE {
			
			export const meta_ = new _Pack.Meta(203, 0, 0, 0, 3, 18, 2, 1);
			
			
			export namespace tune {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements PLAY_TUNE {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				
				tune(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 18 && !this.data_.set_field(18, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				tune_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -18 - 1);
					
					let len = Math.min(src.byteLength, _Host.PLAY_TUNE.tune.item_len_max);
					this.data_.set_field(18, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				tune$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.PLAY_TUNE.tune.item_len_max)
					this.data_.set_field(18, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				tune_(src: _Cursor.UTF8);
				
			}
			
			export function push_<DST extends DST_>(src: PLAY_TUNE, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.tune();
					if (item !== null) dst.tune_(item);
					
				}
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				tune(): string | Uint8Array | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: PLAY_TUNE) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				
				{
					const item = src.tune();
					if (item !== null) dst.tune_(item);
				}
				
				
			}
			
		}
		
		export interface DIGICAM_CONFIGURE {
			shutter_speed(): number;
			
			shutter_speed_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			mode(): number;
			
			mode_(src: number);
			
			aperture(): number;
			
			aperture_(src: number);
			
			iso(): number;
			
			iso_(src: number);
			
			exposure_type(): number;
			
			exposure_type_(src: number);
			
			command_id(): number;
			
			command_id_(src: number);
			
			engine_cut_off(): number;
			
			engine_cut_off_(src: number);
			
			extra_param(): number;
			
			extra_param_(src: number);
			
			extra_value(): number;
			
			extra_value_(src: number);
			
		}
		
		export namespace DIGICAM_CONFIGURE {
			
			export const meta_ = new _Pack.Meta(114, 1, 0, 0, 15, 120);
			
			
			class Impl_ extends _Cursor.View implements DIGICAM_CONFIGURE {
				
				public shutter_speed(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public shutter_speed_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
				public mode(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public mode_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public aperture(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public aperture_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				public iso(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				public iso_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 6, src); }
				
				public exposure_type(): number { return this.data_.bytes.getInt8(this.data_.origin + 7);}
				
				public exposure_type_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 7, src); }
				
				public command_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public command_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
				public engine_cut_off(): number { return this.data_.bytes.getInt8(this.data_.origin + 9);}
				
				public engine_cut_off_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 9, src); }
				
				public extra_param(): number { return this.data_.bytes.getInt8(this.data_.origin + 10);}
				
				public extra_param_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 10, src); }
				
				public extra_value(): number { return this.data_.bytes.getFloat32(this.data_.origin + 11, true);}
				
				public extra_value_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 11, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				mode_(src: number);
				
				shutter_speed_(src: number);
				
				aperture_(src: number);
				
				iso_(src: number);
				
				exposure_type_(src: number);
				
				command_id_(src: number);
				
				engine_cut_off_(src: number);
				
				extra_param_(src: number);
				
				extra_value_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: DIGICAM_CONFIGURE, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.mode_(src.mode());
				
				dst.shutter_speed_(src.shutter_speed());
				
				dst.aperture_(src.aperture());
				
				dst.iso_(src.iso());
				
				dst.exposure_type_(src.exposure_type());
				
				dst.command_id_(src.command_id());
				
				dst.engine_cut_off_(src.engine_cut_off());
				
				dst.extra_param_(src.extra_param());
				
				dst.extra_value_(src.extra_value());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				mode(): number;
				
				shutter_speed(): number;
				
				aperture(): number;
				
				iso(): number;
				
				exposure_type(): number;
				
				command_id(): number;
				
				engine_cut_off(): number;
				
				extra_param(): number;
				
				extra_value(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DIGICAM_CONFIGURE) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.mode_(src.mode());
				
				dst.shutter_speed_(src.shutter_speed());
				
				dst.aperture_(src.aperture());
				
				dst.iso_(src.iso());
				
				dst.exposure_type_(src.exposure_type());
				
				dst.command_id_(src.command_id());
				
				dst.engine_cut_off_(src.engine_cut_off());
				
				dst.extra_param_(src.extra_param());
				
				dst.extra_value_(src.extra_value());
				
			}
			
		}
		
		export interface SCALED_PRESSURE3 {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			press_abs(): number;
			
			press_abs_(src: number);
			
			press_diff(): number;
			
			press_diff_(src: number);
			
			temperature(): number;
			
			temperature_(src: number);
			
		}
		
		export namespace SCALED_PRESSURE3 {
			
			export const meta_ = new _Pack.Meta(130, 0, 1, 0, 14, 112);
			
			
			class Impl_ extends _Cursor.View implements SCALED_PRESSURE3 {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public press_abs(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public press_abs_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public press_diff(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public press_diff_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public temperature(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				public temperature_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 12, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				press_abs_(src: number);
				
				press_diff_(src: number);
				
				temperature_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SCALED_PRESSURE3, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.press_abs_(src.press_abs());
				
				dst.press_diff_(src.press_diff());
				
				dst.temperature_(src.temperature());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				press_abs(): number;
				
				press_diff(): number;
				
				temperature(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SCALED_PRESSURE3) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.press_abs_(src.press_abs());
				
				dst.press_diff_(src.press_diff());
				
				dst.temperature_(src.temperature());
				
			}
			
		}
		
		export interface MISSION_REQUEST_PARTIAL_LIST {
			target_system(): number;
			
			target_component(): number;
			
			start_index(): number;
			
			end_index(): number;
			
			mission_type(): MAV_MISSION_TYPE | null;
			
		}
		
		export namespace MISSION_REQUEST_PARTIAL_LIST {
			
			export const meta_ = new _Pack.Meta(206, 0, 0, 0, 7, 48, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements MISSION_REQUEST_PARTIAL_LIST {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public start_index(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				public end_index(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				
				public mission_type(): MAV_MISSION_TYPE | null {
					if (this.data_.field_bit != 48 && !this.data_.set_field(48, -1)) return null;
					
					return _Host.MAV_MISSION_TYPE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				start_index_(src: number);
				
				end_index_(src: number);
				
				mission_type_(src: _Host.MAV_MISSION_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_REQUEST_PARTIAL_LIST, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.start_index_(src.start_index());
				
				dst.end_index_(src.end_index());
				
				{
					const item = src.mission_type();
					if (item !== null) dst.mission_type_(item);
					
				}
				
			}
			
		}
		
		export interface PARAM_EXT_ACK {
			param_id(): _Cursor.UTF8 | null;
			
			param_id_(src: string | Uint8Array): _Cursor.UTF8;
			
			param_id$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
			param_value(): _Cursor.UTF8 | null;
			
			param_value_(src: string | Uint8Array): _Cursor.UTF8;
			
			param_value$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
			param_type(): MAV_PARAM_EXT_TYPE | null;
			
			param_type_(src: MAV_PARAM_EXT_TYPE);
			
			param_result(): PARAM_ACK | null;
			
			param_result_(src: PARAM_ACK);
			
		}
		
		export namespace PARAM_EXT_ACK {
			
			export const meta_ = new _Pack.Meta(51, 0, 0, 0, 1, 3, 3, 4);
			
			
			export namespace param_id {
				export const item_len_max = 255;
				
			}
			export namespace param_value {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements PARAM_EXT_ACK {
				
				
				param_id(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 3 && !this.data_.set_field(3, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				param_id_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -3 - 1);
					
					let len = Math.min(src.byteLength, _Host.PARAM_EXT_ACK.param_id.item_len_max);
					this.data_.set_field(3, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				param_id$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.PARAM_EXT_ACK.param_id.item_len_max)
					this.data_.set_field(3, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
				param_value(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 4 && !this.data_.set_field(4, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				param_value_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -4 - 1);
					
					let len = Math.min(src.byteLength, _Host.PARAM_EXT_ACK.param_value.item_len_max);
					this.data_.set_field(4, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				param_value$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.PARAM_EXT_ACK.param_value.item_len_max)
					this.data_.set_field(4, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
				public param_type(): MAV_PARAM_EXT_TYPE | null {
					if (this.data_.field_bit != 5 && !this.data_.set_field(5, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public param_type_(src: MAV_PARAM_EXT_TYPE) {
					if (this.data_.field_bit != 5) this.data_.set_field(5, 0);
					
					_Lib.set_bits(src, 4, this.data_.bytes, this.data_.BIT);
				}
				
				
				public param_result(): PARAM_ACK | null {
					if (this.data_.field_bit != 6 && !this.data_.set_field(6, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 2);
				}
				
				
				public param_result_(src: PARAM_ACK) {
					if (this.data_.field_bit != 6) this.data_.set_field(6, 0);
					
					_Lib.set_bits(src, 2, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				param_id_(src: _Cursor.UTF8);
				
				param_value_(src: _Cursor.UTF8);
				
				param_type_(src: _Host.MAV_PARAM_EXT_TYPE);
				
				param_result_(src: _Host.PARAM_ACK);
				
			}
			
			export function push_<DST extends DST_>(src: PARAM_EXT_ACK, dst: DST) {
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
					
				}
				
				{
					const item = src.param_value();
					if (item !== null) dst.param_value_(item);
					
				}
				
				{
					const item = src.param_type();
					if (item !== null) dst.param_type_(item);
					
				}
				
				{
					const item = src.param_result();
					if (item !== null) dst.param_result_(item);
					
				}
				
			}
			
			export interface SRC_ {
				param_id(): string | Uint8Array | null;
				
				param_value(): string | Uint8Array | null;
				
				param_type(): _Host.MAV_PARAM_EXT_TYPE | null;
				
				param_result(): _Host.PARAM_ACK | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: PARAM_EXT_ACK) {
				
				
				{
					const item = src.param_id();
					if (item !== null) dst.param_id_(item);
				}
				
				
				{
					const item = src.param_value();
					if (item !== null) dst.param_value_(item);
				}
				
				{
					const item = src.param_type();
					if (item !== null) dst.param_type_(item);
					
				}
				{
					const item = src.param_result();
					if (item !== null) dst.param_result_(item);
					
				}
				
			}
			
		}
		
		export interface UAVCAN_NODE_INFO {
			uptime_sec(): number;
			
			uptime_sec_(src: number);
			
			sw_vcs_commit(): number;
			
			sw_vcs_commit_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			hw_version_major(): number;
			
			hw_version_major_(src: number);
			
			hw_version_minor(): number;
			
			hw_version_minor_(src: number);
			
			hw_unique_id(): UAVCAN_NODE_INFO.hw_unique_id;
			
			hw_unique_id_(src: UAVCAN_NODE_INFO.hw_unique_id | number[]);
			
			hw_unique_id$(src: Iterator<number>, len: number);
			
			sw_version_major(): number;
			
			sw_version_major_(src: number);
			
			sw_version_minor(): number;
			
			sw_version_minor_(src: number);
			
			name(): _Cursor.UTF8 | null;
			
			name_(src: string | Uint8Array): _Cursor.UTF8;
			
			name$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace UAVCAN_NODE_INFO {
			
			export const meta_ = new _Pack.Meta(127, 0, 2, 1, 37, 290, 2, 1);
			
			
			export interface hw_unique_id extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace hw_unique_id {
				export class Field extends _Cursor.View implements hw_unique_id, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 18 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 18, other.data_.bytes.buffer, other.data_.origin + 18, _Host.UAVCAN_NODE_INFO.hw_unique_id.item_len) === 0;
						for (let i = 0; i < _Host.UAVCAN_NODE_INFO.hw_unique_id.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.UAVCAN_NODE_INFO.hw_unique_id.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 18 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 16;
				
			}
			export namespace name {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements UAVCAN_NODE_INFO {
				
				public uptime_sec(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public uptime_sec_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public sw_vcs_commit(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				public sw_vcs_commit_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 4, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 8, true) + this.data_.bytes.getInt32(this.data_.origin + 8 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 8, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 8 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public hw_version_major(): number { return this.data_.bytes.getInt8(this.data_.origin + 16);}
				
				public hw_version_major_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 16, src); }
				
				public hw_version_minor(): number { return this.data_.bytes.getInt8(this.data_.origin + 17);}
				
				public hw_version_minor_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 17, src); }
				
				public hw_unique_id(): UAVCAN_NODE_INFO.hw_unique_id {
					
					return this.data_.as_field(UAVCAN_NODE_INFO.hw_unique_id.field);
				}
				
				public hw_unique_id_(src: UAVCAN_NODE_INFO.hw_unique_id | number[]): hw_unique_id {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.UAVCAN_NODE_INFO.hw_unique_id.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 18 + index, src[index]);
						return this.data_.as_field(hw_unique_id.field);
					}
					for (let index = 0; index < _Host.UAVCAN_NODE_INFO.hw_unique_id.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 18 + index, src.get(index));
					
					return this.data_.as_field(hw_unique_id.field);
				}
				
				public hw_unique_id$(src: Iterator<number>, len: number): hw_unique_id {
					let len_ = Math.min(len, _Host.UAVCAN_NODE_INFO.hw_unique_id.item_len);
					
					len = Math.min(len, _Host.UAVCAN_NODE_INFO.hw_unique_id.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 18 + index, v.value);
						}
					return this.data_.as_field(hw_unique_id.field);
				}
				
				public sw_version_major(): number { return this.data_.bytes.getInt8(this.data_.origin + 34);}
				
				public sw_version_major_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 34, src); }
				
				public sw_version_minor(): number { return this.data_.bytes.getInt8(this.data_.origin + 35);}
				
				public sw_version_minor_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 35, src); }
				
				
				name(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 290 && !this.data_.set_field(290, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				name_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -290 - 1);
					
					let len = Math.min(src.byteLength, _Host.UAVCAN_NODE_INFO.name.item_len_max);
					this.data_.set_field(290, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				name$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.UAVCAN_NODE_INFO.name.item_len_max)
					this.data_.set_field(290, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				uptime_sec_(src: number);
				
				name_(src: _Cursor.UTF8);
				
				hw_version_major_(src: number);
				
				hw_version_minor_(src: number);
				
				hw_unique_id_(src: _Host.UAVCAN_NODE_INFO.hw_unique_id);
				
				sw_version_major_(src: number);
				
				sw_version_minor_(src: number);
				
				sw_vcs_commit_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: UAVCAN_NODE_INFO, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.uptime_sec_(src.uptime_sec());
				
				{
					const item = src.name();
					if (item !== null) dst.name_(item);
					
				}
				
				dst.hw_version_major_(src.hw_version_major());
				
				dst.hw_version_minor_(src.hw_version_minor());
				dst.hw_unique_id_(src.hw_unique_id());
				
				dst.sw_version_major_(src.sw_version_major());
				
				dst.sw_version_minor_(src.sw_version_minor());
				
				dst.sw_vcs_commit_(src.sw_vcs_commit());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				uptime_sec(): number;
				
				name(): string | Uint8Array | null;
				
				hw_version_major(): number;
				
				hw_version_minor(): number;
				
				hw_unique_id(dst: _Host.UAVCAN_NODE_INFO.hw_unique_id);
				
				sw_version_major(): number;
				
				sw_version_minor(): number;
				
				sw_vcs_commit(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: UAVCAN_NODE_INFO) {
				
				dst.time_usec_(src.time_usec());
				
				dst.uptime_sec_(src.uptime_sec());
				
				
				{
					const item = src.name();
					if (item !== null) dst.name_(item);
				}
				
				
				dst.hw_version_major_(src.hw_version_major());
				
				dst.hw_version_minor_(src.hw_version_minor());
				src.hw_unique_id(dst.hw_unique_id());
				
				dst.sw_version_major_(src.sw_version_major());
				
				dst.sw_version_minor_(src.sw_version_minor());
				
				dst.sw_vcs_commit_(src.sw_vcs_commit());
				
			}
			
		}
		
		export interface DATA16 {
			typE(): number;
			
			typE_(src: number);
			
			len(): number;
			
			len_(src: number);
			
			daTa(): DATA16.daTa;
			
			daTa_(src: DATA16.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace DATA16 {
			
			export const meta_ = new _Pack.Meta(36, 0, 0, 0, 18, 144);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 2 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 2, other.data_.bytes.buffer, other.data_.origin + 2, _Host.DATA16.daTa.item_len) === 0;
						for (let i = 0; i < _Host.DATA16.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.DATA16.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 2 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 16;
				
			}
			
			
			class Impl_ extends _Cursor.View implements DATA16 {
				
				public typE(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public typE_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public len(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public len_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public daTa(): DATA16.daTa {
					
					return this.data_.as_field(DATA16.daTa.field);
				}
				
				public daTa_(src: DATA16.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.DATA16.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.DATA16.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 2 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.DATA16.daTa.item_len);
					
					len = Math.min(len, _Host.DATA16.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				typE_(src: number);
				
				len_(src: number);
				
				daTa_(src: _Host.DATA16.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: DATA16, dst: DST) {
				
				dst.typE_(src.typE());
				
				dst.len_(src.len());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				typE(): number;
				
				len(): number;
				
				daTa(dst: _Host.DATA16.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DATA16) {
				
				dst.typE_(src.typE());
				
				dst.len_(src.len());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface SET_MAG_OFFSETS {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			mag_ofs_x(): number;
			
			mag_ofs_x_(src: number);
			
			mag_ofs_y(): number;
			
			mag_ofs_y_(src: number);
			
			mag_ofs_z(): number;
			
			mag_ofs_z_(src: number);
			
		}
		
		export namespace SET_MAG_OFFSETS {
			
			export const meta_ = new _Pack.Meta(100, 0, 0, 0, 8, 64);
			
			
			class Impl_ extends _Cursor.View implements SET_MAG_OFFSETS {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public mag_ofs_x(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public mag_ofs_x_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public mag_ofs_y(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public mag_ofs_y_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public mag_ofs_z(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				public mag_ofs_z_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 6, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				mag_ofs_x_(src: number);
				
				mag_ofs_y_(src: number);
				
				mag_ofs_z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SET_MAG_OFFSETS, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.mag_ofs_x_(src.mag_ofs_x());
				
				dst.mag_ofs_y_(src.mag_ofs_y());
				
				dst.mag_ofs_z_(src.mag_ofs_z());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				mag_ofs_x(): number;
				
				mag_ofs_y(): number;
				
				mag_ofs_z(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SET_MAG_OFFSETS) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.mag_ofs_x_(src.mag_ofs_x());
				
				dst.mag_ofs_y_(src.mag_ofs_y());
				
				dst.mag_ofs_z_(src.mag_ofs_z());
				
			}
			
		}
		
		export interface AP_ADC {
			adc1(): number;
			
			adc1_(src: number);
			
			adc2(): number;
			
			adc2_(src: number);
			
			adc3(): number;
			
			adc3_(src: number);
			
			adc4(): number;
			
			adc4_(src: number);
			
			adc5(): number;
			
			adc5_(src: number);
			
			adc6(): number;
			
			adc6_(src: number);
			
		}
		
		export namespace AP_ADC {
			
			export const meta_ = new _Pack.Meta(198, 6, 0, 0, 12, 96);
			
			
			class Impl_ extends _Cursor.View implements AP_ADC {
				
				public adc1(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public adc1_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public adc2(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public adc2_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public adc3(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public adc3_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public adc4(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				public adc4_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 6, src, true); }
				
				public adc5(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				public adc5_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 8, src, true); }
				
				public adc6(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				public adc6_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 10, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				adc1_(src: number);
				
				adc2_(src: number);
				
				adc3_(src: number);
				
				adc4_(src: number);
				
				adc5_(src: number);
				
				adc6_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: AP_ADC, dst: DST) {
				
				dst.adc1_(src.adc1());
				
				dst.adc2_(src.adc2());
				
				dst.adc3_(src.adc3());
				
				dst.adc4_(src.adc4());
				
				dst.adc5_(src.adc5());
				
				dst.adc6_(src.adc6());
				
			}
			
			export interface SRC_ {
				adc1(): number;
				
				adc2(): number;
				
				adc3(): number;
				
				adc4(): number;
				
				adc5(): number;
				
				adc6(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: AP_ADC) {
				
				dst.adc1_(src.adc1());
				
				dst.adc2_(src.adc2());
				
				dst.adc3_(src.adc3());
				
				dst.adc4_(src.adc4());
				
				dst.adc5_(src.adc5());
				
				dst.adc6_(src.adc6());
				
			}
			
		}
		
		export interface WIND {
			direction(): number;
			
			direction_(src: number);
			
			speed(): number;
			
			speed_(src: number);
			
			speed_z(): number;
			
			speed_z_(src: number);
			
		}
		
		export namespace WIND {
			
			export const meta_ = new _Pack.Meta(97, 0, 0, 0, 12, 96);
			
			
			class Impl_ extends _Cursor.View implements WIND {
				
				public direction(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public direction_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public speed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public speed_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public speed_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public speed_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				direction_(src: number);
				
				speed_(src: number);
				
				speed_z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: WIND, dst: DST) {
				
				dst.direction_(src.direction());
				
				dst.speed_(src.speed());
				
				dst.speed_z_(src.speed_z());
				
			}
			
			export interface SRC_ {
				direction(): number;
				
				speed(): number;
				
				speed_z(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: WIND) {
				
				dst.direction_(src.direction());
				
				dst.speed_(src.speed());
				
				dst.speed_z_(src.speed_z());
				
			}
			
		}
		
		export interface AUTOPILOT_VERSION_REQUEST {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
		}
		
		export namespace AUTOPILOT_VERSION_REQUEST {
			
			export const meta_ = new _Pack.Meta(142, 0, 0, 0, 2, 16);
			
			
			class Impl_ extends _Cursor.View implements AUTOPILOT_VERSION_REQUEST {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: AUTOPILOT_VERSION_REQUEST, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: AUTOPILOT_VERSION_REQUEST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
			}
			
		}
		
		export interface LOCAL_POSITION_NED {
			time_boot_ms(): number;
			
			x(): number;
			
			y(): number;
			
			z(): number;
			
			vx(): number;
			
			vy(): number;
			
			vz(): number;
			
		}
		
		export namespace LOCAL_POSITION_NED {
			
			export const meta_ = new _Pack.Meta(131, 0, 1, 0, 28, 224);
			
			
			class Impl_ extends _Cursor.View implements LOCAL_POSITION_NED {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public vx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public vy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public vz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				vx_(src: number);
				
				vy_(src: number);
				
				vz_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: LOCAL_POSITION_NED, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
			}
			
		}
		
		export interface DATA_TRANSMISSION_HANDSHAKE {
			width(): number;
			
			width_(src: number);
			
			height(): number;
			
			height_(src: number);
			
			packets(): number;
			
			packets_(src: number);
			
			size(): number;
			
			size_(src: number);
			
			typE(): number;
			
			typE_(src: number);
			
			payload(): number;
			
			payload_(src: number);
			
			jpg_quality(): number;
			
			jpg_quality_(src: number);
			
		}
		
		export namespace DATA_TRANSMISSION_HANDSHAKE {
			
			export const meta_ = new _Pack.Meta(149, 3, 1, 0, 13, 104);
			
			
			class Impl_ extends _Cursor.View implements DATA_TRANSMISSION_HANDSHAKE {
				
				public width(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public width_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public height(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public height_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public packets(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public packets_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public size(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public size_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public typE(): number { return this.data_.bytes.getInt8(this.data_.origin + 10);}
				
				public typE_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 10, src); }
				
				public payload(): number { return this.data_.bytes.getInt8(this.data_.origin + 11);}
				
				public payload_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 11, src); }
				
				public jpg_quality(): number { return this.data_.bytes.getInt8(this.data_.origin + 12);}
				
				public jpg_quality_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 12, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				typE_(src: number);
				
				size_(src: number);
				
				width_(src: number);
				
				height_(src: number);
				
				packets_(src: number);
				
				payload_(src: number);
				
				jpg_quality_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: DATA_TRANSMISSION_HANDSHAKE, dst: DST) {
				
				dst.typE_(src.typE());
				
				dst.size_(src.size());
				
				dst.width_(src.width());
				
				dst.height_(src.height());
				
				dst.packets_(src.packets());
				
				dst.payload_(src.payload());
				
				dst.jpg_quality_(src.jpg_quality());
				
			}
			
			export interface SRC_ {
				typE(): number;
				
				size(): number;
				
				width(): number;
				
				height(): number;
				
				packets(): number;
				
				payload(): number;
				
				jpg_quality(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DATA_TRANSMISSION_HANDSHAKE) {
				
				dst.typE_(src.typE());
				
				dst.size_(src.size());
				
				dst.width_(src.width());
				
				dst.height_(src.height());
				
				dst.packets_(src.packets());
				
				dst.payload_(src.payload());
				
				dst.jpg_quality_(src.jpg_quality());
				
			}
			
		}
		
		export interface GPS_GLOBAL_ORIGIN {
			latitude(): number;
			
			longitude(): number;
			
			altitude(): number;
			
			time_usec(): number | null;
			
		}
		
		export namespace GPS_GLOBAL_ORIGIN {
			
			export const meta_ = new _Pack.Meta(185, 0, 0, 0, 13, 96, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements GPS_GLOBAL_ORIGIN {
				
				public latitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public longitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				
				public altitude(): number { return this.data_.bytes.getInt32(this.data_.origin + 8, true);}
				
				
				public time_usec(): number | null {
					if (this.data_.field_bit != 96 && !this.data_.set_field(96, -1)) return null;
					
					return this.data_.bytes.getUint32(this.data_.BYTE, true) + this.data_.bytes.getInt32(this.data_.BYTE + 4, true) * _Lib.JS_HI;
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				latitude_(src: number);
				
				longitude_(src: number);
				
				altitude_(src: number);
				
				time_usec_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: GPS_GLOBAL_ORIGIN, dst: DST) {
				
				dst.latitude_(src.latitude());
				
				dst.longitude_(src.longitude());
				
				dst.altitude_(src.altitude());
				
				{
					const item = src.time_usec();
					if (item !== null) dst.time_usec_(item);
					
				}
				
			}
			
		}
		
		export interface SCALED_IMU2 {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			xacc(): number;
			
			xacc_(src: number);
			
			yacc(): number;
			
			yacc_(src: number);
			
			zacc(): number;
			
			zacc_(src: number);
			
			xgyro(): number;
			
			xgyro_(src: number);
			
			ygyro(): number;
			
			ygyro_(src: number);
			
			zgyro(): number;
			
			zgyro_(src: number);
			
			xmag(): number;
			
			xmag_(src: number);
			
			ymag(): number;
			
			ymag_(src: number);
			
			zmag(): number;
			
			zmag_(src: number);
			
		}
		
		export namespace SCALED_IMU2 {
			
			export const meta_ = new _Pack.Meta(178, 0, 1, 0, 22, 176);
			
			
			class Impl_ extends _Cursor.View implements SCALED_IMU2 {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public xacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public xacc_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public yacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				public yacc_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 6, src, true); }
				
				public zacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				public zacc_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 8, src, true); }
				
				public xgyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				public xgyro_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 10, src, true); }
				
				public ygyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				public ygyro_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 12, src, true); }
				
				public zgyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				public zgyro_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 14, src, true); }
				
				public xmag(): number { return this.data_.bytes.getInt16(this.data_.origin + 16, true);}
				
				public xmag_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 16, src, true); }
				
				public ymag(): number { return this.data_.bytes.getInt16(this.data_.origin + 18, true);}
				
				public ymag_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 18, src, true); }
				
				public zmag(): number { return this.data_.bytes.getInt16(this.data_.origin + 20, true);}
				
				public zmag_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 20, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				xacc_(src: number);
				
				yacc_(src: number);
				
				zacc_(src: number);
				
				xgyro_(src: number);
				
				ygyro_(src: number);
				
				zgyro_(src: number);
				
				xmag_(src: number);
				
				ymag_(src: number);
				
				zmag_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SCALED_IMU2, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.xmag_(src.xmag());
				
				dst.ymag_(src.ymag());
				
				dst.zmag_(src.zmag());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				xacc(): number;
				
				yacc(): number;
				
				zacc(): number;
				
				xgyro(): number;
				
				ygyro(): number;
				
				zgyro(): number;
				
				xmag(): number;
				
				ymag(): number;
				
				zmag(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SCALED_IMU2) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.xmag_(src.xmag());
				
				dst.ymag_(src.ymag());
				
				dst.zmag_(src.zmag());
				
			}
			
		}
		
		export interface ATTITUDE_QUATERNION {
			time_boot_ms(): number;
			
			q1(): number;
			
			q2(): number;
			
			q3(): number;
			
			q4(): number;
			
			rollspeed(): number;
			
			pitchspeed(): number;
			
			yawspeed(): number;
			
		}
		
		export namespace ATTITUDE_QUATERNION {
			
			export const meta_ = new _Pack.Meta(71, 0, 1, 0, 32, 256);
			
			
			class Impl_ extends _Cursor.View implements ATTITUDE_QUATERNION {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				
				public q1(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				
				public q2(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public q3(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public q4(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public rollspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public pitchspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
				public yawspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				q1_(src: number);
				
				q2_(src: number);
				
				q3_(src: number);
				
				q4_(src: number);
				
				rollspeed_(src: number);
				
				pitchspeed_(src: number);
				
				yawspeed_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: ATTITUDE_QUATERNION, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.q1_(src.q1());
				
				dst.q2_(src.q2());
				
				dst.q3_(src.q3());
				
				dst.q4_(src.q4());
				
				dst.rollspeed_(src.rollspeed());
				
				dst.pitchspeed_(src.pitchspeed());
				
				dst.yawspeed_(src.yawspeed());
				
			}
			
		}
		
		export interface DATA64 {
			typE(): number;
			
			typE_(src: number);
			
			len(): number;
			
			len_(src: number);
			
			daTa(): DATA64.daTa;
			
			daTa_(src: DATA64.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace DATA64 {
			
			export const meta_ = new _Pack.Meta(141, 0, 0, 0, 66, 528);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 2 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 2, other.data_.bytes.buffer, other.data_.origin + 2, _Host.DATA64.daTa.item_len) === 0;
						for (let i = 0; i < _Host.DATA64.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.DATA64.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 2 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 64;
				
			}
			
			
			class Impl_ extends _Cursor.View implements DATA64 {
				
				public typE(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public typE_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public len(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public len_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public daTa(): DATA64.daTa {
					
					return this.data_.as_field(DATA64.daTa.field);
				}
				
				public daTa_(src: DATA64.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.DATA64.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.DATA64.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 2 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.DATA64.daTa.item_len);
					
					len = Math.min(len, _Host.DATA64.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				typE_(src: number);
				
				len_(src: number);
				
				daTa_(src: _Host.DATA64.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: DATA64, dst: DST) {
				
				dst.typE_(src.typE());
				
				dst.len_(src.len());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				typE(): number;
				
				len(): number;
				
				daTa(dst: _Host.DATA64.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DATA64) {
				
				dst.typE_(src.typE());
				
				dst.len_(src.len());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface HIL_ACTUATOR_CONTROLS {
			time_usec(): number;
			
			flags(): number;
			
			controls(): HIL_ACTUATOR_CONTROLS.controls;
			
			mode(): MAV_MODE | null;
			
		}
		
		export namespace HIL_ACTUATOR_CONTROLS {
			
			export const meta_ = new _Pack.Meta(199, 0, 0, 2, 81, 640, 0, 1);
			
			
			export interface controls extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace controls {
				export class Field extends _Cursor.View implements controls, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 16 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 16, other.data_.bytes.buffer, other.data_.origin + 16, _Host.HIL_ACTUATOR_CONTROLS.controls.item_len) === 0;
						for (let i = 0; i < _Host.HIL_ACTUATOR_CONTROLS.controls.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.HIL_ACTUATOR_CONTROLS.controls.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 16;
				
			}
			
			
			class Impl_ extends _Cursor.View implements HIL_ACTUATOR_CONTROLS {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				
				public flags(): number { return this.data_.bytes.getUint32(this.data_.origin + 8, true) + this.data_.bytes.getInt32(this.data_.origin + 8 + 4, true) * _Lib.JS_HI;}
				
				
				public controls(): HIL_ACTUATOR_CONTROLS.controls {
					
					return this.data_.as_field(HIL_ACTUATOR_CONTROLS.controls.field);
				}
				
				
				public mode(): MAV_MODE | null {
					if (this.data_.field_bit != 640 && !this.data_.set_field(640, -1)) return null;
					
					return _Host.MAV_MODE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 4));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				controls_(src: _Host.HIL_ACTUATOR_CONTROLS.controls);
				
				mode_(src: _Host.MAV_MODE);
				
				flags_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HIL_ACTUATOR_CONTROLS, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				dst.controls_(src.controls());
				
				{
					const item = src.mode();
					if (item !== null) dst.mode_(item);
					
				}
				
				dst.flags_(src.flags());
				
			}
			
		}
		
		export interface POSITION_TARGET_LOCAL_NED {
			type_mask(): number;
			
			time_boot_ms(): number;
			
			x(): number;
			
			y(): number;
			
			z(): number;
			
			vx(): number;
			
			vy(): number;
			
			vz(): number;
			
			afx(): number;
			
			afy(): number;
			
			afz(): number;
			
			yaw(): number;
			
			yaw_rate(): number;
			
			coordinate_frame(): MAV_FRAME | null;
			
		}
		
		export namespace POSITION_TARGET_LOCAL_NED {
			
			export const meta_ = new _Pack.Meta(129, 1, 1, 0, 51, 400, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements POSITION_TARGET_LOCAL_NED {
				
				public type_mask(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 2, true);}
				
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 6, true);}
				
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 10, true);}
				
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 14, true);}
				
				
				public vx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 18, true);}
				
				
				public vy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 22, true);}
				
				
				public vz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 26, true);}
				
				
				public afx(): number { return this.data_.bytes.getFloat32(this.data_.origin + 30, true);}
				
				
				public afy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 34, true);}
				
				
				public afz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 38, true);}
				
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 42, true);}
				
				
				public yaw_rate(): number { return this.data_.bytes.getFloat32(this.data_.origin + 46, true);}
				
				
				public coordinate_frame(): MAV_FRAME | null {
					if (this.data_.field_bit != 400 && !this.data_.set_field(400, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				coordinate_frame_(src: _Host.MAV_FRAME);
				
				type_mask_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				vx_(src: number);
				
				vy_(src: number);
				
				vz_(src: number);
				
				afx_(src: number);
				
				afy_(src: number);
				
				afz_(src: number);
				
				yaw_(src: number);
				
				yaw_rate_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: POSITION_TARGET_LOCAL_NED, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				{
					const item = src.coordinate_frame();
					if (item !== null) dst.coordinate_frame_(item);
					
				}
				
				dst.type_mask_(src.type_mask());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				dst.vx_(src.vx());
				
				dst.vy_(src.vy());
				
				dst.vz_(src.vz());
				
				dst.afx_(src.afx());
				
				dst.afy_(src.afy());
				
				dst.afz_(src.afz());
				
				dst.yaw_(src.yaw());
				
				dst.yaw_rate_(src.yaw_rate());
				
			}
			
		}
		
		export interface GIMBAL_REPORT {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			delta_time(): number;
			
			delta_time_(src: number);
			
			delta_angle_x(): number;
			
			delta_angle_x_(src: number);
			
			delta_angle_y(): number;
			
			delta_angle_y_(src: number);
			
			delta_angle_z(): number;
			
			delta_angle_z_(src: number);
			
			delta_velocity_x(): number;
			
			delta_velocity_x_(src: number);
			
			delta_velocity_y(): number;
			
			delta_velocity_y_(src: number);
			
			delta_velocity_z(): number;
			
			delta_velocity_z_(src: number);
			
			joint_roll(): number;
			
			joint_roll_(src: number);
			
			joint_el(): number;
			
			joint_el_(src: number);
			
			joint_az(): number;
			
			joint_az_(src: number);
			
		}
		
		export namespace GIMBAL_REPORT {
			
			export const meta_ = new _Pack.Meta(11, 0, 0, 0, 42, 336);
			
			
			class Impl_ extends _Cursor.View implements GIMBAL_REPORT {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public delta_time(): number { return this.data_.bytes.getFloat32(this.data_.origin + 2, true);}
				
				public delta_time_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 2, src, true); }
				
				public delta_angle_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 6, true);}
				
				public delta_angle_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 6, src, true); }
				
				public delta_angle_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 10, true);}
				
				public delta_angle_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 10, src, true); }
				
				public delta_angle_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 14, true);}
				
				public delta_angle_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 14, src, true); }
				
				public delta_velocity_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 18, true);}
				
				public delta_velocity_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 18, src, true); }
				
				public delta_velocity_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 22, true);}
				
				public delta_velocity_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 22, src, true); }
				
				public delta_velocity_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 26, true);}
				
				public delta_velocity_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 26, src, true); }
				
				public joint_roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 30, true);}
				
				public joint_roll_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 30, src, true); }
				
				public joint_el(): number { return this.data_.bytes.getFloat32(this.data_.origin + 34, true);}
				
				public joint_el_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 34, src, true); }
				
				public joint_az(): number { return this.data_.bytes.getFloat32(this.data_.origin + 38, true);}
				
				public joint_az_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 38, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				delta_time_(src: number);
				
				delta_angle_x_(src: number);
				
				delta_angle_y_(src: number);
				
				delta_angle_z_(src: number);
				
				delta_velocity_x_(src: number);
				
				delta_velocity_y_(src: number);
				
				delta_velocity_z_(src: number);
				
				joint_roll_(src: number);
				
				joint_el_(src: number);
				
				joint_az_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: GIMBAL_REPORT, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.delta_time_(src.delta_time());
				
				dst.delta_angle_x_(src.delta_angle_x());
				
				dst.delta_angle_y_(src.delta_angle_y());
				
				dst.delta_angle_z_(src.delta_angle_z());
				
				dst.delta_velocity_x_(src.delta_velocity_x());
				
				dst.delta_velocity_y_(src.delta_velocity_y());
				
				dst.delta_velocity_z_(src.delta_velocity_z());
				
				dst.joint_roll_(src.joint_roll());
				
				dst.joint_el_(src.joint_el());
				
				dst.joint_az_(src.joint_az());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				delta_time(): number;
				
				delta_angle_x(): number;
				
				delta_angle_y(): number;
				
				delta_angle_z(): number;
				
				delta_velocity_x(): number;
				
				delta_velocity_y(): number;
				
				delta_velocity_z(): number;
				
				joint_roll(): number;
				
				joint_el(): number;
				
				joint_az(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GIMBAL_REPORT) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.delta_time_(src.delta_time());
				
				dst.delta_angle_x_(src.delta_angle_x());
				
				dst.delta_angle_y_(src.delta_angle_y());
				
				dst.delta_angle_z_(src.delta_angle_z());
				
				dst.delta_velocity_x_(src.delta_velocity_x());
				
				dst.delta_velocity_y_(src.delta_velocity_y());
				
				dst.delta_velocity_z_(src.delta_velocity_z());
				
				dst.joint_roll_(src.joint_roll());
				
				dst.joint_el_(src.joint_el());
				
				dst.joint_az_(src.joint_az());
				
			}
			
		}
		
		export interface DEVICE_OP_WRITE {
			request_id(): number;
			
			request_id_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			bus(): number;
			
			bus_(src: number);
			
			address(): number;
			
			address_(src: number);
			
			regstart(): number;
			
			regstart_(src: number);
			
			count(): number;
			
			count_(src: number);
			
			daTa(): DEVICE_OP_WRITE.daTa;
			
			daTa_(src: DEVICE_OP_WRITE.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
			bustype(): DEVICE_OP_BUSTYPE | null;
			
			bustype_(src: DEVICE_OP_BUSTYPE);
			
			busname(): _Cursor.UTF8 | null;
			
			busname_(src: string | Uint8Array): _Cursor.UTF8;
			
			busname$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace DEVICE_OP_WRITE {
			
			export const meta_ = new _Pack.Meta(105, 0, 1, 0, 139, 1106, 2, 2);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 10 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 10, other.data_.bytes.buffer, other.data_.origin + 10, _Host.DEVICE_OP_WRITE.daTa.item_len) === 0;
						for (let i = 0; i < _Host.DEVICE_OP_WRITE.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.DEVICE_OP_WRITE.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 10 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 128;
				
			}
			export namespace busname {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements DEVICE_OP_WRITE {
				
				public request_id(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public request_id_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				public bus(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				public bus_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 6, src); }
				
				public address(): number { return this.data_.bytes.getInt8(this.data_.origin + 7);}
				
				public address_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 7, src); }
				
				public regstart(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public regstart_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
				public count(): number { return this.data_.bytes.getInt8(this.data_.origin + 9);}
				
				public count_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 9, src); }
				
				public daTa(): DEVICE_OP_WRITE.daTa {
					
					return this.data_.as_field(DEVICE_OP_WRITE.daTa.field);
				}
				
				public daTa_(src: DEVICE_OP_WRITE.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.DEVICE_OP_WRITE.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 10 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.DEVICE_OP_WRITE.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 10 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.DEVICE_OP_WRITE.daTa.item_len);
					
					len = Math.min(len, _Host.DEVICE_OP_WRITE.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 10 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
				
				public bustype(): DEVICE_OP_BUSTYPE | null {
					if (this.data_.field_bit != 1106 && !this.data_.set_field(1106, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 1);
				}
				
				
				public bustype_(src: DEVICE_OP_BUSTYPE) {
					if (this.data_.field_bit != 1106) this.data_.set_field(1106, 0);
					
					_Lib.set_bits(src, 1, this.data_.bytes, this.data_.BIT);
				}
				
				
				busname(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 1107 && !this.data_.set_field(1107, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				busname_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -1107 - 1);
					
					let len = Math.min(src.byteLength, _Host.DEVICE_OP_WRITE.busname.item_len_max);
					this.data_.set_field(1107, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				busname$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.DEVICE_OP_WRITE.busname.item_len_max)
					this.data_.set_field(1107, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				request_id_(src: number);
				
				bustype_(src: _Host.DEVICE_OP_BUSTYPE);
				
				bus_(src: number);
				
				address_(src: number);
				
				busname_(src: _Cursor.UTF8);
				
				regstart_(src: number);
				
				count_(src: number);
				
				daTa_(src: _Host.DEVICE_OP_WRITE.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: DEVICE_OP_WRITE, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.request_id_(src.request_id());
				
				{
					const item = src.bustype();
					if (item !== null) dst.bustype_(item);
					
				}
				
				dst.bus_(src.bus());
				
				dst.address_(src.address());
				
				{
					const item = src.busname();
					if (item !== null) dst.busname_(item);
					
				}
				
				dst.regstart_(src.regstart());
				
				dst.count_(src.count());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				request_id(): number;
				
				bustype(): _Host.DEVICE_OP_BUSTYPE | null;
				
				bus(): number;
				
				address(): number;
				
				busname(): string | Uint8Array | null;
				
				regstart(): number;
				
				count(): number;
				
				daTa(dst: _Host.DEVICE_OP_WRITE.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DEVICE_OP_WRITE) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.request_id_(src.request_id());
				{
					const item = src.bustype();
					if (item !== null) dst.bustype_(item);
					
				}
				
				dst.bus_(src.bus());
				
				dst.address_(src.address());
				
				
				{
					const item = src.busname();
					if (item !== null) dst.busname_(item);
				}
				
				
				dst.regstart_(src.regstart());
				
				dst.count_(src.count());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface DISTANCE_SENSOR {
			min_distance(): number;
			
			min_distance_(src: number);
			
			max_distance(): number;
			
			max_distance_(src: number);
			
			current_distance(): number;
			
			current_distance_(src: number);
			
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			id(): number;
			
			id_(src: number);
			
			covariance(): number;
			
			covariance_(src: number);
			
			typE(): MAV_DISTANCE_SENSOR | null;
			
			typE_(src: MAV_DISTANCE_SENSOR);
			
			orientation(): MAV_SENSOR_ORIENTATION | null;
			
			orientation_(src: MAV_SENSOR_ORIENTATION);
			
		}
		
		export namespace DISTANCE_SENSOR {
			
			export const meta_ = new _Pack.Meta(61, 3, 1, 0, 13, 98, 2, 2);
			
			
			class Impl_ extends _Cursor.View implements DISTANCE_SENSOR {
				
				public min_distance(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public min_distance_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public max_distance(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public max_distance_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public current_distance(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public current_distance_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public id(): number { return this.data_.bytes.getInt8(this.data_.origin + 10);}
				
				public id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 10, src); }
				
				public covariance(): number { return this.data_.bytes.getInt8(this.data_.origin + 11);}
				
				public covariance_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 11, src); }
				
				
				public typE(): MAV_DISTANCE_SENSOR | null {
					if (this.data_.field_bit != 98 && !this.data_.set_field(98, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public typE_(src: MAV_DISTANCE_SENSOR) {
					if (this.data_.field_bit != 98) this.data_.set_field(98, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				public orientation(): MAV_SENSOR_ORIENTATION | null {
					if (this.data_.field_bit != 99 && !this.data_.set_field(99, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 6);
				}
				
				
				public orientation_(src: MAV_SENSOR_ORIENTATION) {
					if (this.data_.field_bit != 99) this.data_.set_field(99, 0);
					
					_Lib.set_bits(src, 6, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				min_distance_(src: number);
				
				max_distance_(src: number);
				
				current_distance_(src: number);
				
				typE_(src: _Host.MAV_DISTANCE_SENSOR);
				
				id_(src: number);
				
				orientation_(src: _Host.MAV_SENSOR_ORIENTATION);
				
				covariance_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: DISTANCE_SENSOR, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.min_distance_(src.min_distance());
				
				dst.max_distance_(src.max_distance());
				
				dst.current_distance_(src.current_distance());
				
				{
					const item = src.typE();
					if (item !== null) dst.typE_(item);
					
				}
				
				dst.id_(src.id());
				
				{
					const item = src.orientation();
					if (item !== null) dst.orientation_(item);
					
				}
				
				dst.covariance_(src.covariance());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				min_distance(): number;
				
				max_distance(): number;
				
				current_distance(): number;
				
				typE(): _Host.MAV_DISTANCE_SENSOR | null;
				
				id(): number;
				
				orientation(): _Host.MAV_SENSOR_ORIENTATION | null;
				
				covariance(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DISTANCE_SENSOR) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.min_distance_(src.min_distance());
				
				dst.max_distance_(src.max_distance());
				
				dst.current_distance_(src.current_distance());
				{
					const item = src.typE();
					if (item !== null) dst.typE_(item);
					
				}
				
				dst.id_(src.id());
				{
					const item = src.orientation();
					if (item !== null) dst.orientation_(item);
					
				}
				
				dst.covariance_(src.covariance());
				
			}
			
		}
		
		export interface HIL_OPTICAL_FLOW {
			integration_time_us(): number;
			
			integration_time_us_(src: number);
			
			time_delta_distance_us(): number;
			
			time_delta_distance_us_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			sensor_id(): number;
			
			sensor_id_(src: number);
			
			integrated_x(): number;
			
			integrated_x_(src: number);
			
			integrated_y(): number;
			
			integrated_y_(src: number);
			
			integrated_xgyro(): number;
			
			integrated_xgyro_(src: number);
			
			integrated_ygyro(): number;
			
			integrated_ygyro_(src: number);
			
			integrated_zgyro(): number;
			
			integrated_zgyro_(src: number);
			
			temperature(): number;
			
			temperature_(src: number);
			
			quality(): number;
			
			quality_(src: number);
			
			distance(): number;
			
			distance_(src: number);
			
		}
		
		export namespace HIL_OPTICAL_FLOW {
			
			export const meta_ = new _Pack.Meta(116, 0, 2, 1, 44, 352);
			
			
			class Impl_ extends _Cursor.View implements HIL_OPTICAL_FLOW {
				
				public integration_time_us(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public integration_time_us_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public time_delta_distance_us(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				public time_delta_distance_us_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 4, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 8, true) + this.data_.bytes.getInt32(this.data_.origin + 8 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 8, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 8 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public sensor_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 16);}
				
				public sensor_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 16, src); }
				
				public integrated_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 17, true);}
				
				public integrated_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 17, src, true); }
				
				public integrated_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 21, true);}
				
				public integrated_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 21, src, true); }
				
				public integrated_xgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 25, true);}
				
				public integrated_xgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 25, src, true); }
				
				public integrated_ygyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 29, true);}
				
				public integrated_ygyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 29, src, true); }
				
				public integrated_zgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 33, true);}
				
				public integrated_zgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 33, src, true); }
				
				public temperature(): number { return this.data_.bytes.getInt16(this.data_.origin + 37, true);}
				
				public temperature_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 37, src, true); }
				
				public quality(): number { return this.data_.bytes.getInt8(this.data_.origin + 39);}
				
				public quality_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 39, src); }
				
				public distance(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				public distance_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 40, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				sensor_id_(src: number);
				
				integration_time_us_(src: number);
				
				integrated_x_(src: number);
				
				integrated_y_(src: number);
				
				integrated_xgyro_(src: number);
				
				integrated_ygyro_(src: number);
				
				integrated_zgyro_(src: number);
				
				temperature_(src: number);
				
				quality_(src: number);
				
				time_delta_distance_us_(src: number);
				
				distance_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HIL_OPTICAL_FLOW, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.sensor_id_(src.sensor_id());
				
				dst.integration_time_us_(src.integration_time_us());
				
				dst.integrated_x_(src.integrated_x());
				
				dst.integrated_y_(src.integrated_y());
				
				dst.integrated_xgyro_(src.integrated_xgyro());
				
				dst.integrated_ygyro_(src.integrated_ygyro());
				
				dst.integrated_zgyro_(src.integrated_zgyro());
				
				dst.temperature_(src.temperature());
				
				dst.quality_(src.quality());
				
				dst.time_delta_distance_us_(src.time_delta_distance_us());
				
				dst.distance_(src.distance());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				sensor_id(): number;
				
				integration_time_us(): number;
				
				integrated_x(): number;
				
				integrated_y(): number;
				
				integrated_xgyro(): number;
				
				integrated_ygyro(): number;
				
				integrated_zgyro(): number;
				
				temperature(): number;
				
				quality(): number;
				
				time_delta_distance_us(): number;
				
				distance(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: HIL_OPTICAL_FLOW) {
				
				dst.time_usec_(src.time_usec());
				
				dst.sensor_id_(src.sensor_id());
				
				dst.integration_time_us_(src.integration_time_us());
				
				dst.integrated_x_(src.integrated_x());
				
				dst.integrated_y_(src.integrated_y());
				
				dst.integrated_xgyro_(src.integrated_xgyro());
				
				dst.integrated_ygyro_(src.integrated_ygyro());
				
				dst.integrated_zgyro_(src.integrated_zgyro());
				
				dst.temperature_(src.temperature());
				
				dst.quality_(src.quality());
				
				dst.time_delta_distance_us_(src.time_delta_distance_us());
				
				dst.distance_(src.distance());
				
			}
			
		}
		
		export interface SCALED_PRESSURE2 {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			press_abs(): number;
			
			press_abs_(src: number);
			
			press_diff(): number;
			
			press_diff_(src: number);
			
			temperature(): number;
			
			temperature_(src: number);
			
		}
		
		export namespace SCALED_PRESSURE2 {
			
			export const meta_ = new _Pack.Meta(151, 0, 1, 0, 14, 112);
			
			
			class Impl_ extends _Cursor.View implements SCALED_PRESSURE2 {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public press_abs(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public press_abs_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public press_diff(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public press_diff_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public temperature(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				public temperature_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 12, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				press_abs_(src: number);
				
				press_diff_(src: number);
				
				temperature_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SCALED_PRESSURE2, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.press_abs_(src.press_abs());
				
				dst.press_diff_(src.press_diff());
				
				dst.temperature_(src.temperature());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				press_abs(): number;
				
				press_diff(): number;
				
				temperature(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: SCALED_PRESSURE2) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				dst.press_abs_(src.press_abs());
				
				dst.press_diff_(src.press_diff());
				
				dst.temperature_(src.temperature());
				
			}
			
		}
		
		export interface WIND_COV {
			time_usec(): number;
			
			time_usec_(src: number);
			
			wind_x(): number;
			
			wind_x_(src: number);
			
			wind_y(): number;
			
			wind_y_(src: number);
			
			wind_z(): number;
			
			wind_z_(src: number);
			
			var_horiz(): number;
			
			var_horiz_(src: number);
			
			var_vert(): number;
			
			var_vert_(src: number);
			
			wind_alt(): number;
			
			wind_alt_(src: number);
			
			horiz_accuracy(): number;
			
			horiz_accuracy_(src: number);
			
			vert_accuracy(): number;
			
			vert_accuracy_(src: number);
			
		}
		
		export namespace WIND_COV {
			
			export const meta_ = new _Pack.Meta(160, 0, 0, 1, 40, 320);
			
			
			class Impl_ extends _Cursor.View implements WIND_COV {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public wind_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public wind_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
				public wind_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				public wind_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 12, src, true); }
				
				public wind_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				public wind_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 16, src, true); }
				
				public var_horiz(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				public var_horiz_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 20, src, true); }
				
				public var_vert(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				public var_vert_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 24, src, true); }
				
				public wind_alt(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				public wind_alt_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 28, src, true); }
				
				public horiz_accuracy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				public horiz_accuracy_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 32, src, true); }
				
				public vert_accuracy(): number { return this.data_.bytes.getFloat32(this.data_.origin + 36, true);}
				
				public vert_accuracy_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 36, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				wind_x_(src: number);
				
				wind_y_(src: number);
				
				wind_z_(src: number);
				
				var_horiz_(src: number);
				
				var_vert_(src: number);
				
				wind_alt_(src: number);
				
				horiz_accuracy_(src: number);
				
				vert_accuracy_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: WIND_COV, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.wind_x_(src.wind_x());
				
				dst.wind_y_(src.wind_y());
				
				dst.wind_z_(src.wind_z());
				
				dst.var_horiz_(src.var_horiz());
				
				dst.var_vert_(src.var_vert());
				
				dst.wind_alt_(src.wind_alt());
				
				dst.horiz_accuracy_(src.horiz_accuracy());
				
				dst.vert_accuracy_(src.vert_accuracy());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				wind_x(): number;
				
				wind_y(): number;
				
				wind_z(): number;
				
				var_horiz(): number;
				
				var_vert(): number;
				
				wind_alt(): number;
				
				horiz_accuracy(): number;
				
				vert_accuracy(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: WIND_COV) {
				
				dst.time_usec_(src.time_usec());
				
				dst.wind_x_(src.wind_x());
				
				dst.wind_y_(src.wind_y());
				
				dst.wind_z_(src.wind_z());
				
				dst.var_horiz_(src.var_horiz());
				
				dst.var_vert_(src.var_vert());
				
				dst.wind_alt_(src.wind_alt());
				
				dst.horiz_accuracy_(src.horiz_accuracy());
				
				dst.vert_accuracy_(src.vert_accuracy());
				
			}
			
		}
		
		export interface CHANGE_OPERATOR_CONTROL {
			target_system(): number;
			
			control_request(): number;
			
			version(): number;
			
			passkey(): _Cursor.UTF8 | null;
			
		}
		
		export namespace CHANGE_OPERATOR_CONTROL {
			
			export const meta_ = new _Pack.Meta(154, 0, 0, 0, 4, 26, 2, 1);
			
			
			export namespace passkey {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements CHANGE_OPERATOR_CONTROL {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public control_request(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public version(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				passkey(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 26 && !this.data_.set_field(26, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				control_request_(src: number);
				
				version_(src: number);
				
				passkey_(src: _Cursor.UTF8);
				
			}
			
			export function push_<DST extends DST_>(src: CHANGE_OPERATOR_CONTROL, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.control_request_(src.control_request());
				
				dst.version_(src.version());
				
				{
					const item = src.passkey();
					if (item !== null) dst.passkey_(item);
					
				}
				
			}
			
		}
		
		export interface GOPRO_SET_REQUEST {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			value(): GOPRO_SET_REQUEST.value;
			
			value_(src: GOPRO_SET_REQUEST.value | number[]);
			
			value$(src: Iterator<number>, len: number);
			
			cmd_id(): GOPRO_COMMAND | null;
			
			cmd_id_(src: GOPRO_COMMAND);
			
		}
		
		export namespace GOPRO_SET_REQUEST {
			
			export const meta_ = new _Pack.Meta(118, 0, 0, 0, 7, 48, 0, 1);
			
			
			export interface value extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace value {
				export class Field extends _Cursor.View implements value, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 2 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 2, other.data_.bytes.buffer, other.data_.origin + 2, _Host.GOPRO_SET_REQUEST.value.item_len) === 0;
						for (let i = 0; i < _Host.GOPRO_SET_REQUEST.value.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.GOPRO_SET_REQUEST.value.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 2 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			
			
			class Impl_ extends _Cursor.View implements GOPRO_SET_REQUEST {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public value(): GOPRO_SET_REQUEST.value {
					
					return this.data_.as_field(GOPRO_SET_REQUEST.value.field);
				}
				
				public value_(src: GOPRO_SET_REQUEST.value | number[]): value {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.GOPRO_SET_REQUEST.value.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, src[index]);
						return this.data_.as_field(value.field);
					}
					for (let index = 0; index < _Host.GOPRO_SET_REQUEST.value.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 2 + index, src.get(index));
					
					return this.data_.as_field(value.field);
				}
				
				public value$(src: Iterator<number>, len: number): value {
					let len_ = Math.min(len, _Host.GOPRO_SET_REQUEST.value.item_len);
					
					len = Math.min(len, _Host.GOPRO_SET_REQUEST.value.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, v.value);
						}
					return this.data_.as_field(value.field);
				}
				
				
				public cmd_id(): GOPRO_COMMAND | null {
					if (this.data_.field_bit != 48 && !this.data_.set_field(48, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 5);
				}
				
				
				public cmd_id_(src: GOPRO_COMMAND) {
					if (this.data_.field_bit != 48) this.data_.set_field(48, 0);
					
					_Lib.set_bits(src, 5, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				cmd_id_(src: _Host.GOPRO_COMMAND);
				
				value_(src: _Host.GOPRO_SET_REQUEST.value);
				
			}
			
			export function push_<DST extends DST_>(src: GOPRO_SET_REQUEST, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.cmd_id();
					if (item !== null) dst.cmd_id_(item);
					
				}
				dst.value_(src.value());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				cmd_id(): _Host.GOPRO_COMMAND | null;
				
				value(dst: _Host.GOPRO_SET_REQUEST.value);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GOPRO_SET_REQUEST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				{
					const item = src.cmd_id();
					if (item !== null) dst.cmd_id_(item);
					
				}
				src.value(dst.value());
				
			}
			
		}
		
		export interface SYS_STATUS {
			load(): number;
			
			voltage_battery(): number;
			
			drop_rate_comm(): number;
			
			errors_comm(): number;
			
			errors_count1(): number;
			
			errors_count2(): number;
			
			errors_count3(): number;
			
			errors_count4(): number;
			
			current_battery(): number;
			
			battery_remaining(): number;
			
			onboard_control_sensors_present(): MAV_SYS_STATUS_SENSOR | null;
			
			onboard_control_sensors_enabled(): MAV_SYS_STATUS_SENSOR | null;
			
			onboard_control_sensors_health(): MAV_SYS_STATUS_SENSOR | null;
			
		}
		
		export namespace SYS_STATUS {
			
			export const meta_ = new _Pack.Meta(132, 8, 0, 0, 20, 154, 2, 3);
			
			
			class Impl_ extends _Cursor.View implements SYS_STATUS {
				
				public load(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public voltage_battery(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				
				public drop_rate_comm(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				
				public errors_comm(): number { return this.data_.bytes.getInt16(this.data_.origin + 6, true);}
				
				
				public errors_count1(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				
				public errors_count2(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				
				public errors_count3(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				
				public errors_count4(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				
				public current_battery(): number { return this.data_.bytes.getInt16(this.data_.origin + 16, true);}
				
				
				public battery_remaining(): number { return this.data_.bytes.getInt8(this.data_.origin + 18);}
				
				
				public onboard_control_sensors_present(): MAV_SYS_STATUS_SENSOR | null {
					if (this.data_.field_bit != 154 && !this.data_.set_field(154, -1)) return null;
					
					return _Host.MAV_SYS_STATUS_SENSOR_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 5));
				}
				
				
				public onboard_control_sensors_enabled(): MAV_SYS_STATUS_SENSOR | null {
					if (this.data_.field_bit != 155 && !this.data_.set_field(155, -1)) return null;
					
					return _Host.MAV_SYS_STATUS_SENSOR_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 5));
				}
				
				
				public onboard_control_sensors_health(): MAV_SYS_STATUS_SENSOR | null {
					if (this.data_.field_bit != 156 && !this.data_.set_field(156, -1)) return null;
					
					return _Host.MAV_SYS_STATUS_SENSOR_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 5));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				onboard_control_sensors_present_(src: _Host.MAV_SYS_STATUS_SENSOR);
				
				onboard_control_sensors_enabled_(src: _Host.MAV_SYS_STATUS_SENSOR);
				
				onboard_control_sensors_health_(src: _Host.MAV_SYS_STATUS_SENSOR);
				
				load_(src: number);
				
				voltage_battery_(src: number);
				
				current_battery_(src: number);
				
				battery_remaining_(src: number);
				
				drop_rate_comm_(src: number);
				
				errors_comm_(src: number);
				
				errors_count1_(src: number);
				
				errors_count2_(src: number);
				
				errors_count3_(src: number);
				
				errors_count4_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: SYS_STATUS, dst: DST) {
				
				{
					const item = src.onboard_control_sensors_present();
					if (item !== null) dst.onboard_control_sensors_present_(item);
					
				}
				
				{
					const item = src.onboard_control_sensors_enabled();
					if (item !== null) dst.onboard_control_sensors_enabled_(item);
					
				}
				
				{
					const item = src.onboard_control_sensors_health();
					if (item !== null) dst.onboard_control_sensors_health_(item);
					
				}
				
				dst.load_(src.load());
				
				dst.voltage_battery_(src.voltage_battery());
				
				dst.current_battery_(src.current_battery());
				
				dst.battery_remaining_(src.battery_remaining());
				
				dst.drop_rate_comm_(src.drop_rate_comm());
				
				dst.errors_comm_(src.errors_comm());
				
				dst.errors_count1_(src.errors_count1());
				
				dst.errors_count2_(src.errors_count2());
				
				dst.errors_count3_(src.errors_count3());
				
				dst.errors_count4_(src.errors_count4());
				
			}
			
		}
		
		export interface MISSION_ITEM {
			seq(): number;
			
			target_system(): number;
			
			target_component(): number;
			
			current(): number;
			
			autocontinue(): number;
			
			param1(): number;
			
			param2(): number;
			
			param3(): number;
			
			param4(): number;
			
			x(): number;
			
			y(): number;
			
			z(): number;
			
			frame(): MAV_FRAME | null;
			
			command(): MAV_CMD | null;
			
			mission_type(): MAV_MISSION_TYPE | null;
			
		}
		
		export namespace MISSION_ITEM {
			
			export const meta_ = new _Pack.Meta(35, 1, 0, 0, 35, 274, 2, 3);
			
			
			class Impl_ extends _Cursor.View implements MISSION_ITEM {
				
				public seq(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				
				public current(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				
				public autocontinue(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				
				public param1(): number { return this.data_.bytes.getFloat32(this.data_.origin + 6, true);}
				
				
				public param2(): number { return this.data_.bytes.getFloat32(this.data_.origin + 10, true);}
				
				
				public param3(): number { return this.data_.bytes.getFloat32(this.data_.origin + 14, true);}
				
				
				public param4(): number { return this.data_.bytes.getFloat32(this.data_.origin + 18, true);}
				
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 22, true);}
				
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 26, true);}
				
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 30, true);}
				
				
				public frame(): MAV_FRAME | null {
					if (this.data_.field_bit != 274 && !this.data_.set_field(274, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public command(): MAV_CMD | null {
					if (this.data_.field_bit != 275 && !this.data_.set_field(275, -1)) return null;
					
					return _Host.MAV_CMD_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 8));
				}
				
				
				public mission_type(): MAV_MISSION_TYPE | null {
					if (this.data_.field_bit != 276 && !this.data_.set_field(276, -1)) return null;
					
					return _Host.MAV_MISSION_TYPE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				seq_(src: number);
				
				frame_(src: _Host.MAV_FRAME);
				
				command_(src: _Host.MAV_CMD);
				
				current_(src: number);
				
				autocontinue_(src: number);
				
				param1_(src: number);
				
				param2_(src: number);
				
				param3_(src: number);
				
				param4_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				mission_type_(src: _Host.MAV_MISSION_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_ITEM, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.seq_(src.seq());
				
				{
					const item = src.frame();
					if (item !== null) dst.frame_(item);
					
				}
				
				{
					const item = src.command();
					if (item !== null) dst.command_(item);
					
				}
				
				dst.current_(src.current());
				
				dst.autocontinue_(src.autocontinue());
				
				dst.param1_(src.param1());
				
				dst.param2_(src.param2());
				
				dst.param3_(src.param3());
				
				dst.param4_(src.param4());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				{
					const item = src.mission_type();
					if (item !== null) dst.mission_type_(item);
					
				}
				
			}
			
		}
		
		export interface RAW_IMU {
			time_usec(): number;
			
			xacc(): number;
			
			yacc(): number;
			
			zacc(): number;
			
			xgyro(): number;
			
			ygyro(): number;
			
			zgyro(): number;
			
			xmag(): number;
			
			ymag(): number;
			
			zmag(): number;
			
		}
		
		export namespace RAW_IMU {
			
			export const meta_ = new _Pack.Meta(163, 0, 0, 1, 26, 208);
			
			
			class Impl_ extends _Cursor.View implements RAW_IMU {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				
				public xacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 8, true);}
				
				
				public yacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 10, true);}
				
				
				public zacc(): number { return this.data_.bytes.getInt16(this.data_.origin + 12, true);}
				
				
				public xgyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 14, true);}
				
				
				public ygyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 16, true);}
				
				
				public zgyro(): number { return this.data_.bytes.getInt16(this.data_.origin + 18, true);}
				
				
				public xmag(): number { return this.data_.bytes.getInt16(this.data_.origin + 20, true);}
				
				
				public ymag(): number { return this.data_.bytes.getInt16(this.data_.origin + 22, true);}
				
				
				public zmag(): number { return this.data_.bytes.getInt16(this.data_.origin + 24, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				xacc_(src: number);
				
				yacc_(src: number);
				
				zacc_(src: number);
				
				xgyro_(src: number);
				
				ygyro_(src: number);
				
				zgyro_(src: number);
				
				xmag_(src: number);
				
				ymag_(src: number);
				
				zmag_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: RAW_IMU, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.xmag_(src.xmag());
				
				dst.ymag_(src.ymag());
				
				dst.zmag_(src.zmag());
				
			}
			
		}
		
		export interface COMMAND_INT {
			target_system(): number;
			
			target_component(): number;
			
			current(): number;
			
			autocontinue(): number;
			
			param1(): number;
			
			param2(): number;
			
			param3(): number;
			
			param4(): number;
			
			x(): number;
			
			y(): number;
			
			z(): number;
			
			frame(): MAV_FRAME | null;
			
			command(): MAV_CMD | null;
			
		}
		
		export namespace COMMAND_INT {
			
			export const meta_ = new _Pack.Meta(167, 0, 0, 0, 33, 258, 2, 2);
			
			
			class Impl_ extends _Cursor.View implements COMMAND_INT {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				
				public current(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				public autocontinue(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				
				public param1(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				
				public param2(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public param3(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public param4(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public x(): number { return this.data_.bytes.getInt32(this.data_.origin + 20, true);}
				
				
				public y(): number { return this.data_.bytes.getInt32(this.data_.origin + 24, true);}
				
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				
				public frame(): MAV_FRAME | null {
					if (this.data_.field_bit != 258 && !this.data_.set_field(258, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public command(): MAV_CMD | null {
					if (this.data_.field_bit != 259 && !this.data_.set_field(259, -1)) return null;
					
					return _Host.MAV_CMD_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 8));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				frame_(src: _Host.MAV_FRAME);
				
				command_(src: _Host.MAV_CMD);
				
				current_(src: number);
				
				autocontinue_(src: number);
				
				param1_(src: number);
				
				param2_(src: number);
				
				param3_(src: number);
				
				param4_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: COMMAND_INT, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				{
					const item = src.frame();
					if (item !== null) dst.frame_(item);
					
				}
				
				{
					const item = src.command();
					if (item !== null) dst.command_(item);
					
				}
				
				dst.current_(src.current());
				
				dst.autocontinue_(src.autocontinue());
				
				dst.param1_(src.param1());
				
				dst.param2_(src.param2());
				
				dst.param3_(src.param3());
				
				dst.param4_(src.param4());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
			}
			
		}
		
		export interface OPTICAL_FLOW {
			time_usec(): number;
			
			sensor_id(): number;
			
			flow_x(): number;
			
			flow_y(): number;
			
			flow_comp_m_x(): number;
			
			flow_comp_m_y(): number;
			
			quality(): number;
			
			ground_distance(): number;
			
			flow_rate_x(): number | null;
			
			flow_rate_y(): number | null;
			
		}
		
		export namespace OPTICAL_FLOW {
			
			export const meta_ = new _Pack.Meta(13, 0, 0, 1, 27, 208, 0, 2);
			
			
			class Impl_ extends _Cursor.View implements OPTICAL_FLOW {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				
				public sensor_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				
				public flow_x(): number { return this.data_.bytes.getInt16(this.data_.origin + 9, true);}
				
				
				public flow_y(): number { return this.data_.bytes.getInt16(this.data_.origin + 11, true);}
				
				
				public flow_comp_m_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 13, true);}
				
				
				public flow_comp_m_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 17, true);}
				
				
				public quality(): number { return this.data_.bytes.getInt8(this.data_.origin + 21);}
				
				
				public ground_distance(): number { return this.data_.bytes.getFloat32(this.data_.origin + 22, true);}
				
				
				public flow_rate_x(): number | null {
					if (this.data_.field_bit != 208 && !this.data_.set_field(208, -1)) return null;
					
					return this.data_.bytes.getFloat32(this.data_.BYTE, true);
				}
				
				
				public flow_rate_y(): number | null {
					if (this.data_.field_bit != 209 && !this.data_.set_field(209, -1)) return null;
					
					return this.data_.bytes.getFloat32(this.data_.BYTE, true);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				sensor_id_(src: number);
				
				flow_x_(src: number);
				
				flow_y_(src: number);
				
				flow_comp_m_x_(src: number);
				
				flow_comp_m_y_(src: number);
				
				quality_(src: number);
				
				ground_distance_(src: number);
				
				flow_rate_x_(src: number);
				
				flow_rate_y_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: OPTICAL_FLOW, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.sensor_id_(src.sensor_id());
				
				dst.flow_x_(src.flow_x());
				
				dst.flow_y_(src.flow_y());
				
				dst.flow_comp_m_x_(src.flow_comp_m_x());
				
				dst.flow_comp_m_y_(src.flow_comp_m_y());
				
				dst.quality_(src.quality());
				
				dst.ground_distance_(src.ground_distance());
				
				{
					const item = src.flow_rate_x();
					if (item !== null) dst.flow_rate_x_(item);
					
				}
				
				{
					const item = src.flow_rate_y();
					if (item !== null) dst.flow_rate_y_(item);
					
				}
				
			}
			
		}
		
		export interface MISSION_ITEM_INT {
			seq(): number;
			
			target_system(): number;
			
			target_component(): number;
			
			current(): number;
			
			autocontinue(): number;
			
			param1(): number;
			
			param2(): number;
			
			param3(): number;
			
			param4(): number;
			
			x(): number;
			
			y(): number;
			
			z(): number;
			
			frame(): MAV_FRAME | null;
			
			command(): MAV_CMD | null;
			
			mission_type(): MAV_MISSION_TYPE | null;
			
		}
		
		export namespace MISSION_ITEM_INT {
			
			export const meta_ = new _Pack.Meta(59, 1, 0, 0, 35, 274, 2, 3);
			
			
			class Impl_ extends _Cursor.View implements MISSION_ITEM_INT {
				
				public seq(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				
				public current(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				
				public autocontinue(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				
				public param1(): number { return this.data_.bytes.getFloat32(this.data_.origin + 6, true);}
				
				
				public param2(): number { return this.data_.bytes.getFloat32(this.data_.origin + 10, true);}
				
				
				public param3(): number { return this.data_.bytes.getFloat32(this.data_.origin + 14, true);}
				
				
				public param4(): number { return this.data_.bytes.getFloat32(this.data_.origin + 18, true);}
				
				
				public x(): number { return this.data_.bytes.getInt32(this.data_.origin + 22, true);}
				
				
				public y(): number { return this.data_.bytes.getInt32(this.data_.origin + 26, true);}
				
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 30, true);}
				
				
				public frame(): MAV_FRAME | null {
					if (this.data_.field_bit != 274 && !this.data_.set_field(274, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 4);
				}
				
				
				public command(): MAV_CMD | null {
					if (this.data_.field_bit != 275 && !this.data_.set_field(275, -1)) return null;
					
					return _Host.MAV_CMD_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 8));
				}
				
				
				public mission_type(): MAV_MISSION_TYPE | null {
					if (this.data_.field_bit != 276 && !this.data_.set_field(276, -1)) return null;
					
					return _Host.MAV_MISSION_TYPE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				seq_(src: number);
				
				frame_(src: _Host.MAV_FRAME);
				
				command_(src: _Host.MAV_CMD);
				
				current_(src: number);
				
				autocontinue_(src: number);
				
				param1_(src: number);
				
				param2_(src: number);
				
				param3_(src: number);
				
				param4_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				mission_type_(src: _Host.MAV_MISSION_TYPE);
				
			}
			
			export function push_<DST extends DST_>(src: MISSION_ITEM_INT, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.seq_(src.seq());
				
				{
					const item = src.frame();
					if (item !== null) dst.frame_(item);
					
				}
				
				{
					const item = src.command();
					if (item !== null) dst.command_(item);
					
				}
				
				dst.current_(src.current());
				
				dst.autocontinue_(src.autocontinue());
				
				dst.param1_(src.param1());
				
				dst.param2_(src.param2());
				
				dst.param3_(src.param3());
				
				dst.param4_(src.param4());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				{
					const item = src.mission_type();
					if (item !== null) dst.mission_type_(item);
					
				}
				
			}
			
		}
		
		export interface VISION_POSITION_DELTA {
			time_usec(): number;
			
			time_usec_(src: number);
			
			time_delta_usec(): number;
			
			time_delta_usec_(src: number);
			
			angle_delta(): VISION_POSITION_DELTA.angle_delta;
			
			angle_delta_(src: VISION_POSITION_DELTA.angle_delta | number[]);
			
			angle_delta$(src: Iterator<number>, len: number);
			
			position_delta(): VISION_POSITION_DELTA.position_delta;
			
			position_delta_(src: VISION_POSITION_DELTA.position_delta | number[]);
			
			position_delta$(src: Iterator<number>, len: number);
			
			confidence(): number;
			
			confidence_(src: number);
			
		}
		
		export namespace VISION_POSITION_DELTA {
			
			export const meta_ = new _Pack.Meta(12, 0, 0, 2, 44, 352);
			
			
			export interface angle_delta extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace angle_delta {
				export class Field extends _Cursor.View implements angle_delta, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 16 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 16, other.data_.bytes.buffer, other.data_.origin + 16, _Host.VISION_POSITION_DELTA.angle_delta.item_len) === 0;
						for (let i = 0; i < _Host.VISION_POSITION_DELTA.angle_delta.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.VISION_POSITION_DELTA.angle_delta.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 16 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 3;
				
			}
			
			export interface position_delta extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace position_delta {
				export class Field extends _Cursor.View implements position_delta, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 28 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 28, other.data_.bytes.buffer, other.data_.origin + 28, _Host.VISION_POSITION_DELTA.position_delta.item_len) === 0;
						for (let i = 0; i < _Host.VISION_POSITION_DELTA.position_delta.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.VISION_POSITION_DELTA.position_delta.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setFloat32(this.data_.origin + 28 + index * 4, src, true);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 3;
				
			}
			
			
			class Impl_ extends _Cursor.View implements VISION_POSITION_DELTA {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 0, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 0 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public time_delta_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 8, true) + this.data_.bytes.getInt32(this.data_.origin + 8 + 4, true) * _Lib.JS_HI;}
				
				public time_delta_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 8, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 8 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public angle_delta(): VISION_POSITION_DELTA.angle_delta {
					
					return this.data_.as_field(VISION_POSITION_DELTA.angle_delta.field);
				}
				
				public angle_delta_(src: VISION_POSITION_DELTA.angle_delta | number[]): angle_delta {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.VISION_POSITION_DELTA.angle_delta.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 16 + index * 4, src[index], true);
						return this.data_.as_field(angle_delta.field);
					}
					for (let index = 0; index < _Host.VISION_POSITION_DELTA.angle_delta.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 16 + index * 4, src.get(index), true);
					
					return this.data_.as_field(angle_delta.field);
				}
				
				public angle_delta$(src: Iterator<number>, len: number): angle_delta {
					let len_ = Math.min(len, _Host.VISION_POSITION_DELTA.angle_delta.item_len);
					
					len = Math.min(len, _Host.VISION_POSITION_DELTA.angle_delta.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 16 + index * 4, v.value, true);
						}
					return this.data_.as_field(angle_delta.field);
				}
				
				public position_delta(): VISION_POSITION_DELTA.position_delta {
					
					return this.data_.as_field(VISION_POSITION_DELTA.position_delta.field);
				}
				
				public position_delta_(src: VISION_POSITION_DELTA.position_delta | number[]): position_delta {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.VISION_POSITION_DELTA.position_delta.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setFloat32(this.data_.origin + 28 + index * 4, src[index], true);
						return this.data_.as_field(position_delta.field);
					}
					for (let index = 0; index < _Host.VISION_POSITION_DELTA.position_delta.item_len; index++)
						this.data_.bytes.setFloat32(this.data_.origin + 28 + index * 4, src.get(index), true);
					
					return this.data_.as_field(position_delta.field);
				}
				
				public position_delta$(src: Iterator<number>, len: number): position_delta {
					let len_ = Math.min(len, _Host.VISION_POSITION_DELTA.position_delta.item_len);
					
					len = Math.min(len, _Host.VISION_POSITION_DELTA.position_delta.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setFloat32(this.data_.origin + 28 + index * 4, v.value, true);
						}
					return this.data_.as_field(position_delta.field);
				}
				
				public confidence(): number { return this.data_.bytes.getFloat32(this.data_.origin + 40, true);}
				
				public confidence_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 40, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				time_delta_usec_(src: number);
				
				angle_delta_(src: _Host.VISION_POSITION_DELTA.angle_delta);
				
				position_delta_(src: _Host.VISION_POSITION_DELTA.position_delta);
				
				confidence_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: VISION_POSITION_DELTA, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.time_delta_usec_(src.time_delta_usec());
				dst.angle_delta_(src.angle_delta());
				dst.position_delta_(src.position_delta());
				
				dst.confidence_(src.confidence());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				time_delta_usec(): number;
				
				angle_delta(dst: _Host.VISION_POSITION_DELTA.angle_delta);
				
				position_delta(dst: _Host.VISION_POSITION_DELTA.position_delta);
				
				confidence(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: VISION_POSITION_DELTA) {
				
				dst.time_usec_(src.time_usec());
				
				dst.time_delta_usec_(src.time_delta_usec());
				src.angle_delta(dst.angle_delta());
				src.position_delta(dst.position_delta());
				
				dst.confidence_(src.confidence());
				
			}
			
		}
		
		export interface LOGGING_DATA {
			sequence(): number;
			
			sequence_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			length(): number;
			
			length_(src: number);
			
			first_message_offset(): number;
			
			first_message_offset_(src: number);
			
			daTa(): LOGGING_DATA.daTa;
			
			daTa_(src: LOGGING_DATA.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace LOGGING_DATA {
			
			export const meta_ = new _Pack.Meta(75, 1, 0, 0, 255, 2040);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 6 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 6, other.data_.bytes.buffer, other.data_.origin + 6, _Host.LOGGING_DATA.daTa.item_len) === 0;
						for (let i = 0; i < _Host.LOGGING_DATA.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.LOGGING_DATA.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 6 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 249;
				
			}
			
			
			class Impl_ extends _Cursor.View implements LOGGING_DATA {
				
				public sequence(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public sequence_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
				public length(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public length_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public first_message_offset(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public first_message_offset_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				public daTa(): LOGGING_DATA.daTa {
					
					return this.data_.as_field(LOGGING_DATA.daTa.field);
				}
				
				public daTa_(src: LOGGING_DATA.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.LOGGING_DATA.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 6 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.LOGGING_DATA.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 6 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.LOGGING_DATA.daTa.item_len);
					
					len = Math.min(len, _Host.LOGGING_DATA.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 6 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				sequence_(src: number);
				
				length_(src: number);
				
				first_message_offset_(src: number);
				
				daTa_(src: _Host.LOGGING_DATA.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: LOGGING_DATA, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.sequence_(src.sequence());
				
				dst.length_(src.length());
				
				dst.first_message_offset_(src.first_message_offset());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				sequence(): number;
				
				length(): number;
				
				first_message_offset(): number;
				
				daTa(dst: _Host.LOGGING_DATA.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: LOGGING_DATA) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.sequence_(src.sequence());
				
				dst.length_(src.length());
				
				dst.first_message_offset_(src.first_message_offset());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface DEVICE_OP_READ {
			request_id(): number;
			
			request_id_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			bus(): number;
			
			bus_(src: number);
			
			address(): number;
			
			address_(src: number);
			
			regstart(): number;
			
			regstart_(src: number);
			
			count(): number;
			
			count_(src: number);
			
			bustype(): DEVICE_OP_BUSTYPE | null;
			
			bustype_(src: DEVICE_OP_BUSTYPE);
			
			busname(): _Cursor.UTF8 | null;
			
			busname_(src: string | Uint8Array): _Cursor.UTF8;
			
			busname$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace DEVICE_OP_READ {
			
			export const meta_ = new _Pack.Meta(70, 0, 1, 0, 11, 82, 2, 2);
			
			
			export namespace busname {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements DEVICE_OP_READ {
				
				public request_id(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public request_id_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				public bus(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				public bus_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 6, src); }
				
				public address(): number { return this.data_.bytes.getInt8(this.data_.origin + 7);}
				
				public address_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 7, src); }
				
				public regstart(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public regstart_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
				public count(): number { return this.data_.bytes.getInt8(this.data_.origin + 9);}
				
				public count_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 9, src); }
				
				
				public bustype(): DEVICE_OP_BUSTYPE | null {
					if (this.data_.field_bit != 82 && !this.data_.set_field(82, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 1);
				}
				
				
				public bustype_(src: DEVICE_OP_BUSTYPE) {
					if (this.data_.field_bit != 82) this.data_.set_field(82, 0);
					
					_Lib.set_bits(src, 1, this.data_.bytes, this.data_.BIT);
				}
				
				
				busname(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 83 && !this.data_.set_field(83, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				busname_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -83 - 1);
					
					let len = Math.min(src.byteLength, _Host.DEVICE_OP_READ.busname.item_len_max);
					this.data_.set_field(83, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				busname$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.DEVICE_OP_READ.busname.item_len_max)
					this.data_.set_field(83, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				request_id_(src: number);
				
				bustype_(src: _Host.DEVICE_OP_BUSTYPE);
				
				bus_(src: number);
				
				address_(src: number);
				
				busname_(src: _Cursor.UTF8);
				
				regstart_(src: number);
				
				count_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: DEVICE_OP_READ, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.request_id_(src.request_id());
				
				{
					const item = src.bustype();
					if (item !== null) dst.bustype_(item);
					
				}
				
				dst.bus_(src.bus());
				
				dst.address_(src.address());
				
				{
					const item = src.busname();
					if (item !== null) dst.busname_(item);
					
				}
				
				dst.regstart_(src.regstart());
				
				dst.count_(src.count());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				request_id(): number;
				
				bustype(): _Host.DEVICE_OP_BUSTYPE | null;
				
				bus(): number;
				
				address(): number;
				
				busname(): string | Uint8Array | null;
				
				regstart(): number;
				
				count(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: DEVICE_OP_READ) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.request_id_(src.request_id());
				{
					const item = src.bustype();
					if (item !== null) dst.bustype_(item);
					
				}
				
				dst.bus_(src.bus());
				
				dst.address_(src.address());
				
				
				{
					const item = src.busname();
					if (item !== null) dst.busname_(item);
				}
				
				
				dst.regstart_(src.regstart());
				
				dst.count_(src.count());
				
			}
			
		}
		
		export interface MAG_CAL_PROGRESS {
			compass_id(): number;
			
			compass_id_(src: number);
			
			cal_mask(): number;
			
			cal_mask_(src: number);
			
			attempt(): number;
			
			attempt_(src: number);
			
			completion_pct(): number;
			
			completion_pct_(src: number);
			
			completion_mask(): MAG_CAL_PROGRESS.completion_mask;
			
			completion_mask_(src: MAG_CAL_PROGRESS.completion_mask | number[]);
			
			completion_mask$(src: Iterator<number>, len: number);
			
			direction_x(): number;
			
			direction_x_(src: number);
			
			direction_y(): number;
			
			direction_y_(src: number);
			
			direction_z(): number;
			
			direction_z_(src: number);
			
			cal_status(): MAG_CAL_STATUS | null;
			
			cal_status_(src: MAG_CAL_STATUS);
			
		}
		
		export namespace MAG_CAL_PROGRESS {
			
			export const meta_ = new _Pack.Meta(57, 0, 0, 0, 27, 208, 0, 1);
			
			
			export interface completion_mask extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace completion_mask {
				export class Field extends _Cursor.View implements completion_mask, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 4 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 4, other.data_.bytes.buffer, other.data_.origin + 4, _Host.MAG_CAL_PROGRESS.completion_mask.item_len) === 0;
						for (let i = 0; i < _Host.MAG_CAL_PROGRESS.completion_mask.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.MAG_CAL_PROGRESS.completion_mask.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 4 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 10;
				
			}
			
			
			class Impl_ extends _Cursor.View implements MAG_CAL_PROGRESS {
				
				public compass_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public compass_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public cal_mask(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public cal_mask_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public attempt(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public attempt_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public completion_pct(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public completion_pct_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
				public completion_mask(): MAG_CAL_PROGRESS.completion_mask {
					
					return this.data_.as_field(MAG_CAL_PROGRESS.completion_mask.field);
				}
				
				public completion_mask_(src: MAG_CAL_PROGRESS.completion_mask | number[]): completion_mask {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.MAG_CAL_PROGRESS.completion_mask.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 4 + index, src[index]);
						return this.data_.as_field(completion_mask.field);
					}
					for (let index = 0; index < _Host.MAG_CAL_PROGRESS.completion_mask.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 4 + index, src.get(index));
					
					return this.data_.as_field(completion_mask.field);
				}
				
				public completion_mask$(src: Iterator<number>, len: number): completion_mask {
					let len_ = Math.min(len, _Host.MAG_CAL_PROGRESS.completion_mask.item_len);
					
					len = Math.min(len, _Host.MAG_CAL_PROGRESS.completion_mask.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 4 + index, v.value);
						}
					return this.data_.as_field(completion_mask.field);
				}
				
				public direction_x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 14, true);}
				
				public direction_x_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 14, src, true); }
				
				public direction_y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 18, true);}
				
				public direction_y_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 18, src, true); }
				
				public direction_z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 22, true);}
				
				public direction_z_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 22, src, true); }
				
				
				public cal_status(): MAG_CAL_STATUS | null {
					if (this.data_.field_bit != 208 && !this.data_.set_field(208, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public cal_status_(src: MAG_CAL_STATUS) {
					if (this.data_.field_bit != 208) this.data_.set_field(208, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				compass_id_(src: number);
				
				cal_mask_(src: number);
				
				cal_status_(src: _Host.MAG_CAL_STATUS);
				
				attempt_(src: number);
				
				completion_pct_(src: number);
				
				completion_mask_(src: _Host.MAG_CAL_PROGRESS.completion_mask);
				
				direction_x_(src: number);
				
				direction_y_(src: number);
				
				direction_z_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: MAG_CAL_PROGRESS, dst: DST) {
				
				dst.compass_id_(src.compass_id());
				
				dst.cal_mask_(src.cal_mask());
				
				{
					const item = src.cal_status();
					if (item !== null) dst.cal_status_(item);
					
				}
				
				dst.attempt_(src.attempt());
				
				dst.completion_pct_(src.completion_pct());
				dst.completion_mask_(src.completion_mask());
				
				dst.direction_x_(src.direction_x());
				
				dst.direction_y_(src.direction_y());
				
				dst.direction_z_(src.direction_z());
				
			}
			
			export interface SRC_ {
				compass_id(): number;
				
				cal_mask(): number;
				
				cal_status(): _Host.MAG_CAL_STATUS | null;
				
				attempt(): number;
				
				completion_pct(): number;
				
				completion_mask(dst: _Host.MAG_CAL_PROGRESS.completion_mask);
				
				direction_x(): number;
				
				direction_y(): number;
				
				direction_z(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: MAG_CAL_PROGRESS) {
				
				dst.compass_id_(src.compass_id());
				
				dst.cal_mask_(src.cal_mask());
				{
					const item = src.cal_status();
					if (item !== null) dst.cal_status_(item);
					
				}
				
				dst.attempt_(src.attempt());
				
				dst.completion_pct_(src.completion_pct());
				src.completion_mask(dst.completion_mask());
				
				dst.direction_x_(src.direction_x());
				
				dst.direction_y_(src.direction_y());
				
				dst.direction_z_(src.direction_z());
				
			}
			
		}
		
		export interface HIGHRES_IMU {
			fields_updated(): number;
			
			fields_updated_(src: number);
			
			time_usec(): number;
			
			time_usec_(src: number);
			
			xacc(): number;
			
			xacc_(src: number);
			
			yacc(): number;
			
			yacc_(src: number);
			
			zacc(): number;
			
			zacc_(src: number);
			
			xgyro(): number;
			
			xgyro_(src: number);
			
			ygyro(): number;
			
			ygyro_(src: number);
			
			zgyro(): number;
			
			zgyro_(src: number);
			
			xmag(): number;
			
			xmag_(src: number);
			
			ymag(): number;
			
			ymag_(src: number);
			
			zmag(): number;
			
			zmag_(src: number);
			
			abs_pressure(): number;
			
			abs_pressure_(src: number);
			
			diff_pressure(): number;
			
			diff_pressure_(src: number);
			
			pressure_alt(): number;
			
			pressure_alt_(src: number);
			
			temperature(): number;
			
			temperature_(src: number);
			
		}
		
		export namespace HIGHRES_IMU {
			
			export const meta_ = new _Pack.Meta(137, 1, 0, 1, 62, 496);
			
			
			class Impl_ extends _Cursor.View implements HIGHRES_IMU {
				
				public fields_updated(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public fields_updated_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 2, true) + this.data_.bytes.getInt32(this.data_.origin + 2 + 4, true) * _Lib.JS_HI;}
				
				public time_usec_(src: number) {
					this.data_.bytes.setUint32(this.data_.origin + 2, src, true);
					this.data_.bytes.setUint32(this.data_.origin + 2 + 4, Math.floor((src) / _Lib.JS_HI), true);
				}
				
				public xacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 10, true);}
				
				public xacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 10, src, true); }
				
				public yacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 14, true);}
				
				public yacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 14, src, true); }
				
				public zacc(): number { return this.data_.bytes.getFloat32(this.data_.origin + 18, true);}
				
				public zacc_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 18, src, true); }
				
				public xgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 22, true);}
				
				public xgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 22, src, true); }
				
				public ygyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 26, true);}
				
				public ygyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 26, src, true); }
				
				public zgyro(): number { return this.data_.bytes.getFloat32(this.data_.origin + 30, true);}
				
				public zgyro_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 30, src, true); }
				
				public xmag(): number { return this.data_.bytes.getFloat32(this.data_.origin + 34, true);}
				
				public xmag_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 34, src, true); }
				
				public ymag(): number { return this.data_.bytes.getFloat32(this.data_.origin + 38, true);}
				
				public ymag_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 38, src, true); }
				
				public zmag(): number { return this.data_.bytes.getFloat32(this.data_.origin + 42, true);}
				
				public zmag_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 42, src, true); }
				
				public abs_pressure(): number { return this.data_.bytes.getFloat32(this.data_.origin + 46, true);}
				
				public abs_pressure_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 46, src, true); }
				
				public diff_pressure(): number { return this.data_.bytes.getFloat32(this.data_.origin + 50, true);}
				
				public diff_pressure_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 50, src, true); }
				
				public pressure_alt(): number { return this.data_.bytes.getFloat32(this.data_.origin + 54, true);}
				
				public pressure_alt_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 54, src, true); }
				
				public temperature(): number { return this.data_.bytes.getFloat32(this.data_.origin + 58, true);}
				
				public temperature_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 58, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				xacc_(src: number);
				
				yacc_(src: number);
				
				zacc_(src: number);
				
				xgyro_(src: number);
				
				ygyro_(src: number);
				
				zgyro_(src: number);
				
				xmag_(src: number);
				
				ymag_(src: number);
				
				zmag_(src: number);
				
				abs_pressure_(src: number);
				
				diff_pressure_(src: number);
				
				pressure_alt_(src: number);
				
				temperature_(src: number);
				
				fields_updated_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: HIGHRES_IMU, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.xmag_(src.xmag());
				
				dst.ymag_(src.ymag());
				
				dst.zmag_(src.zmag());
				
				dst.abs_pressure_(src.abs_pressure());
				
				dst.diff_pressure_(src.diff_pressure());
				
				dst.pressure_alt_(src.pressure_alt());
				
				dst.temperature_(src.temperature());
				
				dst.fields_updated_(src.fields_updated());
				
			}
			
			export interface SRC_ {
				time_usec(): number;
				
				xacc(): number;
				
				yacc(): number;
				
				zacc(): number;
				
				xgyro(): number;
				
				ygyro(): number;
				
				zgyro(): number;
				
				xmag(): number;
				
				ymag(): number;
				
				zmag(): number;
				
				abs_pressure(): number;
				
				diff_pressure(): number;
				
				pressure_alt(): number;
				
				temperature(): number;
				
				fields_updated(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: HIGHRES_IMU) {
				
				dst.time_usec_(src.time_usec());
				
				dst.xacc_(src.xacc());
				
				dst.yacc_(src.yacc());
				
				dst.zacc_(src.zacc());
				
				dst.xgyro_(src.xgyro());
				
				dst.ygyro_(src.ygyro());
				
				dst.zgyro_(src.zgyro());
				
				dst.xmag_(src.xmag());
				
				dst.ymag_(src.ymag());
				
				dst.zmag_(src.zmag());
				
				dst.abs_pressure_(src.abs_pressure());
				
				dst.diff_pressure_(src.diff_pressure());
				
				dst.pressure_alt_(src.pressure_alt());
				
				dst.temperature_(src.temperature());
				
				dst.fields_updated_(src.fields_updated());
				
			}
			
		}
		
		export interface EXTENDED_SYS_STATE {
			vtol_state(): MAV_VTOL_STATE | null;
			
			vtol_state_(src: MAV_VTOL_STATE);
			
			landed_state(): MAV_LANDED_STATE | null;
			
			landed_state_(src: MAV_LANDED_STATE);
			
		}
		
		export namespace EXTENDED_SYS_STATE {
			
			export const meta_ = new _Pack.Meta(176, 0, 0, 0, 1, 0, 0, 2);
			
			
			class Impl_ extends _Cursor.View implements EXTENDED_SYS_STATE {
				
				
				public vtol_state(): MAV_VTOL_STATE | null {
					if (this.data_.field_bit != 0 && !this.data_.set_field(0, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public vtol_state_(src: MAV_VTOL_STATE) {
					if (this.data_.field_bit != 0) this.data_.set_field(0, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				public landed_state(): MAV_LANDED_STATE | null {
					if (this.data_.field_bit != 1 && !this.data_.set_field(1, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public landed_state_(src: MAV_LANDED_STATE) {
					if (this.data_.field_bit != 1) this.data_.set_field(1, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				vtol_state_(src: _Host.MAV_VTOL_STATE);
				
				landed_state_(src: _Host.MAV_LANDED_STATE);
				
			}
			
			export function push_<DST extends DST_>(src: EXTENDED_SYS_STATE, dst: DST) {
				
				{
					const item = src.vtol_state();
					if (item !== null) dst.vtol_state_(item);
					
				}
				
				{
					const item = src.landed_state();
					if (item !== null) dst.landed_state_(item);
					
				}
				
			}
			
			export interface SRC_ {
				vtol_state(): _Host.MAV_VTOL_STATE | null;
				
				landed_state(): _Host.MAV_LANDED_STATE | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: EXTENDED_SYS_STATE) {
				{
					const item = src.vtol_state();
					if (item !== null) dst.vtol_state_(item);
					
				}
				{
					const item = src.landed_state();
					if (item !== null) dst.landed_state_(item);
					
				}
				
			}
			
		}
		
		export interface UAVIONIX_ADSB_OUT_DYNAMIC {
			accuracyVert(): number;
			
			accuracyVert_(src: number);
			
			accuracyVel(): number;
			
			accuracyVel_(src: number);
			
			squawk(): number;
			
			squawk_(src: number);
			
			utcTime(): number;
			
			utcTime_(src: number);
			
			accuracyHor(): number;
			
			accuracyHor_(src: number);
			
			gpsLat(): number;
			
			gpsLat_(src: number);
			
			gpsLon(): number;
			
			gpsLon_(src: number);
			
			gpsAlt(): number;
			
			gpsAlt_(src: number);
			
			numSats(): number;
			
			numSats_(src: number);
			
			baroAltMSL(): number;
			
			baroAltMSL_(src: number);
			
			velVert(): number;
			
			velVert_(src: number);
			
			velNS(): number;
			
			velNS_(src: number);
			
			VelEW(): number;
			
			VelEW_(src: number);
			
			gpsFix(): UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX | null;
			
			gpsFix_(src: UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX);
			
			emergencyStatus(): UAVIONIX_ADSB_EMERGENCY_STATUS | null;
			
			emergencyStatus_(src: UAVIONIX_ADSB_EMERGENCY_STATUS);
			
			state(): UAVIONIX_ADSB_OUT_DYNAMIC_STATE | null;
			
			state_(src: UAVIONIX_ADSB_OUT_DYNAMIC_STATE);
			
		}
		
		export namespace UAVIONIX_ADSB_OUT_DYNAMIC {
			
			export const meta_ = new _Pack.Meta(143, 3, 2, 0, 38, 298, 2, 3);
			
			
			class Impl_ extends _Cursor.View implements UAVIONIX_ADSB_OUT_DYNAMIC {
				
				public accuracyVert(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public accuracyVert_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public accuracyVel(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public accuracyVel_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public squawk(): number { return this.data_.bytes.getInt16(this.data_.origin + 4, true);}
				
				public squawk_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 4, src, true); }
				
				public utcTime(): number { return this.data_.bytes.getInt32(this.data_.origin + 6, true);}
				
				public utcTime_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 6, src, true); }
				
				public accuracyHor(): number { return this.data_.bytes.getInt32(this.data_.origin + 10, true);}
				
				public accuracyHor_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 10, src, true); }
				
				public gpsLat(): number { return this.data_.bytes.getInt32(this.data_.origin + 14, true);}
				
				public gpsLat_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 14, src, true); }
				
				public gpsLon(): number { return this.data_.bytes.getInt32(this.data_.origin + 18, true);}
				
				public gpsLon_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 18, src, true); }
				
				public gpsAlt(): number { return this.data_.bytes.getInt32(this.data_.origin + 22, true);}
				
				public gpsAlt_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 22, src, true); }
				
				public numSats(): number { return this.data_.bytes.getInt8(this.data_.origin + 26);}
				
				public numSats_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 26, src); }
				
				public baroAltMSL(): number { return this.data_.bytes.getInt32(this.data_.origin + 27, true);}
				
				public baroAltMSL_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 27, src, true); }
				
				public velVert(): number { return this.data_.bytes.getInt16(this.data_.origin + 31, true);}
				
				public velVert_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 31, src, true); }
				
				public velNS(): number { return this.data_.bytes.getInt16(this.data_.origin + 33, true);}
				
				public velNS_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 33, src, true); }
				
				public VelEW(): number { return this.data_.bytes.getInt16(this.data_.origin + 35, true);}
				
				public VelEW_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 35, src, true); }
				
				
				public gpsFix(): UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX | null {
					if (this.data_.field_bit != 298 && !this.data_.set_field(298, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public gpsFix_(src: UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX) {
					if (this.data_.field_bit != 298) this.data_.set_field(298, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				public emergencyStatus(): UAVIONIX_ADSB_EMERGENCY_STATUS | null {
					if (this.data_.field_bit != 299 && !this.data_.set_field(299, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 3);
				}
				
				
				public emergencyStatus_(src: UAVIONIX_ADSB_EMERGENCY_STATUS) {
					if (this.data_.field_bit != 299) this.data_.set_field(299, 0);
					
					_Lib.set_bits(src, 3, this.data_.bytes, this.data_.BIT);
				}
				
				
				public state(): UAVIONIX_ADSB_OUT_DYNAMIC_STATE | null {
					if (this.data_.field_bit != 300 && !this.data_.set_field(300, -1)) return null;
					
					return _Host.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
				public state_(src: UAVIONIX_ADSB_OUT_DYNAMIC_STATE) {
					if (this.data_.field_bit != 300) this.data_.set_field(300, 0);
					
					_Lib.set_bits(_Host.UAVIONIX_ADSB_OUT_DYNAMIC_STATE_.into(src), 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				utcTime_(src: number);
				
				gpsLat_(src: number);
				
				gpsLon_(src: number);
				
				gpsAlt_(src: number);
				
				gpsFix_(src: _Host.UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX);
				
				numSats_(src: number);
				
				baroAltMSL_(src: number);
				
				accuracyHor_(src: number);
				
				accuracyVert_(src: number);
				
				accuracyVel_(src: number);
				
				velVert_(src: number);
				
				velNS_(src: number);
				
				VelEW_(src: number);
				
				emergencyStatus_(src: _Host.UAVIONIX_ADSB_EMERGENCY_STATUS);
				
				state_(src: _Host.UAVIONIX_ADSB_OUT_DYNAMIC_STATE);
				
				squawk_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: UAVIONIX_ADSB_OUT_DYNAMIC, dst: DST) {
				
				dst.utcTime_(src.utcTime());
				
				dst.gpsLat_(src.gpsLat());
				
				dst.gpsLon_(src.gpsLon());
				
				dst.gpsAlt_(src.gpsAlt());
				
				{
					const item = src.gpsFix();
					if (item !== null) dst.gpsFix_(item);
					
				}
				
				dst.numSats_(src.numSats());
				
				dst.baroAltMSL_(src.baroAltMSL());
				
				dst.accuracyHor_(src.accuracyHor());
				
				dst.accuracyVert_(src.accuracyVert());
				
				dst.accuracyVel_(src.accuracyVel());
				
				dst.velVert_(src.velVert());
				
				dst.velNS_(src.velNS());
				
				dst.VelEW_(src.VelEW());
				
				{
					const item = src.emergencyStatus();
					if (item !== null) dst.emergencyStatus_(item);
					
				}
				
				{
					const item = src.state();
					if (item !== null) dst.state_(item);
					
				}
				
				dst.squawk_(src.squawk());
				
			}
			
			export interface SRC_ {
				utcTime(): number;
				
				gpsLat(): number;
				
				gpsLon(): number;
				
				gpsAlt(): number;
				
				gpsFix(): _Host.UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX | null;
				
				numSats(): number;
				
				baroAltMSL(): number;
				
				accuracyHor(): number;
				
				accuracyVert(): number;
				
				accuracyVel(): number;
				
				velVert(): number;
				
				velNS(): number;
				
				VelEW(): number;
				
				emergencyStatus(): _Host.UAVIONIX_ADSB_EMERGENCY_STATUS | null;
				
				state(): _Host.UAVIONIX_ADSB_OUT_DYNAMIC_STATE | null;
				
				squawk(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: UAVIONIX_ADSB_OUT_DYNAMIC) {
				
				dst.utcTime_(src.utcTime());
				
				dst.gpsLat_(src.gpsLat());
				
				dst.gpsLon_(src.gpsLon());
				
				dst.gpsAlt_(src.gpsAlt());
				{
					const item = src.gpsFix();
					if (item !== null) dst.gpsFix_(item);
					
				}
				
				dst.numSats_(src.numSats());
				
				dst.baroAltMSL_(src.baroAltMSL());
				
				dst.accuracyHor_(src.accuracyHor());
				
				dst.accuracyVert_(src.accuracyVert());
				
				dst.accuracyVel_(src.accuracyVel());
				
				dst.velVert_(src.velVert());
				
				dst.velNS_(src.velNS());
				
				dst.VelEW_(src.VelEW());
				{
					const item = src.emergencyStatus();
					if (item !== null) dst.emergencyStatus_(item);
					
				}
				{
					const item = src.state();
					if (item !== null) dst.state_(item);
					
				}
				
				dst.squawk_(src.squawk());
				
			}
			
		}
		
		export interface GOPRO_GET_RESPONSE {
			value(): GOPRO_GET_RESPONSE.value;
			
			value_(src: GOPRO_GET_RESPONSE.value | number[]);
			
			value$(src: Iterator<number>, len: number);
			
			cmd_id(): GOPRO_COMMAND | null;
			
			cmd_id_(src: GOPRO_COMMAND);
			
			status(): GOPRO_REQUEST_STATUS | null;
			
			status_(src: GOPRO_REQUEST_STATUS);
			
		}
		
		export namespace GOPRO_GET_RESPONSE {
			
			export const meta_ = new _Pack.Meta(208, 0, 0, 0, 5, 32, 0, 2);
			
			
			export interface value extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace value {
				export class Field extends _Cursor.View implements value, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 0 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 0, other.data_.bytes.buffer, other.data_.origin + 0, _Host.GOPRO_GET_RESPONSE.value.item_len) === 0;
						for (let i = 0; i < _Host.GOPRO_GET_RESPONSE.value.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.GOPRO_GET_RESPONSE.value.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 0 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			
			
			class Impl_ extends _Cursor.View implements GOPRO_GET_RESPONSE {
				
				public value(): GOPRO_GET_RESPONSE.value {
					
					return this.data_.as_field(GOPRO_GET_RESPONSE.value.field);
				}
				
				public value_(src: GOPRO_GET_RESPONSE.value | number[]): value {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.GOPRO_GET_RESPONSE.value.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 0 + index, src[index]);
						return this.data_.as_field(value.field);
					}
					for (let index = 0; index < _Host.GOPRO_GET_RESPONSE.value.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 0 + index, src.get(index));
					
					return this.data_.as_field(value.field);
				}
				
				public value$(src: Iterator<number>, len: number): value {
					let len_ = Math.min(len, _Host.GOPRO_GET_RESPONSE.value.item_len);
					
					len = Math.min(len, _Host.GOPRO_GET_RESPONSE.value.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 0 + index, v.value);
						}
					return this.data_.as_field(value.field);
				}
				
				
				public cmd_id(): GOPRO_COMMAND | null {
					if (this.data_.field_bit != 32 && !this.data_.set_field(32, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 5);
				}
				
				
				public cmd_id_(src: GOPRO_COMMAND) {
					if (this.data_.field_bit != 32) this.data_.set_field(32, 0);
					
					_Lib.set_bits(src, 5, this.data_.bytes, this.data_.BIT);
				}
				
				
				public status(): GOPRO_REQUEST_STATUS | null {
					if (this.data_.field_bit != 33 && !this.data_.set_field(33, -1)) return null;
					
					return _Lib.get_bits(this.data_.bytes, this.data_.BIT, 1);
				}
				
				
				public status_(src: GOPRO_REQUEST_STATUS) {
					if (this.data_.field_bit != 33) this.data_.set_field(33, 0);
					
					_Lib.set_bits(src, 1, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				cmd_id_(src: _Host.GOPRO_COMMAND);
				
				status_(src: _Host.GOPRO_REQUEST_STATUS);
				
				value_(src: _Host.GOPRO_GET_RESPONSE.value);
				
			}
			
			export function push_<DST extends DST_>(src: GOPRO_GET_RESPONSE, dst: DST) {
				
				{
					const item = src.cmd_id();
					if (item !== null) dst.cmd_id_(item);
					
				}
				
				{
					const item = src.status();
					if (item !== null) dst.status_(item);
					
				}
				dst.value_(src.value());
				
			}
			
			export interface SRC_ {
				cmd_id(): _Host.GOPRO_COMMAND | null;
				
				status(): _Host.GOPRO_REQUEST_STATUS | null;
				
				value(dst: _Host.GOPRO_GET_RESPONSE.value);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GOPRO_GET_RESPONSE) {
				{
					const item = src.cmd_id();
					if (item !== null) dst.cmd_id_(item);
					
				}
				{
					const item = src.status();
					if (item !== null) dst.status_(item);
					
				}
				src.value(dst.value());
				
			}
			
		}
		
		export interface GPS_INJECT_DATA {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			len(): number;
			
			len_(src: number);
			
			daTa(): GPS_INJECT_DATA.daTa;
			
			daTa_(src: GPS_INJECT_DATA.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace GPS_INJECT_DATA {
			
			export const meta_ = new _Pack.Meta(52, 0, 0, 0, 113, 904);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 3 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 3, other.data_.bytes.buffer, other.data_.origin + 3, _Host.GPS_INJECT_DATA.daTa.item_len) === 0;
						for (let i = 0; i < _Host.GPS_INJECT_DATA.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.GPS_INJECT_DATA.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 3 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 110;
				
			}
			
			
			class Impl_ extends _Cursor.View implements GPS_INJECT_DATA {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public len(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public len_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public daTa(): GPS_INJECT_DATA.daTa {
					
					return this.data_.as_field(GPS_INJECT_DATA.daTa.field);
				}
				
				public daTa_(src: GPS_INJECT_DATA.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.GPS_INJECT_DATA.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 3 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.GPS_INJECT_DATA.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 3 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.GPS_INJECT_DATA.daTa.item_len);
					
					len = Math.min(len, _Host.GPS_INJECT_DATA.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 3 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				len_(src: number);
				
				daTa_(src: _Host.GPS_INJECT_DATA.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: GPS_INJECT_DATA, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.len_(src.len());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				len(): number;
				
				daTa(dst: _Host.GPS_INJECT_DATA.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GPS_INJECT_DATA) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.len_(src.len());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT {
			rfHealth(): UAVIONIX_ADSB_RF_HEALTH | null;
			
			rfHealth_(src: UAVIONIX_ADSB_RF_HEALTH);
			
		}
		
		export namespace UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT {
			
			export const meta_ = new _Pack.Meta(26, 0, 0, 0, 1, 0, 0, 1);
			
			
			class Impl_ extends _Cursor.View implements UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT {
				
				
				public rfHealth(): UAVIONIX_ADSB_RF_HEALTH | null {
					if (this.data_.field_bit != 0 && !this.data_.set_field(0, -1)) return null;
					
					return _Host.UAVIONIX_ADSB_RF_HEALTH_.from(_Lib.get_bits(this.data_.bytes, this.data_.BIT, 3));
				}
				
				
				public rfHealth_(src: UAVIONIX_ADSB_RF_HEALTH) {
					if (this.data_.field_bit != 0) this.data_.set_field(0, 0);
					
					_Lib.set_bits(_Host.UAVIONIX_ADSB_RF_HEALTH_.into(src), 3, this.data_.bytes, this.data_.BIT);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				rfHealth_(src: _Host.UAVIONIX_ADSB_RF_HEALTH);
				
			}
			
			export function push_<DST extends DST_>(src: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT, dst: DST) {
				
				{
					const item = src.rfHealth();
					if (item !== null) dst.rfHealth_(item);
					
				}
				
			}
			
			export interface SRC_ {
				rfHealth(): _Host.UAVIONIX_ADSB_RF_HEALTH | null;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT) {
				{
					const item = src.rfHealth();
					if (item !== null) dst.rfHealth_(item);
					
				}
				
			}
			
		}
		
		export interface ATTITUDE_QUATERNION_COV {
			time_usec(): number;
			
			q(): ATTITUDE_QUATERNION_COV.q;
			
			rollspeed(): number;
			
			pitchspeed(): number;
			
			yawspeed(): number;
			
			covariance(): ATTITUDE_QUATERNION_COV.covariance;
			
		}
		
		export namespace ATTITUDE_QUATERNION_COV {
			
			export const meta_ = new _Pack.Meta(182, 0, 0, 1, 72, 576);
			
			
			export interface q extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace q {
				export class Field extends _Cursor.View implements q, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 8 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 8, other.data_.bytes.buffer, other.data_.origin + 8, _Host.ATTITUDE_QUATERNION_COV.q.item_len) === 0;
						for (let i = 0; i < _Host.ATTITUDE_QUATERNION_COV.q.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.ATTITUDE_QUATERNION_COV.q.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 4;
				
			}
			
			export interface covariance extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
			}
			
			export namespace covariance {
				export class Field extends _Cursor.View implements covariance, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getFloat32(this.data_.origin + 36 + index * 4, true);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 36, other.data_.bytes.buffer, other.data_.origin + 36, _Host.ATTITUDE_QUATERNION_COV.covariance.item_len) === 0;
						for (let i = 0; i < _Host.ATTITUDE_QUATERNION_COV.covariance.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.ATTITUDE_QUATERNION_COV.covariance.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 9;
				
			}
			
			
			class Impl_ extends _Cursor.View implements ATTITUDE_QUATERNION_COV {
				
				public time_usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				
				public q(): ATTITUDE_QUATERNION_COV.q {
					
					return this.data_.as_field(ATTITUDE_QUATERNION_COV.q.field);
				}
				
				public rollspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
				public pitchspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				
				public yawspeed(): number { return this.data_.bytes.getFloat32(this.data_.origin + 32, true);}
				
				
				public covariance(): ATTITUDE_QUATERNION_COV.covariance {
					
					return this.data_.as_field(ATTITUDE_QUATERNION_COV.covariance.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_usec_(src: number);
				
				q_(src: _Host.ATTITUDE_QUATERNION_COV.q);
				
				rollspeed_(src: number);
				
				pitchspeed_(src: number);
				
				yawspeed_(src: number);
				
				covariance_(src: _Host.ATTITUDE_QUATERNION_COV.covariance);
				
			}
			
			export function push_<DST extends DST_>(src: ATTITUDE_QUATERNION_COV, dst: DST) {
				
				dst.time_usec_(src.time_usec());
				dst.q_(src.q());
				
				dst.rollspeed_(src.rollspeed());
				
				dst.pitchspeed_(src.pitchspeed());
				
				dst.yawspeed_(src.yawspeed());
				dst.covariance_(src.covariance());
				
			}
			
		}
		
		export interface NAMED_VALUE_INT {
			time_boot_ms(): number;
			
			time_boot_ms_(src: number);
			
			value(): number;
			
			value_(src: number);
			
			name(): _Cursor.UTF8 | null;
			
			name_(src: string | Uint8Array): _Cursor.UTF8;
			
			name$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8;
			
		}
		
		export namespace NAMED_VALUE_INT {
			
			export const meta_ = new _Pack.Meta(21, 0, 1, 0, 9, 66, 2, 1);
			
			
			export namespace name {
				export const item_len_max = 255;
				
			}
			
			
			class Impl_ extends _Cursor.View implements NAMED_VALUE_INT {
				
				public time_boot_ms(): number { return this.data_.bytes.getInt32(this.data_.origin + 0, true);}
				
				public time_boot_ms_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 0, src, true); }
				
				public value(): number { return this.data_.bytes.getInt32(this.data_.origin + 4, true);}
				
				public value_(src: number) { this.data_.bytes.setInt32(this.data_.origin + 4, src, true); }
				
				
				name(): _Cursor.UTF8 | null {
					if (this.data_.field_bit != 66 && !this.data_.set_field(66, -1)) return null;
					
					return new _Cursor.UTF8(this.data_);
				}
				
				name_(src: string | Uint8Array): _Cursor.UTF8 {
					if (typeof src === "string") return new _Cursor.UTF8(this.data_, src, -66 - 1);
					
					let len = Math.min(src.byteLength, _Host.NAMED_VALUE_INT.name.item_len_max);
					this.data_.set_field(66, len);
					
					_Lib.copy_bytes(src, 0, this.data_.bytes.buffer, this.data_.BYTE, this.data_.item_len);
					return new _Cursor.UTF8(this.data_);
					
				}
				
				name$(bytes: Iterator<number> | null, len: number): _Cursor.UTF8 {
					len = Math.min(len, _Host.NAMED_VALUE_INT.name.item_len_max)
					this.data_.set_field(66, len);
					
					if (bytes)
						for (let index = 0; index < len; index++) {
							let v = bytes.next();
							if (v.done) break;
							
						}
					return new _Cursor.UTF8(this.data_);
				}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				time_boot_ms_(src: number);
				
				name_(src: _Cursor.UTF8);
				
				value_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: NAMED_VALUE_INT, dst: DST) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				{
					const item = src.name();
					if (item !== null) dst.name_(item);
					
				}
				
				dst.value_(src.value());
				
			}
			
			export interface SRC_ {
				time_boot_ms(): number;
				
				name(): string | Uint8Array | null;
				
				value(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: NAMED_VALUE_INT) {
				
				dst.time_boot_ms_(src.time_boot_ms());
				
				
				{
					const item = src.name();
					if (item !== null) dst.name_(item);
				}
				
				
				dst.value_(src.value());
				
			}
			
		}
		
		export interface RPM {
			rpm1(): number;
			
			rpm1_(src: number);
			
			rpm2(): number;
			
			rpm2_(src: number);
			
		}
		
		export namespace RPM {
			
			export const meta_ = new _Pack.Meta(183, 0, 0, 0, 8, 64);
			
			
			class Impl_ extends _Cursor.View implements RPM {
				
				public rpm1(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public rpm1_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public rpm2(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public rpm2_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				rpm1_(src: number);
				
				rpm2_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: RPM, dst: DST) {
				
				dst.rpm1_(src.rpm1());
				
				dst.rpm2_(src.rpm2());
				
			}
			
			export interface SRC_ {
				rpm1(): number;
				
				rpm2(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: RPM) {
				
				dst.rpm1_(src.rpm1());
				
				dst.rpm2_(src.rpm2());
				
			}
			
		}
		
		export interface GPS_RTCM_DATA {
			flags(): number;
			
			flags_(src: number);
			
			len(): number;
			
			len_(src: number);
			
			daTa(): GPS_RTCM_DATA.daTa;
			
			daTa_(src: GPS_RTCM_DATA.daTa | number[]);
			
			daTa$(src: Iterator<number>, len: number);
			
		}
		
		export namespace GPS_RTCM_DATA {
			
			export const meta_ = new _Pack.Meta(88, 0, 0, 0, 182, 1456);
			
			
			export interface daTa extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace daTa {
				export class Field extends _Cursor.View implements daTa, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 2 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 2, other.data_.bytes.buffer, other.data_.origin + 2, _Host.GPS_RTCM_DATA.daTa.item_len) === 0;
						for (let i = 0; i < _Host.GPS_RTCM_DATA.daTa.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.GPS_RTCM_DATA.daTa.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 2 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 180;
				
			}
			
			
			class Impl_ extends _Cursor.View implements GPS_RTCM_DATA {
				
				public flags(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public flags_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public len(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public len_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public daTa(): GPS_RTCM_DATA.daTa {
					
					return this.data_.as_field(GPS_RTCM_DATA.daTa.field);
				}
				
				public daTa_(src: GPS_RTCM_DATA.daTa | number[]): daTa {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.GPS_RTCM_DATA.daTa.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, src[index]);
						return this.data_.as_field(daTa.field);
					}
					for (let index = 0; index < _Host.GPS_RTCM_DATA.daTa.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 2 + index, src.get(index));
					
					return this.data_.as_field(daTa.field);
				}
				
				public daTa$(src: Iterator<number>, len: number): daTa {
					let len_ = Math.min(len, _Host.GPS_RTCM_DATA.daTa.item_len);
					
					len = Math.min(len, _Host.GPS_RTCM_DATA.daTa.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, v.value);
						}
					return this.data_.as_field(daTa.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				flags_(src: number);
				
				len_(src: number);
				
				daTa_(src: _Host.GPS_RTCM_DATA.daTa);
				
			}
			
			export function push_<DST extends DST_>(src: GPS_RTCM_DATA, dst: DST) {
				
				dst.flags_(src.flags());
				
				dst.len_(src.len());
				dst.daTa_(src.daTa());
				
			}
			
			export interface SRC_ {
				flags(): number;
				
				len(): number;
				
				daTa(dst: _Host.GPS_RTCM_DATA.daTa);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: GPS_RTCM_DATA) {
				
				dst.flags_(src.flags());
				
				dst.len_(src.len());
				src.daTa(dst.daTa());
				
			}
			
		}
		
		export interface GLOBAL_VISION_POSITION_ESTIMATE {
			usec(): number;
			
			x(): number;
			
			y(): number;
			
			z(): number;
			
			roll(): number;
			
			pitch(): number;
			
			yaw(): number;
			
		}
		
		export namespace GLOBAL_VISION_POSITION_ESTIMATE {
			
			export const meta_ = new _Pack.Meta(110, 0, 0, 1, 32, 256);
			
			
			class Impl_ extends _Cursor.View implements GLOBAL_VISION_POSITION_ESTIMATE {
				
				public usec(): number { return this.data_.bytes.getUint32(this.data_.origin + 0, true) + this.data_.bytes.getInt32(this.data_.origin + 0 + 4, true) * _Lib.JS_HI;}
				
				
				public x(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				
				public y(): number { return this.data_.bytes.getFloat32(this.data_.origin + 12, true);}
				
				
				public z(): number { return this.data_.bytes.getFloat32(this.data_.origin + 16, true);}
				
				
				public roll(): number { return this.data_.bytes.getFloat32(this.data_.origin + 20, true);}
				
				
				public pitch(): number { return this.data_.bytes.getFloat32(this.data_.origin + 24, true);}
				
				
				public yaw(): number { return this.data_.bytes.getFloat32(this.data_.origin + 28, true);}
				
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				usec_(src: number);
				
				x_(src: number);
				
				y_(src: number);
				
				z_(src: number);
				
				roll_(src: number);
				
				pitch_(src: number);
				
				yaw_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: GLOBAL_VISION_POSITION_ESTIMATE, dst: DST) {
				
				dst.usec_(src.usec());
				
				dst.x_(src.x());
				
				dst.y_(src.y());
				
				dst.z_(src.z());
				
				dst.roll_(src.roll());
				
				dst.pitch_(src.pitch());
				
				dst.yaw_(src.yaw());
				
			}
			
		}
		
		export interface FILE_TRANSFER_PROTOCOL {
			target_network(): number;
			
			target_network_(src: number);
			
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			payload(): FILE_TRANSFER_PROTOCOL.payload;
			
			payload_(src: FILE_TRANSFER_PROTOCOL.payload | number[]);
			
			payload$(src: Iterator<number>, len: number);
			
		}
		
		export namespace FILE_TRANSFER_PROTOCOL {
			
			export const meta_ = new _Pack.Meta(27, 0, 0, 0, 254, 2032);
			
			
			export interface payload extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace payload {
				export class Field extends _Cursor.View implements payload, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 3 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 3, other.data_.bytes.buffer, other.data_.origin + 3, _Host.FILE_TRANSFER_PROTOCOL.payload.item_len) === 0;
						for (let i = 0; i < _Host.FILE_TRANSFER_PROTOCOL.payload.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.FILE_TRANSFER_PROTOCOL.payload.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 3 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 251;
				
			}
			
			
			class Impl_ extends _Cursor.View implements FILE_TRANSFER_PROTOCOL {
				
				public target_network(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_network_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public payload(): FILE_TRANSFER_PROTOCOL.payload {
					
					return this.data_.as_field(FILE_TRANSFER_PROTOCOL.payload.field);
				}
				
				public payload_(src: FILE_TRANSFER_PROTOCOL.payload | number[]): payload {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.FILE_TRANSFER_PROTOCOL.payload.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 3 + index, src[index]);
						return this.data_.as_field(payload.field);
					}
					for (let index = 0; index < _Host.FILE_TRANSFER_PROTOCOL.payload.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 3 + index, src.get(index));
					
					return this.data_.as_field(payload.field);
				}
				
				public payload$(src: Iterator<number>, len: number): payload {
					let len_ = Math.min(len, _Host.FILE_TRANSFER_PROTOCOL.payload.item_len);
					
					len = Math.min(len, _Host.FILE_TRANSFER_PROTOCOL.payload.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 3 + index, v.value);
						}
					return this.data_.as_field(payload.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_network_(src: number);
				
				target_system_(src: number);
				
				target_component_(src: number);
				
				payload_(src: _Host.FILE_TRANSFER_PROTOCOL.payload);
				
			}
			
			export function push_<DST extends DST_>(src: FILE_TRANSFER_PROTOCOL, dst: DST) {
				
				dst.target_network_(src.target_network());
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				dst.payload_(src.payload());
				
			}
			
			export interface SRC_ {
				target_network(): number;
				
				target_system(): number;
				
				target_component(): number;
				
				payload(dst: _Host.FILE_TRANSFER_PROTOCOL.payload);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: FILE_TRANSFER_PROTOCOL) {
				
				dst.target_network_(src.target_network());
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				src.payload(dst.payload());
				
			}
			
		}
		
		export interface RANGEFINDER {
			distance(): number;
			
			distance_(src: number);
			
			voltage(): number;
			
			voltage_(src: number);
			
		}
		
		export namespace RANGEFINDER {
			
			export const meta_ = new _Pack.Meta(153, 0, 0, 0, 8, 64);
			
			
			class Impl_ extends _Cursor.View implements RANGEFINDER {
				
				public distance(): number { return this.data_.bytes.getFloat32(this.data_.origin + 0, true);}
				
				public distance_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 0, src, true); }
				
				public voltage(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public voltage_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				distance_(src: number);
				
				voltage_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: RANGEFINDER, dst: DST) {
				
				dst.distance_(src.distance());
				
				dst.voltage_(src.voltage());
				
			}
			
			export interface SRC_ {
				distance(): number;
				
				voltage(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: RANGEFINDER) {
				
				dst.distance_(src.distance());
				
				dst.voltage_(src.voltage());
				
			}
			
		}
		
		export interface RADIO_STATUS {
			rxerrors(): number;
			
			rxerrors_(src: number);
			
			fixeD(): number;
			
			fixeD_(src: number);
			
			rssi(): number;
			
			rssi_(src: number);
			
			remrssi(): number;
			
			remrssi_(src: number);
			
			txbuf(): number;
			
			txbuf_(src: number);
			
			noise(): number;
			
			noise_(src: number);
			
			remnoise(): number;
			
			remnoise_(src: number);
			
		}
		
		export namespace RADIO_STATUS {
			
			export const meta_ = new _Pack.Meta(107, 2, 0, 0, 9, 72);
			
			
			class Impl_ extends _Cursor.View implements RADIO_STATUS {
				
				public rxerrors(): number { return this.data_.bytes.getInt16(this.data_.origin + 0, true);}
				
				public rxerrors_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 0, src, true); }
				
				public fixeD(): number { return this.data_.bytes.getInt16(this.data_.origin + 2, true);}
				
				public fixeD_(src: number) { this.data_.bytes.setInt16(this.data_.origin + 2, src, true); }
				
				public rssi(): number { return this.data_.bytes.getInt8(this.data_.origin + 4);}
				
				public rssi_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 4, src); }
				
				public remrssi(): number { return this.data_.bytes.getInt8(this.data_.origin + 5);}
				
				public remrssi_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 5, src); }
				
				public txbuf(): number { return this.data_.bytes.getInt8(this.data_.origin + 6);}
				
				public txbuf_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 6, src); }
				
				public noise(): number { return this.data_.bytes.getInt8(this.data_.origin + 7);}
				
				public noise_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 7, src); }
				
				public remnoise(): number { return this.data_.bytes.getInt8(this.data_.origin + 8);}
				
				public remnoise_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 8, src); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				rssi_(src: number);
				
				remrssi_(src: number);
				
				txbuf_(src: number);
				
				noise_(src: number);
				
				remnoise_(src: number);
				
				rxerrors_(src: number);
				
				fixeD_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: RADIO_STATUS, dst: DST) {
				
				dst.rssi_(src.rssi());
				
				dst.remrssi_(src.remrssi());
				
				dst.txbuf_(src.txbuf());
				
				dst.noise_(src.noise());
				
				dst.remnoise_(src.remnoise());
				
				dst.rxerrors_(src.rxerrors());
				
				dst.fixeD_(src.fixeD());
				
			}
			
			export interface SRC_ {
				rssi(): number;
				
				remrssi(): number;
				
				txbuf(): number;
				
				noise(): number;
				
				remnoise(): number;
				
				rxerrors(): number;
				
				fixeD(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: RADIO_STATUS) {
				
				dst.rssi_(src.rssi());
				
				dst.remrssi_(src.remrssi());
				
				dst.txbuf_(src.txbuf());
				
				dst.noise_(src.noise());
				
				dst.remnoise_(src.remnoise());
				
				dst.rxerrors_(src.rxerrors());
				
				dst.fixeD_(src.fixeD());
				
			}
			
		}
		
		export interface FENCE_POINT {
			target_system(): number;
			
			target_system_(src: number);
			
			target_component(): number;
			
			target_component_(src: number);
			
			idx(): number;
			
			idx_(src: number);
			
			count(): number;
			
			count_(src: number);
			
			lat(): number;
			
			lat_(src: number);
			
			lng(): number;
			
			lng_(src: number);
			
		}
		
		export namespace FENCE_POINT {
			
			export const meta_ = new _Pack.Meta(20, 0, 0, 0, 12, 96);
			
			
			class Impl_ extends _Cursor.View implements FENCE_POINT {
				
				public target_system(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public target_system_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public target_component(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public target_component_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public idx(): number { return this.data_.bytes.getInt8(this.data_.origin + 2);}
				
				public idx_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 2, src); }
				
				public count(): number { return this.data_.bytes.getInt8(this.data_.origin + 3);}
				
				public count_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 3, src); }
				
				public lat(): number { return this.data_.bytes.getFloat32(this.data_.origin + 4, true);}
				
				public lat_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 4, src, true); }
				
				public lng(): number { return this.data_.bytes.getFloat32(this.data_.origin + 8, true);}
				
				public lng_(src: number) { this.data_.bytes.setFloat32(this.data_.origin + 8, src, true); }
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				target_system_(src: number);
				
				target_component_(src: number);
				
				idx_(src: number);
				
				count_(src: number);
				
				lat_(src: number);
				
				lng_(src: number);
				
			}
			
			export function push_<DST extends DST_>(src: FENCE_POINT, dst: DST) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.idx_(src.idx());
				
				dst.count_(src.count());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
			}
			
			export interface SRC_ {
				target_system(): number;
				
				target_component(): number;
				
				idx(): number;
				
				count(): number;
				
				lat(): number;
				
				lng(): number;
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: FENCE_POINT) {
				
				dst.target_system_(src.target_system());
				
				dst.target_component_(src.target_component());
				
				dst.idx_(src.idx());
				
				dst.count_(src.count());
				
				dst.lat_(src.lat());
				
				dst.lng_(src.lng());
				
			}
			
		}
		
		export interface RESOURCE_REQUEST {
			request_id(): number;
			
			request_id_(src: number);
			
			uri_type(): number;
			
			uri_type_(src: number);
			
			uri(): RESOURCE_REQUEST.uri;
			
			uri_(src: RESOURCE_REQUEST.uri | number[]);
			
			uri$(src: Iterator<number>, len: number);
			
			transfer_type(): number;
			
			transfer_type_(src: number);
			
			storage(): RESOURCE_REQUEST.storage;
			
			storage_(src: RESOURCE_REQUEST.storage | number[]);
			
			storage$(src: Iterator<number>, len: number);
			
		}
		
		export namespace RESOURCE_REQUEST {
			
			export const meta_ = new _Pack.Meta(67, 0, 0, 0, 243, 1944);
			
			
			export interface uri extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace uri {
				export class Field extends _Cursor.View implements uri, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 2 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 2, other.data_.bytes.buffer, other.data_.origin + 2, _Host.RESOURCE_REQUEST.uri.item_len) === 0;
						for (let i = 0; i < _Host.RESOURCE_REQUEST.uri.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.RESOURCE_REQUEST.uri.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 2 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 120;
				
			}
			
			export interface storage extends Iterable<number> {
				get(index: number);
				
				equals(other: this): boolean;
				
				equals(other: Iterator<number>): boolean;
				
				set(src: number, index: number);
			}
			
			export namespace storage {
				export class Field extends _Cursor.View implements storage, Iterable<number> {
					public get(index: number): number { return this.data_.bytes.getInt8(this.data_.origin + 123 + index);}
					
					equals(other: Iterator<number>): boolean;
					public equals(other: this): boolean;
					
					equals(other): boolean {
						if (other instanceof Field)
							return _Lib.ArrayEquals(this.data_.bytes.buffer, this.data_.origin + 123, other.data_.bytes.buffer, other.data_.origin + 123, _Host.RESOURCE_REQUEST.storage.item_len) === 0;
						for (let i = 0; i < _Host.RESOURCE_REQUEST.storage.item_len; i++) {
							let v = other.next();
							if (v.done || v.value !== this.get(i)) return false;
						}
						return true;
					}
					
					[Symbol.iterator](): Iterator<number> {
						const outer = this;
						let index   = 0;
						const max   = _Host.RESOURCE_REQUEST.storage.item_len;
						return new class implements Iterator<number> {
							value: number;
							done: boolean;
							
							next(value?: any): IteratorResult<number> {
								if ((this.done = (index === max))) index = 0;
								else this.value = outer.get(index++);
								return this
							}
						}
					}
					
					public set(src: number, index: number) { this.data_.bytes.setInt8(this.data_.origin + 123 + index, src);}
					
				}
				
				export const field = Field.prototype;
				
				export const item_len = 120;
				
			}
			
			
			class Impl_ extends _Cursor.View implements RESOURCE_REQUEST {
				
				public request_id(): number { return this.data_.bytes.getInt8(this.data_.origin + 0);}
				
				public request_id_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 0, src); }
				
				public uri_type(): number { return this.data_.bytes.getInt8(this.data_.origin + 1);}
				
				public uri_type_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 1, src); }
				
				public uri(): RESOURCE_REQUEST.uri {
					
					return this.data_.as_field(RESOURCE_REQUEST.uri.field);
				}
				
				public uri_(src: RESOURCE_REQUEST.uri | number[]): uri {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.RESOURCE_REQUEST.uri.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, src[index]);
						return this.data_.as_field(uri.field);
					}
					for (let index = 0; index < _Host.RESOURCE_REQUEST.uri.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 2 + index, src.get(index));
					
					return this.data_.as_field(uri.field);
				}
				
				public uri$(src: Iterator<number>, len: number): uri {
					let len_ = Math.min(len, _Host.RESOURCE_REQUEST.uri.item_len);
					
					len = Math.min(len, _Host.RESOURCE_REQUEST.uri.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 2 + index, v.value);
						}
					return this.data_.as_field(uri.field);
				}
				
				public transfer_type(): number { return this.data_.bytes.getInt8(this.data_.origin + 122);}
				
				public transfer_type_(src: number) { this.data_.bytes.setInt8(this.data_.origin + 122, src); }
				
				public storage(): RESOURCE_REQUEST.storage {
					
					return this.data_.as_field(RESOURCE_REQUEST.storage.field);
				}
				
				public storage_(src: RESOURCE_REQUEST.storage | number[]): storage {
					
					if (src instanceof Array) {
						let len = Math.min(_Host.RESOURCE_REQUEST.storage.item_len, src.length);
						for (let index = 0; index < len; index++)
							this.data_.bytes.setInt8(this.data_.origin + 123 + index, src[index]);
						return this.data_.as_field(storage.field);
					}
					for (let index = 0; index < _Host.RESOURCE_REQUEST.storage.item_len; index++)
						this.data_.bytes.setInt8(this.data_.origin + 123 + index, src.get(index));
					
					return this.data_.as_field(storage.field);
				}
				
				public storage$(src: Iterator<number>, len: number): storage {
					let len_ = Math.min(len, _Host.RESOURCE_REQUEST.storage.item_len);
					
					len = Math.min(len, _Host.RESOURCE_REQUEST.storage.item_len)
					if (src)
						for (let index = 0; index < len; index++) {
							let v = src.next();
							if (v.done) break;
							this.data_.bytes.setInt8(this.data_.origin + 123 + index, v.value);
						}
					return this.data_.as_field(storage.field);
				}
				
			}
			
			export const impl_ = Impl_.prototype;
			
			export interface DST_ {
				request_id_(src: number);
				
				uri_type_(src: number);
				
				uri_(src: _Host.RESOURCE_REQUEST.uri);
				
				transfer_type_(src: number);
				
				storage_(src: _Host.RESOURCE_REQUEST.storage);
				
			}
			
			export function push_<DST extends DST_>(src: RESOURCE_REQUEST, dst: DST) {
				
				dst.request_id_(src.request_id());
				
				dst.uri_type_(src.uri_type());
				dst.uri_(src.uri());
				
				dst.transfer_type_(src.transfer_type());
				dst.storage_(src.storage());
				
			}
			
			export interface SRC_ {
				request_id(): number;
				
				uri_type(): number;
				
				uri(dst: _Host.RESOURCE_REQUEST.uri);
				
				transfer_type(): number;
				
				storage(dst: _Host.RESOURCE_REQUEST.storage);
				
			}
			
			export function pull_<SRC extends SRC_>(src: SRC, dst: RESOURCE_REQUEST) {
				
				dst.request_id_(src.request_id());
				
				dst.uri_type_(src.uri_type());
				src.uri(dst.uri());
				
				dst.transfer_type_(src.transfer_type());
				src.storage(dst.storage());
				
			}
			
		}
		
	}
	import _Host = com.company.demo.GroundControl;
	
	export abstract class CommunicationChannel {
		
		public readonly receiver = new CommunicationChannel.Receiver(this);
		
		public readonly transmitter = new CommunicationChannel.Transmitter(this);
		
		public abstract pullSendingPack(): _Pack | null;
		
		public abstract pushSendingPack(pack: _Pack): boolean;
		
		public sendSwitchModeCommand(): boolean { return this.pushSendingPack(_Host.SwitchModeCommand.pack_); }
		
		public send(src: _Host.FOLLOW_TARGET): boolean ;
		public send(src: _Host.ADSB_VEHICLE): boolean ;
		public send(src: _Host.MESSAGE_INTERVAL): boolean ;
		public send(src: _Host.EKF_STATUS_REPORT): boolean ;
		public send(src: _Host.ESTIMATOR_STATUS): boolean ;
		public send(src: _Host.HWSTATUS): boolean ;
		public send(src: _Host.TIMESYNC): boolean ;
		public send(src: _Host.PARAM_EXT_REQUEST_LIST): boolean ;
		public send(src: _Host.BUTTON_CHANGE): boolean ;
		public send(src: _Host.UAVCAN_NODE_STATUS): boolean ;
		public send(src: _Host.COLLISION): boolean ;
		public send(src: _Host.GIMBAL_TORQUE_CMD_REPORT): boolean ;
		public send(src: _Host.ALTITUDE): boolean ;
		public send(src: _Host.HIL_STATE_QUATERNION): boolean ;
		public send(src: _Host.SENSOR_OFFSETS): boolean ;
		public send(src: _Host.STORAGE_INFORMATION): boolean ;
		public send(src: _Host.CAMERA_INFORMATION): boolean ;
		public send(src: _Host.DEVICE_OP_WRITE_REPLY): boolean ;
		public send(src: _Host.TERRAIN_DATA): boolean ;
		public send(src: _Host.GIMBAL_CONTROL): boolean ;
		public send(src: _Host.VIDEO_STREAM_INFORMATION): boolean ;
		public send(src: _Host.AHRS): boolean ;
		public send(src: _Host.DEBUG): boolean ;
		public send(src: _Host.CAMERA_IMAGE_CAPTURED): boolean ;
		public send(src: _Host.LOG_ENTRY): boolean ;
		public send(src: _Host.ACTUATOR_CONTROL_TARGET): boolean ;
		public send(src: _Host.HIGH_LATENCY): boolean ;
		public send(src: _Host.HOME_POSITION): boolean ;
		public send(src: _Host.FENCE_STATUS): boolean ;
		public send(src: _Host.REMOTE_LOG_BLOCK_STATUS): boolean ;
		public send(src: _Host.OBSTACLE_DISTANCE): boolean ;
		public send(src: _Host.GPS2_RAW): boolean ;
		public send(src: _Host.MEMORY_VECT): boolean ;
		public send(src: _Host.PARAM_EXT_REQUEST_READ): boolean ;
		public send(src: _Host.HIL_SENSOR): boolean ;
		public send(src: _Host.SETUP_SIGNING): boolean ;
		public send(src: _Host.GPS_RTK): boolean ;
		public send(src: _Host.UAVIONIX_ADSB_OUT_CFG): boolean ;
		public send(src: _Host.LANDING_TARGET): boolean ;
		public send(src: _Host.SET_ACTUATOR_CONTROL_TARGET): boolean ;
		public send(src: _Host.CONTROL_SYSTEM_STATE): boolean ;
		public send(src: _Host.DATA32): boolean ;
		public send(src: _Host.PING33): boolean ;
		public send(src: _Host.RALLY_POINT): boolean ;
		public send(src: _Host.ADAP_TUNING): boolean ;
		public send(src: _Host.VIBRATION): boolean ;
		public send(src: _Host.PARAM_EXT_VALUE): boolean ;
		public send(src: _Host.BATTERY2): boolean ;
		public send(src: _Host.LIMITS_STATUS): boolean ;
		public send(src: _Host.CAMERA_FEEDBACK): boolean ;
		public send(src: _Host.HIL_GPS): boolean ;
		public send(src: _Host.FENCE_FETCH_POINT): boolean ;
		public send(src: _Host.RADIO): boolean ;
		public send(src: _Host.AIRSPEED_AUTOCAL): boolean ;
		public send(src: _Host.ATT_POS_MOCAP): boolean ;
		public send(src: _Host.STATUSTEXT): boolean ;
		public send(src: _Host.GOPRO_GET_REQUEST): boolean ;
		public send(src: _Host.CAMERA_CAPTURE_STATUS): boolean ;
		public send(src: _Host.ENCAPSULATED_DATA): boolean ;
		public send(src: _Host.GPS_INPUT): boolean ;
		public send(src: _Host.COMPASSMOT_STATUS): boolean ;
		public send(src: _Host.LOG_REQUEST_DATA): boolean ;
		public send(src: _Host.CAMERA_STATUS): boolean ;
		public send(src: _Host.CAMERA_SETTINGS): boolean ;
		public send(src: _Host.DEVICE_OP_READ_REPLY): boolean ;
		public send(src: _Host.DIGICAM_CONTROL): boolean ;
		public send(src: _Host.NAMED_VALUE_FLOAT): boolean ;
		public send(src: _Host.GOPRO_HEARTBEAT): boolean ;
		public send(src: _Host.AHRS2): boolean ;
		public send(src: _Host.LOG_ERASE): boolean ;
		public send(src: _Host.TERRAIN_REQUEST): boolean ;
		public send(src: _Host.MOUNT_STATUS): boolean ;
		public send(src: _Host.PID_TUNING): boolean ;
		public send(src: _Host.OPTICAL_FLOW_RAD): boolean ;
		public send(src: _Host.LOG_DATA): boolean ;
		public send(src: _Host.AHRS3): boolean ;
		public send(src: _Host.VICON_POSITION_ESTIMATE): boolean ;
		public send(src: _Host.GPS2_RTK): boolean ;
		public send(src: _Host.MAG_CAL_REPORT): boolean ;
		public send(src: _Host.LOG_REQUEST_LIST): boolean ;
		public send(src: _Host.MOUNT_CONFIGURE): boolean ;
		public send(src: _Host.V2_EXTENSION): boolean ;
		public send(src: _Host.POWER_STATUS): boolean ;
		public send(src: _Host.REMOTE_LOG_DATA_BLOCK): boolean ;
		public send(src: _Host.LOGGING_DATA_ACKED): boolean ;
		public send(src: _Host.TERRAIN_CHECK): boolean ;
		public send(src: _Host.TERRAIN_REPORT): boolean ;
		public send(src: _Host.SET_HOME_POSITION): boolean ;
		public send(src: _Host.SCALED_IMU3): boolean ;
		public send(src: _Host.MOUNT_CONTROL): boolean ;
		public send(src: _Host.LED_CONTROL): boolean ;
		public send(src: _Host.SIM_STATE): boolean ;
		public send(src: _Host.WIFI_CONFIG_AP): boolean ;
		public send(src: _Host.DATA96): boolean ;
		public send(src: _Host.FLIGHT_INFORMATION): boolean ;
		public send(src: _Host.MEMINFO): boolean ;
		public send(src: _Host.LOGGING_ACK): boolean ;
		public send(src: _Host.VISION_SPEED_ESTIMATE): boolean ;
		public send(src: _Host.DEBUG_VECT): boolean ;
		public send(src: _Host.CAMERA_TRIGGER): boolean ;
		public send(src: _Host.LOG_REQUEST_END): boolean ;
		public send(src: _Host.GOPRO_SET_RESPONSE): boolean ;
		public send(src: _Host.PROTOCOL_VERSION): boolean ;
		public send(src: _Host.RALLY_FETCH_POINT): boolean ;
		public send(src: _Host.BATTERY_STATUS): boolean ;
		public send(src: _Host.MOUNT_ORIENTATION): boolean ;
		public send(src: _Host.SERIAL_CONTROL): boolean ;
		public send(src: _Host.PARAM_EXT_SET): boolean ;
		public send(src: _Host.AUTOPILOT_VERSION): boolean ;
		public send(src: _Host.SIMSTATE): boolean ;
		public send(src: _Host.SET_VIDEO_STREAM_SETTINGS): boolean ;
		public send(src: _Host.PLAY_TUNE): boolean ;
		public send(src: _Host.DIGICAM_CONFIGURE): boolean ;
		public send(src: _Host.SCALED_PRESSURE3): boolean ;
		public send(src: _Host.PARAM_EXT_ACK): boolean ;
		public send(src: _Host.UAVCAN_NODE_INFO): boolean ;
		public send(src: _Host.DATA16): boolean ;
		public send(src: _Host.SET_MAG_OFFSETS): boolean ;
		public send(src: _Host.SCALED_IMU2): boolean ;
		public send(src: _Host.AP_ADC): boolean ;
		public send(src: _Host.WIND): boolean ;
		public send(src: _Host.AUTOPILOT_VERSION_REQUEST): boolean ;
		public send(src: _Host.DATA_TRANSMISSION_HANDSHAKE): boolean ;
		public send(src: _Host.DATA64): boolean ;
		public send(src: _Host.GIMBAL_REPORT): boolean ;
		public send(src: _Host.DEVICE_OP_WRITE): boolean ;
		public send(src: _Host.DISTANCE_SENSOR): boolean ;
		public send(src: _Host.HIL_OPTICAL_FLOW): boolean ;
		public send(src: _Host.SCALED_PRESSURE2): boolean ;
		public send(src: _Host.WIND_COV): boolean ;
		public send(src: _Host.GOPRO_SET_REQUEST): boolean ;
		public send(src: _Host.VISION_POSITION_DELTA): boolean ;
		public send(src: _Host.LOGGING_DATA): boolean ;
		public send(src: _Host.DEVICE_OP_READ): boolean ;
		public send(src: _Host.MAG_CAL_PROGRESS): boolean ;
		public send(src: _Host.HIGHRES_IMU): boolean ;
		public send(src: _Host.EXTENDED_SYS_STATE): boolean ;
		public send(src: _Host.UAVIONIX_ADSB_OUT_DYNAMIC): boolean ;
		public send(src: _Host.GOPRO_GET_RESPONSE): boolean ;
		public send(src: _Host.GPS_INJECT_DATA): boolean ;
		public send(src: _Host.UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT): boolean ;
		public send(src: _Host.NAMED_VALUE_INT): boolean ;
		public send(src: _Host.RPM): boolean ;
		public send(src: _Host.GPS_RTCM_DATA): boolean ;
		public send(src: _Host.FILE_TRANSFER_PROTOCOL): boolean ;
		public send(src: _Host.RANGEFINDER): boolean ;
		public send(src: _Host.RADIO_STATUS): boolean ;
		public send(src: _Host.FENCE_POINT): boolean ;
		public send(src: _Host.RESOURCE_REQUEST): boolean ;
		
		public send(src): boolean {
			if (!src.data_.bytes) return false;
			let pack = src.data_.unwrap();
			if (this.pushSendingPack(pack)) return true;
			src.data_.wrap(pack);
			return false;
		}
		
		
		abstract onRESOURCE_REQUEST(pack: _Pack);
		
		abstract onATTITUDE_TARGET(pack: _Pack);
		
		abstract onMISSION_COUNT(pack: _Pack);
		
		abstract onADSB_VEHICLE(pack: _Pack);
		
		abstract onMESSAGE_INTERVAL(pack: _Pack);
		
		abstract onESTIMATOR_STATUS(pack: _Pack);
		
		abstract onTIMESYNC(pack: _Pack);
		
		abstract onGLOBAL_POSITION_INT_COV(pack: _Pack);
		
		abstract onBUTTON_CHANGE(pack: _Pack);
		
		abstract onSAFETY_SET_ALLOWED_AREA(pack: _Pack);
		
		abstract onSTORAGE_INFORMATION(pack: _Pack);
		
		abstract onCOLLISION(pack: _Pack);
		
		abstract onALTITUDE(pack: _Pack);
		
		abstract onHIL_STATE_QUATERNION(pack: _Pack);
		
		abstract onCAMERA_INFORMATION(pack: _Pack);
		
		abstract onGPS_STATUS(pack: _Pack);
		
		abstract onPARAM_SET(pack: _Pack);
		
		abstract onTERRAIN_DATA(pack: _Pack);
		
		abstract onRC_CHANNELS_OVERRIDE(pack: _Pack);
		
		abstract onSCALED_IMU(pack: _Pack);
		
		abstract onDEBUG(pack: _Pack);
		
		abstract onCAMERA_IMAGE_CAPTURED(pack: _Pack);
		
		abstract onLOG_ENTRY(pack: _Pack);
		
		abstract onACTUATOR_CONTROL_TARGET(pack: _Pack);
		
		abstract onHIGH_LATENCY(pack: _Pack);
		
		abstract onPARAM_REQUEST_READ(pack: _Pack);
		
		abstract onSET_ATTITUDE_TARGET(pack: _Pack);
		
		abstract onFOLLOW_TARGET(pack: _Pack);
		
		abstract onHIL_STATE(pack: _Pack);
		
		abstract onHOME_POSITION(pack: _Pack);
		
		abstract onGPS2_RAW(pack: _Pack);
		
		abstract onMEMORY_VECT(pack: _Pack);
		
		abstract onREQUEST_DATA_STREAM(pack: _Pack);
		
		abstract onHIL_CONTROLS(pack: _Pack);
		
		abstract onHIL_SENSOR(pack: _Pack);
		
		abstract onSETUP_SIGNING(pack: _Pack);
		
		abstract onGPS_RTK(pack: _Pack);
		
		abstract onPARAM_REQUEST_LIST(pack: _Pack);
		
		abstract onLANDING_TARGET(pack: _Pack);
		
		abstract onSET_ACTUATOR_CONTROL_TARGET(pack: _Pack);
		
		abstract onCONTROL_SYSTEM_STATE(pack: _Pack);
		
		abstract onSET_POSITION_TARGET_GLOBAL_INT(pack: _Pack);
		
		abstract onVIBRATION(pack: _Pack);
		
		abstract onPING33(pack: _Pack);
		
		abstract onVFR_HUD(pack: _Pack);
		
		abstract onMISSION_SET_CURRENT(pack: _Pack);
		
		abstract onHIL_GPS(pack: _Pack);
		
		abstract onNAV_CONTROLLER_OUTPUT(pack: _Pack);
		
		abstract onAUTH_KEY(pack: _Pack);
		
		abstract onLOCAL_POSITION_NED_COV(pack: _Pack);
		
		abstract onATT_POS_MOCAP(pack: _Pack);
		
		abstract onSTATUSTEXT(pack: _Pack);
		
		abstract onPING(pack: _Pack);
		
		abstract onCAMERA_CAPTURE_STATUS(pack: _Pack);
		
		abstract onGLOBAL_POSITION_INT(pack: _Pack);
		
		abstract onENCAPSULATED_DATA(pack: _Pack);
		
		abstract onGPS_INPUT(pack: _Pack);
		
		abstract onCOMMAND_LONG(pack: _Pack);
		
		abstract onLOG_REQUEST_DATA(pack: _Pack);
		
		abstract onGPS_RAW_INT(pack: _Pack);
		
		abstract onRC_CHANNELS_SCALED(pack: _Pack);
		
		abstract onCAMERA_SETTINGS(pack: _Pack);
		
		abstract onRAW_PRESSURE(pack: _Pack);
		
		abstract onNAMED_VALUE_FLOAT(pack: _Pack);
		
		abstract onATTITUDE(pack: _Pack);
		
		abstract onTERRAIN_REQUEST(pack: _Pack);
		
		abstract onMISSION_WRITE_PARTIAL_LIST(pack: _Pack);
		
		abstract onLOG_ERASE(pack: _Pack);
		
		abstract onMANUAL_SETPOINT(pack: _Pack);
		
		abstract onSAFETY_ALLOWED_AREA(pack: _Pack);
		
		abstract onOPTICAL_FLOW_RAD(pack: _Pack);
		
		abstract onLOG_DATA(pack: _Pack);
		
		abstract onMISSION_CLEAR_ALL(pack: _Pack);
		
		abstract onVICON_POSITION_ESTIMATE(pack: _Pack);
		
		abstract onGPS2_RTK(pack: _Pack);
		
		abstract onLOG_REQUEST_LIST(pack: _Pack);
		
		abstract onSCALED_PRESSURE(pack: _Pack);
		
		abstract onMISSION_REQUEST_INT(pack: _Pack);
		
		abstract onV2_EXTENSION(pack: _Pack);
		
		abstract onHEARTBEAT(pack: _Pack);
		
		abstract onPARAM_MAP_RC(pack: _Pack);
		
		abstract onPOWER_STATUS(pack: _Pack);
		
		abstract onTERRAIN_CHECK(pack: _Pack);
		
		abstract onLOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(pack: _Pack);
		
		abstract onCOMMAND_ACK(pack: _Pack);
		
		abstract onDATA_STREAM(pack: _Pack);
		
		abstract onMISSION_REQUEST(pack: _Pack);
		
		abstract onTERRAIN_REPORT(pack: _Pack);
		
		abstract onSET_HOME_POSITION(pack: _Pack);
		
		abstract onSwitchModeCommand();
		
		abstract onHIL_RC_INPUTS_RAW(pack: _Pack);
		
		abstract onSCALED_IMU3(pack: _Pack);
		
		abstract onSET_MODE(pack: _Pack);
		
		abstract onPOSITION_TARGET_GLOBAL_INT(pack: _Pack);
		
		abstract onFLIGHT_INFORMATION(pack: _Pack);
		
		abstract onSIM_STATE(pack: _Pack);
		
		abstract onMISSION_ITEM_REACHED(pack: _Pack);
		
		abstract onRC_CHANNELS_RAW(pack: _Pack);
		
		abstract onSERVO_OUTPUT_RAW(pack: _Pack);
		
		abstract onVISION_SPEED_ESTIMATE(pack: _Pack);
		
		abstract onDEBUG_VECT(pack: _Pack);
		
		abstract onLOG_REQUEST_END(pack: _Pack);
		
		abstract onMISSION_ACK(pack: _Pack);
		
		abstract onCHANGE_OPERATOR_CONTROL_ACK(pack: _Pack);
		
		abstract onMISSION_CURRENT(pack: _Pack);
		
		abstract onSYSTEM_TIME(pack: _Pack);
		
		abstract onCAMERA_TRIGGER(pack: _Pack);
		
		abstract onVISION_POSITION_ESTIMATE(pack: _Pack);
		
		abstract onMANUAL_CONTROL(pack: _Pack);
		
		abstract onRC_CHANNELS(pack: _Pack);
		
		abstract onPARAM_VALUE(pack: _Pack);
		
		abstract onBATTERY_STATUS(pack: _Pack);
		
		abstract onSET_POSITION_TARGET_LOCAL_NED(pack: _Pack);
		
		abstract onSERIAL_CONTROL(pack: _Pack);
		
		abstract onSET_GPS_GLOBAL_ORIGIN(pack: _Pack);
		
		abstract onAUTOPILOT_VERSION(pack: _Pack);
		
		abstract onMISSION_REQUEST_LIST(pack: _Pack);
		
		abstract onPLAY_TUNE(pack: _Pack);
		
		abstract onSCALED_PRESSURE3(pack: _Pack);
		
		abstract onMISSION_REQUEST_PARTIAL_LIST(pack: _Pack);
		
		abstract onLOCAL_POSITION_NED(pack: _Pack);
		
		abstract onDATA_TRANSMISSION_HANDSHAKE(pack: _Pack);
		
		abstract onGPS_GLOBAL_ORIGIN(pack: _Pack);
		
		abstract onSCALED_IMU2(pack: _Pack);
		
		abstract onATTITUDE_QUATERNION(pack: _Pack);
		
		abstract onHIL_ACTUATOR_CONTROLS(pack: _Pack);
		
		abstract onPOSITION_TARGET_LOCAL_NED(pack: _Pack);
		
		abstract onDISTANCE_SENSOR(pack: _Pack);
		
		abstract onHIL_OPTICAL_FLOW(pack: _Pack);
		
		abstract onSCALED_PRESSURE2(pack: _Pack);
		
		abstract onWIND_COV(pack: _Pack);
		
		abstract onCHANGE_OPERATOR_CONTROL(pack: _Pack);
		
		abstract onSYS_STATUS(pack: _Pack);
		
		abstract onMISSION_ITEM(pack: _Pack);
		
		abstract onRAW_IMU(pack: _Pack);
		
		abstract onCOMMAND_INT(pack: _Pack);
		
		abstract onOPTICAL_FLOW(pack: _Pack);
		
		abstract onMISSION_ITEM_INT(pack: _Pack);
		
		abstract onHIGHRES_IMU(pack: _Pack);
		
		abstract onEXTENDED_SYS_STATE(pack: _Pack);
		
		abstract onGPS_INJECT_DATA(pack: _Pack);
		
		abstract onATTITUDE_QUATERNION_COV(pack: _Pack);
		
		abstract onNAMED_VALUE_INT(pack: _Pack);
		
		abstract onRADIO_STATUS(pack: _Pack);
		
		abstract onGPS_RTCM_DATA(pack: _Pack);
		
		abstract onGLOBAL_VISION_POSITION_ESTIMATE(pack: _Pack);
		
		abstract onFILE_TRANSFER_PROTOCOL(pack: _Pack);
		
	}
	
	export namespace CommunicationChannel {
		
		export class Receiver extends _Lib.Channel.Receiver {
			constructor(public readonly ch: CommunicationChannel) { super(1, 1) }
			
			dispatch(id: number, pack: _Pack): _Pack.Meta | null {
				switch (id) {
					
					case 120 :
						if (!pack) return _Host.RC_CHANNELS_SCALED.meta_;
						this.ch.onRC_CHANNELS_SCALED(pack);
						
						break;
					
					case 107 :
						if (!pack) return _Host.RADIO_STATUS.meta_;
						this.ch.onRADIO_STATUS(pack);
						
						break;
					
					case 137 :
						if (!pack) return _Host.HIGHRES_IMU.meta_;
						this.ch.onHIGHRES_IMU(pack);
						
						break;
					
					case 116 :
						if (!pack) return _Host.HIL_OPTICAL_FLOW.meta_;
						this.ch.onHIL_OPTICAL_FLOW(pack);
						
						break;
					
					case 215 :
						if (!pack) return _Host.FLIGHT_INFORMATION.meta_;
						this.ch.onFLIGHT_INFORMATION(pack);
						
						break;
					
					case 195 :
						if (!pack) return _Host.SCALED_IMU.meta_;
						this.ch.onSCALED_IMU(pack);
						
						break;
					
					case 133 :
						if (!pack) return _Host.POSITION_TARGET_GLOBAL_INT.meta_;
						this.ch.onPOSITION_TARGET_GLOBAL_INT(pack);
						
						break;
					
					case 72 :
						if (!pack) return _Host.LOG_REQUEST_DATA.meta_;
						this.ch.onLOG_REQUEST_DATA(pack);
						
						break;
					
					case 185 :
						if (!pack) return _Host.GPS_GLOBAL_ORIGIN.meta_;
						this.ch.onGPS_GLOBAL_ORIGIN(pack);
						
						break;
					
					case 163 :
						if (!pack) return _Host.RAW_IMU.meta_;
						this.ch.onRAW_IMU(pack);
						
						break;
					
					case 125 :
						if (!pack) return _Host.HEARTBEAT.meta_;
						this.ch.onHEARTBEAT(pack);
						
						break;
					
					case 199 :
						if (!pack) return _Host.HIL_ACTUATOR_CONTROLS.meta_;
						this.ch.onHIL_ACTUATOR_CONTROLS(pack);
						
						break;
					
					case 55 :
						if (!pack) return _Host.RC_CHANNELS_OVERRIDE.meta_;
						this.ch.onRC_CHANNELS_OVERRIDE(pack);
						
						break;
					
					case 45 :
						if (!pack) return _Host.COLLISION.meta_;
						this.ch.onCOLLISION(pack);
						
						break;
					
					case 61 :
						if (!pack) return _Host.DISTANCE_SENSOR.meta_;
						this.ch.onDISTANCE_SENSOR(pack);
						
						break;
					
					case 38 :
						if (!pack) return _Host.ESTIMATOR_STATUS.meta_;
						this.ch.onESTIMATOR_STATUS(pack);
						
						break;
					
					case 205 :
						if (!pack) return _Host.SETUP_SIGNING.meta_;
						this.ch.onSETUP_SIGNING(pack);
						
						break;
					
					case 3 :
						if (!pack) return _Host.ACTUATOR_CONTROL_TARGET.meta_;
						this.ch.onACTUATOR_CONTROL_TARGET(pack);
						
						break;
					
					case 56 :
						if (!pack) return _Host.GPS_RAW_INT.meta_;
						this.ch.onGPS_RAW_INT(pack);
						
						break;
					
					case 98 :
						if (!pack) return _Host.REQUEST_DATA_STREAM.meta_;
						this.ch.onREQUEST_DATA_STREAM(pack);
						
						break;
					
					case 212 :
						if (!pack) return _Host.MISSION_SET_CURRENT.meta_;
						this.ch.onMISSION_SET_CURRENT(pack);
						
						break;
					
					case 21 :
						if (!pack) return _Host.NAMED_VALUE_INT.meta_;
						this.ch.onNAMED_VALUE_INT(pack);
						
						break;
					
					case 129 :
						if (!pack) return _Host.POSITION_TARGET_LOCAL_NED.meta_;
						this.ch.onPOSITION_TARGET_LOCAL_NED(pack);
						
						break;
					
					case 152 :
						if (!pack) return _Host.TERRAIN_CHECK.meta_;
						this.ch.onTERRAIN_CHECK(pack);
						
						break;
					
					case 121 :
						if (!pack) return _Host.COMMAND_ACK.meta_;
						this.ch.onCOMMAND_ACK(pack);
						
						break;
					
					case 124 :
						if (!pack) return _Host.STATUSTEXT.meta_;
						this.ch.onSTATUSTEXT(pack);
						
						break;
					
					case 2 :
						if (!pack) return _Host.SCALED_IMU3.meta_;
						this.ch.onSCALED_IMU3(pack);
						
						break;
					
					case 168 :
						if (!pack) return _Host.HIL_GPS.meta_;
						this.ch.onHIL_GPS(pack);
						
						break;
					
					case 42 :
						if (!pack) return _Host.VISION_SPEED_ESTIMATE.meta_;
						this.ch.onVISION_SPEED_ESTIMATE(pack);
						
						break;
					
					case 187 :
						if (!pack) return _Host.DEBUG_VECT.meta_;
						this.ch.onDEBUG_VECT(pack);
						
						break;
					
					case 94 :
						if (!pack) return _Host.SET_ACTUATOR_CONTROL_TARGET.meta_;
						this.ch.onSET_ACTUATOR_CONTROL_TARGET(pack);
						
						break;
					
					case 204 :
						if (!pack) return _Host.LOG_DATA.meta_;
						this.ch.onLOG_DATA(pack);
						
						break;
					
					case 58 :
						if (!pack) return _Host.STORAGE_INFORMATION.meta_;
						this.ch.onSTORAGE_INFORMATION(pack);
						
						break;
					
					case 102 :
						if (!pack) return _Host.LOG_REQUEST_END.meta_;
						this.ch.onLOG_REQUEST_END(pack);
						
						break;
					
					case 132 :
						if (!pack) return _Host.SYS_STATUS.meta_;
						this.ch.onSYS_STATUS(pack);
						
						break;
					
					case 50 :
						if (!pack) return _Host.MISSION_COUNT.meta_;
						this.ch.onMISSION_COUNT(pack);
						
						break;
					
					case 216 :
						if (!pack) return _Host.CAMERA_CAPTURE_STATUS.meta_;
						this.ch.onCAMERA_CAPTURE_STATUS(pack);
						
						break;
					
					case 146 :
						if (!pack) return _Host.BUTTON_CHANGE.meta_;
						this.ch.onBUTTON_CHANGE(pack);
						
						break;
					
					case 73 :
						if (!pack) return _Host.GPS_INPUT.meta_;
						this.ch.onGPS_INPUT(pack);
						
						break;
					
					case 6 :
						if (!pack) return _Host.GLOBAL_POSITION_INT_COV.meta_;
						this.ch.onGLOBAL_POSITION_INT_COV(pack);
						
						break;
					
					case 189 :
						if (!pack) return _Host.MISSION_CURRENT.meta_;
						this.ch.onMISSION_CURRENT(pack);
						
						break;
					
					case 172 :
						if (!pack) return _Host.LANDING_TARGET.meta_;
						this.ch.onLANDING_TARGET(pack);
						
						break;
					
					case 35 :
						if (!pack) return _Host.MISSION_ITEM.meta_;
						this.ch.onMISSION_ITEM(pack);
						
						break;
					
					case 206 :
						if (!pack) return _Host.MISSION_REQUEST_PARTIAL_LIST.meta_;
						this.ch.onMISSION_REQUEST_PARTIAL_LIST(pack);
						
						break;
					
					case 196 :
						if (!pack) return _Host.HIL_STATE_QUATERNION.meta_;
						this.ch.onHIL_STATE_QUATERNION(pack);
						
						break;
					
					case 188 :
						if (!pack) return _Host.MISSION_REQUEST_INT.meta_;
						this.ch.onMISSION_REQUEST_INT(pack);
						
						break;
					
					case 31 :
						if (!pack) return _Host.DATA_STREAM.meta_;
						this.ch.onDATA_STREAM(pack);
						
						break;
					
					case 156 :
						if (!pack) return _Host.POWER_STATUS.meta_;
						this.ch.onPOWER_STATUS(pack);
						
						break;
					
					case 34 :
						if (!pack) return _Host.ALTITUDE.meta_;
						this.ch.onALTITUDE(pack);
						
						break;
					
					case 167 :
						if (!pack) return _Host.COMMAND_INT.meta_;
						this.ch.onCOMMAND_INT(pack);
						
						break;
					
					case 154 :
						if (!pack) return _Host.CHANGE_OPERATOR_CONTROL.meta_;
						this.ch.onCHANGE_OPERATOR_CONTROL(pack);
						
						break;
					
					case 162 :
						if (!pack) return _Host.GLOBAL_POSITION_INT.meta_;
						this.ch.onGLOBAL_POSITION_INT(pack);
						
						break;
					
					case 99 :
						if (!pack) return _Host.SERIAL_CONTROL.meta_;
						this.ch.onSERIAL_CONTROL(pack);
						
						break;
					
					case 91 :
						if (!pack) return _Host.GPS2_RTK.meta_;
						this.ch.onGPS2_RTK(pack);
						
						break;
					
					case 200 :
						if (!pack) return _Host.ATT_POS_MOCAP.meta_;
						this.ch.onATT_POS_MOCAP(pack);
						
						break;
					
					case 59 :
						if (!pack) return _Host.MISSION_ITEM_INT.meta_;
						this.ch.onMISSION_ITEM_INT(pack);
						
						break;
					
					case 176 :
						if (!pack) return _Host.EXTENDED_SYS_STATE.meta_;
						this.ch.onEXTENDED_SYS_STATE(pack);
						
						break;
					
					case 67 :
						if (!pack) return _Host.RESOURCE_REQUEST.meta_;
						this.ch.onRESOURCE_REQUEST(pack);
						
						break;
					
					case 173 :
						if (!pack) return _Host.TERRAIN_DATA.meta_;
						this.ch.onTERRAIN_DATA(pack);
						
						break;
					
					case 174 :
						if (!pack) return _Host.V2_EXTENSION.meta_;
						this.ch.onV2_EXTENSION(pack);
						
						break;
					
					case 25 :
						if (!pack) return _Host.MISSION_REQUEST_LIST.meta_;
						this.ch.onMISSION_REQUEST_LIST(pack);
						
						break;
					
					case 78 :
						if (!pack) return _Host.ADSB_VEHICLE.meta_;
						this.ch.onADSB_VEHICLE(pack);
						
						break;
					
					case 151 :
						if (!pack) return _Host.SCALED_PRESSURE2.meta_;
						this.ch.onSCALED_PRESSURE2(pack);
						
						break;
					
					case 108 :
						if (!pack) return _Host.SIM_STATE.meta_;
						this.ch.onSIM_STATE(pack);
						
						break;
					
					case 41 :
						if (!pack) return _Host.MESSAGE_INTERVAL.meta_;
						this.ch.onMESSAGE_INTERVAL(pack);
						
						break;
					
					case 145 :
						if (!pack) return _Host.MISSION_WRITE_PARTIAL_LIST.meta_;
						this.ch.onMISSION_WRITE_PARTIAL_LIST(pack);
						
						break;
					
					case 130 :
						if (!pack) return _Host.SCALED_PRESSURE3.meta_;
						this.ch.onSCALED_PRESSURE3(pack);
						
						break;
					
					case 24 :
						if (!pack) return _Host.SAFETY_SET_ALLOWED_AREA.meta_;
						this.ch.onSAFETY_SET_ALLOWED_AREA(pack);
						
						break;
					
					case 92 :
						if (!pack) return _Host.TERRAIN_REQUEST.meta_;
						this.ch.onTERRAIN_REQUEST(pack);
						
						break;
					
					case 122 :
						if (!pack) return _Host.PING.meta_;
						this.ch.onPING(pack);
						
						break;
					
					case 7 :
						if (!pack) return _Host.SET_MODE.meta_;
						this.ch.onSET_MODE(pack);
						
						break;
					
					case 134 :
						if (!pack) return _Host.ATTITUDE.meta_;
						this.ch.onATTITUDE(pack);
						
						break;
					
					case 18 :
						if (!pack) return _Host.SCALED_PRESSURE.meta_;
						this.ch.onSCALED_PRESSURE(pack);
						
						break;
					
					case 219 :
						if (!pack) return _Host.MANUAL_SETPOINT.meta_;
						this.ch.onMANUAL_SETPOINT(pack);
						
						break;
					
					case 15 :
						if (!pack) return _Host.VFR_HUD.meta_;
						this.ch.onVFR_HUD(pack);
						
						break;
					
					case 10 :
						if (!pack) return _Host.CAMERA_IMAGE_CAPTURED.meta_;
						this.ch.onCAMERA_IMAGE_CAPTURED(pack);
						
						break;
					
					case 16 :
						if (!pack) return _Host.VISION_POSITION_ESTIMATE.meta_;
						this.ch.onVISION_POSITION_ESTIMATE(pack);
						
						break;
					
					case 106 :
						if (!pack) return _Host.ATTITUDE_TARGET.meta_;
						this.ch.onATTITUDE_TARGET(pack);
						
						break;
					
					case 27 :
						if (!pack) return _Host.FILE_TRANSFER_PROTOCOL.meta_;
						this.ch.onFILE_TRANSFER_PROTOCOL(pack);
						
						break;
					
					case 13 :
						if (!pack) return _Host.OPTICAL_FLOW.meta_;
						this.ch.onOPTICAL_FLOW(pack);
						
						break;
					
					case 157 :
						if (!pack) return _Host.CAMERA_INFORMATION.meta_;
						this.ch.onCAMERA_INFORMATION(pack);
						
						break;
					
					case 103 :
						if (!pack) return _Host.VIBRATION.meta_;
						this.ch.onVIBRATION(pack);
						
						break;
					
					case 218 :
						if (!pack) return _Host.SET_POSITION_TARGET_GLOBAL_INT.meta_;
						this.ch.onSET_POSITION_TARGET_GLOBAL_INT(pack);
						
						break;
					
					case 71 :
						if (!pack) return _Host.ATTITUDE_QUATERNION.meta_;
						this.ch.onATTITUDE_QUATERNION(pack);
						
						break;
					
					case 181 :
						if (!pack) return _Host.CAMERA_SETTINGS.meta_;
						this.ch.onCAMERA_SETTINGS(pack);
						
						break;
					
					case 77 :
						if (!pack) return _Host.SET_HOME_POSITION.meta_;
						this.ch.onSET_HOME_POSITION(pack);
						
						break;
					
					case 62 :
						if (!pack) return _Host.CHANGE_OPERATOR_CONTROL_ACK.meta_;
						this.ch.onCHANGE_OPERATOR_CONTROL_ACK(pack);
						
						break;
					
					case 87 :
						if (!pack) return _Host.HIGH_LATENCY.meta_;
						this.ch.onHIGH_LATENCY(pack);
						
						break;
					
					case 161 :
						if (!pack) return _Host.LOG_ENTRY.meta_;
						this.ch.onLOG_ENTRY(pack);
						
						break;
					
					case 170 :
						if (!pack) return _Host.ENCAPSULATED_DATA.meta_;
						this.ch.onENCAPSULATED_DATA(pack);
						
						break;
					
					case 179 :
						if (!pack) return _Host.SAFETY_ALLOWED_AREA.meta_;
						this.ch.onSAFETY_ALLOWED_AREA(pack);
						
						break;
					
					case 37 :
						if (!pack) return _Host.LOG_REQUEST_LIST.meta_;
						this.ch.onLOG_REQUEST_LIST(pack);
						
						break;
					
					case 95 :
						if (!pack) return _Host.AUTH_KEY.meta_;
						this.ch.onAUTH_KEY(pack);
						
						break;
					
					case 101 :
						if (!pack) return _Host.COMMAND_LONG.meta_;
						this.ch.onCOMMAND_LONG(pack);
						
						break;
					
					case 48 :
						if (!pack) return _Host.GPS_STATUS.meta_;
						this.ch.onGPS_STATUS(pack);
						
						break;
					
					case 201 :
						if (!pack) return _Host.NAV_CONTROLLER_OUTPUT.meta_;
						this.ch.onNAV_CONTROLLER_OUTPUT(pack);
						
						break;
					
					case 203 :
						if (!pack) return _Host.PLAY_TUNE.meta_;
						this.ch.onPLAY_TUNE(pack);
						
						break;
					
					case 111 :
						if (!pack) return _Host.BATTERY_STATUS.meta_;
						this.ch.onBATTERY_STATUS(pack);
						
						break;
					
					case 4 :
						if (!pack) return _Host.LOG_ERASE.meta_;
						this.ch.onLOG_ERASE(pack);
						
						break;
					
					case 210 :
						if (!pack) return _Host.HOME_POSITION.meta_;
						this.ch.onHOME_POSITION(pack);
						
						break;
					
					case 169 :
						if (!pack) return _Host.HIL_SENSOR.meta_;
						this.ch.onHIL_SENSOR(pack);
						
						break;
					
					case 52 :
						if (!pack) return _Host.GPS_INJECT_DATA.meta_;
						this.ch.onGPS_INJECT_DATA(pack);
						
						break;
					
					case 209 :
						if (!pack) return _Host.SET_POSITION_TARGET_LOCAL_NED.meta_;
						this.ch.onSET_POSITION_TARGET_LOCAL_NED(pack);
						
						break;
					
					case 81 :
						if (!pack) return _Host.MISSION_ITEM_REACHED.meta_;
						this.ch.onMISSION_ITEM_REACHED(pack);
						
						break;
					
					case 180 :
						if (!pack) return _Host.LOCAL_POSITION_NED_COV.meta_;
						this.ch.onLOCAL_POSITION_NED_COV(pack);
						
						break;
					
					case 191 :
						if (!pack) return _Host.CAMERA_TRIGGER.meta_;
						this.ch.onCAMERA_TRIGGER(pack);
						
						break;
					
					case 9 :
						if (!pack) return _Host.SYSTEM_TIME.meta_;
						this.ch.onSYSTEM_TIME(pack);
						
						break;
					
					case 207 :
						if (!pack) return _Host.CONTROL_SYSTEM_STATE.meta_;
						this.ch.onCONTROL_SYSTEM_STATE(pack);
						
						break;
					
					case 148 :
						if (!pack) return _Host.RC_CHANNELS_RAW.meta_;
						this.ch.onRC_CHANNELS_RAW(pack);
						
						break;
					
					case 178 :
						if (!pack) return _Host.SCALED_IMU2.meta_;
						this.ch.onSCALED_IMU2(pack);
						
						break;
					
					case 131 :
						if (!pack) return _Host.LOCAL_POSITION_NED.meta_;
						this.ch.onLOCAL_POSITION_NED(pack);
						
						break;
					
					case 149 :
						if (!pack) return _Host.DATA_TRANSMISSION_HANDSHAKE.meta_;
						this.ch.onDATA_TRANSMISSION_HANDSHAKE(pack);
						
						break;
					
					case 139 :
						if (!pack) return _Host.PING33.meta_;
						this.ch.onPING33(pack);
						
						break;
					
					case 135 :
						if (!pack) return _Host.VICON_POSITION_ESTIMATE.meta_;
						this.ch.onVICON_POSITION_ESTIMATE(pack);
						
						break;
					
					case 123 :
						if (!pack) return _Host.PARAM_SET.meta_;
						this.ch.onPARAM_SET(pack);
						
						break;
					
					case 86 :
						if (!pack) return _Host.TERRAIN_REPORT.meta_;
						this.ch.onTERRAIN_REPORT(pack);
						
						break;
					
					case 74 :
						if (!pack) return _Host.SET_ATTITUDE_TARGET.meta_;
						this.ch.onSET_ATTITUDE_TARGET(pack);
						
						break;
					
					case 213 :
						if (!pack) return _Host.GPS2_RAW.meta_;
						this.ch.onGPS2_RAW(pack);
						
						break;
					
					case 47 :
						if (!pack) return _Host.PARAM_REQUEST_LIST.meta_;
						this.ch.onPARAM_REQUEST_LIST(pack);
						
						break;
					
					case 60 :
						if (!pack) return _Host.AUTOPILOT_VERSION.meta_;
						this.ch.onAUTOPILOT_VERSION(pack);
						
						break;
					
					case 126 :
						if (!pack) return _Host.DEBUG.meta_;
						this.ch.onDEBUG(pack);
						
						break;
					
					case 82 :
						if (!pack) return _Host.HIL_CONTROLS.meta_;
						this.ch.onHIL_CONTROLS(pack);
						
						break;
					
					case 39 :
						if (!pack) return _Host.FOLLOW_TARGET.meta_;
						this.ch.onFOLLOW_TARGET(pack);
						
						break;
					
					case 184 :
						if (!pack) return _Host.HIL_RC_INPUTS_RAW.meta_;
						this.ch.onHIL_RC_INPUTS_RAW(pack);
						
						break;
					
					case 53 :
						if (!pack) return _Host.SET_GPS_GLOBAL_ORIGIN.meta_;
						this.ch.onSET_GPS_GLOBAL_ORIGIN(pack);
						
						break;
					
					case 182 :
						if (!pack) return _Host.ATTITUDE_QUATERNION_COV.meta_;
						this.ch.onATTITUDE_QUATERNION_COV(pack);
						
						break;
					
					case 136 :
						if (!pack) return _Host.PARAM_VALUE.meta_;
						this.ch.onPARAM_VALUE(pack);
						
						break;
					
					case 147 :
						if (!pack) return _Host.MISSION_REQUEST.meta_;
						this.ch.onMISSION_REQUEST(pack);
						
						break;
					
					case 202 :
						if (!pack) return _Host.OPTICAL_FLOW_RAD.meta_;
						this.ch.onOPTICAL_FLOW_RAD(pack);
						
						break;
					
					case 160 :
						if (!pack) return _Host.WIND_COV.meta_;
						this.ch.onWIND_COV(pack);
						
						break;
					
					case 46 :
						if (!pack) return _Host.TIMESYNC.meta_;
						this.ch.onTIMESYNC(pack);
						
						break;
					
					case 85 :
						if (!pack) return _Host.MISSION_ACK.meta_;
						this.ch.onMISSION_ACK(pack);
						
						break;
					
					case 166 :
						if (!pack) return _Host.PARAM_REQUEST_READ.meta_;
						this.ch.onPARAM_REQUEST_READ(pack);
						
						break;
					
					case 140 :
						if (!pack) return _Host.HIL_STATE.meta_;
						this.ch.onHIL_STATE(pack);
						
						break;
					
					case 89 :
						if (!pack) return _Host.GPS_RTK.meta_;
						this.ch.onGPS_RTK(pack);
						
						break;
					
					case 19 :
						if (!pack) return _Host.RAW_PRESSURE.meta_;
						this.ch.onRAW_PRESSURE(pack);
						
						break;
					
					case 193 :
						if (!pack) return _Host.MISSION_CLEAR_ALL.meta_;
						this.ch.onMISSION_CLEAR_ALL(pack);
						
						break;
					
					case 28 :
						if (!pack) return _Host.SwitchModeCommand.pack_.meta;
						this.ch.onSwitchModeCommand();
						
						break;
					
					case 23 :
						if (!pack) return _Host.RC_CHANNELS.meta_;
						this.ch.onRC_CHANNELS(pack);
						
						break;
					
					case 158 :
						if (!pack) return _Host.LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET.meta_;
						this.ch.onLOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(pack);
						
						break;
					
					case 110 :
						if (!pack) return _Host.GLOBAL_VISION_POSITION_ESTIMATE.meta_;
						this.ch.onGLOBAL_VISION_POSITION_ESTIMATE(pack);
						
						break;
					
					case 79 :
						if (!pack) return _Host.SERVO_OUTPUT_RAW.meta_;
						this.ch.onSERVO_OUTPUT_RAW(pack);
						
						break;
					
					case 8 :
						if (!pack) return _Host.NAMED_VALUE_FLOAT.meta_;
						this.ch.onNAMED_VALUE_FLOAT(pack);
						
						break;
					
					case 30 :
						if (!pack) return _Host.MEMORY_VECT.meta_;
						this.ch.onMEMORY_VECT(pack);
						
						break;
					
					case 54 :
						if (!pack) return _Host.MANUAL_CONTROL.meta_;
						this.ch.onMANUAL_CONTROL(pack);
						
						break;
					
					case 88 :
						if (!pack) return _Host.GPS_RTCM_DATA.meta_;
						this.ch.onGPS_RTCM_DATA(pack);
						
						break;
					
					case 29 :
						if (!pack) return _Host.PARAM_MAP_RC.meta_;
						this.ch.onPARAM_MAP_RC(pack);
						
						break;
					
				}
				return null;
			}
		}
		
		
		export class Transmitter extends _Lib.Channel.Transmitter {
			constructor(public readonly ch: CommunicationChannel) { super(1, 1); }
			
			public pullSendingPack(): _Pack | null { return this.ch.pullSendingPack(); }
		}
		
		export namespace NEW {
			/**
			 *current motion information from a designated system */
			export function FOLLOW_TARGET(cur: _Cursor): _Host.FOLLOW_TARGET {
				cur.wrap(GroundControl.FOLLOW_TARGET.meta_);
				return cur.as_pack(_Host.FOLLOW_TARGET.impl_);
			}
			
			/**
			 *The location and information of an ADSB vehicle */
			export function ADSB_VEHICLE(cur: _Cursor): _Host.ADSB_VEHICLE {
				cur.wrap(GroundControl.ADSB_VEHICLE.meta_);
				return cur.as_pack(_Host.ADSB_VEHICLE.impl_);
			}
			
			/**
			 *This interface replaces DATA_STREAM */
			export function MESSAGE_INTERVAL(cur: _Cursor): _Host.MESSAGE_INTERVAL {
				cur.wrap(GroundControl.MESSAGE_INTERVAL.meta_);
				return cur.as_pack(_Host.MESSAGE_INTERVAL.impl_);
			}
			
			/**
			 *EKF Status message including flags and variances */
			export function EKF_STATUS_REPORT(cur: _Cursor): _Host.EKF_STATUS_REPORT {
				cur.wrap(GroundControl.EKF_STATUS_REPORT.meta_);
				return cur.as_pack(_Host.EKF_STATUS_REPORT.impl_);
			}
			
			/**
			 *Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message
			 *				 is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS
			 *				 enum definition for further information. The innovaton test ratios show the magnitude of the sensor innovation
			 *				 divided by the innovation check threshold. Under normal operation the innovaton test ratios should be
			 *				 below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation
			 *				 and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation
			 *				 test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should
			 *				 be optional and controllable by the user */
			export function ESTIMATOR_STATUS(cur: _Cursor): _Host.ESTIMATOR_STATUS {
				cur.wrap(GroundControl.ESTIMATOR_STATUS.meta_);
				return cur.as_pack(_Host.ESTIMATOR_STATUS.impl_);
			}
			
			/**
			 *Status of key hardware */
			export function HWSTATUS(cur: _Cursor): _Host.HWSTATUS {
				cur.wrap(GroundControl.HWSTATUS.meta_);
				return cur.as_pack(_Host.HWSTATUS.impl_);
			}
			
			/**
			 *Time synchronization message. */
			export function TIMESYNC(cur: _Cursor): _Host.TIMESYNC {
				cur.wrap(GroundControl.TIMESYNC.meta_);
				return cur.as_pack(_Host.TIMESYNC.impl_);
			}
			
			/**
			 *Request all parameters of this component. After this request, all parameters are emitted. */
			export function PARAM_EXT_REQUEST_LIST(cur: _Cursor): _Host.PARAM_EXT_REQUEST_LIST {
				cur.wrap(GroundControl.PARAM_EXT_REQUEST_LIST.meta_);
				return cur.as_pack(_Host.PARAM_EXT_REQUEST_LIST.impl_);
			}
			
			/**
			 *Report button state change */
			export function BUTTON_CHANGE(cur: _Cursor): _Host.BUTTON_CHANGE {
				cur.wrap(GroundControl.BUTTON_CHANGE.meta_);
				return cur.as_pack(_Host.BUTTON_CHANGE.impl_);
			}
			
			/**
			 *General status information of an UAVCAN node. Please refer to the definition of the UAVCAN message "uavcan.protocol.NodeStatus"
			 *				 for the background information. The UAVCAN specification is available at http:uavcan.org */
			export function UAVCAN_NODE_STATUS(cur: _Cursor): _Host.UAVCAN_NODE_STATUS {
				cur.wrap(GroundControl.UAVCAN_NODE_STATUS.meta_);
				return cur.as_pack(_Host.UAVCAN_NODE_STATUS.impl_);
			}
			
			/**
			 *Information about a potential collision */
			export function COLLISION(cur: _Cursor): _Host.COLLISION {
				cur.wrap(GroundControl.COLLISION.meta_);
				return cur.as_pack(_Host.COLLISION.impl_);
			}
			
			/**
			 *100 Hz gimbal torque command telemetry */
			export function GIMBAL_TORQUE_CMD_REPORT(cur: _Cursor): _Host.GIMBAL_TORQUE_CMD_REPORT {
				cur.wrap(GroundControl.GIMBAL_TORQUE_CMD_REPORT.meta_);
				return cur.as_pack(_Host.GIMBAL_TORQUE_CMD_REPORT.impl_);
			}
			
			/**
			 *The current system altitude. */
			export function ALTITUDE(cur: _Cursor): _Host.ALTITUDE {
				cur.wrap(GroundControl.ALTITUDE.meta_);
				return cur.as_pack(_Host.ALTITUDE.impl_);
			}
			
			/**
			 *Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful
			 *				 for high throughput applications such as hardware in the loop simulations */
			export function HIL_STATE_QUATERNION(cur: _Cursor): _Host.HIL_STATE_QUATERNION {
				cur.wrap(GroundControl.HIL_STATE_QUATERNION.meta_);
				return cur.as_pack(_Host.HIL_STATE_QUATERNION.impl_);
			}
			
			/**
			 *Offsets and calibrations values for hardware sensors. This makes it easier to debug the calibration process */
			export function SENSOR_OFFSETS(cur: _Cursor): _Host.SENSOR_OFFSETS {
				cur.wrap(GroundControl.SENSOR_OFFSETS.meta_);
				return cur.as_pack(_Host.SENSOR_OFFSETS.impl_);
			}
			
			/**
			 *WIP: Information about a storage medium. */
			export function STORAGE_INFORMATION(cur: _Cursor): _Host.STORAGE_INFORMATION {
				cur.wrap(GroundControl.STORAGE_INFORMATION.meta_);
				return cur.as_pack(_Host.STORAGE_INFORMATION.impl_);
			}
			
			/**
			 *WIP: Information about a camera */
			export function CAMERA_INFORMATION(cur: _Cursor): _Host.CAMERA_INFORMATION {
				cur.wrap(GroundControl.CAMERA_INFORMATION.meta_);
				return cur.as_pack(_Host.CAMERA_INFORMATION.impl_);
			}
			
			/**
			 *Write registers reply */
			export function DEVICE_OP_WRITE_REPLY(cur: _Cursor): _Host.DEVICE_OP_WRITE_REPLY {
				cur.wrap(GroundControl.DEVICE_OP_WRITE_REPLY.meta_);
				return cur.as_pack(_Host.DEVICE_OP_WRITE_REPLY.impl_);
			}
			
			/**
			 *Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUES */
			export function TERRAIN_DATA(cur: _Cursor): _Host.TERRAIN_DATA {
				cur.wrap(GroundControl.TERRAIN_DATA.meta_);
				return cur.as_pack(_Host.TERRAIN_DATA.impl_);
			}
			
			/**
			 *Control message for rate gimbal */
			export function GIMBAL_CONTROL(cur: _Cursor): _Host.GIMBAL_CONTROL {
				cur.wrap(GroundControl.GIMBAL_CONTROL.meta_);
				return cur.as_pack(_Host.GIMBAL_CONTROL.impl_);
			}
			
			/**
			 *WIP: Information about video stream */
			export function VIDEO_STREAM_INFORMATION(cur: _Cursor): _Host.VIDEO_STREAM_INFORMATION {
				cur.wrap(GroundControl.VIDEO_STREAM_INFORMATION.meta_);
				return cur.as_pack(_Host.VIDEO_STREAM_INFORMATION.impl_);
			}
			
			/**
			 *Status of DCM attitude estimator */
			export function AHRS(cur: _Cursor): _Host.AHRS {
				cur.wrap(GroundControl.AHRS.meta_);
				return cur.as_pack(_Host.AHRS.impl_);
			}
			
			/**
			 *Send a debug value. The index is used to discriminate between values. These values show up in the plot
			 *				 of QGroundControl as DEBUG N */
			export function DEBUG(cur: _Cursor): _Host.DEBUG {
				cur.wrap(GroundControl.DEBUG.meta_);
				return cur.as_pack(_Host.DEBUG.impl_);
			}
			
			/**
			 *Information about a captured image */
			export function CAMERA_IMAGE_CAPTURED(cur: _Cursor): _Host.CAMERA_IMAGE_CAPTURED {
				cur.wrap(GroundControl.CAMERA_IMAGE_CAPTURED.meta_);
				return cur.as_pack(_Host.CAMERA_IMAGE_CAPTURED.impl_);
			}
			
			/**
			 *Reply to LOG_REQUEST_LIST */
			export function LOG_ENTRY(cur: _Cursor): _Host.LOG_ENTRY {
				cur.wrap(GroundControl.LOG_ENTRY.meta_);
				return cur.as_pack(_Host.LOG_ENTRY.impl_);
			}
			
			/**
			 *Set the vehicle attitude and body angular rates. */
			export function ACTUATOR_CONTROL_TARGET(cur: _Cursor): _Host.ACTUATOR_CONTROL_TARGET {
				cur.wrap(GroundControl.ACTUATOR_CONTROL_TARGET.meta_);
				return cur.as_pack(_Host.ACTUATOR_CONTROL_TARGET.impl_);
			}
			
			/**
			 *Message appropriate for high latency connections like Iridium */
			export function HIGH_LATENCY(cur: _Cursor): _Host.HIGH_LATENCY {
				cur.wrap(GroundControl.HIGH_LATENCY.meta_);
				return cur.as_pack(_Host.HIGH_LATENCY.impl_);
			}
			
			/**
			 *This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system
			 *				 will return to and land on. The position is set automatically by the system during the takeoff in case
			 *				 it was not explicitely set by the operator before or after. The position the system will return to and
			 *				 land on. The global and local positions encode the position in the respective coordinate frames, while
			 *				 the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading
			 *				 and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes
			 *				 the point to which the system should fly in normal flight mode and then perform a landing sequence along
			 *				 the vector */
			export function HOME_POSITION(cur: _Cursor): _Host.HOME_POSITION {
				cur.wrap(GroundControl.HOME_POSITION.meta_);
				return cur.as_pack(_Host.HOME_POSITION.impl_);
			}
			
			/**
			 *Status of geo-fencing. Sent in extended status stream when fencing enabled */
			export function FENCE_STATUS(cur: _Cursor): _Host.FENCE_STATUS {
				cur.wrap(GroundControl.FENCE_STATUS.meta_);
				return cur.as_pack(_Host.FENCE_STATUS.impl_);
			}
			
			/**
			 *Send Status of each log block that autopilot board might have sent */
			export function REMOTE_LOG_BLOCK_STATUS(cur: _Cursor): _Host.REMOTE_LOG_BLOCK_STATUS {
				cur.wrap(GroundControl.REMOTE_LOG_BLOCK_STATUS.meta_);
				return cur.as_pack(_Host.REMOTE_LOG_BLOCK_STATUS.impl_);
			}
			
			/**
			 *Obstacle distances in front of the sensor, starting from the left in increment degrees to the right */
			export function OBSTACLE_DISTANCE(cur: _Cursor): _Host.OBSTACLE_DISTANCE {
				cur.wrap(GroundControl.OBSTACLE_DISTANCE.meta_);
				return cur.as_pack(_Host.OBSTACLE_DISTANCE.impl_);
			}
			
			/**
			 *Second GPS data. Coordinate frame is right-handed, Z-axis up (GPS frame). */
			export function GPS2_RAW(cur: _Cursor): _Host.GPS2_RAW {
				cur.wrap(GroundControl.GPS2_RAW.meta_);
				return cur.as_pack(_Host.GPS2_RAW.impl_);
			}
			
			/**
			 *Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient
			 *				 way for testing new messages and getting experimental debug output */
			export function MEMORY_VECT(cur: _Cursor): _Host.MEMORY_VECT {
				cur.wrap(GroundControl.MEMORY_VECT.meta_);
				return cur.as_pack(_Host.MEMORY_VECT.impl_);
			}
			
			/**
			 *Request to read the value of a parameter with the either the param_id string id or param_index. */
			export function PARAM_EXT_REQUEST_READ(cur: _Cursor): _Host.PARAM_EXT_REQUEST_READ {
				cur.wrap(GroundControl.PARAM_EXT_REQUEST_READ.meta_);
				return cur.as_pack(_Host.PARAM_EXT_REQUEST_READ.impl_);
			}
			
			/**
			 *The IMU readings in SI units in NED body frame */
			export function HIL_SENSOR(cur: _Cursor): _Host.HIL_SENSOR {
				cur.wrap(GroundControl.HIL_SENSOR.meta_);
				return cur.as_pack(_Host.HIL_SENSOR.impl_);
			}
			
			/**
			 *Setup a MAVLink2 signing key. If called with secret_key of all zero and zero initial_timestamp will disable
			 *				 signin */
			export function SETUP_SIGNING(cur: _Cursor): _Host.SETUP_SIGNING {
				cur.wrap(GroundControl.SETUP_SIGNING.meta_);
				return cur.as_pack(_Host.SETUP_SIGNING.impl_);
			}
			
			/**
			 *RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */
			export function GPS_RTK(cur: _Cursor): _Host.GPS_RTK {
				cur.wrap(GroundControl.GPS_RTK.meta_);
				return cur.as_pack(_Host.GPS_RTK.impl_);
			}
			
			/**
			 *Static data to configure the ADS-B transponder (send within 10 sec of a POR and every 10 sec thereafter */
			export function UAVIONIX_ADSB_OUT_CFG(cur: _Cursor): _Host.UAVIONIX_ADSB_OUT_CFG {
				cur.wrap(GroundControl.UAVIONIX_ADSB_OUT_CFG.meta_);
				return cur.as_pack(_Host.UAVIONIX_ADSB_OUT_CFG.impl_);
			}
			
			/**
			 *The location of a landing area captured from a downward facing camera */
			export function LANDING_TARGET(cur: _Cursor): _Host.LANDING_TARGET {
				cur.wrap(GroundControl.LANDING_TARGET.meta_);
				return cur.as_pack(_Host.LANDING_TARGET.impl_);
			}
			
			/**
			 *Set the vehicle attitude and body angular rates. */
			export function SET_ACTUATOR_CONTROL_TARGET(cur: _Cursor): _Host.SET_ACTUATOR_CONTROL_TARGET {
				cur.wrap(GroundControl.SET_ACTUATOR_CONTROL_TARGET.meta_);
				return cur.as_pack(_Host.SET_ACTUATOR_CONTROL_TARGET.impl_);
			}
			
			/**
			 *The smoothed, monotonic system state used to feed the control loops of the system. */
			export function CONTROL_SYSTEM_STATE(cur: _Cursor): _Host.CONTROL_SYSTEM_STATE {
				cur.wrap(GroundControl.CONTROL_SYSTEM_STATE.meta_);
				return cur.as_pack(_Host.CONTROL_SYSTEM_STATE.impl_);
			}
			
			/**
			 *Data packet, size 32 */
			export function DATA32(cur: _Cursor): _Host.DATA32 {
				cur.wrap(GroundControl.DATA32.meta_);
				return cur.as_pack(_Host.DATA32.impl_);
			}
			
			export function PING33(cur: _Cursor): _Host.PING33     //switch blink mode user command bytes
			
			{
				cur.wrap(GroundControl.PING33.meta_);
				return cur.as_pack(_Host.PING33.impl_);
			}
			
			/**
			 *GCS */
			export function RALLY_POINT(cur: _Cursor): _Host.RALLY_POINT {
				cur.wrap(GroundControl.RALLY_POINT.meta_);
				return cur.as_pack(_Host.RALLY_POINT.impl_);
			}
			
			/**
			 *Adaptive Controller tuning information */
			export function ADAP_TUNING(cur: _Cursor): _Host.ADAP_TUNING {
				cur.wrap(GroundControl.ADAP_TUNING.meta_);
				return cur.as_pack(_Host.ADAP_TUNING.impl_);
			}
			
			/**
			 *Vibration levels and accelerometer clipping */
			export function VIBRATION(cur: _Cursor): _Host.VIBRATION {
				cur.wrap(GroundControl.VIBRATION.meta_);
				return cur.as_pack(_Host.VIBRATION.impl_);
			}
			
			/**
			 *Emit the value of a parameter. The inclusion of param_count and param_index in the message allows the
			 *				 recipient to keep track of received parameters and allows them to re-request missing parameters after
			 *				 a loss or timeout */
			export function PARAM_EXT_VALUE(cur: _Cursor): _Host.PARAM_EXT_VALUE {
				cur.wrap(GroundControl.PARAM_EXT_VALUE.meta_);
				return cur.as_pack(_Host.PARAM_EXT_VALUE.impl_);
			}
			
			/**
			 *2nd Battery status */
			export function BATTERY2(cur: _Cursor): _Host.BATTERY2 {
				cur.wrap(GroundControl.BATTERY2.meta_);
				return cur.as_pack(_Host.BATTERY2.impl_);
			}
			
			/**
			 *Status of AP_Limits. Sent in extended status stream when AP_Limits is enabled */
			export function LIMITS_STATUS(cur: _Cursor): _Host.LIMITS_STATUS {
				cur.wrap(GroundControl.LIMITS_STATUS.meta_);
				return cur.as_pack(_Host.LIMITS_STATUS.impl_);
			}
			
			/**
			 *Camera Capture Feedback */
			export function CAMERA_FEEDBACK(cur: _Cursor): _Host.CAMERA_FEEDBACK {
				cur.wrap(GroundControl.CAMERA_FEEDBACK.meta_);
				return cur.as_pack(_Host.CAMERA_FEEDBACK.impl_);
			}
			
			/**
			 *The global position, as returned by the Global Positioning System (GPS). This is
			 *				 NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame). */
			export function HIL_GPS(cur: _Cursor): _Host.HIL_GPS {
				cur.wrap(GroundControl.HIL_GPS.meta_);
				return cur.as_pack(_Host.HIL_GPS.impl_);
			}
			
			/**
			 *Request a current fence point from MAV */
			export function FENCE_FETCH_POINT(cur: _Cursor): _Host.FENCE_FETCH_POINT {
				cur.wrap(GroundControl.FENCE_FETCH_POINT.meta_);
				return cur.as_pack(_Host.FENCE_FETCH_POINT.impl_);
			}
			
			/**
			 *Status generated by radio */
			export function RADIO(cur: _Cursor): _Host.RADIO {
				cur.wrap(GroundControl.RADIO.meta_);
				return cur.as_pack(_Host.RADIO.impl_);
			}
			
			/**
			 *Airspeed auto-calibration */
			export function AIRSPEED_AUTOCAL(cur: _Cursor): _Host.AIRSPEED_AUTOCAL {
				cur.wrap(GroundControl.AIRSPEED_AUTOCAL.meta_);
				return cur.as_pack(_Host.AIRSPEED_AUTOCAL.impl_);
			}
			
			/**
			 *Motion capture attitude and position */
			export function ATT_POS_MOCAP(cur: _Cursor): _Host.ATT_POS_MOCAP {
				cur.wrap(GroundControl.ATT_POS_MOCAP.meta_);
				return cur.as_pack(_Host.ATT_POS_MOCAP.impl_);
			}
			
			/**
			 *Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING:
			 *				 They consume quite some bandwidth, so use only for important status and error messages. If implemented
			 *				 wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz) */
			export function STATUSTEXT(cur: _Cursor): _Host.STATUSTEXT {
				cur.wrap(GroundControl.STATUSTEXT.meta_);
				return cur.as_pack(_Host.STATUSTEXT.impl_);
			}
			
			/**
			 *Request a GOPRO_COMMAND response from the GoPro */
			export function GOPRO_GET_REQUEST(cur: _Cursor): _Host.GOPRO_GET_REQUEST {
				cur.wrap(GroundControl.GOPRO_GET_REQUEST.meta_);
				return cur.as_pack(_Host.GOPRO_GET_REQUEST.impl_);
			}
			
			/**
			 *WIP: Information about the status of a capture */
			export function CAMERA_CAPTURE_STATUS(cur: _Cursor): _Host.CAMERA_CAPTURE_STATUS {
				cur.wrap(GroundControl.CAMERA_CAPTURE_STATUS.meta_);
				return cur.as_pack(_Host.CAMERA_CAPTURE_STATUS.impl_);
			}
			
			export function ENCAPSULATED_DATA(cur: _Cursor): _Host.ENCAPSULATED_DATA {
				cur.wrap(GroundControl.ENCAPSULATED_DATA.meta_);
				return cur.as_pack(_Host.ENCAPSULATED_DATA.impl_);
			}
			
			/**
			 *GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position
			 *				 estimate of the sytem */
			export function GPS_INPUT(cur: _Cursor): _Host.GPS_INPUT {
				cur.wrap(GroundControl.GPS_INPUT.meta_);
				return cur.as_pack(_Host.GPS_INPUT.impl_);
			}
			
			/**
			 *Status of compassmot calibration */
			export function COMPASSMOT_STATUS(cur: _Cursor): _Host.COMPASSMOT_STATUS {
				cur.wrap(GroundControl.COMPASSMOT_STATUS.meta_);
				return cur.as_pack(_Host.COMPASSMOT_STATUS.impl_);
			}
			
			/**
			 *Request a chunk of a log */
			export function LOG_REQUEST_DATA(cur: _Cursor): _Host.LOG_REQUEST_DATA {
				cur.wrap(GroundControl.LOG_REQUEST_DATA.meta_);
				return cur.as_pack(_Host.LOG_REQUEST_DATA.impl_);
			}
			
			/**
			 *Camera Event */
			export function CAMERA_STATUS(cur: _Cursor): _Host.CAMERA_STATUS {
				cur.wrap(GroundControl.CAMERA_STATUS.meta_);
				return cur.as_pack(_Host.CAMERA_STATUS.impl_);
			}
			
			/**
			 *WIP: Settings of a camera, can be requested using MAV_CMD_REQUEST_CAMERA_SETTINGS. */
			export function CAMERA_SETTINGS(cur: _Cursor): _Host.CAMERA_SETTINGS {
				cur.wrap(GroundControl.CAMERA_SETTINGS.meta_);
				return cur.as_pack(_Host.CAMERA_SETTINGS.impl_);
			}
			
			/**
			 *Read registers reply */
			export function DEVICE_OP_READ_REPLY(cur: _Cursor): _Host.DEVICE_OP_READ_REPLY {
				cur.wrap(GroundControl.DEVICE_OP_READ_REPLY.meta_);
				return cur.as_pack(_Host.DEVICE_OP_READ_REPLY.impl_);
			}
			
			/**
			 *Control on-board Camera Control System to take shots. */
			export function DIGICAM_CONTROL(cur: _Cursor): _Host.DIGICAM_CONTROL {
				cur.wrap(GroundControl.DIGICAM_CONTROL.meta_);
				return cur.as_pack(_Host.DIGICAM_CONTROL.impl_);
			}
			
			/**
			 *Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite
			 *				 efficient way for testing new messages and getting experimental debug output */
			export function NAMED_VALUE_FLOAT(cur: _Cursor): _Host.NAMED_VALUE_FLOAT {
				cur.wrap(GroundControl.NAMED_VALUE_FLOAT.meta_);
				return cur.as_pack(_Host.NAMED_VALUE_FLOAT.impl_);
			}
			
			/**
			 *Heartbeat from a HeroBus attached GoPro */
			export function GOPRO_HEARTBEAT(cur: _Cursor): _Host.GOPRO_HEARTBEAT {
				cur.wrap(GroundControl.GOPRO_HEARTBEAT.meta_);
				return cur.as_pack(_Host.GOPRO_HEARTBEAT.impl_);
			}
			
			/**
			 *Status of secondary AHRS filter if available */
			export function AHRS2(cur: _Cursor): _Host.AHRS2 {
				cur.wrap(GroundControl.AHRS2.meta_);
				return cur.as_pack(_Host.AHRS2.impl_);
			}
			
			/**
			 *Erase all logs */
			export function LOG_ERASE(cur: _Cursor): _Host.LOG_ERASE {
				cur.wrap(GroundControl.LOG_ERASE.meta_);
				return cur.as_pack(_Host.LOG_ERASE.impl_);
			}
			
			/**
			 *Request for terrain data and terrain status */
			export function TERRAIN_REQUEST(cur: _Cursor): _Host.TERRAIN_REQUEST {
				cur.wrap(GroundControl.TERRAIN_REQUEST.meta_);
				return cur.as_pack(_Host.TERRAIN_REQUEST.impl_);
			}
			
			/**
			 *Message with some status from APM to GCS about camera or antenna mount */
			export function MOUNT_STATUS(cur: _Cursor): _Host.MOUNT_STATUS {
				cur.wrap(GroundControl.MOUNT_STATUS.meta_);
				return cur.as_pack(_Host.MOUNT_STATUS.impl_);
			}
			
			/**
			 *PID tuning information */
			export function PID_TUNING(cur: _Cursor): _Host.PID_TUNING {
				cur.wrap(GroundControl.PID_TUNING.meta_);
				return cur.as_pack(_Host.PID_TUNING.impl_);
			}
			
			/**
			 *Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor) */
			export function OPTICAL_FLOW_RAD(cur: _Cursor): _Host.OPTICAL_FLOW_RAD {
				cur.wrap(GroundControl.OPTICAL_FLOW_RAD.meta_);
				return cur.as_pack(_Host.OPTICAL_FLOW_RAD.impl_);
			}
			
			/**
			 *Reply to LOG_REQUEST_DATA */
			export function LOG_DATA(cur: _Cursor): _Host.LOG_DATA {
				cur.wrap(GroundControl.LOG_DATA.meta_);
				return cur.as_pack(_Host.LOG_DATA.impl_);
			}
			
			/**
			 *Status of third AHRS filter if available. This is for ANU research group (Ali and Sean) */
			export function AHRS3(cur: _Cursor): _Host.AHRS3 {
				cur.wrap(GroundControl.AHRS3.meta_);
				return cur.as_pack(_Host.AHRS3.impl_);
			}
			
			export function VICON_POSITION_ESTIMATE(cur: _Cursor): _Host.VICON_POSITION_ESTIMATE {
				cur.wrap(GroundControl.VICON_POSITION_ESTIMATE.meta_);
				return cur.as_pack(_Host.VICON_POSITION_ESTIMATE.impl_);
			}
			
			/**
			 *RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */
			export function GPS2_RTK(cur: _Cursor): _Host.GPS2_RTK {
				cur.wrap(GroundControl.GPS2_RTK.meta_);
				return cur.as_pack(_Host.GPS2_RTK.impl_);
			}
			
			/**
			 *Reports results of completed compass calibration. Sent until MAG_CAL_ACK received. */
			export function MAG_CAL_REPORT(cur: _Cursor): _Host.MAG_CAL_REPORT {
				cur.wrap(GroundControl.MAG_CAL_REPORT.meta_);
				return cur.as_pack(_Host.MAG_CAL_REPORT.impl_);
			}
			
			/**
			 *Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END
			 *				 is called */
			export function LOG_REQUEST_LIST(cur: _Cursor): _Host.LOG_REQUEST_LIST {
				cur.wrap(GroundControl.LOG_REQUEST_LIST.meta_);
				return cur.as_pack(_Host.LOG_REQUEST_LIST.impl_);
			}
			
			/**
			 *Message to configure a camera mount, directional antenna, etc. */
			export function MOUNT_CONFIGURE(cur: _Cursor): _Host.MOUNT_CONFIGURE {
				cur.wrap(GroundControl.MOUNT_CONFIGURE.meta_);
				return cur.as_pack(_Host.MOUNT_CONFIGURE.impl_);
			}
			
			/**
			 *Message implementing parts of the V2 payload specs in V1 frames for transitional support. */
			export function V2_EXTENSION(cur: _Cursor): _Host.V2_EXTENSION {
				cur.wrap(GroundControl.V2_EXTENSION.meta_);
				return cur.as_pack(_Host.V2_EXTENSION.impl_);
			}
			
			/**
			 *Power supply status */
			export function POWER_STATUS(cur: _Cursor): _Host.POWER_STATUS {
				cur.wrap(GroundControl.POWER_STATUS.meta_);
				return cur.as_pack(_Host.POWER_STATUS.impl_);
			}
			
			/**
			 *Send a block of log data to remote location */
			export function REMOTE_LOG_DATA_BLOCK(cur: _Cursor): _Host.REMOTE_LOG_DATA_BLOCK {
				cur.wrap(GroundControl.REMOTE_LOG_DATA_BLOCK.meta_);
				return cur.as_pack(_Host.REMOTE_LOG_DATA_BLOCK.impl_);
			}
			
			/**
			 *A message containing logged data which requires a LOGGING_ACK to be sent back */
			export function LOGGING_DATA_ACKED(cur: _Cursor): _Host.LOGGING_DATA_ACKED {
				cur.wrap(GroundControl.LOGGING_DATA_ACKED.meta_);
				return cur.as_pack(_Host.LOGGING_DATA_ACKED.impl_);
			}
			
			/**
			 *Request that the vehicle report terrain height at the given location. Used by GCS to check if vehicle
			 *				 has all terrain data needed for a mission */
			export function TERRAIN_CHECK(cur: _Cursor): _Host.TERRAIN_CHECK {
				cur.wrap(GroundControl.TERRAIN_CHECK.meta_);
				return cur.as_pack(_Host.TERRAIN_CHECK.impl_);
			}
			
			/**
			 *Response from a TERRAIN_CHECK request */
			export function TERRAIN_REPORT(cur: _Cursor): _Host.TERRAIN_REPORT {
				cur.wrap(GroundControl.TERRAIN_REPORT.meta_);
				return cur.as_pack(_Host.TERRAIN_REPORT.impl_);
			}
			
			/**
			 *The position the system will return to and land on. The position is set automatically by the system during
			 *				 the takeoff in case it was not explicitely set by the operator before or after. The global and local
			 *				 positions encode the position in the respective coordinate frames, while the q parameter encodes the
			 *				 orientation of the surface. Under normal conditions it describes the heading and terrain slope, which
			 *				 can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which
			 *				 the system should fly in normal flight mode and then perform a landing sequence along the vector */
			export function SET_HOME_POSITION(cur: _Cursor): _Host.SET_HOME_POSITION {
				cur.wrap(GroundControl.SET_HOME_POSITION.meta_);
				return cur.as_pack(_Host.SET_HOME_POSITION.impl_);
			}
			
			/**
			 *The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described
			 *				 unit */
			export function SCALED_IMU3(cur: _Cursor): _Host.SCALED_IMU3 {
				cur.wrap(GroundControl.SCALED_IMU3.meta_);
				return cur.as_pack(_Host.SCALED_IMU3.impl_);
			}
			
			/**
			 *Message to control a camera mount, directional antenna, etc. */
			export function MOUNT_CONTROL(cur: _Cursor): _Host.MOUNT_CONTROL {
				cur.wrap(GroundControl.MOUNT_CONTROL.meta_);
				return cur.as_pack(_Host.MOUNT_CONTROL.impl_);
			}
			
			/**
			 *Control vehicle LEDs */
			export function LED_CONTROL(cur: _Cursor): _Host.LED_CONTROL {
				cur.wrap(GroundControl.LED_CONTROL.meta_);
				return cur.as_pack(_Host.LED_CONTROL.impl_);
			}
			
			/**
			 *Status of simulation environment, if used */
			export function SIM_STATE(cur: _Cursor): _Host.SIM_STATE {
				cur.wrap(GroundControl.SIM_STATE.meta_);
				return cur.as_pack(_Host.SIM_STATE.impl_);
			}
			
			/**
			 *Configure AP SSID and Password. */
			export function WIFI_CONFIG_AP(cur: _Cursor): _Host.WIFI_CONFIG_AP {
				cur.wrap(GroundControl.WIFI_CONFIG_AP.meta_);
				return cur.as_pack(_Host.WIFI_CONFIG_AP.impl_);
			}
			
			/**
			 *Data packet, size 96 */
			export function DATA96(cur: _Cursor): _Host.DATA96 {
				cur.wrap(GroundControl.DATA96.meta_);
				return cur.as_pack(_Host.DATA96.impl_);
			}
			
			/**
			 *WIP: Information about flight since last arming */
			export function FLIGHT_INFORMATION(cur: _Cursor): _Host.FLIGHT_INFORMATION {
				cur.wrap(GroundControl.FLIGHT_INFORMATION.meta_);
				return cur.as_pack(_Host.FLIGHT_INFORMATION.impl_);
			}
			
			/**
			 *state of APM memory */
			export function MEMINFO(cur: _Cursor): _Host.MEMINFO {
				cur.wrap(GroundControl.MEMINFO.meta_);
				return cur.as_pack(_Host.MEMINFO.impl_);
			}
			
			/**
			 *An ack for a LOGGING_DATA_ACKED message */
			export function LOGGING_ACK(cur: _Cursor): _Host.LOGGING_ACK {
				cur.wrap(GroundControl.LOGGING_ACK.meta_);
				return cur.as_pack(_Host.LOGGING_ACK.impl_);
			}
			
			export function VISION_SPEED_ESTIMATE(cur: _Cursor): _Host.VISION_SPEED_ESTIMATE {
				cur.wrap(GroundControl.VISION_SPEED_ESTIMATE.meta_);
				return cur.as_pack(_Host.VISION_SPEED_ESTIMATE.impl_);
			}
			
			export function DEBUG_VECT(cur: _Cursor): _Host.DEBUG_VECT {
				cur.wrap(GroundControl.DEBUG_VECT.meta_);
				return cur.as_pack(_Host.DEBUG_VECT.impl_);
			}
			
			/**
			 *Camera-IMU triggering and synchronisation message. */
			export function CAMERA_TRIGGER(cur: _Cursor): _Host.CAMERA_TRIGGER {
				cur.wrap(GroundControl.CAMERA_TRIGGER.meta_);
				return cur.as_pack(_Host.CAMERA_TRIGGER.impl_);
			}
			
			/**
			 *Stop log transfer and resume normal logging */
			export function LOG_REQUEST_END(cur: _Cursor): _Host.LOG_REQUEST_END {
				cur.wrap(GroundControl.LOG_REQUEST_END.meta_);
				return cur.as_pack(_Host.LOG_REQUEST_END.impl_);
			}
			
			/**
			 *Response from a GOPRO_COMMAND set request */
			export function GOPRO_SET_RESPONSE(cur: _Cursor): _Host.GOPRO_SET_RESPONSE {
				cur.wrap(GroundControl.GOPRO_SET_RESPONSE.meta_);
				return cur.as_pack(_Host.GOPRO_SET_RESPONSE.impl_);
			}
			
			/**
			 *WIP: Version and capability of protocol version. This message is the response to REQUEST_PROTOCOL_VERSION
			 *				 and is used as part of the handshaking to establish which MAVLink version should be used on the network.
			 *				 Every node should respond to REQUEST_PROTOCOL_VERSION to enable the handshaking. Library implementers
			 *				 should consider adding this into the default decoding state machine to allow the protocol core to respond
			 *				 directly */
			export function PROTOCOL_VERSION(cur: _Cursor): _Host.PROTOCOL_VERSION {
				cur.wrap(GroundControl.PROTOCOL_VERSION.meta_);
				return cur.as_pack(_Host.PROTOCOL_VERSION.impl_);
			}
			
			/**
			 *Request a current rally point from MAV. MAV should respond with a RALLY_POINT message. MAV should not
			 *				 respond if the request is invalid */
			export function RALLY_FETCH_POINT(cur: _Cursor): _Host.RALLY_FETCH_POINT {
				cur.wrap(GroundControl.RALLY_FETCH_POINT.meta_);
				return cur.as_pack(_Host.RALLY_FETCH_POINT.impl_);
			}
			
			/**
			 *Battery information */
			export function BATTERY_STATUS(cur: _Cursor): _Host.BATTERY_STATUS {
				cur.wrap(GroundControl.BATTERY_STATUS.meta_);
				return cur.as_pack(_Host.BATTERY_STATUS.impl_);
			}
			
			export function MOUNT_ORIENTATION(cur: _Cursor): _Host.MOUNT_ORIENTATION {
				cur.wrap(GroundControl.MOUNT_ORIENTATION.meta_);
				return cur.as_pack(_Host.MOUNT_ORIENTATION.impl_);
			}
			
			/**
			 *Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or
			 *				 telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages
			 *				 or change the devices settings. A message with zero bytes can be used to change just the baudrate */
			export function SERIAL_CONTROL(cur: _Cursor): _Host.SERIAL_CONTROL {
				cur.wrap(GroundControl.SERIAL_CONTROL.meta_);
				return cur.as_pack(_Host.SERIAL_CONTROL.impl_);
			}
			
			/**
			 *Set a parameter value. In order to deal with message loss (and retransmission of PARAM_EXT_SET), when
			 *				 setting a parameter value and the new value is the same as the current value, you will immediately get
			 *				 a PARAM_ACK_ACCEPTED response. If the current state is PARAM_ACK_IN_PROGRESS, you will accordingly receive
			 *				 a PARAM_ACK_IN_PROGRESS in response */
			export function PARAM_EXT_SET(cur: _Cursor): _Host.PARAM_EXT_SET {
				cur.wrap(GroundControl.PARAM_EXT_SET.meta_);
				return cur.as_pack(_Host.PARAM_EXT_SET.impl_);
			}
			
			/**
			 *Version and capability of autopilot software */
			export function AUTOPILOT_VERSION(cur: _Cursor): _Host.AUTOPILOT_VERSION {
				cur.wrap(GroundControl.AUTOPILOT_VERSION.meta_);
				return cur.as_pack(_Host.AUTOPILOT_VERSION.impl_);
			}
			
			/**
			 *Status of simulation environment, if used */
			export function SIMSTATE(cur: _Cursor): _Host.SIMSTATE {
				cur.wrap(GroundControl.SIMSTATE.meta_);
				return cur.as_pack(_Host.SIMSTATE.impl_);
			}
			
			/**
			 *WIP: Message that sets video stream settings */
			export function SET_VIDEO_STREAM_SETTINGS(cur: _Cursor): _Host.SET_VIDEO_STREAM_SETTINGS {
				cur.wrap(GroundControl.SET_VIDEO_STREAM_SETTINGS.meta_);
				return cur.as_pack(_Host.SET_VIDEO_STREAM_SETTINGS.impl_);
			}
			
			/**
			 *Control vehicle tone generation (buzzer) */
			export function PLAY_TUNE(cur: _Cursor): _Host.PLAY_TUNE {
				cur.wrap(GroundControl.PLAY_TUNE.meta_);
				return cur.as_pack(_Host.PLAY_TUNE.impl_);
			}
			
			/**
			 *Configure on-board Camera Control System. */
			export function DIGICAM_CONFIGURE(cur: _Cursor): _Host.DIGICAM_CONFIGURE {
				cur.wrap(GroundControl.DIGICAM_CONFIGURE.meta_);
				return cur.as_pack(_Host.DIGICAM_CONFIGURE.impl_);
			}
			
			/**
			 *Barometer readings for 3rd barometer */
			export function SCALED_PRESSURE3(cur: _Cursor): _Host.SCALED_PRESSURE3 {
				cur.wrap(GroundControl.SCALED_PRESSURE3.meta_);
				return cur.as_pack(_Host.SCALED_PRESSURE3.impl_);
			}
			
			/**
			 *Response from a PARAM_EXT_SET message. */
			export function PARAM_EXT_ACK(cur: _Cursor): _Host.PARAM_EXT_ACK {
				cur.wrap(GroundControl.PARAM_EXT_ACK.meta_);
				return cur.as_pack(_Host.PARAM_EXT_ACK.impl_);
			}
			
			/**
			 *General information describing a particular UAVCAN node. Please refer to the definition of the UAVCAN
			 *				 service "uavcan.protocol.GetNodeInfo" for the background information. This message should be emitted
			 *				 by the system whenever a new node appears online, or an existing node reboots. Additionally, it can be
			 *				 emitted upon request from the other end of the MAVLink channel (see MAV_CMD_UAVCAN_GET_NODE_INFO). It
			 *				 is also not prohibited to emit this message unconditionally at a low frequency. The UAVCAN specification
			 *				 is available at http:uavcan.org */
			export function UAVCAN_NODE_INFO(cur: _Cursor): _Host.UAVCAN_NODE_INFO {
				cur.wrap(GroundControl.UAVCAN_NODE_INFO.meta_);
				return cur.as_pack(_Host.UAVCAN_NODE_INFO.impl_);
			}
			
			/**
			 *Data packet, size 16 */
			export function DATA16(cur: _Cursor): _Host.DATA16 {
				cur.wrap(GroundControl.DATA16.meta_);
				return cur.as_pack(_Host.DATA16.impl_);
			}
			
			/**
			 *Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the magnetometer offsets */
			export function SET_MAG_OFFSETS(cur: _Cursor): _Host.SET_MAG_OFFSETS {
				cur.wrap(GroundControl.SET_MAG_OFFSETS.meta_);
				return cur.as_pack(_Host.SET_MAG_OFFSETS.impl_);
			}
			
			/**
			 *The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to
			 *				 the described unit */
			export function SCALED_IMU2(cur: _Cursor): _Host.SCALED_IMU2 {
				cur.wrap(GroundControl.SCALED_IMU2.meta_);
				return cur.as_pack(_Host.SCALED_IMU2.impl_);
			}
			
			/**
			 *raw ADC output */
			export function AP_ADC(cur: _Cursor): _Host.AP_ADC {
				cur.wrap(GroundControl.AP_ADC.meta_);
				return cur.as_pack(_Host.AP_ADC.impl_);
			}
			
			/**
			 *Wind estimation */
			export function WIND(cur: _Cursor): _Host.WIND {
				cur.wrap(GroundControl.WIND.meta_);
				return cur.as_pack(_Host.WIND.impl_);
			}
			
			/**
			 *Request the autopilot version from the system/component. */
			export function AUTOPILOT_VERSION_REQUEST(cur: _Cursor): _Host.AUTOPILOT_VERSION_REQUEST {
				cur.wrap(GroundControl.AUTOPILOT_VERSION_REQUEST.meta_);
				return cur.as_pack(_Host.AUTOPILOT_VERSION_REQUEST.impl_);
			}
			
			export function DATA_TRANSMISSION_HANDSHAKE(cur: _Cursor): _Host.DATA_TRANSMISSION_HANDSHAKE {
				cur.wrap(GroundControl.DATA_TRANSMISSION_HANDSHAKE.meta_);
				return cur.as_pack(_Host.DATA_TRANSMISSION_HANDSHAKE.impl_);
			}
			
			/**
			 *Data packet, size 64 */
			export function DATA64(cur: _Cursor): _Host.DATA64 {
				cur.wrap(GroundControl.DATA64.meta_);
				return cur.as_pack(_Host.DATA64.impl_);
			}
			
			/**
			 *3 axis gimbal mesuraments */
			export function GIMBAL_REPORT(cur: _Cursor): _Host.GIMBAL_REPORT {
				cur.wrap(GroundControl.GIMBAL_REPORT.meta_);
				return cur.as_pack(_Host.GIMBAL_REPORT.impl_);
			}
			
			/**
			 *Write registers for a device */
			export function DEVICE_OP_WRITE(cur: _Cursor): _Host.DEVICE_OP_WRITE {
				cur.wrap(GroundControl.DEVICE_OP_WRITE.meta_);
				return cur.as_pack(_Host.DEVICE_OP_WRITE.impl_);
			}
			
			export function DISTANCE_SENSOR(cur: _Cursor): _Host.DISTANCE_SENSOR {
				cur.wrap(GroundControl.DISTANCE_SENSOR.meta_);
				return cur.as_pack(_Host.DISTANCE_SENSOR.impl_);
			}
			
			/**
			 *Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor) */
			export function HIL_OPTICAL_FLOW(cur: _Cursor): _Host.HIL_OPTICAL_FLOW {
				cur.wrap(GroundControl.HIL_OPTICAL_FLOW.meta_);
				return cur.as_pack(_Host.HIL_OPTICAL_FLOW.impl_);
			}
			
			/**
			 *Barometer readings for 2nd barometer */
			export function SCALED_PRESSURE2(cur: _Cursor): _Host.SCALED_PRESSURE2 {
				cur.wrap(GroundControl.SCALED_PRESSURE2.meta_);
				return cur.as_pack(_Host.SCALED_PRESSURE2.impl_);
			}
			
			export function WIND_COV(cur: _Cursor): _Host.WIND_COV {
				cur.wrap(GroundControl.WIND_COV.meta_);
				return cur.as_pack(_Host.WIND_COV.impl_);
			}
			
			/**
			 *Request to set a GOPRO_COMMAND with a desired */
			export function GOPRO_SET_REQUEST(cur: _Cursor): _Host.GOPRO_SET_REQUEST {
				cur.wrap(GroundControl.GOPRO_SET_REQUEST.meta_);
				return cur.as_pack(_Host.GOPRO_SET_REQUEST.impl_);
			}
			
			/**
			 *camera vision based attitude and position deltas */
			export function VISION_POSITION_DELTA(cur: _Cursor): _Host.VISION_POSITION_DELTA {
				cur.wrap(GroundControl.VISION_POSITION_DELTA.meta_);
				return cur.as_pack(_Host.VISION_POSITION_DELTA.impl_);
			}
			
			/**
			 *A message containing logged data (see also MAV_CMD_LOGGING_START) */
			export function LOGGING_DATA(cur: _Cursor): _Host.LOGGING_DATA {
				cur.wrap(GroundControl.LOGGING_DATA.meta_);
				return cur.as_pack(_Host.LOGGING_DATA.impl_);
			}
			
			/**
			 *Read registers for a device */
			export function DEVICE_OP_READ(cur: _Cursor): _Host.DEVICE_OP_READ {
				cur.wrap(GroundControl.DEVICE_OP_READ.meta_);
				return cur.as_pack(_Host.DEVICE_OP_READ.impl_);
			}
			
			/**
			 *Reports progress of compass calibration. */
			export function MAG_CAL_PROGRESS(cur: _Cursor): _Host.MAG_CAL_PROGRESS {
				cur.wrap(GroundControl.MAG_CAL_PROGRESS.meta_);
				return cur.as_pack(_Host.MAG_CAL_PROGRESS.impl_);
			}
			
			/**
			 *The IMU readings in SI units in NED body frame */
			export function HIGHRES_IMU(cur: _Cursor): _Host.HIGHRES_IMU {
				cur.wrap(GroundControl.HIGHRES_IMU.meta_);
				return cur.as_pack(_Host.HIGHRES_IMU.impl_);
			}
			
			/**
			 *Provides state for additional features */
			export function EXTENDED_SYS_STATE(cur: _Cursor): _Host.EXTENDED_SYS_STATE {
				cur.wrap(GroundControl.EXTENDED_SYS_STATE.meta_);
				return cur.as_pack(_Host.EXTENDED_SYS_STATE.impl_);
			}
			
			/**
			 *Dynamic data used to generate ADS-B out transponder data (send at 5Hz) */
			export function UAVIONIX_ADSB_OUT_DYNAMIC(cur: _Cursor): _Host.UAVIONIX_ADSB_OUT_DYNAMIC {
				cur.wrap(GroundControl.UAVIONIX_ADSB_OUT_DYNAMIC.meta_);
				return cur.as_pack(_Host.UAVIONIX_ADSB_OUT_DYNAMIC.impl_);
			}
			
			/**
			 *Response from a GOPRO_COMMAND get request */
			export function GOPRO_GET_RESPONSE(cur: _Cursor): _Host.GOPRO_GET_RESPONSE {
				cur.wrap(GroundControl.GOPRO_GET_RESPONSE.meta_);
				return cur.as_pack(_Host.GOPRO_GET_RESPONSE.impl_);
			}
			
			/**
			 *data for injecting into the onboard GPS (used for DGPS) */
			export function GPS_INJECT_DATA(cur: _Cursor): _Host.GPS_INJECT_DATA {
				cur.wrap(GroundControl.GPS_INJECT_DATA.meta_);
				return cur.as_pack(_Host.GPS_INJECT_DATA.impl_);
			}
			
			/**
			 *Transceiver heartbeat with health report (updated every 10s) */
			export function UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT(cur: _Cursor): _Host.UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT {
				cur.wrap(GroundControl.UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT.meta_);
				return cur.as_pack(_Host.UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT.impl_);
			}
			
			/**
			 *Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite
			 *				 efficient way for testing new messages and getting experimental debug output */
			export function NAMED_VALUE_INT(cur: _Cursor): _Host.NAMED_VALUE_INT {
				cur.wrap(GroundControl.NAMED_VALUE_INT.meta_);
				return cur.as_pack(_Host.NAMED_VALUE_INT.impl_);
			}
			
			/**
			 *RPM sensor output */
			export function RPM(cur: _Cursor): _Host.RPM {
				cur.wrap(GroundControl.RPM.meta_);
				return cur.as_pack(_Host.RPM.impl_);
			}
			
			/**
			 *RTCM message for injecting into the onboard GPS (used for DGPS) */
			export function GPS_RTCM_DATA(cur: _Cursor): _Host.GPS_RTCM_DATA {
				cur.wrap(GroundControl.GPS_RTCM_DATA.meta_);
				return cur.as_pack(_Host.GPS_RTCM_DATA.impl_);
			}
			
			/**
			 *File transfer message */
			export function FILE_TRANSFER_PROTOCOL(cur: _Cursor): _Host.FILE_TRANSFER_PROTOCOL {
				cur.wrap(GroundControl.FILE_TRANSFER_PROTOCOL.meta_);
				return cur.as_pack(_Host.FILE_TRANSFER_PROTOCOL.impl_);
			}
			
			/**
			 *Rangefinder reporting */
			export function RANGEFINDER(cur: _Cursor): _Host.RANGEFINDER {
				cur.wrap(GroundControl.RANGEFINDER.meta_);
				return cur.as_pack(_Host.RANGEFINDER.impl_);
			}
			
			/**
			 *Status generated by radio and injected into MAVLink stream. */
			export function RADIO_STATUS(cur: _Cursor): _Host.RADIO_STATUS {
				cur.wrap(GroundControl.RADIO_STATUS.meta_);
				return cur.as_pack(_Host.RADIO_STATUS.impl_);
			}
			
			/**
			 *GCS */
			export function FENCE_POINT(cur: _Cursor): _Host.FENCE_POINT {
				cur.wrap(GroundControl.FENCE_POINT.meta_);
				return cur.as_pack(_Host.FENCE_POINT.impl_);
			}
			
			/**
			 *The autopilot is requesting a resource (file, binary, other type of data) */
			export function RESOURCE_REQUEST(cur: _Cursor): _Host.RESOURCE_REQUEST {
				cur.wrap(GroundControl.RESOURCE_REQUEST.meta_);
				return cur.as_pack(_Host.RESOURCE_REQUEST.impl_);
			}
			
		}
		
		
	}
	
}// namespace  com.company.demo
export namespace org.unirail.AdHoc {
	import _Host = com.company.demo.GroundControl;
	
	
	export namespace Config_ {
		export function Cursor(): _Cursor { return new _Cursor(1, 2);}
		
		
		export const RECEIVE_REQ_MAX_BYTES  = 255;
		export const RECEIVE_FULL_MAX_BYTES = 6850;
		
		
		export const SEND_REQ_MAX_BYTES  = 255;
		export const SEND_FULL_MAX_BYTES = 6850;
		
		
		function Config_() {
			let _ad_hoc1491 = new _Pack.Meta.Field(1, true, 1, 4, 18, 0, 0, undefined);
			let _ad_hoc1031 = new _Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1942 = new _Pack.Meta.Field(1, true, 1, 8, 1, 0, 0, undefined);
			let _ad_hoc19   = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc83   = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc306  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc2414 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1863 = new _Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc2118 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc244  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc827  = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc828  = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc212  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc636  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc423  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc645  = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc1516 = new _Pack.Meta.Field(2, false, 1, 1, 18, 10, 5, undefined);
			let _ad_hoc105  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc188  = new _Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc1003 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc202  = new _Pack.Meta.Field(7, false, 1, 8, 1, 0, 0, undefined);
			let _ad_hoc882  = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc686  = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc10   = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc587  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc208  = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc196  = new _Pack.Meta.Field(7, false, 1, 8, 1, 0, 0, undefined);
			let _ad_hoc1508 = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc2097 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc152  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1012 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc820  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc4    = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc684  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc17   = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc215  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc104  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc2116 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc706  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc880  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc326  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc20   = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc1133 = new _Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc1522 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc630  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc210  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc151  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc11   = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc16   = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc1853 = new _Pack.Meta.Field(2, false, 1, 1, 18, 10, 5, undefined);
			let _ad_hoc192  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc2004 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc218  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc2110 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1500 = new _Pack.Meta.Field(8, false, 1, 6, 9, 12, 5, undefined, 2);
			let _ad_hoc12   = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc705  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc1515 = new _Pack.Meta.Field(1, false, 1, 4, 6, 2, 0, undefined, 2);
			let _ad_hoc1332 = new _Pack.Meta.Field(1, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc1510 = new _Pack.Meta.Field(1, false, 1, 4, 6, 2, 0, undefined, 2);
			let _ad_hoc629  = new _Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc1507 = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc189  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc352  = new _Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc1487 = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc1472 = new _Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc353  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc214  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1989 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1519 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc963  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc683  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc883  = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc80   = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1471 = new _Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc354  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc351  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1865 = new _Pack.Meta.Field(1, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc71   = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc424  = new _Pack.Meta.Field(7, false, 1, 8, 1, 0, 0, undefined);
			let _ad_hoc628  = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc211  = new _Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc972  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1861 = new _Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc377  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc84   = new _Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc2160 = new _Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc285  = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc421  = new _Pack.Meta.Field(7, false, 1, 8, 1, 0, 0, undefined);
			let _ad_hoc1512 = new _Pack.Meta.Field(2, false, 1, 4, 6, 12, 5, undefined, 2);
			let _ad_hoc1520 = new _Pack.Meta.Field(5, false, 8, 1, 6, 2, 0, undefined, 2);
			let _ad_hoc1331 = new _Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc141  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc803  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc1488 = new _Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1494 = new _Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1513 = new _Pack.Meta.Field(2, false, 1, 4, 18, 10, 5, undefined);
			let _ad_hoc585  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc688  = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc710  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc349  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc966  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc243  = new _Pack.Meta.Field(7, false, 1, 6, 1, 0, 0, undefined);
			let _ad_hoc372  = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc219  = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc1862 = new _Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc687  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc2083 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1503 = new _Pack.Meta.Field(8, false, 1, 5, 3, 14, 5, undefined, 2, 2);
			let _ad_hoc1018 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1029 = new _Pack.Meta.Field(1, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc191  = new _Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc1132 = new _Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc107  = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc1008 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1135 = new _Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc153  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc112  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc1185 = new _Pack.Meta.Field(1, true, 1, 8, 1, 0, 0, undefined);
			let _ad_hoc86   = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc426  = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc1    = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc804  = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc1954 = new _Pack.Meta.Field(1, true, 1, 8, 1, 0, 0, undefined);
			let _ad_hoc1181 = new _Pack.Meta.Field(1, true, 1, 8, 1, 0, 0, undefined);
			let _ad_hoc85   = new _Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc1521 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1134 = new _Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc2427 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1139 = new _Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc420  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1138 = new _Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc1511 = new _Pack.Meta.Field(2, false, 1, 4, 6, 12, 5, undefined, 2);
			let _ad_hoc1518 = new _Pack.Meta.Field(2, false, 1, 4, 18, 10, 5, undefined);
			let _ad_hoc1506 = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc190  = new _Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc802  = new _Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc209  = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc425  = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc999  = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1330 = new _Pack.Meta.Field(1, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc2016 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1505 = new _Pack.Meta.Field(8, false, 1, 9, 9, 12, 5, undefined, 2);
			let _ad_hoc1490 = new _Pack.Meta.Field(1, true, 1, 4, 6, 3, 0, undefined, 3);
			let _ad_hoc1986 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1517 = new _Pack.Meta.Field(2, false, 1, 4, 18, 10, 5, undefined);
			let _ad_hoc586  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc1504 = new _Pack.Meta.Field(7, false, 1, 6, 9, 2, 0, undefined, 2);
			let _ad_hoc106  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc1137 = new _Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc59   = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc51   = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1502 = new _Pack.Meta.Field(7, false, 1, 5, 3, 4, 0, undefined, 2, 2);
			let _ad_hoc350  = new _Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc1136 = new _Pack.Meta.Field(1, true, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc1498 = new _Pack.Meta.Field(1, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc150  = new _Pack.Meta.Field(7, false, 1, 8, 1, 0, 0, undefined);
			let _ad_hoc282  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc140  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc139  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc195  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc58   = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc376  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc881  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1499 = new _Pack.Meta.Field(7, false, 1, 6, 27, 0, 0, undefined);
			let _ad_hoc2084 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc149  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc342  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc193  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc194  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc2119 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1033 = new _Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc234  = new _Pack.Meta.Field(7, false, 1, 2, 1, 0, 0, undefined);
			let _ad_hoc1964 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc2126 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc2085 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc2106 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc2117 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc826  = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc281  = new _Pack.Meta.Field(7, false, 1, 5, 1, 0, 0, undefined);
			let _ad_hoc1501 = new _Pack.Meta.Field(7, false, 1, 5, 9, 2, 0, undefined, 2);
			let _ad_hoc1492 = new _Pack.Meta.Field(2, true, 1, 4, 18, 10, 5, undefined);
			let _ad_hoc1030 = new _Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc2074 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc248  = new _Pack.Meta.Field(7, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc1509 = new _Pack.Meta.Field(1, false, 1, 4, 6, 2, 0, undefined, 2);
			let _ad_hoc2111 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1864 = new _Pack.Meta.Field(2, false, 1, 4, 4, 6, 3, undefined);
			let _ad_hoc1980 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc1032 = new _Pack.Meta.Field(1, true, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc2043 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc233  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1991 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			let _ad_hoc685  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc9    = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1333 = new _Pack.Meta.Field(1, false, 1, 1, 1, 0, 0, undefined);
			let _ad_hoc957  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc422  = new _Pack.Meta.Field(7, false, 1, 3, 1, 0, 0, undefined);
			let _ad_hoc213  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc411  = new _Pack.Meta.Field(7, false, 1, 4, 1, 0, 0, undefined);
			let _ad_hoc1188 = new _Pack.Meta.Field(3, false, 8, 1, 1, 8, 0, undefined);
			
			_Host.LIMITS_STATUS.meta_.fields[0]                           = _ad_hoc189;
			_Host.LIMITS_STATUS.meta_.fields[1]                           = _ad_hoc188;
			_Host.LIMITS_STATUS.meta_.fields[2]                           = _ad_hoc190;
			_Host.LIMITS_STATUS.meta_.fields[3]                           = _ad_hoc191;
			_Host.CAMERA_SETTINGS.meta_.fields[0]                         = _ad_hoc84;
			_Host.AUTOPILOT_VERSION.meta_.fields[0]                       = _ad_hoc281;
			_Host.AUTOPILOT_VERSION.meta_.fields[1]                       = _ad_hoc1853;
			_Host.DEVICE_OP_WRITE.meta_.fields[0]                         = _ad_hoc285;
			_Host.DEVICE_OP_WRITE.meta_.fields[1]                         = _ad_hoc2427;
			_Host.MISSION_ITEM_INT.meta_.fields[0]                        = _ad_hoc195;
			_Host.MISSION_ITEM_INT.meta_.fields[1]                        = _ad_hoc196;
			_Host.MISSION_ITEM_INT.meta_.fields[2]                        = _ad_hoc194;
			_Host.MISSION_CLEAR_ALL.meta_.fields[0]                       = _ad_hoc71;
			_Host.ESTIMATOR_STATUS.meta_.fields[0]                        = _ad_hoc9;
			_Host.HIL_ACTUATOR_CONTROLS.meta_.fields[0]                   = _ad_hoc326;
			_Host.HOME_POSITION.meta_.fields[0]                           = _ad_hoc1942;
			_Host.PARAM_EXT_VALUE.meta_.fields[0]                         = _ad_hoc2110;
			_Host.PARAM_EXT_VALUE.meta_.fields[1]                         = _ad_hoc2111;
			_Host.PARAM_EXT_VALUE.meta_.fields[2]                         = _ad_hoc411;
			_Host.GPS_INPUT.meta_.fields[0]                               = _ad_hoc881;
			_Host.PARAM_EXT_ACK.meta_.fields[0]                           = _ad_hoc2118;
			_Host.PARAM_EXT_ACK.meta_.fields[1]                           = _ad_hoc2119;
			_Host.PARAM_EXT_ACK.meta_.fields[2]                           = _ad_hoc233;
			_Host.PARAM_EXT_ACK.meta_.fields[3]                           = _ad_hoc234;
			_Host.MISSION_REQUEST_PARTIAL_LIST.meta_.fields[0]            = _ad_hoc354;
			_Host.CAMERA_FEEDBACK.meta_.fields[0]                         = _ad_hoc4;
			_Host.PARAM_MAP_RC.meta_.fields[0]                            = _ad_hoc1188;
			_Host.GOPRO_GET_REQUEST.meta_.fields[0]                       = _ad_hoc107;
			_Host.EKF_STATUS_REPORT.meta_.fields[0]                       = _ad_hoc710;
			_Host.MISSION_WRITE_PARTIAL_LIST.meta_.fields[0]              = _ad_hoc422;
			_Host.PARAM_EXT_SET.meta_.fields[0]                           = _ad_hoc2116;
			_Host.PARAM_EXT_SET.meta_.fields[1]                           = _ad_hoc2117;
			_Host.PARAM_EXT_SET.meta_.fields[2]                           = _ad_hoc152;
			_Host.REMOTE_LOG_BLOCK_STATUS.meta_.fields[0]                 = _ad_hoc372;
			_Host.COMMAND_LONG.meta_.fields[0]                            = _ad_hoc202;
			_Host.UAVIONIX_ADSB_OUT_DYNAMIC.meta_.fields[0]               = _ad_hoc587;
			_Host.UAVIONIX_ADSB_OUT_DYNAMIC.meta_.fields[1]               = _ad_hoc585;
			_Host.UAVIONIX_ADSB_OUT_DYNAMIC.meta_.fields[2]               = _ad_hoc586;
			_Host.SERIAL_CONTROL.meta_.fields[0]                          = _ad_hoc706;
			_Host.SERIAL_CONTROL.meta_.fields[1]                          = _ad_hoc705;
			_Host.BATTERY_STATUS.meta_.fields[0]                          = _ad_hoc58;
			_Host.BATTERY_STATUS.meta_.fields[1]                          = _ad_hoc59;
			_Host.SET_GPS_GLOBAL_ORIGIN.meta_.fields[0]                   = _ad_hoc1181;
			_Host.SET_HOME_POSITION.meta_.fields[0]                       = _ad_hoc1954;
			_Host.OPTICAL_FLOW.meta_.fields[0]                            = _ad_hoc1471;
			_Host.OPTICAL_FLOW.meta_.fields[1]                            = _ad_hoc1472;
			_Host.POSITION_TARGET_GLOBAL_INT.meta_.fields[0]              = _ad_hoc376;
			_Host.PARAM_SET.meta_.fields[0]                               = _ad_hoc1018;
			_Host.PARAM_SET.meta_.fields[1]                               = _ad_hoc1;
			_Host.REMOTE_LOG_DATA_BLOCK.meta_.fields[0]                   = _ad_hoc219;
			_Host.SAFETY_ALLOWED_AREA.meta_.fields[0]                     = _ad_hoc880;
			_Host.VIDEO_STREAM_INFORMATION.meta_.fields[0]                = _ad_hoc2074;
			_Host.CHANGE_OPERATOR_CONTROL.meta_.fields[0]                 = _ad_hoc999;
			_Host.MEMINFO.meta_.fields[0]                                 = _ad_hoc2160;
			_Host.MISSION_COUNT.meta_.fields[0]                           = _ad_hoc16;
			_Host.MAG_CAL_PROGRESS.meta_.fields[0]                        = _ad_hoc141;
			_Host.UAVCAN_NODE_INFO.meta_.fields[0]                        = _ad_hoc2097;
			_Host.ADSB_VEHICLE.meta_.fields[0]                            = _ad_hoc10;
			_Host.ADSB_VEHICLE.meta_.fields[1]                            = _ad_hoc1964;
			_Host.ADSB_VEHICLE.meta_.fields[2]                            = _ad_hoc11;
			_Host.ADSB_VEHICLE.meta_.fields[3]                            = _ad_hoc12;
			_Host.SERVO_OUTPUT_RAW.meta_.fields[0]                        = _ad_hoc1132;
			_Host.SERVO_OUTPUT_RAW.meta_.fields[1]                        = _ad_hoc1133;
			_Host.SERVO_OUTPUT_RAW.meta_.fields[2]                        = _ad_hoc1134;
			_Host.SERVO_OUTPUT_RAW.meta_.fields[3]                        = _ad_hoc1135;
			_Host.SERVO_OUTPUT_RAW.meta_.fields[4]                        = _ad_hoc1136;
			_Host.SERVO_OUTPUT_RAW.meta_.fields[5]                        = _ad_hoc1137;
			_Host.SERVO_OUTPUT_RAW.meta_.fields[6]                        = _ad_hoc1138;
			_Host.SERVO_OUTPUT_RAW.meta_.fields[7]                        = _ad_hoc1139;
			_Host.SET_MODE.meta_.fields[0]                                = _ad_hoc80;
			_Host.OBSTACLE_DISTANCE.meta_.fields[0]                       = _ad_hoc282;
			_Host.PING33.meta_.fields[0]                                  = _ad_hoc1487;
			_Host.PING33.meta_.fields[1]                                  = _ad_hoc1488;
			_Host.PING33.meta_.fields[2]                                  = _ad_hoc1490;
			_Host.PING33.meta_.fields[3]                                  = _ad_hoc1491;
			_Host.PING33.meta_.fields[4]                                  = _ad_hoc1492;
			_Host.PING33.meta_.fields[5]                                  = _ad_hoc1494;
			_Host.PING33.meta_.fields[6]                                  = _ad_hoc1498;
			_Host.PING33.meta_.fields[7]                                  = _ad_hoc1499;
			_Host.PING33.meta_.fields[8]                                  = _ad_hoc1500;
			_Host.PING33.meta_.fields[9]                                  = _ad_hoc1501;
			_Host.PING33.meta_.fields[10]                                 = _ad_hoc1502;
			_Host.PING33.meta_.fields[11]                                 = _ad_hoc1503;
			_Host.PING33.meta_.fields[12]                                 = _ad_hoc1504;
			_Host.PING33.meta_.fields[13]                                 = _ad_hoc1505;
			_Host.PING33.meta_.fields[14]                                 = _ad_hoc1506;
			_Host.PING33.meta_.fields[15]                                 = _ad_hoc1507;
			_Host.PING33.meta_.fields[16]                                 = _ad_hoc1508;
			_Host.PING33.meta_.fields[17]                                 = _ad_hoc139;
			_Host.PING33.meta_.fields[18]                                 = _ad_hoc1509;
			_Host.PING33.meta_.fields[19]                                 = _ad_hoc1510;
			_Host.PING33.meta_.fields[20]                                 = _ad_hoc1511;
			_Host.PING33.meta_.fields[21]                                 = _ad_hoc1512;
			_Host.PING33.meta_.fields[22]                                 = _ad_hoc1513;
			_Host.PING33.meta_.fields[23]                                 = _ad_hoc1515;
			_Host.PING33.meta_.fields[24]                                 = _ad_hoc1516;
			_Host.PING33.meta_.fields[25]                                 = _ad_hoc1517;
			_Host.PING33.meta_.fields[26]                                 = _ad_hoc1518;
			_Host.PING33.meta_.fields[27]                                 = _ad_hoc1519;
			_Host.PING33.meta_.fields[28]                                 = _ad_hoc1520;
			_Host.PING33.meta_.fields[29]                                 = _ad_hoc1521;
			_Host.PING33.meta_.fields[30]                                 = _ad_hoc1522;
			_Host.PARAM_REQUEST_READ.meta_.fields[0]                      = _ad_hoc1008;
			_Host.EXTENDED_SYS_STATE.meta_.fields[0]                      = _ad_hoc19;
			_Host.EXTENDED_SYS_STATE.meta_.fields[1]                      = _ad_hoc20;
			_Host.CAMERA_STATUS.meta_.fields[0]                           = _ad_hoc684;
			_Host.UAVIONIX_ADSB_OUT_CFG.meta_.fields[0]                   = _ad_hoc2126;
			_Host.UAVIONIX_ADSB_OUT_CFG.meta_.fields[1]                   = _ad_hoc209;
			_Host.UAVIONIX_ADSB_OUT_CFG.meta_.fields[2]                   = _ad_hoc212;
			_Host.UAVIONIX_ADSB_OUT_CFG.meta_.fields[3]                   = _ad_hoc210;
			_Host.UAVIONIX_ADSB_OUT_CFG.meta_.fields[4]                   = _ad_hoc208;
			_Host.UAVIONIX_ADSB_OUT_CFG.meta_.fields[5]                   = _ad_hoc211;
			_Host.NAMED_VALUE_FLOAT.meta_.fields[0]                       = _ad_hoc1986;
			_Host.DEVICE_OP_READ.meta_.fields[0]                          = _ad_hoc248;
			_Host.DEVICE_OP_READ.meta_.fields[1]                          = _ad_hoc2414;
			_Host.SET_POSITION_TARGET_GLOBAL_INT.meta_.fields[0]          = _ad_hoc957;
			_Host.WIFI_CONFIG_AP.meta_.fields[0]                          = _ad_hoc2084;
			_Host.WIFI_CONFIG_AP.meta_.fields[1]                          = _ad_hoc2085;
			_Host.MISSION_ACK.meta_.fields[0]                             = _ad_hoc192;
			_Host.MISSION_ACK.meta_.fields[1]                             = _ad_hoc193;
			_Host.MISSION_REQUEST.meta_.fields[0]                         = _ad_hoc218;
			_Host.RALLY_POINT.meta_.fields[0]                             = _ad_hoc645;
			_Host.DISTANCE_SENSOR.meta_.fields[0]                         = _ad_hoc244;
			_Host.DISTANCE_SENSOR.meta_.fields[1]                         = _ad_hoc243;
			_Host.MAG_CAL_REPORT.meta_.fields[0]                          = _ad_hoc83;
			_Host.POSITION_TARGET_LOCAL_NED.meta_.fields[0]               = _ad_hoc86;
			_Host.PLAY_TUNE.meta_.fields[0]                               = _ad_hoc2004;
			_Host.SET_VIDEO_STREAM_SETTINGS.meta_.fields[0]               = _ad_hoc2083;
			_Host.HEARTBEAT.meta_.fields[0]                               = _ad_hoc688;
			_Host.HEARTBEAT.meta_.fields[1]                               = _ad_hoc686;
			_Host.HEARTBEAT.meta_.fields[2]                               = _ad_hoc685;
			_Host.HEARTBEAT.meta_.fields[3]                               = _ad_hoc687;
			_Host.CAMERA_IMAGE_CAPTURED.meta_.fields[0]                   = _ad_hoc2043;
			_Host.PID_TUNING.meta_.fields[0]                              = _ad_hoc104;
			_Host.SYS_STATUS.meta_.fields[0]                              = _ad_hoc828;
			_Host.SYS_STATUS.meta_.fields[1]                              = _ad_hoc826;
			_Host.SYS_STATUS.meta_.fields[2]                              = _ad_hoc827;
			_Host.FENCE_STATUS.meta_.fields[0]                            = _ad_hoc85;
			_Host.GOPRO_SET_REQUEST.meta_.fields[0]                       = _ad_hoc17;
			_Host.CAMERA_INFORMATION.meta_.fields[0]                      = _ad_hoc342;
			_Host.CAMERA_INFORMATION.meta_.fields[1]                      = _ad_hoc2016;
			_Host.GOPRO_GET_RESPONSE.meta_.fields[0]                      = _ad_hoc426;
			_Host.GOPRO_GET_RESPONSE.meta_.fields[1]                      = _ad_hoc425;
			_Host.LANDING_TARGET.meta_.fields[0]                          = _ad_hoc351;
			_Host.LANDING_TARGET.meta_.fields[1]                          = _ad_hoc1861;
			_Host.LANDING_TARGET.meta_.fields[2]                          = _ad_hoc1862;
			_Host.LANDING_TARGET.meta_.fields[3]                          = _ad_hoc1863;
			_Host.LANDING_TARGET.meta_.fields[4]                          = _ad_hoc1864;
			_Host.LANDING_TARGET.meta_.fields[5]                          = _ad_hoc352;
			_Host.LANDING_TARGET.meta_.fields[6]                          = _ad_hoc1865;
			_Host.MISSION_REQUEST_LIST.meta_.fields[0]                    = _ad_hoc820;
			_Host.PARAM_VALUE.meta_.fields[0]                             = _ad_hoc1012;
			_Host.PARAM_VALUE.meta_.fields[1]                             = _ad_hoc966;
			_Host.POWER_STATUS.meta_.fields[0]                            = _ad_hoc140;
			_Host.LOCAL_POSITION_NED_COV.meta_.fields[0]                  = _ad_hoc112;
			_Host.GOPRO_SET_RESPONSE.meta_.fields[0]                      = _ad_hoc882;
			_Host.GOPRO_SET_RESPONSE.meta_.fields[1]                      = _ad_hoc883;
			_Host.GPS2_RAW.meta_.fields[0]                                = _ad_hoc972;
			_Host.SET_POSITION_TARGET_LOCAL_NED.meta_.fields[0]           = _ad_hoc51;
			_Host.GPS_RAW_INT.meta_.fields[0]                             = _ad_hoc153;
			_Host.GPS_RAW_INT.meta_.fields[1]                             = _ad_hoc1029;
			_Host.GPS_RAW_INT.meta_.fields[2]                             = _ad_hoc1030;
			_Host.GPS_RAW_INT.meta_.fields[3]                             = _ad_hoc1031;
			_Host.GPS_RAW_INT.meta_.fields[4]                             = _ad_hoc1032;
			_Host.GPS_RAW_INT.meta_.fields[5]                             = _ad_hoc1033;
			_Host.ADAP_TUNING.meta_.fields[0]                             = _ad_hoc963;
			_Host.COLLISION.meta_.fields[0]                               = _ad_hoc804;
			_Host.COLLISION.meta_.fields[1]                               = _ad_hoc803;
			_Host.COLLISION.meta_.fields[2]                               = _ad_hoc802;
			_Host.HIL_CONTROLS.meta_.fields[0]                            = _ad_hoc353;
			_Host.NAMED_VALUE_INT.meta_.fields[0]                         = _ad_hoc1989;
			_Host.GPS_GLOBAL_ORIGIN.meta_.fields[0]                       = _ad_hoc1185;
			_Host.PARAM_EXT_REQUEST_READ.meta_.fields[0]                  = _ad_hoc2106;
			_Host.HIGH_LATENCY.meta_.fields[0]                            = _ad_hoc213;
			_Host.HIGH_LATENCY.meta_.fields[1]                            = _ad_hoc215;
			_Host.HIGH_LATENCY.meta_.fields[2]                            = _ad_hoc214;
			_Host.SAFETY_SET_ALLOWED_AREA.meta_.fields[0]                 = _ad_hoc306;
			_Host.COMMAND_ACK.meta_.fields[0]                             = _ad_hoc424;
			_Host.COMMAND_ACK.meta_.fields[1]                             = _ad_hoc423;
			_Host.COMMAND_ACK.meta_.fields[2]                             = _ad_hoc1330;
			_Host.COMMAND_ACK.meta_.fields[3]                             = _ad_hoc1331;
			_Host.COMMAND_ACK.meta_.fields[4]                             = _ad_hoc1332;
			_Host.COMMAND_ACK.meta_.fields[5]                             = _ad_hoc1333;
			_Host.GOPRO_HEARTBEAT.meta_.fields[0]                         = _ad_hoc629;
			_Host.GOPRO_HEARTBEAT.meta_.fields[1]                         = _ad_hoc630;
			_Host.GOPRO_HEARTBEAT.meta_.fields[2]                         = _ad_hoc628;
			_Host.UAVCAN_NODE_STATUS.meta_.fields[0]                      = _ad_hoc350;
			_Host.UAVCAN_NODE_STATUS.meta_.fields[1]                      = _ad_hoc349;
			_Host.MISSION_ITEM.meta_.fields[0]                            = _ad_hoc149;
			_Host.MISSION_ITEM.meta_.fields[1]                            = _ad_hoc150;
			_Host.MISSION_ITEM.meta_.fields[2]                            = _ad_hoc151;
			_Host.UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT.meta_.fields[0] = _ad_hoc377;
			_Host.COMMAND_INT.meta_.fields[0]                             = _ad_hoc420;
			_Host.COMMAND_INT.meta_.fields[1]                             = _ad_hoc421;
			_Host.AUTH_KEY.meta_.fields[0]                                = _ad_hoc1003;
			_Host.MOUNT_CONFIGURE.meta_.fields[0]                         = _ad_hoc106;
			_Host.GLOBAL_POSITION_INT_COV.meta_.fields[0]                 = _ad_hoc636;
			_Host.MISSION_REQUEST_INT.meta_.fields[0]                     = _ad_hoc105;
			_Host.STATUSTEXT.meta_.fields[0]                              = _ad_hoc683;
			_Host.STATUSTEXT.meta_.fields[1]                              = _ad_hoc1991;
			_Host.DEBUG_VECT.meta_.fields[0]                              = _ad_hoc1980;
			
		}
		
		Config_();
		
	}
}
												
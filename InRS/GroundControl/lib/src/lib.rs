#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(unused_imports)]

#![feature(const_transmute)]
#[macro_use]
extern crate bitflags;

#[path = "util.rs"]
pub mod util_;

pub use ad_hoc_sys as sys;


pub mod com {
    pub mod company {
        pub mod demo {
            pub mod GroundControl {
                use std::str;
                use std::mem::transmute;
                use crate::util_;

                /**
*Reports the current commanded attitude of the vehicle as specified by the autopilot. This should match
*				 the commands sent in a SET_ATTITUDE_TARGET message if the vehicle is being controlled this way */

                pub mod ATTITUDE_TARGET {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::ATTITUDE_TARGET) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn type_mask(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 4, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn q(&mut self) -> crate::util_::ItemArray__ad_hoc1352 {
                            let src = self.0;

                            let len = 4 as usize;
                            let offset = 5;
                            let bytes = src;
                            crate::util_::ItemArray__ad_hoc1352 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                        pub fn body_roll_rate(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 21, 4usize) as u32)
                        }
                        pub fn body_pitch_rate(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 25, 4usize) as u32)
                        }
                        pub fn body_yaw_rate(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 29, 4usize) as u32)
                        }
                        pub fn thrust(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 33, 4usize) as u32)
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.type_mask(src.type_mask());
                        dst.q(&mut src.q());
                        dst.body_roll_rate(src.body_roll_rate());
                        dst.body_pitch_rate(src.body_pitch_rate());
                        dst.body_yaw_rate(src.body_yaw_rate());
                        dst.thrust(src.thrust());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn type_mask(&mut self, src: i8);
                        fn q(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1352);
                        fn body_roll_rate(&mut self, src: f32);
                        fn body_pitch_rate(&mut self, src: f32);
                        fn body_yaw_rate(&mut self, src: f32);
                        fn thrust(&mut self, src: f32);
                    }

                    pub mod q {
                        pub const len: usize = 4usize;
                    }
                }

                /**
*This message is emitted as response to MISSION_REQUEST_LIST by the MAV and to initiate a write transaction.
*				 The GCS can then request the individual mission item based on the knowledge of the total number of waypoints */

                pub mod MISSION_COUNT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_COUNT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn count(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 3, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn mission_type(&mut self) -> Option<packs::MAV_MISSION_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 32 && !src.set_field(32, -1) { return None; }

                            Some({ packs::MAV_MISSION_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.count(src.count());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        if let Some(src) = src.mission_type() {
                            dst.mission_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn count(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn mission_type(&mut self, src: packs::MAV_MISSION_TYPE);
                    }
                }

                /**
*The location and information of an ADSB vehicle */

                pub mod ADSB_VEHICLE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::ADSB_VEHICLE) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn heading(&mut self) -> crate::util_::Item__ad_hoc1961 {
                            crate::util_::Item__ad_hoc1961(self.0)
                        }
                        pub fn hor_velocity(&mut self) -> crate::util_::Item__ad_hoc1962 {
                            crate::util_::Item__ad_hoc1962(self.0)
                        }
                        pub fn squawk(&mut self) -> crate::util_::Item__ad_hoc1966 {
                            crate::util_::Item__ad_hoc1966(self.0)
                        }
                        pub fn ICAO_address(&mut self) -> crate::util_::Item__ad_hoc1957 {
                            crate::util_::Item__ad_hoc1957(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc1958 {
                            crate::util_::Item__ad_hoc1958(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc1959 {
                            crate::util_::Item__ad_hoc1959(self.0)
                        }
                        pub fn altitude(&mut self) -> crate::util_::Item__ad_hoc1960 {
                            crate::util_::Item__ad_hoc1960(self.0)
                        }
                        pub fn ver_velocity(&mut self) -> crate::util_::Item__ad_hoc1963 {
                            crate::util_::Item__ad_hoc1963(self.0)
                        }
                        pub fn tslc(&mut self) -> crate::util_::Item__ad_hoc1965 {
                            crate::util_::Item__ad_hoc1965(self.0)
                        }
                        pub fn altitude_type(&mut self) -> crate::util_::Item__ad_hoc10 {
                            crate::util_::Item__ad_hoc10(self.0)
                        }
                        pub fn callsign(&mut self) -> crate::util_::Item__ad_hoc1964 {
                            crate::util_::Item__ad_hoc1964(self.0)
                        }
                        pub fn emitter_type(&mut self) -> crate::util_::Item__ad_hoc11 {
                            crate::util_::Item__ad_hoc11(self.0)
                        }
                        pub fn flags(&mut self) -> crate::util_::Item__ad_hoc12 {
                            crate::util_::Item__ad_hoc12(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.heading(src.heading().get());
                        dst.hor_velocity(src.hor_velocity().get());
                        dst.squawk(src.squawk().get());
                        dst.ICAO_address(src.ICAO_address().get());
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                        dst.altitude(src.altitude().get());
                        dst.ver_velocity(src.ver_velocity().get());
                        dst.tslc(src.tslc().get());
                        if let Some(src) = src.altitude_type().get() {
                            dst.altitude_type(src);
                        }
                        if let Some(src) = src.callsign().get() {
                            dst.callsign(src);
                        }
                        if let Some(src) = src.emitter_type().get() {
                            dst.emitter_type(src);
                        }
                        if let Some(src) = src.flags().get() {
                            dst.flags(src);
                        }
                    }

                    pub trait DST_ {
                        fn heading(&mut self, src: i16);
                        fn hor_velocity(&mut self, src: i16);
                        fn squawk(&mut self, src: i16);
                        fn ICAO_address(&mut self, src: i32);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn altitude(&mut self, src: i32);
                        fn ver_velocity(&mut self, src: i16);
                        fn tslc(&mut self, src: i8);
                        fn altitude_type(&mut self, src: packs::ADSB_ALTITUDE_TYPE);
                        fn callsign(&mut self, src: &str);
                        fn emitter_type(&mut self, src: packs::ADSB_EMITTER_TYPE);
                        fn flags(&mut self, src: packs::ADSB_FLAGS);
                    }

                    pub trait SRC_ {
                        fn heading(&mut self) -> i16;
                        fn hor_velocity(&mut self) -> i16;
                        fn squawk(&mut self) -> i16;
                        fn ICAO_address(&mut self) -> i32;
                        fn lat(&mut self) -> i32;
                        fn lon(&mut self) -> i32;
                        fn altitude(&mut self) -> i32;
                        fn ver_velocity(&mut self) -> i16;
                        fn tslc(&mut self) -> i8;
                        fn altitude_type(&mut self) -> Option<packs::ADSB_ALTITUDE_TYPE>;
                        fn callsign_item_exists_(&mut self) -> usize;
                        fn callsign(&mut self, dst: &mut [u8]);
                        fn emitter_type(&mut self) -> Option<packs::ADSB_EMITTER_TYPE>;
                        fn flags(&mut self) -> Option<packs::ADSB_FLAGS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.heading().set(src.heading());
                        dst.hor_velocity().set(src.hor_velocity());
                        dst.squawk().set(src.squawk());
                        dst.ICAO_address().set(src.ICAO_address());
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                        dst.altitude().set(src.altitude());
                        dst.ver_velocity().set(src.ver_velocity());
                        dst.tslc().set(src.tslc());
                        if let Some(src) = src.altitude_type() {
                            dst.altitude_type().set(src);
                        }
                        let len = src.callsign_item_exists_();
                        if 0 < len {
                            dst.0.set_field(203, len as i32);

                            src.callsign(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                        if let Some(src) = src.emitter_type() {
                            dst.emitter_type().set(src);
                        }
                        if let Some(src) = src.flags() {
                            dst.flags().set(src);
                        }
                    }

                    pub mod callsign {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*This interface replaces DATA_STREAM */

                pub mod MESSAGE_INTERVAL {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MESSAGE_INTERVAL) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn message_id(&mut self) -> crate::util_::Item__ad_hoc1955 {
                            crate::util_::Item__ad_hoc1955(self.0)
                        }
                        pub fn interval_us(&mut self) -> crate::util_::Item__ad_hoc1956 {
                            crate::util_::Item__ad_hoc1956(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.message_id(src.message_id().get());
                        dst.interval_us(src.interval_us().get());
                    }

                    pub trait DST_ {
                        fn message_id(&mut self, src: i16);
                        fn interval_us(&mut self, src: i32);
                    }

                    pub trait SRC_ {
                        fn message_id(&mut self) -> i16;
                        fn interval_us(&mut self) -> i32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.message_id().set(src.message_id());
                        dst.interval_us().set(src.interval_us());
                    }
                }

                /**
*EKF Status message including flags and variances */

                pub mod EKF_STATUS_REPORT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::EKF_STATUS_REPORT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn velocity_variance(&mut self) -> crate::util_::Item__ad_hoc2368 {
                            crate::util_::Item__ad_hoc2368(self.0)
                        }
                        pub fn pos_horiz_variance(&mut self) -> crate::util_::Item__ad_hoc2369 {
                            crate::util_::Item__ad_hoc2369(self.0)
                        }
                        pub fn pos_vert_variance(&mut self) -> crate::util_::Item__ad_hoc2370 {
                            crate::util_::Item__ad_hoc2370(self.0)
                        }
                        pub fn compass_variance(&mut self) -> crate::util_::Item__ad_hoc2371 {
                            crate::util_::Item__ad_hoc2371(self.0)
                        }
                        pub fn terrain_alt_variance(&mut self) -> crate::util_::Item__ad_hoc2372 {
                            crate::util_::Item__ad_hoc2372(self.0)
                        }
                        pub fn flags(&mut self) -> crate::util_::Item__ad_hoc710 {
                            crate::util_::Item__ad_hoc710(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.velocity_variance(src.velocity_variance().get());
                        dst.pos_horiz_variance(src.pos_horiz_variance().get());
                        dst.pos_vert_variance(src.pos_vert_variance().get());
                        dst.compass_variance(src.compass_variance().get());
                        dst.terrain_alt_variance(src.terrain_alt_variance().get());
                        if let Some(src) = src.flags().get() {
                            dst.flags(src);
                        }
                    }

                    pub trait DST_ {
                        fn velocity_variance(&mut self, src: f32);
                        fn pos_horiz_variance(&mut self, src: f32);
                        fn pos_vert_variance(&mut self, src: f32);
                        fn compass_variance(&mut self, src: f32);
                        fn terrain_alt_variance(&mut self, src: f32);
                        fn flags(&mut self, src: packs::EKF_STATUS_FLAGS);
                    }

                    pub trait SRC_ {
                        fn velocity_variance(&mut self) -> f32;
                        fn pos_horiz_variance(&mut self) -> f32;
                        fn pos_vert_variance(&mut self) -> f32;
                        fn compass_variance(&mut self) -> f32;
                        fn terrain_alt_variance(&mut self) -> f32;
                        fn flags(&mut self) -> Option<packs::EKF_STATUS_FLAGS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.velocity_variance().set(src.velocity_variance());
                        dst.pos_horiz_variance().set(src.pos_horiz_variance());
                        dst.pos_vert_variance().set(src.pos_vert_variance());
                        dst.compass_variance().set(src.compass_variance());
                        dst.terrain_alt_variance().set(src.terrain_alt_variance());
                        if let Some(src) = src.flags() {
                            dst.flags().set(src);
                        }
                    }
                }

                /**
*Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message
*				 is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS
*				 enum definition for further information. The innovaton test ratios show the magnitude of the sensor innovation
*				 divided by the innovation check threshold. Under normal operation the innovaton test ratios should be
*				 below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation
*				 and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation
*				 test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should
*				 be optional and controllable by the user */

                pub mod ESTIMATOR_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::ESTIMATOR_STATUS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1866 {
                            crate::util_::Item__ad_hoc1866(self.0)
                        }
                        pub fn vel_ratio(&mut self) -> crate::util_::Item__ad_hoc1867 {
                            crate::util_::Item__ad_hoc1867(self.0)
                        }
                        pub fn pos_horiz_ratio(&mut self) -> crate::util_::Item__ad_hoc1868 {
                            crate::util_::Item__ad_hoc1868(self.0)
                        }
                        pub fn pos_vert_ratio(&mut self) -> crate::util_::Item__ad_hoc1869 {
                            crate::util_::Item__ad_hoc1869(self.0)
                        }
                        pub fn mag_ratio(&mut self) -> crate::util_::Item__ad_hoc1870 {
                            crate::util_::Item__ad_hoc1870(self.0)
                        }
                        pub fn hagl_ratio(&mut self) -> crate::util_::Item__ad_hoc1871 {
                            crate::util_::Item__ad_hoc1871(self.0)
                        }
                        pub fn tas_ratio(&mut self) -> crate::util_::Item__ad_hoc1872 {
                            crate::util_::Item__ad_hoc1872(self.0)
                        }
                        pub fn pos_horiz_accuracy(&mut self) -> crate::util_::Item__ad_hoc1873 {
                            crate::util_::Item__ad_hoc1873(self.0)
                        }
                        pub fn pos_vert_accuracy(&mut self) -> crate::util_::Item__ad_hoc1874 {
                            crate::util_::Item__ad_hoc1874(self.0)
                        }
                        pub fn flags(&mut self) -> crate::util_::Item__ad_hoc9 {
                            crate::util_::Item__ad_hoc9(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec().get());
                        dst.vel_ratio(src.vel_ratio().get());
                        dst.pos_horiz_ratio(src.pos_horiz_ratio().get());
                        dst.pos_vert_ratio(src.pos_vert_ratio().get());
                        dst.mag_ratio(src.mag_ratio().get());
                        dst.hagl_ratio(src.hagl_ratio().get());
                        dst.tas_ratio(src.tas_ratio().get());
                        dst.pos_horiz_accuracy(src.pos_horiz_accuracy().get());
                        dst.pos_vert_accuracy(src.pos_vert_accuracy().get());
                        if let Some(src) = src.flags().get() {
                            dst.flags(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn vel_ratio(&mut self, src: f32);
                        fn pos_horiz_ratio(&mut self, src: f32);
                        fn pos_vert_ratio(&mut self, src: f32);
                        fn mag_ratio(&mut self, src: f32);
                        fn hagl_ratio(&mut self, src: f32);
                        fn tas_ratio(&mut self, src: f32);
                        fn pos_horiz_accuracy(&mut self, src: f32);
                        fn pos_vert_accuracy(&mut self, src: f32);
                        fn flags(&mut self, src: packs::ESTIMATOR_STATUS_FLAGS);
                    }

                    pub trait SRC_ {
                        fn time_usec(&mut self) -> i64;
                        fn vel_ratio(&mut self) -> f32;
                        fn pos_horiz_ratio(&mut self) -> f32;
                        fn pos_vert_ratio(&mut self) -> f32;
                        fn mag_ratio(&mut self) -> f32;
                        fn hagl_ratio(&mut self) -> f32;
                        fn tas_ratio(&mut self) -> f32;
                        fn pos_horiz_accuracy(&mut self) -> f32;
                        fn pos_vert_accuracy(&mut self) -> f32;
                        fn flags(&mut self) -> Option<packs::ESTIMATOR_STATUS_FLAGS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_usec().set(src.time_usec());
                        dst.vel_ratio().set(src.vel_ratio());
                        dst.pos_horiz_ratio().set(src.pos_horiz_ratio());
                        dst.pos_vert_ratio().set(src.pos_vert_ratio());
                        dst.mag_ratio().set(src.mag_ratio());
                        dst.hagl_ratio().set(src.hagl_ratio());
                        dst.tas_ratio().set(src.tas_ratio());
                        dst.pos_horiz_accuracy().set(src.pos_horiz_accuracy());
                        dst.pos_vert_accuracy().set(src.pos_vert_accuracy());
                        if let Some(src) = src.flags() {
                            dst.flags().set(src);
                        }
                    }
                }

                /**
*Status of key hardware */

                pub mod HWSTATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HWSTATUS) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn Vcc(&mut self) -> crate::util_::Item__ad_hoc2234 {
                            crate::util_::Item__ad_hoc2234(self.0)
                        }
                        pub fn I2Cerr(&mut self) -> crate::util_::Item__ad_hoc2235 {
                            crate::util_::Item__ad_hoc2235(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.Vcc(src.Vcc().get());
                        dst.I2Cerr(src.I2Cerr().get());
                    }

                    pub trait DST_ {
                        fn Vcc(&mut self, src: i16);
                        fn I2Cerr(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn Vcc(&mut self) -> i16;
                        fn I2Cerr(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.Vcc().set(src.Vcc());
                        dst.I2Cerr().set(src.I2Cerr());
                    }
                }

                /**
*Time synchronization message. */

                pub mod TIMESYNC {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::TIMESYNC) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn tc1(&mut self) -> crate::util_::Item__ad_hoc1608 {
                            crate::util_::Item__ad_hoc1608(self.0)
                        }
                        pub fn ts1(&mut self) -> crate::util_::Item__ad_hoc1609 {
                            crate::util_::Item__ad_hoc1609(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.tc1(src.tc1().get());
                        dst.ts1(src.ts1().get());
                    }

                    pub trait DST_ {
                        fn tc1(&mut self, src: i64);
                        fn ts1(&mut self, src: i64);
                    }

                    pub trait SRC_ {
                        fn tc1(&mut self) -> i64;
                        fn ts1(&mut self) -> i64;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.tc1().set(src.tc1());
                        dst.ts1().set(src.ts1());
                    }
                }

                /**
*Request all parameters of this component. After this request, all parameters are emitted. */

                pub mod PARAM_EXT_REQUEST_LIST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PARAM_EXT_REQUEST_LIST) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2108 {
                            crate::util_::Item__ad_hoc2108(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2109 {
                            crate::util_::Item__ad_hoc2109(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                    }
                }

                /**
*The filtered global position (e.g. fused GPS and accelerometers). The position is in GPS-frame (right-handed,
*				 Z-up). It  is designed as scaled integer message since the resolution of float is not sufficient. NOTE:
*				 This message is intended for onboard networks / companion computers and higher-bandwidth links and optimized
*				 for accuracy and completeness. Please use the GLOBAL_POSITION_INT message for a minimal subset */

                pub mod GLOBAL_POSITION_INT_COV {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GLOBAL_POSITION_INT_COV) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn lat(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 8, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn lon(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 12, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn alt(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 16, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn relative_alt(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 20, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn vx(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 24, 4usize) as u32)
                        }
                        pub fn vy(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 28, 4usize) as u32)
                        }
                        pub fn vz(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 32, 4usize) as u32)
                        }
                        pub fn covariance(&mut self) -> crate::util_::ItemArray__ad_hoc1234 {
                            let src = &mut self.0;

                            let len = 36 as usize;
                            let offset = 36;
                            let bytes = src.base.bytes;
                            crate::util_::ItemArray__ad_hoc1234 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                        pub fn estimator_type(&mut self) -> Option<packs::MAV_ESTIMATOR_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 1440 && !src.set_field(1440, -1) { return None; }

                            Some({ packs::MAV_ESTIMATOR_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i8).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec());
                        dst.lat(src.lat());
                        dst.lon(src.lon());
                        dst.alt(src.alt());
                        dst.relative_alt(src.relative_alt());
                        dst.vx(src.vx());
                        dst.vy(src.vy());
                        dst.vz(src.vz());
                        dst.covariance(&mut src.covariance());
                        if let Some(src) = src.estimator_type() {
                            dst.estimator_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn alt(&mut self, src: i32);
                        fn relative_alt(&mut self, src: i32);
                        fn vx(&mut self, src: f32);
                        fn vy(&mut self, src: f32);
                        fn vz(&mut self, src: f32);
                        fn covariance(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1234);
                        fn estimator_type(&mut self, src: packs::MAV_ESTIMATOR_TYPE);
                    }

                    pub mod covariance {
                        pub const len: usize = 36usize;
                    }
                }

                /**
*Report button state change */

                pub mod BUTTON_CHANGE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::BUTTON_CHANGE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc1999 {
                            crate::util_::Item__ad_hoc1999(self.0)
                        }
                        pub fn last_change_ms(&mut self) -> crate::util_::Item__ad_hoc2000 {
                            crate::util_::Item__ad_hoc2000(self.0)
                        }
                        pub fn state(&mut self) -> crate::util_::Item__ad_hoc2001 {
                            crate::util_::Item__ad_hoc2001(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.last_change_ms(src.last_change_ms().get());
                        dst.state(src.state().get());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn last_change_ms(&mut self, src: i32);
                        fn state(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn last_change_ms(&mut self) -> i32;
                        fn state(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.last_change_ms().set(src.last_change_ms());
                        dst.state().set(src.state());
                    }
                }

                /**
*Set a safety zone (volume), which is defined by two corners of a cube. This message can be used to tell
*				 the MAV which setpoints/waypoints to accept and which to reject. Safety areas are often enforced by national
*				 or competition regulations */

                pub mod SAFETY_SET_ALLOWED_AREA {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SAFETY_SET_ALLOWED_AREA) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn p1x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 2, 4usize) as u32)
                        }
                        pub fn p1y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 6, 4usize) as u32)
                        }
                        pub fn p1z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 10, 4usize) as u32)
                        }
                        pub fn p2x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 14, 4usize) as u32)
                        }
                        pub fn p2y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 18, 4usize) as u32)
                        }
                        pub fn p2z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 22, 4usize) as u32)
                        }
                        pub fn frame(&mut self) -> Option<packs::MAV_FRAME> {
                            let src = &mut self.0;
                            if src.base.field_bit != 208 && !src.set_field(208, -1) { return None; }

                            Some({ packs::MAV_FRAME::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.p1x(src.p1x());
                        dst.p1y(src.p1y());
                        dst.p1z(src.p1z());
                        dst.p2x(src.p2x());
                        dst.p2y(src.p2y());
                        dst.p2z(src.p2z());
                        if let Some(src) = src.frame() {
                            dst.frame(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn p1x(&mut self, src: f32);
                        fn p1y(&mut self, src: f32);
                        fn p1z(&mut self, src: f32);
                        fn p2x(&mut self, src: f32);
                        fn p2y(&mut self, src: f32);
                        fn p2z(&mut self, src: f32);
                        fn frame(&mut self, src: packs::MAV_FRAME);
                    }
                }

                /**
*General status information of an UAVCAN node. Please refer to the definition of the UAVCAN message "uavcan.protocol.NodeStatus"
*				 for the background information. The UAVCAN specification is available at http:uavcan.org */

                pub mod UAVCAN_NODE_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::UAVCAN_NODE_STATUS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn vendor_specific_status_code(&mut self) -> crate::util_::Item__ad_hoc2094 {
                            crate::util_::Item__ad_hoc2094(self.0)
                        }
                        pub fn uptime_sec(&mut self) -> crate::util_::Item__ad_hoc2092 {
                            crate::util_::Item__ad_hoc2092(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc2091 {
                            crate::util_::Item__ad_hoc2091(self.0)
                        }
                        pub fn sub_mode(&mut self) -> crate::util_::Item__ad_hoc2093 {
                            crate::util_::Item__ad_hoc2093(self.0)
                        }
                        pub fn health(&mut self) -> crate::util_::Item__ad_hoc350 {
                            crate::util_::Item__ad_hoc350(self.0)
                        }
                        pub fn mode(&mut self) -> crate::util_::Item__ad_hoc349 {
                            crate::util_::Item__ad_hoc349(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.vendor_specific_status_code(src.vendor_specific_status_code().get());
                        dst.uptime_sec(src.uptime_sec().get());
                        dst.time_usec(src.time_usec().get());
                        dst.sub_mode(src.sub_mode().get());
                        if let Some(src) = src.health().get() {
                            dst.health(src);
                        }
                        if let Some(src) = src.mode().get() {
                            dst.mode(src);
                        }
                    }

                    pub trait DST_ {
                        fn vendor_specific_status_code(&mut self, src: i16);
                        fn uptime_sec(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                        fn sub_mode(&mut self, src: i8);
                        fn health(&mut self, src: packs::UAVCAN_NODE_HEALTH);
                        fn mode(&mut self, src: packs::UAVCAN_NODE_MODE);
                    }

                    pub trait SRC_ {
                        fn vendor_specific_status_code(&mut self) -> i16;
                        fn uptime_sec(&mut self) -> i32;
                        fn time_usec(&mut self) -> i64;
                        fn sub_mode(&mut self) -> i8;
                        fn health(&mut self) -> Option<packs::UAVCAN_NODE_HEALTH>;
                        fn mode(&mut self) -> Option<packs::UAVCAN_NODE_MODE>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.vendor_specific_status_code().set(src.vendor_specific_status_code());
                        dst.uptime_sec().set(src.uptime_sec());
                        dst.time_usec().set(src.time_usec());
                        dst.sub_mode().set(src.sub_mode());
                        if let Some(src) = src.health() {
                            dst.health().set(src);
                        }
                        if let Some(src) = src.mode() {
                            dst.mode().set(src);
                        }
                    }
                }

                /**
*Information about a potential collision */

                pub mod COLLISION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::COLLISION) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn id(&mut self) -> crate::util_::Item__ad_hoc1967 {
                            crate::util_::Item__ad_hoc1967(self.0)
                        }
                        pub fn time_to_minimum_delta(&mut self) -> crate::util_::Item__ad_hoc1968 {
                            crate::util_::Item__ad_hoc1968(self.0)
                        }
                        pub fn altitude_minimum_delta(&mut self) -> crate::util_::Item__ad_hoc1969 {
                            crate::util_::Item__ad_hoc1969(self.0)
                        }
                        pub fn horizontal_minimum_delta(&mut self) -> crate::util_::Item__ad_hoc1970 {
                            crate::util_::Item__ad_hoc1970(self.0)
                        }
                        pub fn sRc(&mut self) -> crate::util_::Item__ad_hoc804 {
                            crate::util_::Item__ad_hoc804(self.0)
                        }
                        pub fn action(&mut self) -> crate::util_::Item__ad_hoc803 {
                            crate::util_::Item__ad_hoc803(self.0)
                        }
                        pub fn threat_level(&mut self) -> crate::util_::Item__ad_hoc802 {
                            crate::util_::Item__ad_hoc802(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.id(src.id().get());
                        dst.time_to_minimum_delta(src.time_to_minimum_delta().get());
                        dst.altitude_minimum_delta(src.altitude_minimum_delta().get());
                        dst.horizontal_minimum_delta(src.horizontal_minimum_delta().get());
                        if let Some(src) = src.sRc().get() {
                            dst.sRc(src);
                        }
                        if let Some(src) = src.action().get() {
                            dst.action(src);
                        }
                        if let Some(src) = src.threat_level().get() {
                            dst.threat_level(src);
                        }
                    }

                    pub trait DST_ {
                        fn id(&mut self, src: i32);
                        fn time_to_minimum_delta(&mut self, src: f32);
                        fn altitude_minimum_delta(&mut self, src: f32);
                        fn horizontal_minimum_delta(&mut self, src: f32);
                        fn sRc(&mut self, src: packs::MAV_COLLISION_SRC);
                        fn action(&mut self, src: packs::MAV_COLLISION_ACTION);
                        fn threat_level(&mut self, src: packs::MAV_COLLISION_THREAT_LEVEL);
                    }

                    pub trait SRC_ {
                        fn id(&mut self) -> i32;
                        fn time_to_minimum_delta(&mut self) -> f32;
                        fn altitude_minimum_delta(&mut self) -> f32;
                        fn horizontal_minimum_delta(&mut self) -> f32;
                        fn sRc(&mut self) -> Option<packs::MAV_COLLISION_SRC>;
                        fn action(&mut self) -> Option<packs::MAV_COLLISION_ACTION>;
                        fn threat_level(&mut self) -> Option<packs::MAV_COLLISION_THREAT_LEVEL>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.id().set(src.id());
                        dst.time_to_minimum_delta().set(src.time_to_minimum_delta());
                        dst.altitude_minimum_delta().set(src.altitude_minimum_delta());
                        dst.horizontal_minimum_delta().set(src.horizontal_minimum_delta());
                        if let Some(src) = src.sRc() {
                            dst.sRc().set(src);
                        }
                        if let Some(src) = src.action() {
                            dst.action().set(src);
                        }
                        if let Some(src) = src.threat_level() {
                            dst.threat_level().set(src);
                        }
                    }
                }

                /**
*100 Hz gimbal torque command telemetry */

                pub mod GIMBAL_TORQUE_CMD_REPORT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GIMBAL_TORQUE_CMD_REPORT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2396 {
                            crate::util_::Item__ad_hoc2396(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2397 {
                            crate::util_::Item__ad_hoc2397(self.0)
                        }
                        pub fn rl_torque_cmd(&mut self) -> crate::util_::Item__ad_hoc2398 {
                            crate::util_::Item__ad_hoc2398(self.0)
                        }
                        pub fn el_torque_cmd(&mut self) -> crate::util_::Item__ad_hoc2399 {
                            crate::util_::Item__ad_hoc2399(self.0)
                        }
                        pub fn az_torque_cmd(&mut self) -> crate::util_::Item__ad_hoc2400 {
                            crate::util_::Item__ad_hoc2400(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.rl_torque_cmd(src.rl_torque_cmd().get());
                        dst.el_torque_cmd(src.el_torque_cmd().get());
                        dst.az_torque_cmd(src.az_torque_cmd().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn rl_torque_cmd(&mut self, src: i16);
                        fn el_torque_cmd(&mut self, src: i16);
                        fn az_torque_cmd(&mut self, src: i16);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn rl_torque_cmd(&mut self) -> i16;
                        fn el_torque_cmd(&mut self) -> i16;
                        fn az_torque_cmd(&mut self) -> i16;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.rl_torque_cmd().set(src.rl_torque_cmd());
                        dst.el_torque_cmd().set(src.el_torque_cmd());
                        dst.az_torque_cmd().set(src.az_torque_cmd());
                    }
                }

                /**
*The current system altitude. */

                pub mod ALTITUDE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::ALTITUDE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1792 {
                            crate::util_::Item__ad_hoc1792(self.0)
                        }
                        pub fn altitude_monotonic(&mut self) -> crate::util_::Item__ad_hoc1793 {
                            crate::util_::Item__ad_hoc1793(self.0)
                        }
                        pub fn altitude_amsl(&mut self) -> crate::util_::Item__ad_hoc1794 {
                            crate::util_::Item__ad_hoc1794(self.0)
                        }
                        pub fn altitude_local(&mut self) -> crate::util_::Item__ad_hoc1795 {
                            crate::util_::Item__ad_hoc1795(self.0)
                        }
                        pub fn altitude_relative(&mut self) -> crate::util_::Item__ad_hoc1796 {
                            crate::util_::Item__ad_hoc1796(self.0)
                        }
                        pub fn altitude_terrain(&mut self) -> crate::util_::Item__ad_hoc1797 {
                            crate::util_::Item__ad_hoc1797(self.0)
                        }
                        pub fn bottom_clearance(&mut self) -> crate::util_::Item__ad_hoc1798 {
                            crate::util_::Item__ad_hoc1798(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec().get());
                        dst.altitude_monotonic(src.altitude_monotonic().get());
                        dst.altitude_amsl(src.altitude_amsl().get());
                        dst.altitude_local(src.altitude_local().get());
                        dst.altitude_relative(src.altitude_relative().get());
                        dst.altitude_terrain(src.altitude_terrain().get());
                        dst.bottom_clearance(src.bottom_clearance().get());
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn altitude_monotonic(&mut self, src: f32);
                        fn altitude_amsl(&mut self, src: f32);
                        fn altitude_local(&mut self, src: f32);
                        fn altitude_relative(&mut self, src: f32);
                        fn altitude_terrain(&mut self, src: f32);
                        fn bottom_clearance(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn time_usec(&mut self) -> i64;
                        fn altitude_monotonic(&mut self) -> f32;
                        fn altitude_amsl(&mut self) -> f32;
                        fn altitude_local(&mut self) -> f32;
                        fn altitude_relative(&mut self) -> f32;
                        fn altitude_terrain(&mut self) -> f32;
                        fn bottom_clearance(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_usec().set(src.time_usec());
                        dst.altitude_monotonic().set(src.altitude_monotonic());
                        dst.altitude_amsl().set(src.altitude_amsl());
                        dst.altitude_local().set(src.altitude_local());
                        dst.altitude_relative().set(src.altitude_relative());
                        dst.altitude_terrain().set(src.altitude_terrain());
                        dst.bottom_clearance().set(src.bottom_clearance());
                    }
                }

                /**
*Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful
*				 for high throughput applications such as hardware in the loop simulations */

                pub mod HIL_STATE_QUATERNION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HIL_STATE_QUATERNION) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn ind_airspeed(&mut self) -> crate::util_::Item__ad_hoc1648 {
                            crate::util_::Item__ad_hoc1648(self.0)
                        }
                        pub fn true_airspeed(&mut self) -> crate::util_::Item__ad_hoc1649 {
                            crate::util_::Item__ad_hoc1649(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1637 {
                            crate::util_::Item__ad_hoc1637(self.0)
                        }
                        pub fn attitude_quaternion(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1638 {
                            let dst = self.0;

                            let len = 4 as usize;
                            let offset = 12;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1638 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn rollspeed(&mut self) -> crate::util_::Item__ad_hoc1639 {
                            crate::util_::Item__ad_hoc1639(self.0)
                        }
                        pub fn pitchspeed(&mut self) -> crate::util_::Item__ad_hoc1640 {
                            crate::util_::Item__ad_hoc1640(self.0)
                        }
                        pub fn yawspeed(&mut self) -> crate::util_::Item__ad_hoc1641 {
                            crate::util_::Item__ad_hoc1641(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc1642 {
                            crate::util_::Item__ad_hoc1642(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc1643 {
                            crate::util_::Item__ad_hoc1643(self.0)
                        }
                        pub fn alt(&mut self) -> crate::util_::Item__ad_hoc1644 {
                            crate::util_::Item__ad_hoc1644(self.0)
                        }
                        pub fn vx(&mut self) -> crate::util_::Item__ad_hoc1645 {
                            crate::util_::Item__ad_hoc1645(self.0)
                        }
                        pub fn vy(&mut self) -> crate::util_::Item__ad_hoc1646 {
                            crate::util_::Item__ad_hoc1646(self.0)
                        }
                        pub fn vz(&mut self) -> crate::util_::Item__ad_hoc1647 {
                            crate::util_::Item__ad_hoc1647(self.0)
                        }
                        pub fn xacc(&mut self) -> crate::util_::Item__ad_hoc1650 {
                            crate::util_::Item__ad_hoc1650(self.0)
                        }
                        pub fn yacc(&mut self) -> crate::util_::Item__ad_hoc1651 {
                            crate::util_::Item__ad_hoc1651(self.0)
                        }
                        pub fn zacc(&mut self) -> crate::util_::Item__ad_hoc1652 {
                            crate::util_::Item__ad_hoc1652(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.ind_airspeed(src.ind_airspeed().get());
                        dst.true_airspeed(src.true_airspeed().get());
                        dst.time_usec(src.time_usec().get());
                        dst.attitude_quaternion(&mut src.attitude_quaternion(None));
                        dst.rollspeed(src.rollspeed().get());
                        dst.pitchspeed(src.pitchspeed().get());
                        dst.yawspeed(src.yawspeed().get());
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                        dst.alt(src.alt().get());
                        dst.vx(src.vx().get());
                        dst.vy(src.vy().get());
                        dst.vz(src.vz().get());
                        dst.xacc(src.xacc().get());
                        dst.yacc(src.yacc().get());
                        dst.zacc(src.zacc().get());
                    }

                    pub trait DST_ {
                        fn ind_airspeed(&mut self, src: i16);
                        fn true_airspeed(&mut self, src: i16);
                        fn time_usec(&mut self, src: i64);
                        fn attitude_quaternion(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1638);
                        fn rollspeed(&mut self, src: f32);
                        fn pitchspeed(&mut self, src: f32);
                        fn yawspeed(&mut self, src: f32);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn alt(&mut self, src: i32);
                        fn vx(&mut self, src: i16);
                        fn vy(&mut self, src: i16);
                        fn vz(&mut self, src: i16);
                        fn xacc(&mut self, src: i16);
                        fn yacc(&mut self, src: i16);
                        fn zacc(&mut self, src: i16);
                    }

                    pub trait SRC_ {
                        fn ind_airspeed(&mut self) -> i16;
                        fn true_airspeed(&mut self) -> i16;
                        fn time_usec(&mut self) -> i64;
                        fn attitude_quaternion(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1638);
                        fn rollspeed(&mut self) -> f32;
                        fn pitchspeed(&mut self) -> f32;
                        fn yawspeed(&mut self) -> f32;
                        fn lat(&mut self) -> i32;
                        fn lon(&mut self) -> i32;
                        fn alt(&mut self) -> i32;
                        fn vx(&mut self) -> i16;
                        fn vy(&mut self) -> i16;
                        fn vz(&mut self) -> i16;
                        fn xacc(&mut self) -> i16;
                        fn yacc(&mut self) -> i16;
                        fn zacc(&mut self) -> i16;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.ind_airspeed().set(src.ind_airspeed());
                        dst.true_airspeed().set(src.true_airspeed());
                        dst.time_usec().set(src.time_usec());
                        src.attitude_quaternion(&mut dst.attitude_quaternion(None));
                        dst.rollspeed().set(src.rollspeed());
                        dst.pitchspeed().set(src.pitchspeed());
                        dst.yawspeed().set(src.yawspeed());
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                        dst.alt().set(src.alt());
                        dst.vx().set(src.vx());
                        dst.vy().set(src.vy());
                        dst.vz().set(src.vz());
                        dst.xacc().set(src.xacc());
                        dst.yacc().set(src.yacc());
                        dst.zacc().set(src.zacc());
                    }

                    pub mod attitude_quaternion {
                        pub const len: usize = 4usize;
                    }
                }

                /**
*Offsets and calibrations values for hardware sensors. This makes it easier to debug the calibration process */

                pub mod SENSOR_OFFSETS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SENSOR_OFFSETS) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn mag_ofs_x(&mut self) -> crate::util_::Item__ad_hoc2141 {
                            crate::util_::Item__ad_hoc2141(self.0)
                        }
                        pub fn mag_ofs_y(&mut self) -> crate::util_::Item__ad_hoc2142 {
                            crate::util_::Item__ad_hoc2142(self.0)
                        }
                        pub fn mag_ofs_z(&mut self) -> crate::util_::Item__ad_hoc2143 {
                            crate::util_::Item__ad_hoc2143(self.0)
                        }
                        pub fn mag_declination(&mut self) -> crate::util_::Item__ad_hoc2144 {
                            crate::util_::Item__ad_hoc2144(self.0)
                        }
                        pub fn raw_press(&mut self) -> crate::util_::Item__ad_hoc2145 {
                            crate::util_::Item__ad_hoc2145(self.0)
                        }
                        pub fn raw_temp(&mut self) -> crate::util_::Item__ad_hoc2146 {
                            crate::util_::Item__ad_hoc2146(self.0)
                        }
                        pub fn gyro_cal_x(&mut self) -> crate::util_::Item__ad_hoc2147 {
                            crate::util_::Item__ad_hoc2147(self.0)
                        }
                        pub fn gyro_cal_y(&mut self) -> crate::util_::Item__ad_hoc2148 {
                            crate::util_::Item__ad_hoc2148(self.0)
                        }
                        pub fn gyro_cal_z(&mut self) -> crate::util_::Item__ad_hoc2149 {
                            crate::util_::Item__ad_hoc2149(self.0)
                        }
                        pub fn accel_cal_x(&mut self) -> crate::util_::Item__ad_hoc2150 {
                            crate::util_::Item__ad_hoc2150(self.0)
                        }
                        pub fn accel_cal_y(&mut self) -> crate::util_::Item__ad_hoc2151 {
                            crate::util_::Item__ad_hoc2151(self.0)
                        }
                        pub fn accel_cal_z(&mut self) -> crate::util_::Item__ad_hoc2152 {
                            crate::util_::Item__ad_hoc2152(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.mag_ofs_x(src.mag_ofs_x().get());
                        dst.mag_ofs_y(src.mag_ofs_y().get());
                        dst.mag_ofs_z(src.mag_ofs_z().get());
                        dst.mag_declination(src.mag_declination().get());
                        dst.raw_press(src.raw_press().get());
                        dst.raw_temp(src.raw_temp().get());
                        dst.gyro_cal_x(src.gyro_cal_x().get());
                        dst.gyro_cal_y(src.gyro_cal_y().get());
                        dst.gyro_cal_z(src.gyro_cal_z().get());
                        dst.accel_cal_x(src.accel_cal_x().get());
                        dst.accel_cal_y(src.accel_cal_y().get());
                        dst.accel_cal_z(src.accel_cal_z().get());
                    }

                    pub trait DST_ {
                        fn mag_ofs_x(&mut self, src: i16);
                        fn mag_ofs_y(&mut self, src: i16);
                        fn mag_ofs_z(&mut self, src: i16);
                        fn mag_declination(&mut self, src: f32);
                        fn raw_press(&mut self, src: i32);
                        fn raw_temp(&mut self, src: i32);
                        fn gyro_cal_x(&mut self, src: f32);
                        fn gyro_cal_y(&mut self, src: f32);
                        fn gyro_cal_z(&mut self, src: f32);
                        fn accel_cal_x(&mut self, src: f32);
                        fn accel_cal_y(&mut self, src: f32);
                        fn accel_cal_z(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn mag_ofs_x(&mut self) -> i16;
                        fn mag_ofs_y(&mut self) -> i16;
                        fn mag_ofs_z(&mut self) -> i16;
                        fn mag_declination(&mut self) -> f32;
                        fn raw_press(&mut self) -> i32;
                        fn raw_temp(&mut self) -> i32;
                        fn gyro_cal_x(&mut self) -> f32;
                        fn gyro_cal_y(&mut self) -> f32;
                        fn gyro_cal_z(&mut self) -> f32;
                        fn accel_cal_x(&mut self) -> f32;
                        fn accel_cal_y(&mut self) -> f32;
                        fn accel_cal_z(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.mag_ofs_x().set(src.mag_ofs_x());
                        dst.mag_ofs_y().set(src.mag_ofs_y());
                        dst.mag_ofs_z().set(src.mag_ofs_z());
                        dst.mag_declination().set(src.mag_declination());
                        dst.raw_press().set(src.raw_press());
                        dst.raw_temp().set(src.raw_temp());
                        dst.gyro_cal_x().set(src.gyro_cal_x());
                        dst.gyro_cal_y().set(src.gyro_cal_y());
                        dst.gyro_cal_z().set(src.gyro_cal_z());
                        dst.accel_cal_x().set(src.accel_cal_x());
                        dst.accel_cal_y().set(src.accel_cal_y());
                        dst.accel_cal_z().set(src.accel_cal_z());
                    }
                }

                /**
*WIP: Information about a storage medium. */

                pub mod STORAGE_INFORMATION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::STORAGE_INFORMATION) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc2018 {
                            crate::util_::Item__ad_hoc2018(self.0)
                        }
                        pub fn storage_id(&mut self) -> crate::util_::Item__ad_hoc2019 {
                            crate::util_::Item__ad_hoc2019(self.0)
                        }
                        pub fn storage_count(&mut self) -> crate::util_::Item__ad_hoc2020 {
                            crate::util_::Item__ad_hoc2020(self.0)
                        }
                        pub fn status(&mut self) -> crate::util_::Item__ad_hoc2021 {
                            crate::util_::Item__ad_hoc2021(self.0)
                        }
                        pub fn total_capacity(&mut self) -> crate::util_::Item__ad_hoc2022 {
                            crate::util_::Item__ad_hoc2022(self.0)
                        }
                        pub fn used_capacity(&mut self) -> crate::util_::Item__ad_hoc2023 {
                            crate::util_::Item__ad_hoc2023(self.0)
                        }
                        pub fn available_capacity(&mut self) -> crate::util_::Item__ad_hoc2024 {
                            crate::util_::Item__ad_hoc2024(self.0)
                        }
                        pub fn read_speed(&mut self) -> crate::util_::Item__ad_hoc2025 {
                            crate::util_::Item__ad_hoc2025(self.0)
                        }
                        pub fn write_speed(&mut self) -> crate::util_::Item__ad_hoc2026 {
                            crate::util_::Item__ad_hoc2026(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.storage_id(src.storage_id().get());
                        dst.storage_count(src.storage_count().get());
                        dst.status(src.status().get());
                        dst.total_capacity(src.total_capacity().get());
                        dst.used_capacity(src.used_capacity().get());
                        dst.available_capacity(src.available_capacity().get());
                        dst.read_speed(src.read_speed().get());
                        dst.write_speed(src.write_speed().get());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn storage_id(&mut self, src: i8);
                        fn storage_count(&mut self, src: i8);
                        fn status(&mut self, src: i8);
                        fn total_capacity(&mut self, src: f32);
                        fn used_capacity(&mut self, src: f32);
                        fn available_capacity(&mut self, src: f32);
                        fn read_speed(&mut self, src: f32);
                        fn write_speed(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn storage_id(&mut self) -> i8;
                        fn storage_count(&mut self) -> i8;
                        fn status(&mut self) -> i8;
                        fn total_capacity(&mut self) -> f32;
                        fn used_capacity(&mut self) -> f32;
                        fn available_capacity(&mut self) -> f32;
                        fn read_speed(&mut self) -> f32;
                        fn write_speed(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.storage_id().set(src.storage_id());
                        dst.storage_count().set(src.storage_count());
                        dst.status().set(src.status());
                        dst.total_capacity().set(src.total_capacity());
                        dst.used_capacity().set(src.used_capacity());
                        dst.available_capacity().set(src.available_capacity());
                        dst.read_speed().set(src.read_speed());
                        dst.write_speed().set(src.write_speed());
                    }
                }

                /**
*WIP: Information about a camera */

                pub mod CAMERA_INFORMATION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::CAMERA_INFORMATION) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn resolution_h(&mut self) -> crate::util_::Item__ad_hoc2012 {
                            crate::util_::Item__ad_hoc2012(self.0)
                        }
                        pub fn resolution_v(&mut self) -> crate::util_::Item__ad_hoc2013 {
                            crate::util_::Item__ad_hoc2013(self.0)
                        }
                        pub fn cam_definition_version(&mut self) -> crate::util_::Item__ad_hoc2015 {
                            crate::util_::Item__ad_hoc2015(self.0)
                        }
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc2005 {
                            crate::util_::Item__ad_hoc2005(self.0)
                        }
                        pub fn firmware_version(&mut self) -> crate::util_::Item__ad_hoc2008 {
                            crate::util_::Item__ad_hoc2008(self.0)
                        }
                        pub fn vendor_name(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2006 {
                            let dst = &mut self.0;

                            let len = 32 as usize;
                            let offset = 14;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc2006 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn model_name(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2007 {
                            let dst = &mut self.0;

                            let len = 32 as usize;
                            let offset = 46;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc2007 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn focal_length(&mut self) -> crate::util_::Item__ad_hoc2009 {
                            crate::util_::Item__ad_hoc2009(self.0)
                        }
                        pub fn sensor_size_h(&mut self) -> crate::util_::Item__ad_hoc2010 {
                            crate::util_::Item__ad_hoc2010(self.0)
                        }
                        pub fn sensor_size_v(&mut self) -> crate::util_::Item__ad_hoc2011 {
                            crate::util_::Item__ad_hoc2011(self.0)
                        }
                        pub fn lens_id(&mut self) -> crate::util_::Item__ad_hoc2014 {
                            crate::util_::Item__ad_hoc2014(self.0)
                        }
                        pub fn flags(&mut self) -> crate::util_::Item__ad_hoc342 {
                            crate::util_::Item__ad_hoc342(self.0)
                        }
                        pub fn cam_definition_uri(&mut self) -> crate::util_::Item__ad_hoc2016 {
                            crate::util_::Item__ad_hoc2016(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.resolution_h(src.resolution_h().get());
                        dst.resolution_v(src.resolution_v().get());
                        dst.cam_definition_version(src.cam_definition_version().get());
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.firmware_version(src.firmware_version().get());
                        dst.vendor_name(&mut src.vendor_name(None));
                        dst.model_name(&mut src.model_name(None));
                        dst.focal_length(src.focal_length().get());
                        dst.sensor_size_h(src.sensor_size_h().get());
                        dst.sensor_size_v(src.sensor_size_v().get());
                        dst.lens_id(src.lens_id().get());
                        if let Some(src) = src.flags().get() {
                            dst.flags(src);
                        }
                        if let Some(src) = src.cam_definition_uri().get() {
                            dst.cam_definition_uri(src);
                        }
                    }

                    pub trait DST_ {
                        fn resolution_h(&mut self, src: i16);
                        fn resolution_v(&mut self, src: i16);
                        fn cam_definition_version(&mut self, src: i16);
                        fn time_boot_ms(&mut self, src: i32);
                        fn firmware_version(&mut self, src: i32);
                        fn vendor_name(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2006);
                        fn model_name(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2007);
                        fn focal_length(&mut self, src: f32);
                        fn sensor_size_h(&mut self, src: f32);
                        fn sensor_size_v(&mut self, src: f32);
                        fn lens_id(&mut self, src: i8);
                        fn flags(&mut self, src: packs::CAMERA_CAP_FLAGS);
                        fn cam_definition_uri(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn resolution_h(&mut self) -> i16;
                        fn resolution_v(&mut self) -> i16;
                        fn cam_definition_version(&mut self) -> i16;
                        fn time_boot_ms(&mut self) -> i32;
                        fn firmware_version(&mut self) -> i32;
                        fn vendor_name(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2006);
                        fn model_name(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2007);
                        fn focal_length(&mut self) -> f32;
                        fn sensor_size_h(&mut self) -> f32;
                        fn sensor_size_v(&mut self) -> f32;
                        fn lens_id(&mut self) -> i8;
                        fn flags(&mut self) -> Option<packs::CAMERA_CAP_FLAGS>;
                        fn cam_definition_uri_item_exists_(&mut self) -> usize;
                        fn cam_definition_uri(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.resolution_h().set(src.resolution_h());
                        dst.resolution_v().set(src.resolution_v());
                        dst.cam_definition_version().set(src.cam_definition_version());
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.firmware_version().set(src.firmware_version());
                        src.vendor_name(&mut dst.vendor_name(None));
                        src.model_name(&mut dst.model_name(None));
                        dst.focal_length().set(src.focal_length());
                        dst.sensor_size_h().set(src.sensor_size_h());
                        dst.sensor_size_v().set(src.sensor_size_v());
                        dst.lens_id().set(src.lens_id());
                        if let Some(src) = src.flags() {
                            dst.flags().set(src);
                        }
                        let len = src.cam_definition_uri_item_exists_();
                        if 0 < len {
                            dst.0.set_field(731, len as i32);

                            src.cam_definition_uri(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod vendor_name {
                        pub const len: usize = 32usize;
                    }

                    pub mod model_name {
                        pub const len: usize = 32usize;
                    }

                    pub mod cam_definition_uri {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*The positioning status, as reported by GPS. This message is intended to display status information about
*				 each satellite visible to the receiver. See message GLOBAL_POSITION for the global position estimate.
*				 This message can contain information for up to 20 satellites */

                pub mod GPS_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GPS_STATUS) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn satellites_visible(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn satellite_prn(&mut self) -> crate::util_::ItemArray__ad_hoc1035 {
                            let src = self.0;

                            let len = 20 as usize;
                            let offset = 1;
                            let bytes = src;
                            crate::util_::ItemArray__ad_hoc1035 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                        pub fn satellite_used(&mut self) -> crate::util_::ItemArray__ad_hoc1036 {
                            let src = self.0;

                            let len = 20 as usize;
                            let offset = 21;
                            let bytes = src;
                            crate::util_::ItemArray__ad_hoc1036 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                        pub fn satellite_elevation(&mut self) -> crate::util_::ItemArray__ad_hoc1037 {
                            let src = self.0;

                            let len = 20 as usize;
                            let offset = 41;
                            let bytes = src;
                            crate::util_::ItemArray__ad_hoc1037 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                        pub fn satellite_azimuth(&mut self) -> crate::util_::ItemArray__ad_hoc1038 {
                            let src = self.0;

                            let len = 20 as usize;
                            let offset = 61;
                            let bytes = src;
                            crate::util_::ItemArray__ad_hoc1038 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                        pub fn satellite_snr(&mut self) -> crate::util_::ItemArray__ad_hoc1039 {
                            let src = self.0;

                            let len = 20 as usize;
                            let offset = 81;
                            let bytes = src;
                            crate::util_::ItemArray__ad_hoc1039 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.satellites_visible(src.satellites_visible());
                        dst.satellite_prn(&mut src.satellite_prn());
                        dst.satellite_used(&mut src.satellite_used());
                        dst.satellite_elevation(&mut src.satellite_elevation());
                        dst.satellite_azimuth(&mut src.satellite_azimuth());
                        dst.satellite_snr(&mut src.satellite_snr());
                    }

                    pub trait DST_ {
                        fn satellites_visible(&mut self, src: i8);
                        fn satellite_prn(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1035);
                        fn satellite_used(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1036);
                        fn satellite_elevation(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1037);
                        fn satellite_azimuth(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1038);
                        fn satellite_snr(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1039);
                    }

                    pub mod satellite_prn {
                        pub const len: usize = 20usize;
                    }

                    pub mod satellite_used {
                        pub const len: usize = 20usize;
                    }

                    pub mod satellite_elevation {
                        pub const len: usize = 20usize;
                    }

                    pub mod satellite_azimuth {
                        pub const len: usize = 20usize;
                    }

                    pub mod satellite_snr {
                        pub const len: usize = 20usize;
                    }
                }

                /**
*Write registers reply */

                pub mod DEVICE_OP_WRITE_REPLY {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DEVICE_OP_WRITE_REPLY) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn request_id(&mut self) -> crate::util_::Item__ad_hoc2431 {
                            crate::util_::Item__ad_hoc2431(self.0)
                        }
                        pub fn result(&mut self) -> crate::util_::Item__ad_hoc2432 {
                            crate::util_::Item__ad_hoc2432(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.request_id(src.request_id().get());
                        dst.result(src.result().get());
                    }

                    pub trait DST_ {
                        fn request_id(&mut self, src: i32);
                        fn result(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn request_id(&mut self) -> i32;
                        fn result(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.request_id().set(src.request_id());
                        dst.result().set(src.result());
                    }
                }

                /**
*Set a parameter value TEMPORARILY to RAM. It will be reset to default on system reboot. Send the ACTION
*				 MAV_ACTION_STORAGE_WRITE to PERMANENTLY write the RAM contents to EEPROM. IMPORTANT: The receiving component
*				 should acknowledge the new parameter value by sending a param_value message to all communication partners.
*				 This will also ensure that multiple GCS all have an up-to-date list of all parameters. If the sending
*				 GCS did not receive a PARAM_VALUE message within its timeout time, it should re-send the PARAM_SET message */

                pub mod PARAM_SET {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PARAM_SET) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn param_value(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 2, 4usize) as u32)
                        }

                        pub fn param_id(&mut self) -> Option<&str> {
                            let src = &mut self.0;
                            if src.base.field_bit != 50 && !src.set_field(50, -1) { return None; }
                            Some(src.get_str())
                        }
                        pub fn param_type(&mut self) -> Option<packs::MAV_PARAM_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 51 && !src.set_field(51, -1) { return None; }

                            Some({ packs::MAV_PARAM_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.param_value(src.param_value());
                        if let Some(src) = src.param_id() {
                            dst.param_id(src);
                        }
                        if let Some(src) = src.param_type() {
                            dst.param_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn param_value(&mut self, src: f32);
                        fn param_id(&mut self, src: &str);
                        fn param_type(&mut self, src: packs::MAV_PARAM_TYPE);
                    }

                    pub mod param_id {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUES */

                pub mod TERRAIN_DATA {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::TERRAIN_DATA) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn grid_spacing(&mut self) -> crate::util_::Item__ad_hoc1763 {
                            crate::util_::Item__ad_hoc1763(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc1761 {
                            crate::util_::Item__ad_hoc1761(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc1762 {
                            crate::util_::Item__ad_hoc1762(self.0)
                        }
                        pub fn gridbit(&mut self) -> crate::util_::Item__ad_hoc1764 {
                            crate::util_::Item__ad_hoc1764(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i16>>) -> crate::util_::ItemArray__ad_hoc1765 {
                            let dst = self.0;

                            let len = 16 as usize;
                            let offset = 11;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1765 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.grid_spacing(src.grid_spacing().get());
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                        dst.gridbit(src.gridbit().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn grid_spacing(&mut self, src: i16);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn gridbit(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1765);
                    }

                    pub trait SRC_ {
                        fn grid_spacing(&mut self) -> i16;
                        fn lat(&mut self) -> i32;
                        fn lon(&mut self) -> i32;
                        fn gridbit(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1765);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.grid_spacing().set(src.grid_spacing());
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                        dst.gridbit().set(src.gridbit());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 16usize;
                    }
                }

                /**
*Control message for rate gimbal */

                pub mod GIMBAL_CONTROL {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GIMBAL_CONTROL) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2391 {
                            crate::util_::Item__ad_hoc2391(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2392 {
                            crate::util_::Item__ad_hoc2392(self.0)
                        }
                        pub fn demanded_rate_x(&mut self) -> crate::util_::Item__ad_hoc2393 {
                            crate::util_::Item__ad_hoc2393(self.0)
                        }
                        pub fn demanded_rate_y(&mut self) -> crate::util_::Item__ad_hoc2394 {
                            crate::util_::Item__ad_hoc2394(self.0)
                        }
                        pub fn demanded_rate_z(&mut self) -> crate::util_::Item__ad_hoc2395 {
                            crate::util_::Item__ad_hoc2395(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.demanded_rate_x(src.demanded_rate_x().get());
                        dst.demanded_rate_y(src.demanded_rate_y().get());
                        dst.demanded_rate_z(src.demanded_rate_z().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn demanded_rate_x(&mut self, src: f32);
                        fn demanded_rate_y(&mut self, src: f32);
                        fn demanded_rate_z(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn demanded_rate_x(&mut self) -> f32;
                        fn demanded_rate_y(&mut self) -> f32;
                        fn demanded_rate_z(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.demanded_rate_x().set(src.demanded_rate_x());
                        dst.demanded_rate_y().set(src.demanded_rate_y());
                        dst.demanded_rate_z().set(src.demanded_rate_z());
                    }
                }

                /**
*The RAW values of the RC channels sent to the MAV to override info received from the RC radio. A value
*				 of UINT16_MAX means no change to that channel. A value of 0 means control of that channel should be released
*				 back to the RC radio. The standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds:
*				 100%. Individual receivers/transmitters might violate this specification */

                pub mod RC_CHANNELS_OVERRIDE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RC_CHANNELS_OVERRIDE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn chan1_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan2_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 2, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan3_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 4, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan4_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 6, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan5_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 8, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan6_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 10, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan7_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 12, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan8_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 14, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 16, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 17, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.chan1_raw(src.chan1_raw());
                        dst.chan2_raw(src.chan2_raw());
                        dst.chan3_raw(src.chan3_raw());
                        dst.chan4_raw(src.chan4_raw());
                        dst.chan5_raw(src.chan5_raw());
                        dst.chan6_raw(src.chan6_raw());
                        dst.chan7_raw(src.chan7_raw());
                        dst.chan8_raw(src.chan8_raw());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                    }

                    pub trait DST_ {
                        fn chan1_raw(&mut self, src: i16);
                        fn chan2_raw(&mut self, src: i16);
                        fn chan3_raw(&mut self, src: i16);
                        fn chan4_raw(&mut self, src: i16);
                        fn chan5_raw(&mut self, src: i16);
                        fn chan6_raw(&mut self, src: i16);
                        fn chan7_raw(&mut self, src: i16);
                        fn chan8_raw(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }
                }

                /**
*The RAW IMU readings for the usual 9DOF sensor setup. This message should contain the scaled values to
*				 the described unit */

                pub mod SCALED_IMU {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SCALED_IMU) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn xacc(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 4, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn yacc(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 6, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn zacc(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 8, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn xgyro(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 10, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn ygyro(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 12, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn zgyro(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 14, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn xmag(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 16, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn ymag(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 18, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn zmag(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 20, 2 as usize) as i16;
                            (dst) as i16
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.xacc(src.xacc());
                        dst.yacc(src.yacc());
                        dst.zacc(src.zacc());
                        dst.xgyro(src.xgyro());
                        dst.ygyro(src.ygyro());
                        dst.zgyro(src.zgyro());
                        dst.xmag(src.xmag());
                        dst.ymag(src.ymag());
                        dst.zmag(src.zmag());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn xacc(&mut self, src: i16);
                        fn yacc(&mut self, src: i16);
                        fn zacc(&mut self, src: i16);
                        fn xgyro(&mut self, src: i16);
                        fn ygyro(&mut self, src: i16);
                        fn zgyro(&mut self, src: i16);
                        fn xmag(&mut self, src: i16);
                        fn ymag(&mut self, src: i16);
                        fn zmag(&mut self, src: i16);
                    }
                }

                /**
*WIP: Information about video stream */

                pub mod VIDEO_STREAM_INFORMATION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::VIDEO_STREAM_INFORMATION) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn resolution_h(&mut self) -> crate::util_::Item__ad_hoc2070 {
                            crate::util_::Item__ad_hoc2070(self.0)
                        }
                        pub fn resolution_v(&mut self) -> crate::util_::Item__ad_hoc2071 {
                            crate::util_::Item__ad_hoc2071(self.0)
                        }
                        pub fn rotation(&mut self) -> crate::util_::Item__ad_hoc2073 {
                            crate::util_::Item__ad_hoc2073(self.0)
                        }
                        pub fn bitrate(&mut self) -> crate::util_::Item__ad_hoc2072 {
                            crate::util_::Item__ad_hoc2072(self.0)
                        }
                        pub fn camera_id(&mut self) -> crate::util_::Item__ad_hoc2067 {
                            crate::util_::Item__ad_hoc2067(self.0)
                        }
                        pub fn status(&mut self) -> crate::util_::Item__ad_hoc2068 {
                            crate::util_::Item__ad_hoc2068(self.0)
                        }
                        pub fn framerate(&mut self) -> crate::util_::Item__ad_hoc2069 {
                            crate::util_::Item__ad_hoc2069(self.0)
                        }
                        pub fn uri(&mut self) -> crate::util_::Item__ad_hoc2074 {
                            crate::util_::Item__ad_hoc2074(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.resolution_h(src.resolution_h().get());
                        dst.resolution_v(src.resolution_v().get());
                        dst.rotation(src.rotation().get());
                        dst.bitrate(src.bitrate().get());
                        dst.camera_id(src.camera_id().get());
                        dst.status(src.status().get());
                        dst.framerate(src.framerate().get());
                        if let Some(src) = src.uri().get() {
                            dst.uri(src);
                        }
                    }

                    pub trait DST_ {
                        fn resolution_h(&mut self, src: i16);
                        fn resolution_v(&mut self, src: i16);
                        fn rotation(&mut self, src: i16);
                        fn bitrate(&mut self, src: i32);
                        fn camera_id(&mut self, src: i8);
                        fn status(&mut self, src: i8);
                        fn framerate(&mut self, src: f32);
                        fn uri(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn resolution_h(&mut self) -> i16;
                        fn resolution_v(&mut self) -> i16;
                        fn rotation(&mut self) -> i16;
                        fn bitrate(&mut self) -> i32;
                        fn camera_id(&mut self) -> i8;
                        fn status(&mut self) -> i8;
                        fn framerate(&mut self) -> f32;
                        fn uri_item_exists_(&mut self) -> usize;
                        fn uri(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.resolution_h().set(src.resolution_h());
                        dst.resolution_v().set(src.resolution_v());
                        dst.rotation().set(src.rotation());
                        dst.bitrate().set(src.bitrate());
                        dst.camera_id().set(src.camera_id());
                        dst.status().set(src.status());
                        dst.framerate().set(src.framerate());
                        let len = src.uri_item_exists_();
                        if 0 < len {
                            dst.0.set_field(130, len as i32);

                            src.uri(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod uri {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Status of DCM attitude estimator */

                pub mod AHRS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::AHRS) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn omegaIx(&mut self) -> crate::util_::Item__ad_hoc2216 {
                            crate::util_::Item__ad_hoc2216(self.0)
                        }
                        pub fn omegaIy(&mut self) -> crate::util_::Item__ad_hoc2217 {
                            crate::util_::Item__ad_hoc2217(self.0)
                        }
                        pub fn omegaIz(&mut self) -> crate::util_::Item__ad_hoc2218 {
                            crate::util_::Item__ad_hoc2218(self.0)
                        }
                        pub fn accel_weight(&mut self) -> crate::util_::Item__ad_hoc2219 {
                            crate::util_::Item__ad_hoc2219(self.0)
                        }
                        pub fn renorm_val(&mut self) -> crate::util_::Item__ad_hoc2220 {
                            crate::util_::Item__ad_hoc2220(self.0)
                        }
                        pub fn error_rp(&mut self) -> crate::util_::Item__ad_hoc2221 {
                            crate::util_::Item__ad_hoc2221(self.0)
                        }
                        pub fn error_yaw(&mut self) -> crate::util_::Item__ad_hoc2222 {
                            crate::util_::Item__ad_hoc2222(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.omegaIx(src.omegaIx().get());
                        dst.omegaIy(src.omegaIy().get());
                        dst.omegaIz(src.omegaIz().get());
                        dst.accel_weight(src.accel_weight().get());
                        dst.renorm_val(src.renorm_val().get());
                        dst.error_rp(src.error_rp().get());
                        dst.error_yaw(src.error_yaw().get());
                    }

                    pub trait DST_ {
                        fn omegaIx(&mut self, src: f32);
                        fn omegaIy(&mut self, src: f32);
                        fn omegaIz(&mut self, src: f32);
                        fn accel_weight(&mut self, src: f32);
                        fn renorm_val(&mut self, src: f32);
                        fn error_rp(&mut self, src: f32);
                        fn error_yaw(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn omegaIx(&mut self) -> f32;
                        fn omegaIy(&mut self) -> f32;
                        fn omegaIz(&mut self) -> f32;
                        fn accel_weight(&mut self) -> f32;
                        fn renorm_val(&mut self) -> f32;
                        fn error_rp(&mut self) -> f32;
                        fn error_yaw(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.omegaIx().set(src.omegaIx());
                        dst.omegaIy().set(src.omegaIy());
                        dst.omegaIz().set(src.omegaIz());
                        dst.accel_weight().set(src.accel_weight());
                        dst.renorm_val().set(src.renorm_val());
                        dst.error_rp().set(src.error_rp());
                        dst.error_yaw().set(src.error_yaw());
                    }
                }

                /**
*Send a debug value. The index is used to discriminate between values. These values show up in the plot
*				 of QGroundControl as DEBUG N */

                pub mod DEBUG {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DEBUG) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc1992 {
                            crate::util_::Item__ad_hoc1992(self.0)
                        }
                        pub fn ind(&mut self) -> crate::util_::Item__ad_hoc1993 {
                            crate::util_::Item__ad_hoc1993(self.0)
                        }
                        pub fn value(&mut self) -> crate::util_::Item__ad_hoc1994 {
                            crate::util_::Item__ad_hoc1994(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.ind(src.ind().get());
                        dst.value(src.value().get());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn ind(&mut self, src: i8);
                        fn value(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn ind(&mut self) -> i8;
                        fn value(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.ind().set(src.ind());
                        dst.value().set(src.value());
                    }
                }

                /**
*Information about a captured image */

                pub mod CAMERA_IMAGE_CAPTURED {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::CAMERA_IMAGE_CAPTURED) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc2033 {
                            crate::util_::Item__ad_hoc2033(self.0)
                        }
                        pub fn time_utc(&mut self) -> crate::util_::Item__ad_hoc2034 {
                            crate::util_::Item__ad_hoc2034(self.0)
                        }
                        pub fn camera_id(&mut self) -> crate::util_::Item__ad_hoc2035 {
                            crate::util_::Item__ad_hoc2035(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc2036 {
                            crate::util_::Item__ad_hoc2036(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc2037 {
                            crate::util_::Item__ad_hoc2037(self.0)
                        }
                        pub fn alt(&mut self) -> crate::util_::Item__ad_hoc2038 {
                            crate::util_::Item__ad_hoc2038(self.0)
                        }
                        pub fn relative_alt(&mut self) -> crate::util_::Item__ad_hoc2039 {
                            crate::util_::Item__ad_hoc2039(self.0)
                        }
                        pub fn q(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc2040 {
                            let dst = &mut self.0;

                            let len = 4 as usize;
                            let offset = 29;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc2040 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn image_index(&mut self) -> crate::util_::Item__ad_hoc2041 {
                            crate::util_::Item__ad_hoc2041(self.0)
                        }
                        pub fn capture_result(&mut self) -> crate::util_::Item__ad_hoc2042 {
                            crate::util_::Item__ad_hoc2042(self.0)
                        }
                        pub fn file_url(&mut self) -> crate::util_::Item__ad_hoc2043 {
                            crate::util_::Item__ad_hoc2043(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.time_utc(src.time_utc().get());
                        dst.camera_id(src.camera_id().get());
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                        dst.alt(src.alt().get());
                        dst.relative_alt(src.relative_alt().get());
                        dst.q(&mut src.q(None));
                        dst.image_index(src.image_index().get());
                        dst.capture_result(src.capture_result().get());
                        if let Some(src) = src.file_url().get() {
                            dst.file_url(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn time_utc(&mut self, src: i64);
                        fn camera_id(&mut self, src: i8);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn alt(&mut self, src: i32);
                        fn relative_alt(&mut self, src: i32);
                        fn q(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2040);
                        fn image_index(&mut self, src: i32);
                        fn capture_result(&mut self, src: i8);
                        fn file_url(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn time_utc(&mut self) -> i64;
                        fn camera_id(&mut self) -> i8;
                        fn lat(&mut self) -> i32;
                        fn lon(&mut self) -> i32;
                        fn alt(&mut self) -> i32;
                        fn relative_alt(&mut self) -> i32;
                        fn q(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2040);
                        fn image_index(&mut self) -> i32;
                        fn capture_result(&mut self) -> i8;
                        fn file_url_item_exists_(&mut self) -> usize;
                        fn file_url(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.time_utc().set(src.time_utc());
                        dst.camera_id().set(src.camera_id());
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                        dst.alt().set(src.alt());
                        dst.relative_alt().set(src.relative_alt());
                        src.q(&mut dst.q(None));
                        dst.image_index().set(src.image_index());
                        dst.capture_result().set(src.capture_result());
                        let len = src.file_url_item_exists_();
                        if 0 < len {
                            dst.0.set_field(402, len as i32);

                            src.file_url(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod q {
                        pub const len: usize = 4usize;
                    }

                    pub mod file_url {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Reply to LOG_REQUEST_LIST */

                pub mod LOG_ENTRY {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOG_ENTRY) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn id(&mut self) -> crate::util_::Item__ad_hoc1667 {
                            crate::util_::Item__ad_hoc1667(self.0)
                        }
                        pub fn num_logs(&mut self) -> crate::util_::Item__ad_hoc1668 {
                            crate::util_::Item__ad_hoc1668(self.0)
                        }
                        pub fn last_log_num(&mut self) -> crate::util_::Item__ad_hoc1669 {
                            crate::util_::Item__ad_hoc1669(self.0)
                        }
                        pub fn time_utc(&mut self) -> crate::util_::Item__ad_hoc1670 {
                            crate::util_::Item__ad_hoc1670(self.0)
                        }
                        pub fn size(&mut self) -> crate::util_::Item__ad_hoc1671 {
                            crate::util_::Item__ad_hoc1671(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.id(src.id().get());
                        dst.num_logs(src.num_logs().get());
                        dst.last_log_num(src.last_log_num().get());
                        dst.time_utc(src.time_utc().get());
                        dst.size(src.size().get());
                    }

                    pub trait DST_ {
                        fn id(&mut self, src: i16);
                        fn num_logs(&mut self, src: i16);
                        fn last_log_num(&mut self, src: i16);
                        fn time_utc(&mut self, src: i32);
                        fn size(&mut self, src: i32);
                    }

                    pub trait SRC_ {
                        fn id(&mut self) -> i16;
                        fn num_logs(&mut self) -> i16;
                        fn last_log_num(&mut self) -> i16;
                        fn time_utc(&mut self) -> i32;
                        fn size(&mut self) -> i32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.id().set(src.id());
                        dst.num_logs().set(src.num_logs());
                        dst.last_log_num().set(src.last_log_num());
                        dst.time_utc().set(src.time_utc());
                        dst.size().set(src.size());
                    }
                }

                /**
*Set the vehicle attitude and body angular rates. */

                pub mod ACTUATOR_CONTROL_TARGET {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::ACTUATOR_CONTROL_TARGET) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1789 {
                            crate::util_::Item__ad_hoc1789(self.0)
                        }
                        pub fn group_mlx(&mut self) -> crate::util_::Item__ad_hoc1790 {
                            crate::util_::Item__ad_hoc1790(self.0)
                        }
                        pub fn controls(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1791 {
                            let dst = self.0;

                            let len = 8 as usize;
                            let offset = 9;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1791 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec().get());
                        dst.group_mlx(src.group_mlx().get());
                        dst.controls(&mut src.controls(None));
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn group_mlx(&mut self, src: i8);
                        fn controls(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1791);
                    }

                    pub trait SRC_ {
                        fn time_usec(&mut self) -> i64;
                        fn group_mlx(&mut self) -> i8;
                        fn controls(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1791);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_usec().set(src.time_usec());
                        dst.group_mlx().set(src.group_mlx());
                        src.controls(&mut dst.controls(None));
                    }

                    pub mod controls {
                        pub const len: usize = 8usize;
                    }
                }

                /**
*Message appropriate for high latency connections like Iridium */

                pub mod HIGH_LATENCY {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HIGH_LATENCY) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn heading(&mut self) -> crate::util_::Item__ad_hoc1907 {
                            crate::util_::Item__ad_hoc1907(self.0)
                        }
                        pub fn wp_distance(&mut self) -> crate::util_::Item__ad_hoc1924 {
                            crate::util_::Item__ad_hoc1924(self.0)
                        }
                        pub fn custom_mode(&mut self) -> crate::util_::Item__ad_hoc1904 {
                            crate::util_::Item__ad_hoc1904(self.0)
                        }
                        pub fn roll(&mut self) -> crate::util_::Item__ad_hoc1905 {
                            crate::util_::Item__ad_hoc1905(self.0)
                        }
                        pub fn pitch(&mut self) -> crate::util_::Item__ad_hoc1906 {
                            crate::util_::Item__ad_hoc1906(self.0)
                        }
                        pub fn throttle(&mut self) -> crate::util_::Item__ad_hoc1908 {
                            crate::util_::Item__ad_hoc1908(self.0)
                        }
                        pub fn heading_sp(&mut self) -> crate::util_::Item__ad_hoc1909 {
                            crate::util_::Item__ad_hoc1909(self.0)
                        }
                        pub fn latitude(&mut self) -> crate::util_::Item__ad_hoc1910 {
                            crate::util_::Item__ad_hoc1910(self.0)
                        }
                        pub fn longitude(&mut self) -> crate::util_::Item__ad_hoc1911 {
                            crate::util_::Item__ad_hoc1911(self.0)
                        }
                        pub fn altitude_amsl(&mut self) -> crate::util_::Item__ad_hoc1912 {
                            crate::util_::Item__ad_hoc1912(self.0)
                        }
                        pub fn altitude_sp(&mut self) -> crate::util_::Item__ad_hoc1913 {
                            crate::util_::Item__ad_hoc1913(self.0)
                        }
                        pub fn airspeed(&mut self) -> crate::util_::Item__ad_hoc1914 {
                            crate::util_::Item__ad_hoc1914(self.0)
                        }
                        pub fn airspeed_sp(&mut self) -> crate::util_::Item__ad_hoc1915 {
                            crate::util_::Item__ad_hoc1915(self.0)
                        }
                        pub fn groundspeed(&mut self) -> crate::util_::Item__ad_hoc1916 {
                            crate::util_::Item__ad_hoc1916(self.0)
                        }
                        pub fn climb_rate(&mut self) -> crate::util_::Item__ad_hoc1917 {
                            crate::util_::Item__ad_hoc1917(self.0)
                        }
                        pub fn gps_nsat(&mut self) -> crate::util_::Item__ad_hoc1918 {
                            crate::util_::Item__ad_hoc1918(self.0)
                        }
                        pub fn battery_remaining(&mut self) -> crate::util_::Item__ad_hoc1919 {
                            crate::util_::Item__ad_hoc1919(self.0)
                        }
                        pub fn temperature(&mut self) -> crate::util_::Item__ad_hoc1920 {
                            crate::util_::Item__ad_hoc1920(self.0)
                        }
                        pub fn temperature_air(&mut self) -> crate::util_::Item__ad_hoc1921 {
                            crate::util_::Item__ad_hoc1921(self.0)
                        }
                        pub fn failsafe(&mut self) -> crate::util_::Item__ad_hoc1922 {
                            crate::util_::Item__ad_hoc1922(self.0)
                        }
                        pub fn wp_num(&mut self) -> crate::util_::Item__ad_hoc1923 {
                            crate::util_::Item__ad_hoc1923(self.0)
                        }
                        pub fn base_mode(&mut self) -> crate::util_::Item__ad_hoc213 {
                            crate::util_::Item__ad_hoc213(self.0)
                        }
                        pub fn landed_state(&mut self) -> crate::util_::Item__ad_hoc215 {
                            crate::util_::Item__ad_hoc215(self.0)
                        }
                        pub fn gps_fix_type(&mut self) -> crate::util_::Item__ad_hoc214 {
                            crate::util_::Item__ad_hoc214(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.heading(src.heading().get());
                        dst.wp_distance(src.wp_distance().get());
                        dst.custom_mode(src.custom_mode().get());
                        dst.roll(src.roll().get());
                        dst.pitch(src.pitch().get());
                        dst.throttle(src.throttle().get());
                        dst.heading_sp(src.heading_sp().get());
                        dst.latitude(src.latitude().get());
                        dst.longitude(src.longitude().get());
                        dst.altitude_amsl(src.altitude_amsl().get());
                        dst.altitude_sp(src.altitude_sp().get());
                        dst.airspeed(src.airspeed().get());
                        dst.airspeed_sp(src.airspeed_sp().get());
                        dst.groundspeed(src.groundspeed().get());
                        dst.climb_rate(src.climb_rate().get());
                        dst.gps_nsat(src.gps_nsat().get());
                        dst.battery_remaining(src.battery_remaining().get());
                        dst.temperature(src.temperature().get());
                        dst.temperature_air(src.temperature_air().get());
                        dst.failsafe(src.failsafe().get());
                        dst.wp_num(src.wp_num().get());
                        if let Some(src) = src.base_mode().get() {
                            dst.base_mode(src);
                        }
                        if let Some(src) = src.landed_state().get() {
                            dst.landed_state(src);
                        }
                        if let Some(src) = src.gps_fix_type().get() {
                            dst.gps_fix_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn heading(&mut self, src: i16);
                        fn wp_distance(&mut self, src: i16);
                        fn custom_mode(&mut self, src: i32);
                        fn roll(&mut self, src: i16);
                        fn pitch(&mut self, src: i16);
                        fn throttle(&mut self, src: i8);
                        fn heading_sp(&mut self, src: i16);
                        fn latitude(&mut self, src: i32);
                        fn longitude(&mut self, src: i32);
                        fn altitude_amsl(&mut self, src: i16);
                        fn altitude_sp(&mut self, src: i16);
                        fn airspeed(&mut self, src: i8);
                        fn airspeed_sp(&mut self, src: i8);
                        fn groundspeed(&mut self, src: i8);
                        fn climb_rate(&mut self, src: i8);
                        fn gps_nsat(&mut self, src: i8);
                        fn battery_remaining(&mut self, src: i8);
                        fn temperature(&mut self, src: i8);
                        fn temperature_air(&mut self, src: i8);
                        fn failsafe(&mut self, src: i8);
                        fn wp_num(&mut self, src: i8);
                        fn base_mode(&mut self, src: packs::MAV_MODE_FLAG);
                        fn landed_state(&mut self, src: packs::MAV_LANDED_STATE);
                        fn gps_fix_type(&mut self, src: packs::GPS_FIX_TYPE);
                    }

                    pub trait SRC_ {
                        fn heading(&mut self) -> i16;
                        fn wp_distance(&mut self) -> i16;
                        fn custom_mode(&mut self) -> i32;
                        fn roll(&mut self) -> i16;
                        fn pitch(&mut self) -> i16;
                        fn throttle(&mut self) -> i8;
                        fn heading_sp(&mut self) -> i16;
                        fn latitude(&mut self) -> i32;
                        fn longitude(&mut self) -> i32;
                        fn altitude_amsl(&mut self) -> i16;
                        fn altitude_sp(&mut self) -> i16;
                        fn airspeed(&mut self) -> i8;
                        fn airspeed_sp(&mut self) -> i8;
                        fn groundspeed(&mut self) -> i8;
                        fn climb_rate(&mut self) -> i8;
                        fn gps_nsat(&mut self) -> i8;
                        fn battery_remaining(&mut self) -> i8;
                        fn temperature(&mut self) -> i8;
                        fn temperature_air(&mut self) -> i8;
                        fn failsafe(&mut self) -> i8;
                        fn wp_num(&mut self) -> i8;
                        fn base_mode(&mut self) -> Option<packs::MAV_MODE_FLAG>;
                        fn landed_state(&mut self) -> Option<packs::MAV_LANDED_STATE>;
                        fn gps_fix_type(&mut self) -> Option<packs::GPS_FIX_TYPE>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.heading().set(src.heading());
                        dst.wp_distance().set(src.wp_distance());
                        dst.custom_mode().set(src.custom_mode());
                        dst.roll().set(src.roll());
                        dst.pitch().set(src.pitch());
                        dst.throttle().set(src.throttle());
                        dst.heading_sp().set(src.heading_sp());
                        dst.latitude().set(src.latitude());
                        dst.longitude().set(src.longitude());
                        dst.altitude_amsl().set(src.altitude_amsl());
                        dst.altitude_sp().set(src.altitude_sp());
                        dst.airspeed().set(src.airspeed());
                        dst.airspeed_sp().set(src.airspeed_sp());
                        dst.groundspeed().set(src.groundspeed());
                        dst.climb_rate().set(src.climb_rate());
                        dst.gps_nsat().set(src.gps_nsat());
                        dst.battery_remaining().set(src.battery_remaining());
                        dst.temperature().set(src.temperature());
                        dst.temperature_air().set(src.temperature_air());
                        dst.failsafe().set(src.failsafe());
                        dst.wp_num().set(src.wp_num());
                        if let Some(src) = src.base_mode() {
                            dst.base_mode().set(src);
                        }
                        if let Some(src) = src.landed_state() {
                            dst.landed_state().set(src);
                        }
                        if let Some(src) = src.gps_fix_type() {
                            dst.gps_fix_type().set(src);
                        }
                    }
                }

                /**
*value[float]. This allows to send a parameter to any other component (such as the GCS) without the need
*				 of previous knowledge of possible parameter names. Thus the same GCS can store different parameters for
*				 different autopilots. See also http:qgroundcontrol.org/parameter_interface for a full documentation
*				 of QGroundControl and IMU code */

                pub mod PARAM_REQUEST_READ {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PARAM_REQUEST_READ) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn param_index(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 2 as usize) as i16;
                            (dst) as i16
                        }

                        pub fn param_id(&mut self) -> Option<&str> {
                            let src = &mut self.0;
                            if src.base.field_bit != 34 && !src.set_field(34, -1) { return None; }
                            Some(src.get_str())
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.param_index(src.param_index());
                        if let Some(src) = src.param_id() {
                            dst.param_id(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn param_index(&mut self, src: i16);
                        fn param_id(&mut self, src: &str);
                    }

                    pub mod param_id {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Sets a desired vehicle attitude. Used by an external controller to command the vehicle (manual controller
*				 or other system) */

                pub mod SET_ATTITUDE_TARGET {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SET_ATTITUDE_TARGET) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 4, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 5, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn type_mask(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 6, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn q(&mut self) -> crate::util_::ItemArray__ad_hoc1345 {
                            let src = self.0;

                            let len = 4 as usize;
                            let offset = 7;
                            let bytes = src;
                            crate::util_::ItemArray__ad_hoc1345 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                        pub fn body_roll_rate(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 23, 4usize) as u32)
                        }
                        pub fn body_pitch_rate(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 27, 4usize) as u32)
                        }
                        pub fn body_yaw_rate(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 31, 4usize) as u32)
                        }
                        pub fn thrust(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 35, 4usize) as u32)
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.type_mask(src.type_mask());
                        dst.q(&mut src.q());
                        dst.body_roll_rate(src.body_roll_rate());
                        dst.body_pitch_rate(src.body_pitch_rate());
                        dst.body_yaw_rate(src.body_yaw_rate());
                        dst.thrust(src.thrust());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn type_mask(&mut self, src: i8);
                        fn q(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1345);
                        fn body_roll_rate(&mut self, src: f32);
                        fn body_pitch_rate(&mut self, src: f32);
                        fn body_yaw_rate(&mut self, src: f32);
                        fn thrust(&mut self, src: f32);
                    }

                    pub mod q {
                        pub const len: usize = 4usize;
                    }
                }

                /**
*current motion information from a designated system */

                pub mod FOLLOW_TARGET {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::FOLLOW_TARGET) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn timestamp(&mut self) -> crate::util_::Item__ad_hoc1808 {
                            crate::util_::Item__ad_hoc1808(self.0)
                        }
                        pub fn custom_state(&mut self) -> crate::util_::Item__ad_hoc1818 {
                            crate::util_::Item__ad_hoc1818(self.0)
                        }
                        pub fn est_capabilities(&mut self) -> crate::util_::Item__ad_hoc1809 {
                            crate::util_::Item__ad_hoc1809(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc1810 {
                            crate::util_::Item__ad_hoc1810(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc1811 {
                            crate::util_::Item__ad_hoc1811(self.0)
                        }
                        pub fn alt(&mut self) -> crate::util_::Item__ad_hoc1812 {
                            crate::util_::Item__ad_hoc1812(self.0)
                        }
                        pub fn vel(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1813 {
                            let dst = self.0;

                            let len = 3 as usize;
                            let offset = 29;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1813 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn acc(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1814 {
                            let dst = self.0;

                            let len = 3 as usize;
                            let offset = 41;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1814 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn attitude_q(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1815 {
                            let dst = self.0;

                            let len = 4 as usize;
                            let offset = 53;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1815 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn rates(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1816 {
                            let dst = self.0;

                            let len = 3 as usize;
                            let offset = 69;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1816 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn position_cov(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1817 {
                            let dst = self.0;

                            let len = 3 as usize;
                            let offset = 81;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1817 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.timestamp(src.timestamp().get());
                        dst.custom_state(src.custom_state().get());
                        dst.est_capabilities(src.est_capabilities().get());
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                        dst.alt(src.alt().get());
                        dst.vel(&mut src.vel(None));
                        dst.acc(&mut src.acc(None));
                        dst.attitude_q(&mut src.attitude_q(None));
                        dst.rates(&mut src.rates(None));
                        dst.position_cov(&mut src.position_cov(None));
                    }

                    pub trait DST_ {
                        fn timestamp(&mut self, src: i64);
                        fn custom_state(&mut self, src: i64);
                        fn est_capabilities(&mut self, src: i8);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn alt(&mut self, src: f32);
                        fn vel(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1813);
                        fn acc(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1814);
                        fn attitude_q(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1815);
                        fn rates(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1816);
                        fn position_cov(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1817);
                    }

                    pub trait SRC_ {
                        fn timestamp(&mut self) -> i64;
                        fn custom_state(&mut self) -> i64;
                        fn est_capabilities(&mut self) -> i8;
                        fn lat(&mut self) -> i32;
                        fn lon(&mut self) -> i32;
                        fn alt(&mut self) -> f32;
                        fn vel(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1813);
                        fn acc(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1814);
                        fn attitude_q(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1815);
                        fn rates(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1816);
                        fn position_cov(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1817);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.timestamp().set(src.timestamp());
                        dst.custom_state().set(src.custom_state());
                        dst.est_capabilities().set(src.est_capabilities());
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                        dst.alt().set(src.alt());
                        src.vel(&mut dst.vel(None));
                        src.acc(&mut dst.acc(None));
                        src.attitude_q(&mut dst.attitude_q(None));
                        src.rates(&mut dst.rates(None));
                        src.position_cov(&mut dst.position_cov(None));
                    }

                    pub mod vel {
                        pub const len: usize = 3usize;
                    }

                    pub mod acc {
                        pub const len: usize = 3usize;
                    }

                    pub mod attitude_q {
                        pub const len: usize = 4usize;
                    }

                    pub mod rates {
                        pub const len: usize = 3usize;
                    }

                    pub mod position_cov {
                        pub const len: usize = 3usize;
                    }
                }

                /**
*DEPRECATED PACKET! Suffers from missing airspeed fields and singularities due to Euler angles. Please
*				 use HIL_STATE_QUATERNION instead. Sent from simulation to autopilot. This packet is useful for high throughput
*				 applications such as hardware in the loop simulations */

                pub mod HIL_STATE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HIL_STATE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn roll(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 8, 4usize) as u32)
                        }
                        pub fn pitch(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 12, 4usize) as u32)
                        }
                        pub fn yaw(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 16, 4usize) as u32)
                        }
                        pub fn rollspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 20, 4usize) as u32)
                        }
                        pub fn pitchspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 24, 4usize) as u32)
                        }
                        pub fn yawspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 28, 4usize) as u32)
                        }
                        pub fn lat(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 32, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn lon(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 36, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn alt(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 40, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn vx(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 44, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn vy(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 46, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn vz(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 48, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn xacc(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 50, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn yacc(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 52, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn zacc(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 54, 2 as usize) as i16;
                            (dst) as i16
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec());
                        dst.roll(src.roll());
                        dst.pitch(src.pitch());
                        dst.yaw(src.yaw());
                        dst.rollspeed(src.rollspeed());
                        dst.pitchspeed(src.pitchspeed());
                        dst.yawspeed(src.yawspeed());
                        dst.lat(src.lat());
                        dst.lon(src.lon());
                        dst.alt(src.alt());
                        dst.vx(src.vx());
                        dst.vy(src.vy());
                        dst.vz(src.vz());
                        dst.xacc(src.xacc());
                        dst.yacc(src.yacc());
                        dst.zacc(src.zacc());
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn rollspeed(&mut self, src: f32);
                        fn pitchspeed(&mut self, src: f32);
                        fn yawspeed(&mut self, src: f32);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn alt(&mut self, src: i32);
                        fn vx(&mut self, src: i16);
                        fn vy(&mut self, src: i16);
                        fn vz(&mut self, src: i16);
                        fn xacc(&mut self, src: i16);
                        fn yacc(&mut self, src: i16);
                        fn zacc(&mut self, src: i16);
                    }
                }

                /**
*This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system
*				 will return to and land on. The position is set automatically by the system during the takeoff in case
*				 it was not explicitely set by the operator before or after. The position the system will return to and
*				 land on. The global and local positions encode the position in the respective coordinate frames, while
*				 the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading
*				 and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes
*				 the point to which the system should fly in normal flight mode and then perform a landing sequence along
*				 the vector */

                pub mod HOME_POSITION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HOME_POSITION) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn latitude(&mut self) -> crate::util_::Item__ad_hoc1932 {
                            crate::util_::Item__ad_hoc1932(self.0)
                        }
                        pub fn longitude(&mut self) -> crate::util_::Item__ad_hoc1933 {
                            crate::util_::Item__ad_hoc1933(self.0)
                        }
                        pub fn altitude(&mut self) -> crate::util_::Item__ad_hoc1934 {
                            crate::util_::Item__ad_hoc1934(self.0)
                        }
                        pub fn x(&mut self) -> crate::util_::Item__ad_hoc1935 {
                            crate::util_::Item__ad_hoc1935(self.0)
                        }
                        pub fn y(&mut self) -> crate::util_::Item__ad_hoc1936 {
                            crate::util_::Item__ad_hoc1936(self.0)
                        }
                        pub fn z(&mut self) -> crate::util_::Item__ad_hoc1937 {
                            crate::util_::Item__ad_hoc1937(self.0)
                        }
                        pub fn q(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1938 {
                            let dst = &mut self.0;

                            let len = 4 as usize;
                            let offset = 24;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc1938 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn approach_x(&mut self) -> crate::util_::Item__ad_hoc1939 {
                            crate::util_::Item__ad_hoc1939(self.0)
                        }
                        pub fn approach_y(&mut self) -> crate::util_::Item__ad_hoc1940 {
                            crate::util_::Item__ad_hoc1940(self.0)
                        }
                        pub fn approach_z(&mut self) -> crate::util_::Item__ad_hoc1941 {
                            crate::util_::Item__ad_hoc1941(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1942 {
                            crate::util_::Item__ad_hoc1942(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.latitude(src.latitude().get());
                        dst.longitude(src.longitude().get());
                        dst.altitude(src.altitude().get());
                        dst.x(src.x().get());
                        dst.y(src.y().get());
                        dst.z(src.z().get());
                        dst.q(&mut src.q(None));
                        dst.approach_x(src.approach_x().get());
                        dst.approach_y(src.approach_y().get());
                        dst.approach_z(src.approach_z().get());
                        if let Some(src) = src.time_usec().get() {
                            dst.time_usec(src);
                        }
                    }

                    pub trait DST_ {
                        fn latitude(&mut self, src: i32);
                        fn longitude(&mut self, src: i32);
                        fn altitude(&mut self, src: i32);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn q(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1938);
                        fn approach_x(&mut self, src: f32);
                        fn approach_y(&mut self, src: f32);
                        fn approach_z(&mut self, src: f32);
                        fn time_usec(&mut self, src: i64);
                    }

                    pub trait SRC_ {
                        fn latitude(&mut self) -> i32;
                        fn longitude(&mut self) -> i32;
                        fn altitude(&mut self) -> i32;
                        fn x(&mut self) -> f32;
                        fn y(&mut self) -> f32;
                        fn z(&mut self) -> f32;
                        fn q(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1938);
                        fn approach_x(&mut self) -> f32;
                        fn approach_y(&mut self) -> f32;
                        fn approach_z(&mut self) -> f32;
                        fn time_usec(&mut self) -> Option<i64>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.latitude().set(src.latitude());
                        dst.longitude().set(src.longitude());
                        dst.altitude().set(src.altitude());
                        dst.x().set(src.x());
                        dst.y().set(src.y());
                        dst.z().set(src.z());
                        src.q(&mut dst.q(None));
                        dst.approach_x().set(src.approach_x());
                        dst.approach_y().set(src.approach_y());
                        dst.approach_z().set(src.approach_z());
                        if let Some(src) = src.time_usec() {
                            dst.time_usec().set(src);
                        }
                    }

                    pub mod q {
                        pub const len: usize = 4usize;
                    }
                }

                /**
*Status of geo-fencing. Sent in extended status stream when fencing enabled */

                pub mod FENCE_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::FENCE_STATUS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn breach_count(&mut self) -> crate::util_::Item__ad_hoc2214 {
                            crate::util_::Item__ad_hoc2214(self.0)
                        }
                        pub fn breach_time(&mut self) -> crate::util_::Item__ad_hoc2215 {
                            crate::util_::Item__ad_hoc2215(self.0)
                        }
                        pub fn breach_status(&mut self) -> crate::util_::Item__ad_hoc2213 {
                            crate::util_::Item__ad_hoc2213(self.0)
                        }
                        pub fn breach_type(&mut self) -> crate::util_::Item__ad_hoc85 {
                            crate::util_::Item__ad_hoc85(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.breach_count(src.breach_count().get());
                        dst.breach_time(src.breach_time().get());
                        dst.breach_status(src.breach_status().get());
                        if let Some(src) = src.breach_type().get() {
                            dst.breach_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn breach_count(&mut self, src: i16);
                        fn breach_time(&mut self, src: i32);
                        fn breach_status(&mut self, src: i8);
                        fn breach_type(&mut self, src: packs::FENCE_BREACH);
                    }

                    pub trait SRC_ {
                        fn breach_count(&mut self) -> i16;
                        fn breach_time(&mut self) -> i32;
                        fn breach_status(&mut self) -> i8;
                        fn breach_type(&mut self) -> Option<packs::FENCE_BREACH>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.breach_count().set(src.breach_count());
                        dst.breach_time().set(src.breach_time());
                        dst.breach_status().set(src.breach_status());
                        if let Some(src) = src.breach_type() {
                            dst.breach_type().set(src);
                        }
                    }
                }

                /**
*Send Status of each log block that autopilot board might have sent */

                pub mod REMOTE_LOG_BLOCK_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::REMOTE_LOG_BLOCK_STATUS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn seqno(&mut self) -> crate::util_::Item__ad_hoc2340 {
                            crate::util_::Item__ad_hoc2340(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2338 {
                            crate::util_::Item__ad_hoc2338(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2339 {
                            crate::util_::Item__ad_hoc2339(self.0)
                        }
                        pub fn status(&mut self) -> crate::util_::Item__ad_hoc372 {
                            crate::util_::Item__ad_hoc372(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.seqno(src.seqno().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        if let Some(src) = src.status().get() {
                            dst.status(src);
                        }
                    }

                    pub trait DST_ {
                        fn seqno(&mut self, src: i32);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn status(&mut self, src: packs::MAV_REMOTE_LOG_DATA_BLOCK_STATUSES);
                    }

                    pub trait SRC_ {
                        fn seqno(&mut self) -> i32;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn status(&mut self) -> Option<packs::MAV_REMOTE_LOG_DATA_BLOCK_STATUSES>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.seqno().set(src.seqno());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        if let Some(src) = src.status() {
                            dst.status().set(src);
                        }
                    }
                }

                /**
*Obstacle distances in front of the sensor, starting from the left in increment degrees to the right */

                pub mod OBSTACLE_DISTANCE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::OBSTACLE_DISTANCE) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn distances(&mut self, src: Option<&mut dyn Iterator<Item=i16>>) -> crate::util_::ItemArray__ad_hoc2121 {
                            let dst = &mut self.0;

                            let len = 72 as usize;
                            let offset = 0;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc2121 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn min_distance(&mut self) -> crate::util_::Item__ad_hoc2123 {
                            crate::util_::Item__ad_hoc2123(self.0)
                        }
                        pub fn max_distance(&mut self) -> crate::util_::Item__ad_hoc2124 {
                            crate::util_::Item__ad_hoc2124(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc2120 {
                            crate::util_::Item__ad_hoc2120(self.0)
                        }
                        pub fn increment(&mut self) -> crate::util_::Item__ad_hoc2122 {
                            crate::util_::Item__ad_hoc2122(self.0)
                        }
                        pub fn sensor_type(&mut self) -> crate::util_::Item__ad_hoc282 {
                            crate::util_::Item__ad_hoc282(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.distances(&mut src.distances(None));
                        dst.min_distance(src.min_distance().get());
                        dst.max_distance(src.max_distance().get());
                        dst.time_usec(src.time_usec().get());
                        dst.increment(src.increment().get());
                        if let Some(src) = src.sensor_type().get() {
                            dst.sensor_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn distances(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2121);
                        fn min_distance(&mut self, src: i16);
                        fn max_distance(&mut self, src: i16);
                        fn time_usec(&mut self, src: i64);
                        fn increment(&mut self, src: i8);
                        fn sensor_type(&mut self, src: packs::MAV_DISTANCE_SENSOR);
                    }

                    pub trait SRC_ {
                        fn distances(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2121);
                        fn min_distance(&mut self) -> i16;
                        fn max_distance(&mut self) -> i16;
                        fn time_usec(&mut self) -> i64;
                        fn increment(&mut self) -> i8;
                        fn sensor_type(&mut self) -> Option<packs::MAV_DISTANCE_SENSOR>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        src.distances(&mut dst.distances(None));
                        dst.min_distance().set(src.min_distance());
                        dst.max_distance().set(src.max_distance());
                        dst.time_usec().set(src.time_usec());
                        dst.increment().set(src.increment());
                        if let Some(src) = src.sensor_type() {
                            dst.sensor_type().set(src);
                        }
                    }

                    pub mod distances {
                        pub const len: usize = 72usize;
                    }
                }

                /**
*Second GPS data. Coordinate frame is right-handed, Z-axis up (GPS frame). */

                pub mod GPS2_RAW {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GPS2_RAW) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn eph(&mut self) -> crate::util_::Item__ad_hoc1693 {
                            crate::util_::Item__ad_hoc1693(self.0)
                        }
                        pub fn epv(&mut self) -> crate::util_::Item__ad_hoc1694 {
                            crate::util_::Item__ad_hoc1694(self.0)
                        }
                        pub fn vel(&mut self) -> crate::util_::Item__ad_hoc1695 {
                            crate::util_::Item__ad_hoc1695(self.0)
                        }
                        pub fn cog(&mut self) -> crate::util_::Item__ad_hoc1696 {
                            crate::util_::Item__ad_hoc1696(self.0)
                        }
                        pub fn dgps_age(&mut self) -> crate::util_::Item__ad_hoc1699 {
                            crate::util_::Item__ad_hoc1699(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1689 {
                            crate::util_::Item__ad_hoc1689(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc1690 {
                            crate::util_::Item__ad_hoc1690(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc1691 {
                            crate::util_::Item__ad_hoc1691(self.0)
                        }
                        pub fn alt(&mut self) -> crate::util_::Item__ad_hoc1692 {
                            crate::util_::Item__ad_hoc1692(self.0)
                        }
                        pub fn satellites_visible(&mut self) -> crate::util_::Item__ad_hoc1697 {
                            crate::util_::Item__ad_hoc1697(self.0)
                        }
                        pub fn dgps_numch(&mut self) -> crate::util_::Item__ad_hoc1698 {
                            crate::util_::Item__ad_hoc1698(self.0)
                        }
                        pub fn fix_type(&mut self) -> crate::util_::Item__ad_hoc972 {
                            crate::util_::Item__ad_hoc972(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.eph(src.eph().get());
                        dst.epv(src.epv().get());
                        dst.vel(src.vel().get());
                        dst.cog(src.cog().get());
                        dst.dgps_age(src.dgps_age().get());
                        dst.time_usec(src.time_usec().get());
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                        dst.alt(src.alt().get());
                        dst.satellites_visible(src.satellites_visible().get());
                        dst.dgps_numch(src.dgps_numch().get());
                        if let Some(src) = src.fix_type().get() {
                            dst.fix_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn eph(&mut self, src: i16);
                        fn epv(&mut self, src: i16);
                        fn vel(&mut self, src: i16);
                        fn cog(&mut self, src: i16);
                        fn dgps_age(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn alt(&mut self, src: i32);
                        fn satellites_visible(&mut self, src: i8);
                        fn dgps_numch(&mut self, src: i8);
                        fn fix_type(&mut self, src: packs::GPS_FIX_TYPE);
                    }

                    pub trait SRC_ {
                        fn eph(&mut self) -> i16;
                        fn epv(&mut self) -> i16;
                        fn vel(&mut self) -> i16;
                        fn cog(&mut self) -> i16;
                        fn dgps_age(&mut self) -> i32;
                        fn time_usec(&mut self) -> i64;
                        fn lat(&mut self) -> i32;
                        fn lon(&mut self) -> i32;
                        fn alt(&mut self) -> i32;
                        fn satellites_visible(&mut self) -> i8;
                        fn dgps_numch(&mut self) -> i8;
                        fn fix_type(&mut self) -> Option<packs::GPS_FIX_TYPE>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.eph().set(src.eph());
                        dst.epv().set(src.epv());
                        dst.vel().set(src.vel());
                        dst.cog().set(src.cog());
                        dst.dgps_age().set(src.dgps_age());
                        dst.time_usec().set(src.time_usec());
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                        dst.alt().set(src.alt());
                        dst.satellites_visible().set(src.satellites_visible());
                        dst.dgps_numch().set(src.dgps_numch());
                        if let Some(src) = src.fix_type() {
                            dst.fix_type().set(src);
                        }
                    }
                }

                /**
*THIS INTERFACE IS DEPRECATED. USE SET_MESSAGE_INTERVAL INSTEAD. */

                pub mod REQUEST_DATA_STREAM {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::REQUEST_DATA_STREAM) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn req_message_rate(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 3, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn req_stream_id(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 4, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn start_stop(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 5, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.req_message_rate(src.req_message_rate());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.req_stream_id(src.req_stream_id());
                        dst.start_stop(src.start_stop());
                    }

                    pub trait DST_ {
                        fn req_message_rate(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn req_stream_id(&mut self, src: i8);
                        fn start_stop(&mut self, src: i8);
                    }
                }

                /**
*Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient
*				 way for testing new messages and getting experimental debug output */

                pub mod MEMORY_VECT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MEMORY_VECT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn address(&mut self) -> crate::util_::Item__ad_hoc1976 {
                            crate::util_::Item__ad_hoc1976(self.0)
                        }
                        pub fn ver(&mut self) -> crate::util_::Item__ad_hoc1977 {
                            crate::util_::Item__ad_hoc1977(self.0)
                        }
                        pub fn typE(&mut self) -> crate::util_::Item__ad_hoc1978 {
                            crate::util_::Item__ad_hoc1978(self.0)
                        }
                        pub fn value(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1979 {
                            let dst = self.0;

                            let len = 32 as usize;
                            let offset = 4;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1979 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.address(src.address().get());
                        dst.ver(src.ver().get());
                        dst.typE(src.typE().get());
                        dst.value(&mut src.value(None));
                    }

                    pub trait DST_ {
                        fn address(&mut self, src: i16);
                        fn ver(&mut self, src: i8);
                        fn typE(&mut self, src: i8);
                        fn value(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1979);
                    }

                    pub trait SRC_ {
                        fn address(&mut self) -> i16;
                        fn ver(&mut self) -> i8;
                        fn typE(&mut self) -> i8;
                        fn value(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1979);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.address().set(src.address());
                        dst.ver().set(src.ver());
                        dst.typE().set(src.typE());
                        src.value(&mut dst.value(None));
                    }

                    pub mod value {
                        pub const len: usize = 32usize;
                    }
                }

                /**
*Request to read the value of a parameter with the either the param_id string id or param_index. */

                pub mod PARAM_EXT_REQUEST_READ {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PARAM_EXT_REQUEST_READ) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2104 {
                            crate::util_::Item__ad_hoc2104(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2105 {
                            crate::util_::Item__ad_hoc2105(self.0)
                        }
                        pub fn param_index(&mut self) -> crate::util_::Item__ad_hoc2107 {
                            crate::util_::Item__ad_hoc2107(self.0)
                        }
                        pub fn param_id(&mut self) -> crate::util_::Item__ad_hoc2106 {
                            crate::util_::Item__ad_hoc2106(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.param_index(src.param_index().get());
                        if let Some(src) = src.param_id().get() {
                            dst.param_id(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn param_index(&mut self, src: i16);
                        fn param_id(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn param_index(&mut self) -> i16;
                        fn param_id_item_exists_(&mut self) -> usize;
                        fn param_id(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.param_index().set(src.param_index());
                        let len = src.param_id_item_exists_();
                        if 0 < len {
                            dst.0.set_field(34, len as i32);

                            src.param_id(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod param_id {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Sent from autopilot to simulation. Hardware in the loop control outputs */

                pub mod HIL_CONTROLS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HIL_CONTROLS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn roll_ailerons(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 8, 4usize) as u32)
                        }
                        pub fn pitch_elevator(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 12, 4usize) as u32)
                        }
                        pub fn yaw_rudder(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 16, 4usize) as u32)
                        }
                        pub fn throttle(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 20, 4usize) as u32)
                        }
                        pub fn aux1(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 24, 4usize) as u32)
                        }
                        pub fn aux2(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 28, 4usize) as u32)
                        }
                        pub fn aux3(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 32, 4usize) as u32)
                        }
                        pub fn aux4(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 36, 4usize) as u32)
                        }
                        pub fn nav_mode(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 40, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn mode(&mut self) -> Option<packs::MAV_MODE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 328 && !src.set_field(328, -1) { return None; }

                            Some({ packs::MAV_MODE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec());
                        dst.roll_ailerons(src.roll_ailerons());
                        dst.pitch_elevator(src.pitch_elevator());
                        dst.yaw_rudder(src.yaw_rudder());
                        dst.throttle(src.throttle());
                        dst.aux1(src.aux1());
                        dst.aux2(src.aux2());
                        dst.aux3(src.aux3());
                        dst.aux4(src.aux4());
                        dst.nav_mode(src.nav_mode());
                        if let Some(src) = src.mode() {
                            dst.mode(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn roll_ailerons(&mut self, src: f32);
                        fn pitch_elevator(&mut self, src: f32);
                        fn yaw_rudder(&mut self, src: f32);
                        fn throttle(&mut self, src: f32);
                        fn aux1(&mut self, src: f32);
                        fn aux2(&mut self, src: f32);
                        fn aux3(&mut self, src: f32);
                        fn aux4(&mut self, src: f32);
                        fn nav_mode(&mut self, src: i8);
                        fn mode(&mut self, src: packs::MAV_MODE);
                    }
                }

                /**
*The IMU readings in SI units in NED body frame */

                pub mod HIL_SENSOR {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HIL_SENSOR) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn fields_updated(&mut self) -> crate::util_::Item__ad_hoc1575 {
                            crate::util_::Item__ad_hoc1575(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1561 {
                            crate::util_::Item__ad_hoc1561(self.0)
                        }
                        pub fn xacc(&mut self) -> crate::util_::Item__ad_hoc1562 {
                            crate::util_::Item__ad_hoc1562(self.0)
                        }
                        pub fn yacc(&mut self) -> crate::util_::Item__ad_hoc1563 {
                            crate::util_::Item__ad_hoc1563(self.0)
                        }
                        pub fn zacc(&mut self) -> crate::util_::Item__ad_hoc1564 {
                            crate::util_::Item__ad_hoc1564(self.0)
                        }
                        pub fn xgyro(&mut self) -> crate::util_::Item__ad_hoc1565 {
                            crate::util_::Item__ad_hoc1565(self.0)
                        }
                        pub fn ygyro(&mut self) -> crate::util_::Item__ad_hoc1566 {
                            crate::util_::Item__ad_hoc1566(self.0)
                        }
                        pub fn zgyro(&mut self) -> crate::util_::Item__ad_hoc1567 {
                            crate::util_::Item__ad_hoc1567(self.0)
                        }
                        pub fn xmag(&mut self) -> crate::util_::Item__ad_hoc1568 {
                            crate::util_::Item__ad_hoc1568(self.0)
                        }
                        pub fn ymag(&mut self) -> crate::util_::Item__ad_hoc1569 {
                            crate::util_::Item__ad_hoc1569(self.0)
                        }
                        pub fn zmag(&mut self) -> crate::util_::Item__ad_hoc1570 {
                            crate::util_::Item__ad_hoc1570(self.0)
                        }
                        pub fn abs_pressure(&mut self) -> crate::util_::Item__ad_hoc1571 {
                            crate::util_::Item__ad_hoc1571(self.0)
                        }
                        pub fn diff_pressure(&mut self) -> crate::util_::Item__ad_hoc1572 {
                            crate::util_::Item__ad_hoc1572(self.0)
                        }
                        pub fn pressure_alt(&mut self) -> crate::util_::Item__ad_hoc1573 {
                            crate::util_::Item__ad_hoc1573(self.0)
                        }
                        pub fn temperature(&mut self) -> crate::util_::Item__ad_hoc1574 {
                            crate::util_::Item__ad_hoc1574(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.fields_updated(src.fields_updated().get());
                        dst.time_usec(src.time_usec().get());
                        dst.xacc(src.xacc().get());
                        dst.yacc(src.yacc().get());
                        dst.zacc(src.zacc().get());
                        dst.xgyro(src.xgyro().get());
                        dst.ygyro(src.ygyro().get());
                        dst.zgyro(src.zgyro().get());
                        dst.xmag(src.xmag().get());
                        dst.ymag(src.ymag().get());
                        dst.zmag(src.zmag().get());
                        dst.abs_pressure(src.abs_pressure().get());
                        dst.diff_pressure(src.diff_pressure().get());
                        dst.pressure_alt(src.pressure_alt().get());
                        dst.temperature(src.temperature().get());
                    }

                    pub trait DST_ {
                        fn fields_updated(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                        fn xacc(&mut self, src: f32);
                        fn yacc(&mut self, src: f32);
                        fn zacc(&mut self, src: f32);
                        fn xgyro(&mut self, src: f32);
                        fn ygyro(&mut self, src: f32);
                        fn zgyro(&mut self, src: f32);
                        fn xmag(&mut self, src: f32);
                        fn ymag(&mut self, src: f32);
                        fn zmag(&mut self, src: f32);
                        fn abs_pressure(&mut self, src: f32);
                        fn diff_pressure(&mut self, src: f32);
                        fn pressure_alt(&mut self, src: f32);
                        fn temperature(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn fields_updated(&mut self) -> i32;
                        fn time_usec(&mut self) -> i64;
                        fn xacc(&mut self) -> f32;
                        fn yacc(&mut self) -> f32;
                        fn zacc(&mut self) -> f32;
                        fn xgyro(&mut self) -> f32;
                        fn ygyro(&mut self) -> f32;
                        fn zgyro(&mut self) -> f32;
                        fn xmag(&mut self) -> f32;
                        fn ymag(&mut self) -> f32;
                        fn zmag(&mut self) -> f32;
                        fn abs_pressure(&mut self) -> f32;
                        fn diff_pressure(&mut self) -> f32;
                        fn pressure_alt(&mut self) -> f32;
                        fn temperature(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.fields_updated().set(src.fields_updated());
                        dst.time_usec().set(src.time_usec());
                        dst.xacc().set(src.xacc());
                        dst.yacc().set(src.yacc());
                        dst.zacc().set(src.zacc());
                        dst.xgyro().set(src.xgyro());
                        dst.ygyro().set(src.ygyro());
                        dst.zgyro().set(src.zgyro());
                        dst.xmag().set(src.xmag());
                        dst.ymag().set(src.ymag());
                        dst.zmag().set(src.zmag());
                        dst.abs_pressure().set(src.abs_pressure());
                        dst.diff_pressure().set(src.diff_pressure());
                        dst.pressure_alt().set(src.pressure_alt());
                        dst.temperature().set(src.temperature());
                    }
                }

                /**
*Setup a MAVLink2 signing key. If called with secret_key of all zero and zero initial_timestamp will disable
*				 signin */

                pub mod SETUP_SIGNING {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SETUP_SIGNING) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn initial_timestamp(&mut self) -> crate::util_::Item__ad_hoc1998 {
                            crate::util_::Item__ad_hoc1998(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc1995 {
                            crate::util_::Item__ad_hoc1995(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc1996 {
                            crate::util_::Item__ad_hoc1996(self.0)
                        }
                        pub fn secret_key(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1997 {
                            let dst = self.0;

                            let len = 32 as usize;
                            let offset = 10;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1997 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.initial_timestamp(src.initial_timestamp().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.secret_key(&mut src.secret_key(None));
                    }

                    pub trait DST_ {
                        fn initial_timestamp(&mut self, src: i64);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn secret_key(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1997);
                    }

                    pub trait SRC_ {
                        fn initial_timestamp(&mut self) -> i64;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn secret_key(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1997);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.initial_timestamp().set(src.initial_timestamp());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        src.secret_key(&mut dst.secret_key(None));
                    }

                    pub mod secret_key {
                        pub const len: usize = 32usize;
                    }
                }

                /**
*RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */

                pub mod GPS_RTK {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GPS_RTK) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn wn(&mut self) -> crate::util_::Item__ad_hoc1708 {
                            crate::util_::Item__ad_hoc1708(self.0)
                        }
                        pub fn time_last_baseline_ms(&mut self) -> crate::util_::Item__ad_hoc1706 {
                            crate::util_::Item__ad_hoc1706(self.0)
                        }
                        pub fn tow(&mut self) -> crate::util_::Item__ad_hoc1709 {
                            crate::util_::Item__ad_hoc1709(self.0)
                        }
                        pub fn accuracy(&mut self) -> crate::util_::Item__ad_hoc1717 {
                            crate::util_::Item__ad_hoc1717(self.0)
                        }
                        pub fn rtk_receiver_id(&mut self) -> crate::util_::Item__ad_hoc1707 {
                            crate::util_::Item__ad_hoc1707(self.0)
                        }
                        pub fn rtk_health(&mut self) -> crate::util_::Item__ad_hoc1710 {
                            crate::util_::Item__ad_hoc1710(self.0)
                        }
                        pub fn rtk_rate(&mut self) -> crate::util_::Item__ad_hoc1711 {
                            crate::util_::Item__ad_hoc1711(self.0)
                        }
                        pub fn nsats(&mut self) -> crate::util_::Item__ad_hoc1712 {
                            crate::util_::Item__ad_hoc1712(self.0)
                        }
                        pub fn baseline_coords_type(&mut self) -> crate::util_::Item__ad_hoc1713 {
                            crate::util_::Item__ad_hoc1713(self.0)
                        }
                        pub fn baseline_a_mm(&mut self) -> crate::util_::Item__ad_hoc1714 {
                            crate::util_::Item__ad_hoc1714(self.0)
                        }
                        pub fn baseline_b_mm(&mut self) -> crate::util_::Item__ad_hoc1715 {
                            crate::util_::Item__ad_hoc1715(self.0)
                        }
                        pub fn baseline_c_mm(&mut self) -> crate::util_::Item__ad_hoc1716 {
                            crate::util_::Item__ad_hoc1716(self.0)
                        }
                        pub fn iar_num_hypotheses(&mut self) -> crate::util_::Item__ad_hoc1718 {
                            crate::util_::Item__ad_hoc1718(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.wn(src.wn().get());
                        dst.time_last_baseline_ms(src.time_last_baseline_ms().get());
                        dst.tow(src.tow().get());
                        dst.accuracy(src.accuracy().get());
                        dst.rtk_receiver_id(src.rtk_receiver_id().get());
                        dst.rtk_health(src.rtk_health().get());
                        dst.rtk_rate(src.rtk_rate().get());
                        dst.nsats(src.nsats().get());
                        dst.baseline_coords_type(src.baseline_coords_type().get());
                        dst.baseline_a_mm(src.baseline_a_mm().get());
                        dst.baseline_b_mm(src.baseline_b_mm().get());
                        dst.baseline_c_mm(src.baseline_c_mm().get());
                        dst.iar_num_hypotheses(src.iar_num_hypotheses().get());
                    }

                    pub trait DST_ {
                        fn wn(&mut self, src: i16);
                        fn time_last_baseline_ms(&mut self, src: i32);
                        fn tow(&mut self, src: i32);
                        fn accuracy(&mut self, src: i32);
                        fn rtk_receiver_id(&mut self, src: i8);
                        fn rtk_health(&mut self, src: i8);
                        fn rtk_rate(&mut self, src: i8);
                        fn nsats(&mut self, src: i8);
                        fn baseline_coords_type(&mut self, src: i8);
                        fn baseline_a_mm(&mut self, src: i32);
                        fn baseline_b_mm(&mut self, src: i32);
                        fn baseline_c_mm(&mut self, src: i32);
                        fn iar_num_hypotheses(&mut self, src: i32);
                    }

                    pub trait SRC_ {
                        fn wn(&mut self) -> i16;
                        fn time_last_baseline_ms(&mut self) -> i32;
                        fn tow(&mut self) -> i32;
                        fn accuracy(&mut self) -> i32;
                        fn rtk_receiver_id(&mut self) -> i8;
                        fn rtk_health(&mut self) -> i8;
                        fn rtk_rate(&mut self) -> i8;
                        fn nsats(&mut self) -> i8;
                        fn baseline_coords_type(&mut self) -> i8;
                        fn baseline_a_mm(&mut self) -> i32;
                        fn baseline_b_mm(&mut self) -> i32;
                        fn baseline_c_mm(&mut self) -> i32;
                        fn iar_num_hypotheses(&mut self) -> i32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.wn().set(src.wn());
                        dst.time_last_baseline_ms().set(src.time_last_baseline_ms());
                        dst.tow().set(src.tow());
                        dst.accuracy().set(src.accuracy());
                        dst.rtk_receiver_id().set(src.rtk_receiver_id());
                        dst.rtk_health().set(src.rtk_health());
                        dst.rtk_rate().set(src.rtk_rate());
                        dst.nsats().set(src.nsats());
                        dst.baseline_coords_type().set(src.baseline_coords_type());
                        dst.baseline_a_mm().set(src.baseline_a_mm());
                        dst.baseline_b_mm().set(src.baseline_b_mm());
                        dst.baseline_c_mm().set(src.baseline_c_mm());
                        dst.iar_num_hypotheses().set(src.iar_num_hypotheses());
                    }
                }

                /**
*Request all parameters of this component. After this request, all parameters are emitted. */

                pub mod PARAM_REQUEST_LIST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PARAM_REQUEST_LIST) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }
                }

                /**
*Static data to configure the ADS-B transponder (send within 10 sec of a POR and every 10 sec thereafter */

                pub mod UAVIONIX_ADSB_OUT_CFG {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::UAVIONIX_ADSB_OUT_CFG) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn stallSpeed(&mut self) -> crate::util_::Item__ad_hoc2127 {
                            crate::util_::Item__ad_hoc2127(self.0)
                        }
                        pub fn ICAO(&mut self) -> crate::util_::Item__ad_hoc2125 {
                            crate::util_::Item__ad_hoc2125(self.0)
                        }
                        pub fn callsign(&mut self) -> crate::util_::Item__ad_hoc2126 {
                            crate::util_::Item__ad_hoc2126(self.0)
                        }
                        pub fn emitterType(&mut self) -> crate::util_::Item__ad_hoc209 {
                            crate::util_::Item__ad_hoc209(self.0)
                        }
                        pub fn aircraftSize(&mut self) -> crate::util_::Item__ad_hoc212 {
                            crate::util_::Item__ad_hoc212(self.0)
                        }
                        pub fn gpsOffsetLat(&mut self) -> crate::util_::Item__ad_hoc210 {
                            crate::util_::Item__ad_hoc210(self.0)
                        }
                        pub fn gpsOffsetLon(&mut self) -> crate::util_::Item__ad_hoc208 {
                            crate::util_::Item__ad_hoc208(self.0)
                        }
                        pub fn rfSelect(&mut self) -> crate::util_::Item__ad_hoc211 {
                            crate::util_::Item__ad_hoc211(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.stallSpeed(src.stallSpeed().get());
                        dst.ICAO(src.ICAO().get());
                        if let Some(src) = src.callsign().get() {
                            dst.callsign(src);
                        }
                        if let Some(src) = src.emitterType().get() {
                            dst.emitterType(src);
                        }
                        if let Some(src) = src.aircraftSize().get() {
                            dst.aircraftSize(src);
                        }
                        if let Some(src) = src.gpsOffsetLat().get() {
                            dst.gpsOffsetLat(src);
                        }
                        if let Some(src) = src.gpsOffsetLon().get() {
                            dst.gpsOffsetLon(src);
                        }
                        if let Some(src) = src.rfSelect().get() {
                            dst.rfSelect(src);
                        }
                    }

                    pub trait DST_ {
                        fn stallSpeed(&mut self, src: i16);
                        fn ICAO(&mut self, src: i32);
                        fn callsign(&mut self, src: &str);
                        fn emitterType(&mut self, src: packs::ADSB_EMITTER_TYPE);
                        fn aircraftSize(&mut self, src: packs::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE);
                        fn gpsOffsetLat(&mut self, src: packs::UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT);
                        fn gpsOffsetLon(&mut self, src: packs::UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON);
                        fn rfSelect(&mut self, src: packs::UAVIONIX_ADSB_OUT_RF_SELECT);
                    }

                    pub trait SRC_ {
                        fn stallSpeed(&mut self) -> i16;
                        fn ICAO(&mut self) -> i32;
                        fn callsign_item_exists_(&mut self) -> usize;
                        fn callsign(&mut self, dst: &mut [u8]);
                        fn emitterType(&mut self) -> Option<packs::ADSB_EMITTER_TYPE>;
                        fn aircraftSize(&mut self) -> Option<packs::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE>;
                        fn gpsOffsetLat(&mut self) -> Option<packs::UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT>;
                        fn gpsOffsetLon(&mut self) -> Option<packs::UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON>;
                        fn rfSelect(&mut self) -> Option<packs::UAVIONIX_ADSB_OUT_RF_SELECT>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.stallSpeed().set(src.stallSpeed());
                        dst.ICAO().set(src.ICAO());
                        let len = src.callsign_item_exists_();
                        if 0 < len {
                            dst.0.set_field(51, len as i32);

                            src.callsign(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                        if let Some(src) = src.emitterType() {
                            dst.emitterType().set(src);
                        }
                        if let Some(src) = src.aircraftSize() {
                            dst.aircraftSize().set(src);
                        }
                        if let Some(src) = src.gpsOffsetLat() {
                            dst.gpsOffsetLat().set(src);
                        }
                        if let Some(src) = src.gpsOffsetLon() {
                            dst.gpsOffsetLon().set(src);
                        }
                        if let Some(src) = src.rfSelect() {
                            dst.rfSelect().set(src);
                        }
                    }

                    pub mod callsign {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*The location of a landing area captured from a downward facing camera */

                pub mod LANDING_TARGET {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LANDING_TARGET) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1854 {
                            crate::util_::Item__ad_hoc1854(self.0)
                        }
                        pub fn target_num(&mut self) -> crate::util_::Item__ad_hoc1855 {
                            crate::util_::Item__ad_hoc1855(self.0)
                        }
                        pub fn angle_x(&mut self) -> crate::util_::Item__ad_hoc1856 {
                            crate::util_::Item__ad_hoc1856(self.0)
                        }
                        pub fn angle_y(&mut self) -> crate::util_::Item__ad_hoc1857 {
                            crate::util_::Item__ad_hoc1857(self.0)
                        }
                        pub fn distance(&mut self) -> crate::util_::Item__ad_hoc1858 {
                            crate::util_::Item__ad_hoc1858(self.0)
                        }
                        pub fn size_x(&mut self) -> crate::util_::Item__ad_hoc1859 {
                            crate::util_::Item__ad_hoc1859(self.0)
                        }
                        pub fn size_y(&mut self) -> crate::util_::Item__ad_hoc1860 {
                            crate::util_::Item__ad_hoc1860(self.0)
                        }
                        pub fn frame(&mut self) -> crate::util_::Item__ad_hoc351 {
                            crate::util_::Item__ad_hoc351(self.0)
                        }
                        pub fn x(&mut self) -> crate::util_::Item__ad_hoc1861 {
                            crate::util_::Item__ad_hoc1861(self.0)
                        }
                        pub fn y(&mut self) -> crate::util_::Item__ad_hoc1862 {
                            crate::util_::Item__ad_hoc1862(self.0)
                        }
                        pub fn z(&mut self) -> crate::util_::Item__ad_hoc1863 {
                            crate::util_::Item__ad_hoc1863(self.0)
                        }
                        pub fn q(&mut self) -> crate::util_::FieldI__ad_hoc1864 {
                            crate::util_::FieldI__ad_hoc1864(self.0)
                        }
                        pub fn typE(&mut self) -> crate::util_::Item__ad_hoc352 {
                            crate::util_::Item__ad_hoc352(self.0)
                        }
                        pub fn position_valid(&mut self) -> crate::util_::Item__ad_hoc1865 {
                            crate::util_::Item__ad_hoc1865(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec().get());
                        dst.target_num(src.target_num().get());
                        dst.angle_x(src.angle_x().get());
                        dst.angle_y(src.angle_y().get());
                        dst.distance(src.distance().get());
                        dst.size_x(src.size_x().get());
                        dst.size_y(src.size_y().get());
                        if let Some(src) = src.frame().get() {
                            dst.frame(src);
                        }
                        if let Some(src) = src.x().get() {
                            dst.x(src);
                        }
                        if let Some(src) = src.y().get() {
                            dst.y(src);
                        }
                        if let Some(src) = src.z().get() {
                            dst.z(src);
                        }

                        if let Some(mut src) = src.q().items() {
                            src.enumerate(0,
                                          |src, d0| {
                                              if let Some(q) = src.get(d0) {
                                                  dst.q(q, d0);
                                              }
                                          },
                            );
                        }
                        if let Some(src) = src.typE().get() {
                            dst.typE(src);
                        }
                        if let Some(src) = src.position_valid().get() {
                            dst.position_valid(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn target_num(&mut self, src: i8);
                        fn angle_x(&mut self, src: f32);
                        fn angle_y(&mut self, src: f32);
                        fn distance(&mut self, src: f32);
                        fn size_x(&mut self, src: f32);
                        fn size_y(&mut self, src: f32);
                        fn frame(&mut self, src: packs::MAV_FRAME);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn q(&mut self, src: f32, d0: usize);
                        fn typE(&mut self, src: packs::LANDING_TARGET_TYPE);
                        fn position_valid(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn time_usec(&mut self) -> i64;
                        fn target_num(&mut self) -> i8;
                        fn angle_x(&mut self) -> f32;
                        fn angle_y(&mut self) -> f32;
                        fn distance(&mut self) -> f32;
                        fn size_x(&mut self) -> f32;
                        fn size_y(&mut self) -> f32;
                        fn frame(&mut self) -> Option<packs::MAV_FRAME>;
                        fn x(&mut self) -> Option<f32>;
                        fn y(&mut self) -> Option<f32>;
                        fn z(&mut self) -> Option<f32>;
                        fn q_exists_(&mut self) -> bool;
                        fn q(&mut self, d0: usize) -> Option<f32>;
                        fn typE(&mut self) -> Option<packs::LANDING_TARGET_TYPE>;
                        fn position_valid(&mut self) -> Option<i8>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_usec().set(src.time_usec());
                        dst.target_num().set(src.target_num());
                        dst.angle_x().set(src.angle_x());
                        dst.angle_y().set(src.angle_y());
                        dst.distance().set(src.distance());
                        dst.size_x().set(src.size_x());
                        dst.size_y().set(src.size_y());
                        if let Some(src) = src.frame() {
                            dst.frame().set(src);
                        }
                        if let Some(src) = src.x() {
                            dst.x().set(src);
                        }
                        if let Some(src) = src.y() {
                            dst.y().set(src);
                        }
                        if let Some(src) = src.z() {
                            dst.z().set(src);
                        }

                        if src.q_exists_() {
                            dst.0.set_field(239, 0);
                            let mut dst = dst.q();
                            for d0 in 0..packs::LANDING_TARGET::q::d0 {
                                if let Some(src) = src.q(d0) {
                                    dst.set(src, d0);
                                }
                            }
                        }
                        if let Some(src) = src.typE() {
                            dst.typE().set(src);
                        }
                        if let Some(src) = src.position_valid() {
                            dst.position_valid().set(src);
                        }
                    }

                    pub mod q {
                        pub const d0: usize = 4;
                    }
                }

                /**
*Set the vehicle attitude and body angular rates. */

                pub mod SET_ACTUATOR_CONTROL_TARGET {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SET_ACTUATOR_CONTROL_TARGET) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1784 {
                            crate::util_::Item__ad_hoc1784(self.0)
                        }
                        pub fn group_mlx(&mut self) -> crate::util_::Item__ad_hoc1785 {
                            crate::util_::Item__ad_hoc1785(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc1786 {
                            crate::util_::Item__ad_hoc1786(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc1787 {
                            crate::util_::Item__ad_hoc1787(self.0)
                        }
                        pub fn controls(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1788 {
                            let dst = self.0;

                            let len = 8 as usize;
                            let offset = 11;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1788 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec().get());
                        dst.group_mlx(src.group_mlx().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.controls(&mut src.controls(None));
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn group_mlx(&mut self, src: i8);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn controls(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1788);
                    }

                    pub trait SRC_ {
                        fn time_usec(&mut self) -> i64;
                        fn group_mlx(&mut self) -> i8;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn controls(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1788);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_usec().set(src.time_usec());
                        dst.group_mlx().set(src.group_mlx());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        src.controls(&mut dst.controls(None));
                    }

                    pub mod controls {
                        pub const len: usize = 8usize;
                    }
                }

                /**
*The smoothed, monotonic system state used to feed the control loops of the system. */

                pub mod CONTROL_SYSTEM_STATE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::CONTROL_SYSTEM_STATE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1819 {
                            crate::util_::Item__ad_hoc1819(self.0)
                        }
                        pub fn x_acc(&mut self) -> crate::util_::Item__ad_hoc1820 {
                            crate::util_::Item__ad_hoc1820(self.0)
                        }
                        pub fn y_acc(&mut self) -> crate::util_::Item__ad_hoc1821 {
                            crate::util_::Item__ad_hoc1821(self.0)
                        }
                        pub fn z_acc(&mut self) -> crate::util_::Item__ad_hoc1822 {
                            crate::util_::Item__ad_hoc1822(self.0)
                        }
                        pub fn x_vel(&mut self) -> crate::util_::Item__ad_hoc1823 {
                            crate::util_::Item__ad_hoc1823(self.0)
                        }
                        pub fn y_vel(&mut self) -> crate::util_::Item__ad_hoc1824 {
                            crate::util_::Item__ad_hoc1824(self.0)
                        }
                        pub fn z_vel(&mut self) -> crate::util_::Item__ad_hoc1825 {
                            crate::util_::Item__ad_hoc1825(self.0)
                        }
                        pub fn x_pos(&mut self) -> crate::util_::Item__ad_hoc1826 {
                            crate::util_::Item__ad_hoc1826(self.0)
                        }
                        pub fn y_pos(&mut self) -> crate::util_::Item__ad_hoc1827 {
                            crate::util_::Item__ad_hoc1827(self.0)
                        }
                        pub fn z_pos(&mut self) -> crate::util_::Item__ad_hoc1828 {
                            crate::util_::Item__ad_hoc1828(self.0)
                        }
                        pub fn airspeed(&mut self) -> crate::util_::Item__ad_hoc1829 {
                            crate::util_::Item__ad_hoc1829(self.0)
                        }
                        pub fn vel_variance(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1830 {
                            let dst = self.0;

                            let len = 3 as usize;
                            let offset = 48;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1830 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn pos_variance(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1831 {
                            let dst = self.0;

                            let len = 3 as usize;
                            let offset = 60;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1831 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn q(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1832 {
                            let dst = self.0;

                            let len = 4 as usize;
                            let offset = 72;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1832 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn roll_rate(&mut self) -> crate::util_::Item__ad_hoc1833 {
                            crate::util_::Item__ad_hoc1833(self.0)
                        }
                        pub fn pitch_rate(&mut self) -> crate::util_::Item__ad_hoc1834 {
                            crate::util_::Item__ad_hoc1834(self.0)
                        }
                        pub fn yaw_rate(&mut self) -> crate::util_::Item__ad_hoc1835 {
                            crate::util_::Item__ad_hoc1835(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec().get());
                        dst.x_acc(src.x_acc().get());
                        dst.y_acc(src.y_acc().get());
                        dst.z_acc(src.z_acc().get());
                        dst.x_vel(src.x_vel().get());
                        dst.y_vel(src.y_vel().get());
                        dst.z_vel(src.z_vel().get());
                        dst.x_pos(src.x_pos().get());
                        dst.y_pos(src.y_pos().get());
                        dst.z_pos(src.z_pos().get());
                        dst.airspeed(src.airspeed().get());
                        dst.vel_variance(&mut src.vel_variance(None));
                        dst.pos_variance(&mut src.pos_variance(None));
                        dst.q(&mut src.q(None));
                        dst.roll_rate(src.roll_rate().get());
                        dst.pitch_rate(src.pitch_rate().get());
                        dst.yaw_rate(src.yaw_rate().get());
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn x_acc(&mut self, src: f32);
                        fn y_acc(&mut self, src: f32);
                        fn z_acc(&mut self, src: f32);
                        fn x_vel(&mut self, src: f32);
                        fn y_vel(&mut self, src: f32);
                        fn z_vel(&mut self, src: f32);
                        fn x_pos(&mut self, src: f32);
                        fn y_pos(&mut self, src: f32);
                        fn z_pos(&mut self, src: f32);
                        fn airspeed(&mut self, src: f32);
                        fn vel_variance(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1830);
                        fn pos_variance(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1831);
                        fn q(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1832);
                        fn roll_rate(&mut self, src: f32);
                        fn pitch_rate(&mut self, src: f32);
                        fn yaw_rate(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn time_usec(&mut self) -> i64;
                        fn x_acc(&mut self) -> f32;
                        fn y_acc(&mut self) -> f32;
                        fn z_acc(&mut self) -> f32;
                        fn x_vel(&mut self) -> f32;
                        fn y_vel(&mut self) -> f32;
                        fn z_vel(&mut self) -> f32;
                        fn x_pos(&mut self) -> f32;
                        fn y_pos(&mut self) -> f32;
                        fn z_pos(&mut self) -> f32;
                        fn airspeed(&mut self) -> f32;
                        fn vel_variance(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1830);
                        fn pos_variance(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1831);
                        fn q(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1832);
                        fn roll_rate(&mut self) -> f32;
                        fn pitch_rate(&mut self) -> f32;
                        fn yaw_rate(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_usec().set(src.time_usec());
                        dst.x_acc().set(src.x_acc());
                        dst.y_acc().set(src.y_acc());
                        dst.z_acc().set(src.z_acc());
                        dst.x_vel().set(src.x_vel());
                        dst.y_vel().set(src.y_vel());
                        dst.z_vel().set(src.z_vel());
                        dst.x_pos().set(src.x_pos());
                        dst.y_pos().set(src.y_pos());
                        dst.z_pos().set(src.z_pos());
                        dst.airspeed().set(src.airspeed());
                        src.vel_variance(&mut dst.vel_variance(None));
                        src.pos_variance(&mut dst.pos_variance(None));
                        src.q(&mut dst.q(None));
                        dst.roll_rate().set(src.roll_rate());
                        dst.pitch_rate().set(src.pitch_rate());
                        dst.yaw_rate().set(src.yaw_rate());
                    }

                    pub mod vel_variance {
                        pub const len: usize = 3usize;
                    }

                    pub mod pos_variance {
                        pub const len: usize = 3usize;
                    }

                    pub mod q {
                        pub const len: usize = 4usize;
                    }
                }

                /**
*Sets a desired vehicle position, velocity, and/or acceleration in a global coordinate system (WGS84).
*				 Used by an external controller to command the vehicle (manual controller or other system) */

                pub mod SET_POSITION_TARGET_GLOBAL_INT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SET_POSITION_TARGET_GLOBAL_INT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn type_mask(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 6, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 7, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn lat_int(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 8, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn lon_int(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 12, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn alt(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 16, 4usize) as u32)
                        }
                        pub fn vx(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 20, 4usize) as u32)
                        }
                        pub fn vy(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 24, 4usize) as u32)
                        }
                        pub fn vz(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 28, 4usize) as u32)
                        }
                        pub fn afx(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 32, 4usize) as u32)
                        }
                        pub fn afy(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 36, 4usize) as u32)
                        }
                        pub fn afz(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 40, 4usize) as u32)
                        }
                        pub fn yaw(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 44, 4usize) as u32)
                        }
                        pub fn yaw_rate(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 48, 4usize) as u32)
                        }
                        pub fn coordinate_frame(&mut self) -> Option<packs::MAV_FRAME> {
                            let src = &mut self.0;
                            if src.base.field_bit != 416 && !src.set_field(416, -1) { return None; }

                            Some({ packs::MAV_FRAME::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.type_mask(src.type_mask());
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.lat_int(src.lat_int());
                        dst.lon_int(src.lon_int());
                        dst.alt(src.alt());
                        dst.vx(src.vx());
                        dst.vy(src.vy());
                        dst.vz(src.vz());
                        dst.afx(src.afx());
                        dst.afy(src.afy());
                        dst.afz(src.afz());
                        dst.yaw(src.yaw());
                        dst.yaw_rate(src.yaw_rate());
                        if let Some(src) = src.coordinate_frame() {
                            dst.coordinate_frame(src);
                        }
                    }

                    pub trait DST_ {
                        fn type_mask(&mut self, src: i16);
                        fn time_boot_ms(&mut self, src: i32);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn lat_int(&mut self, src: i32);
                        fn lon_int(&mut self, src: i32);
                        fn alt(&mut self, src: f32);
                        fn vx(&mut self, src: f32);
                        fn vy(&mut self, src: f32);
                        fn vz(&mut self, src: f32);
                        fn afx(&mut self, src: f32);
                        fn afy(&mut self, src: f32);
                        fn afz(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn yaw_rate(&mut self, src: f32);
                        fn coordinate_frame(&mut self, src: packs::MAV_FRAME);
                    }
                }

                /**
*Data packet, size 32 */

                pub mod DATA32 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DATA32) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn typE(&mut self) -> crate::util_::Item__ad_hoc2254 {
                            crate::util_::Item__ad_hoc2254(self.0)
                        }
                        pub fn len(&mut self) -> crate::util_::Item__ad_hoc2255 {
                            crate::util_::Item__ad_hoc2255(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2256 {
                            let dst = self.0;

                            let len = 32 as usize;
                            let offset = 2;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2256 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.typE(src.typE().get());
                        dst.len(src.len().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn typE(&mut self, src: i8);
                        fn len(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2256);
                    }

                    pub trait SRC_ {
                        fn typE(&mut self) -> i8;
                        fn len(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2256);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.typE().set(src.typE());
                        dst.len().set(src.len());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 32usize;
                    }
                }

                pub mod PING33 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PING33) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn TTTT(&mut self) -> crate::util_::Item__ad_hoc1493 {
                            crate::util_::Item__ad_hoc1493(self.0)
                        }
                        pub fn field(&mut self) -> crate::util_::Item__ad_hoc1489 {
                            crate::util_::Item__ad_hoc1489(self.0)
                        }
                        pub fn bit_field(&mut self) -> crate::util_::Item__ad_hoc1497 {
                            crate::util_::Item__ad_hoc1497(self.0)
                        }
                        pub fn field6(&mut self) -> crate::util_::Item__ad_hoc1514 {
                            crate::util_::Item__ad_hoc1514(self.0)
                        }
                        pub fn testBOOL2(&mut self) -> crate::util_::Item__ad_hoc1495 {
                            crate::util_::Item__ad_hoc1495(self.0)
                        }
                        pub fn testBOOL3(&mut self) -> crate::util_::Item__ad_hoc1496 {
                            crate::util_::Item__ad_hoc1496(self.0)
                        }
                        pub fn testBOOL(&mut self) -> crate::util_::Item__ad_hoc1487 {
                            crate::util_::Item__ad_hoc1487(self.0)
                        }
                        pub fn seq(&mut self) -> crate::util_::Item__ad_hoc1488 {
                            crate::util_::Item__ad_hoc1488(self.0)
                        }
                        pub fn field1(&mut self) -> Result<crate::util_::Item__ad_hoc1490, crate::util_::FieldI__ad_hoc1490> {
                            if self.0.base.field_bit != 1236 && !self.0.set_field(1236, -1) { return Err(crate::util_::FieldI__ad_hoc1490(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1490(self.0))
                        }
                        pub fn field12(&mut self) -> crate::util_::FieldI__ad_hoc1491 {
                            crate::util_::FieldI__ad_hoc1491(self.0)
                        }
                        pub fn field13(&mut self) -> crate::util_::FieldI__ad_hoc1492 {
                            crate::util_::FieldI__ad_hoc1492(self.0)
                        }
                        pub fn WWWWWWWW(&mut self) -> crate::util_::Item__ad_hoc1494 {
                            crate::util_::Item__ad_hoc1494(self.0)
                        }
                        pub fn bit_field2(&mut self) -> crate::util_::Item__ad_hoc1498 {
                            crate::util_::Item__ad_hoc1498(self.0)
                        }
                        pub fn Field_Bits(&mut self) -> crate::util_::FieldI__ad_hoc1499 {
                            crate::util_::FieldI__ad_hoc1499(self.0)
                        }
                        pub fn SparseFixAllBits(&mut self) -> Result<crate::util_::Item__ad_hoc1500, crate::util_::FieldI__ad_hoc1500> {
                            if self.0.base.field_bit != 1242 && !self.0.set_field(1242, -1) { return Err(crate::util_::FieldI__ad_hoc1500(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1500(self.0))
                        }
                        pub fn FixAllBits(&mut self) -> Result<crate::util_::Item__ad_hoc1501, crate::util_::FieldI__ad_hoc1501> {
                            if self.0.base.field_bit != 1243 && !self.0.set_field(1243, -1) { return Err(crate::util_::FieldI__ad_hoc1501(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1501(self.0))
                        }
                        pub fn VarAllBits(&mut self) -> Result<crate::util_::Item__ad_hoc1502, crate::util_::FieldI__ad_hoc1502> {
                            if self.0.base.field_bit != 1244 && !self.0.set_field(1244, -1) { return Err(crate::util_::FieldI__ad_hoc1502(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1502(self.0))
                        }
                        pub fn SparseVarAllBits(&mut self) -> Result<crate::util_::Item__ad_hoc1503, crate::util_::FieldI__ad_hoc1503> {
                            if self.0.base.field_bit != 1245 && !self.0.set_field(1245, -1) { return Err(crate::util_::FieldI__ad_hoc1503(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1503(self.0))
                        }
                        pub fn VarEachBits(&mut self) -> Result<crate::util_::Item__ad_hoc1504, crate::util_::FieldI__ad_hoc1504> {
                            if self.0.base.field_bit != 1246 && !self.0.set_field(1246, -1) { return Err(crate::util_::FieldI__ad_hoc1504(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1504(self.0))
                        }
                        pub fn SparsVarEachBits(&mut self) -> Result<crate::util_::Item__ad_hoc1505, crate::util_::FieldI__ad_hoc1505> {
                            if self.0.base.field_bit != 1247 && !self.0.set_field(1247, -1) { return Err(crate::util_::FieldI__ad_hoc1505(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1505(self.0))
                        }
                        pub fn testBOOLX(&mut self) -> crate::util_::Item__ad_hoc1506 {
                            crate::util_::Item__ad_hoc1506(self.0)
                        }
                        pub fn testBOOL2X(&mut self) -> crate::util_::Item__ad_hoc1507 {
                            crate::util_::Item__ad_hoc1507(self.0)
                        }
                        pub fn testBOOL3X(&mut self) -> crate::util_::Item__ad_hoc1508 {
                            crate::util_::Item__ad_hoc1508(self.0)
                        }
                        pub fn MMMMMM(&mut self) -> crate::util_::Item__ad_hoc139 {
                            crate::util_::Item__ad_hoc139(self.0)
                        }
                        pub fn field44(&mut self) -> Result<crate::util_::Item__ad_hoc1509, crate::util_::FieldI__ad_hoc1509> {
                            if self.0.base.field_bit != 1252 && !self.0.set_field(1252, -1) { return Err(crate::util_::FieldI__ad_hoc1509(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1509(self.0))
                        }
                        pub fn field634(&mut self) -> Result<crate::util_::Item__ad_hoc1510, crate::util_::FieldI__ad_hoc1510> {
                            if self.0.base.field_bit != 1253 && !self.0.set_field(1253, -1) { return Err(crate::util_::FieldI__ad_hoc1510(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1510(self.0))
                        }
                        pub fn field33344(&mut self) -> Result<crate::util_::Item__ad_hoc1511, crate::util_::FieldI__ad_hoc1511> {
                            if self.0.base.field_bit != 1254 && !self.0.set_field(1254, -1) { return Err(crate::util_::FieldI__ad_hoc1511(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1511(self.0))
                        }
                        pub fn field333634(&mut self) -> Result<crate::util_::Item__ad_hoc1512, crate::util_::FieldI__ad_hoc1512> {
                            if self.0.base.field_bit != 1255 && !self.0.set_field(1255, -1) { return Err(crate::util_::FieldI__ad_hoc1512(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1512(self.0))
                        }
                        pub fn field__(&mut self) -> crate::util_::FieldI__ad_hoc1513 {
                            crate::util_::FieldI__ad_hoc1513(self.0)
                        }
                        pub fn field63(&mut self) -> Result<crate::util_::Item__ad_hoc1515, crate::util_::FieldI__ad_hoc1515> {
                            if self.0.base.field_bit != 1257 && !self.0.set_field(1257, -1) { return Err(crate::util_::FieldI__ad_hoc1515(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1515(self.0))
                        }
                        pub fn uid2(&mut self) -> crate::util_::FieldI__ad_hoc1516 {
                            crate::util_::FieldI__ad_hoc1516(self.0)
                        }
                        pub fn field2(&mut self) -> crate::util_::FieldI__ad_hoc1517 {
                            crate::util_::FieldI__ad_hoc1517(self.0)
                        }
                        pub fn field4(&mut self) -> crate::util_::FieldI__ad_hoc1518 {
                            crate::util_::FieldI__ad_hoc1518(self.0)
                        }
                        pub fn stringtest1(&mut self) -> crate::util_::Item__ad_hoc1519 {
                            crate::util_::Item__ad_hoc1519(self.0)
                        }
                        pub fn stringtest2(&mut self) -> Result<crate::util_::Item__ad_hoc1520, crate::util_::FieldI__ad_hoc1520> {
                            if self.0.base.field_bit != 1262 && !self.0.set_field(1262, -1) { return Err(crate::util_::FieldI__ad_hoc1520(self.0)); }
                            Ok(crate::util_::Item__ad_hoc1520(self.0))
                        }
                        pub fn stringtest3(&mut self) -> crate::util_::Item__ad_hoc1521 {
                            crate::util_::Item__ad_hoc1521(self.0)
                        }
                        pub fn stringtest4(&mut self) -> crate::util_::Item__ad_hoc1522 {
                            crate::util_::Item__ad_hoc1522(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        src.TTTT().enumerate(0, 0, 0,
                                             |src, d0, d1, d2| {
                                                 dst.TTTT(src.get(d0, d1, d2), d0, d1, d2);
                                             },
                        );
                        dst.field(src.field().get());
                        dst.bit_field(src.bit_field().get());
                        src.field6().enumerate(0, 0, 0,
                                               |src, d0, d1, d2| {
                                                   dst.field6(src.get(d0, d1, d2), d0, d1, d2);
                                               },
                        );
                        dst.testBOOL2(src.testBOOL2().get());
                        dst.testBOOL3(src.testBOOL3().get());
                        if let Some(src) = src.testBOOL().get() {
                            dst.testBOOL(src);
                        }
                        if let Some(src) = src.seq().get() {
                            dst.seq(src);
                        }

                        if let Ok(mut src) = src.field1() {
                            dst.field1_init_(src.d0());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              dst.field1(src.get(d0, d1, d2), d0, d1, d2);
                                          },
                            );
                        }

                        if let Some(mut src) = src.field12().items() {
                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              dst.field12(src.get(d0, d1, d2), d0, d1, d2);
                                          },
                            );
                        }

                        if let Some(mut src) = src.field13().items() {
                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              if let Some(field13) = src.get(d0, d1, d2) {
                                                  dst.field13(field13, d0, d1, d2);
                                              }
                                          },
                            );
                        }
                        if let Some(src) = src.WWWWWWWW().get() {
                            dst.WWWWWWWW(src);
                        }
                        if let Some(src) = src.bit_field2().get() {
                            dst.bit_field2(src);
                        }

                        if let Some(mut src) = src.Field_Bits().items() {
                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              dst.Field_Bits(src.get(d0, d1, d2), d0, d1, d2);
                                          },
                            );
                        }

                        if let Ok(mut src) = src.SparseFixAllBits() {
                            dst.SparseFixAllBits_init_(src.d0());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              if let Some(SparseFixAllBits) = src.get(d0, d1, d2) {
                                                  dst.SparseFixAllBits(SparseFixAllBits, d0, d1, d2);
                                              }
                                          },
                            );
                        }

                        if let Ok(mut src) = src.FixAllBits() {
                            dst.FixAllBits_init_(src.d0());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              dst.FixAllBits(src.get(d0, d1, d2), d0, d1, d2);
                                          },
                            );
                        }

                        if let Ok(mut src) = src.VarAllBits() {
                            dst.VarAllBits_init_(src.d0(), src.d2());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              dst.VarAllBits(src.get(d0, d1, d2), d0, d1, d2);
                                          },
                            );
                        }

                        if let Ok(mut src) = src.SparseVarAllBits() {
                            dst.SparseVarAllBits_init_(src.d0(), src.d2());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              if let Some(SparseVarAllBits) = src.get(d0, d1, d2) {
                                                  dst.SparseVarAllBits(SparseVarAllBits, d0, d1, d2);
                                              }
                                          },
                            );
                        }

                        if let Ok(mut src) = src.VarEachBits() {
                            dst.VarEachBits_init_(src.d0());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              dst.VarEachBits(src.get(d0, d1, d2), d0, d1, d2);
                                          },
                            );
                        }

                        if let Ok(mut src) = src.SparsVarEachBits() {
                            dst.SparsVarEachBits_init_(src.d0());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              if let Some(SparsVarEachBits) = src.get(d0, d1, d2) {
                                                  dst.SparsVarEachBits(SparsVarEachBits, d0, d1, d2);
                                              }
                                          },
                            );
                        }
                        if let Some(src) = src.testBOOLX().get() {
                            dst.testBOOLX(src);
                        }
                        if let Some(src) = src.testBOOL2X().get() {
                            dst.testBOOL2X(src);
                        }
                        if let Some(src) = src.testBOOL3X().get() {
                            dst.testBOOL3X(src);
                        }
                        if let Some(src) = src.MMMMMM().get() {
                            dst.MMMMMM(src);
                        }

                        if let Ok(mut src) = src.field44() {
                            dst.field44_init_(src.d2());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              dst.field44(src.get(d0, d1, d2), d0, d1, d2);
                                          },
                            );
                        }

                        if let Ok(mut src) = src.field634() {
                            dst.field634_init_(src.d2());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              dst.field634(src.get(d0, d1, d2), d0, d1, d2);
                                          },
                            );
                        }

                        if let Ok(mut src) = src.field33344() {
                            dst.field33344_init_(src.d2());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              if let Some(field33344) = src.get(d0, d1, d2) {
                                                  dst.field33344(field33344, d0, d1, d2);
                                              }
                                          },
                            );
                        }

                        if let Ok(mut src) = src.field333634() {
                            dst.field333634_init_(src.d2());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              if let Some(field333634) = src.get(d0, d1, d2) {
                                                  dst.field333634(field333634, d0, d1, d2);
                                              }
                                          },
                            );
                        }

                        if let Some(mut src) = src.field__().items() {
                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              if let Some(field__) = src.get(d0, d1, d2) {
                                                  dst.field__(field__, d0, d1, d2);
                                              }
                                          },
                            );
                        }

                        if let Ok(mut src) = src.field63() {
                            dst.field63_init_(src.d2());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              dst.field63(src.get(d0, d1, d2), d0, d1, d2);
                                          },
                            );
                        }

                        if let Some(mut src) = src.uid2().items() {
                            src.enumerate(0,
                                          |src, d0| {
                                              if let Some(uid2) = src.get(d0) {
                                                  dst.uid2(uid2, d0);
                                              }
                                          },
                            );
                        }

                        if let Some(mut src) = src.field2().items() {
                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              if let Some(field2) = src.get(d0, d1, d2) {
                                                  dst.field2(field2, d0, d1, d2);
                                              }
                                          },
                            );
                        }

                        if let Some(mut src) = src.field4().items() {
                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              if let Some(field4) = src.get(d0, d1, d2) {
                                                  dst.field4(field4, d0, d1, d2);
                                              }
                                          },
                            );
                        }
                        if let Some(src) = src.stringtest1().get() {
                            dst.stringtest1(src);
                        }

                        if let Ok(mut src) = src.stringtest2() {
                            dst.stringtest2_init_(src.d2());

                            src.enumerate(0, 0, 0,
                                          |src, d0, d1, d2| {
                                              if let Some(src) = src.get(d0, d1, d2) {
                                                  dst.stringtest2(src, d0, d1, d2);
                                              }
                                          },
                            );
                        }
                        if let Some(src) = src.stringtest3().get() {
                            dst.stringtest3(src);
                        }
                        if let Some(src) = src.stringtest4().get() {
                            dst.stringtest4(src);
                        }
                    }

                    pub trait DST_ {
                        fn TTTT(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn field(&mut self, src: i64);
                        fn bit_field(&mut self, src: i8);
                        fn field6(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn testBOOL2(&mut self, src: bool);
                        fn testBOOL3(&mut self, src: bool);
                        fn testBOOL(&mut self, src: bool);
                        fn seq(&mut self, src: i64);
                        fn field1_init_(&mut self, d0: usize);
                        fn field1(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn field12(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn field13(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn WWWWWWWW(&mut self, src: i32);
                        fn bit_field2(&mut self, src: i8);
                        fn Field_Bits(&mut self, src: i8, d0: usize, d1: usize, d2: usize);
                        fn SparseFixAllBits_init_(&mut self, d0: usize);
                        fn SparseFixAllBits(&mut self, src: i8, d0: usize, d1: usize, d2: usize);
                        fn FixAllBits_init_(&mut self, d0: usize);
                        fn FixAllBits(&mut self, src: i8, d0: usize, d1: usize, d2: usize);
                        fn VarAllBits_init_(&mut self, d0: usize, d2: usize);
                        fn VarAllBits(&mut self, src: i8, d0: usize, d1: usize, d2: usize);
                        fn SparseVarAllBits_init_(&mut self, d0: usize, d2: usize);
                        fn SparseVarAllBits(&mut self, src: i8, d0: usize, d1: usize, d2: usize);
                        fn VarEachBits_init_(&mut self, d0: usize);
                        fn VarEachBits(&mut self, src: i8, d0: usize, d1: usize, d2: usize);
                        fn SparsVarEachBits_init_(&mut self, d0: usize);
                        fn SparsVarEachBits(&mut self, src: i16, d0: usize, d1: usize, d2: usize);
                        fn testBOOLX(&mut self, src: bool);
                        fn testBOOL2X(&mut self, src: bool);
                        fn testBOOL3X(&mut self, src: bool);
                        fn MMMMMM(&mut self, src: packs::MAV_MODE);
                        fn field44_init_(&mut self, d2: usize);
                        fn field44(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn field634_init_(&mut self, d2: usize);
                        fn field634(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn field33344_init_(&mut self, d2: usize);
                        fn field33344(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn field333634_init_(&mut self, d2: usize);
                        fn field333634(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn field__(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn field63_init_(&mut self, d2: usize);
                        fn field63(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn uid2(&mut self, src: i8, d0: usize);
                        fn field2(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn field4(&mut self, src: i32, d0: usize, d1: usize, d2: usize);
                        fn stringtest1(&mut self, src: &str);
                        fn stringtest2_init_(&mut self, d2: usize);
                        fn stringtest2(&mut self, src: &str, d0: usize, d1: usize, d2: usize);
                        fn stringtest3(&mut self, src: &str);
                        fn stringtest4(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn TTTT(&mut self, d0: usize, d1: usize, d2: usize) -> i32;
                        fn field(&mut self) -> i64;
                        fn bit_field(&mut self) -> i8;
                        fn field6(&mut self, d0: usize, d1: usize, d2: usize) -> i32;
                        fn testBOOL2(&mut self) -> bool;
                        fn testBOOL3(&mut self) -> bool;
                        fn testBOOL(&mut self) -> Option<bool>;
                        fn seq(&mut self) -> Option<i64>;
                        fn field1_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1490);
                        fn field1(&mut self, d0: usize, d1: usize, d2: usize) -> i32;
                        fn field12_exists_(&mut self) -> bool;
                        fn field12(&mut self, d0: usize, d1: usize, d2: usize) -> i32;
                        fn field13_exists_(&mut self) -> bool;
                        fn field13(&mut self, d0: usize, d1: usize, d2: usize) -> Option<i32>;
                        fn WWWWWWWW(&mut self) -> Option<i32>;
                        fn bit_field2(&mut self) -> Option<i8>;
                        fn Field_Bits_exists_(&mut self) -> bool;
                        fn Field_Bits(&mut self, d0: usize, d1: usize, d2: usize) -> i8;
                        fn SparseFixAllBits_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1500);
                        fn SparseFixAllBits(&mut self, d0: usize, d1: usize, d2: usize) -> Option<i8>;
                        fn FixAllBits_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1501);
                        fn FixAllBits(&mut self, d0: usize, d1: usize, d2: usize) -> i8;
                        fn VarAllBits_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1502);
                        fn VarAllBits(&mut self, d0: usize, d1: usize, d2: usize) -> i8;
                        fn SparseVarAllBits_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1503);
                        fn SparseVarAllBits(&mut self, d0: usize, d1: usize, d2: usize) -> Option<i8>;
                        fn VarEachBits_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1504);
                        fn VarEachBits(&mut self, d0: usize, d1: usize, d2: usize) -> i8;
                        fn SparsVarEachBits_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1505);
                        fn SparsVarEachBits(&mut self, d0: usize, d1: usize, d2: usize) -> Option<i16>;
                        fn testBOOLX(&mut self) -> Option<bool>;
                        fn testBOOL2X(&mut self) -> Option<bool>;
                        fn testBOOL3X(&mut self) -> Option<bool>;
                        fn MMMMMM(&mut self) -> Option<packs::MAV_MODE>;
                        fn field44_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1509);
                        fn field44(&mut self, d0: usize, d1: usize, d2: usize) -> i32;
                        fn field634_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1510);
                        fn field634(&mut self, d0: usize, d1: usize, d2: usize) -> i32;
                        fn field33344_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1511);
                        fn field33344(&mut self, d0: usize, d1: usize, d2: usize) -> Option<i32>;
                        fn field333634_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1512);
                        fn field333634(&mut self, d0: usize, d1: usize, d2: usize) -> Option<i32>;
                        fn field___exists_(&mut self) -> bool;
                        fn field__(&mut self, d0: usize, d1: usize, d2: usize) -> Option<i32>;
                        fn field63_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1515);
                        fn field63(&mut self, d0: usize, d1: usize, d2: usize) -> i32;
                        fn uid2_exists_(&mut self) -> bool;
                        fn uid2(&mut self, d0: usize) -> Option<i8>;
                        fn field2_exists_(&mut self) -> bool;
                        fn field2(&mut self, d0: usize, d1: usize, d2: usize) -> Option<i32>;
                        fn field4_exists_(&mut self) -> bool;
                        fn field4(&mut self, d0: usize, d1: usize, d2: usize) -> Option<i32>;
                        fn stringtest1_item_exists_(&mut self) -> usize;
                        fn stringtest1(&mut self, dst: &mut [u8]);
                        fn stringtest2_exists_(&mut self, init: crate::util_::FieldI__ad_hoc1520);
                        fn stringtest2_item_exists_(&mut self, d0: usize, d1: usize, d2: usize) -> usize;
                        fn stringtest2(&mut self, dst: &mut [u8], d0: usize, d1: usize, d2: usize);
                        fn stringtest3_item_exists_(&mut self) -> usize;
                        fn stringtest3(&mut self, dst: &mut [u8]);
                        fn stringtest4_item_exists_(&mut self) -> usize;
                        fn stringtest4(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.TTTT().enumerate(0, 0, 0,
                                             |dst, d0, d1, d2| {
                                                 dst.set(src.TTTT(d0, d1, d2), d0, d1, d2);
                                             },
                        );
                        dst.field().set(src.field());
                        dst.bit_field().set(src.bit_field());
                        dst.field6().enumerate(0, 0, 0,
                                               |dst, d0, d1, d2| {
                                                   dst.set(src.field6(d0, d1, d2), d0, d1, d2);
                                               },
                        );
                        dst.testBOOL2().set(src.testBOOL2());
                        dst.testBOOL3().set(src.testBOOL3());
                        if let Some(src) = src.testBOOL() {
                            dst.testBOOL().set(src);
                        }
                        if let Some(src) = src.seq() {
                            dst.seq().set(src);
                        }

                        src.field1_exists_(crate::util_::FieldI__ad_hoc1490(dst.0));
                        if let Ok(mut dst) = dst.field1() {
                            for d0 in 0..dst.d0() {
                                for d1 in 0..packs::PING33::field1::d1 {
                                    for d2 in 0..packs::PING33::field1::d2 {
                                        dst.set(src.field1(d0, d1, d2), d0, d1, d2);
                                    }
                                }
                            }
                        }

                        if src.field12_exists_() {
                            dst.0.set_field(1237, 0);
                            let mut dst = dst.field12();
                            for d0 in 0..packs::PING33::field12::d0 {
                                for d1 in 0..packs::PING33::field12::d1 {
                                    for d2 in 0..packs::PING33::field12::d2 {
                                        dst.set(src.field12(d0, d1, d2), d0, d1, d2);
                                    }
                                }
                            }
                        }

                        if src.field13_exists_() {
                            dst.0.set_field(1238, 0);
                            let mut dst = dst.field13();
                            for d0 in 0..packs::PING33::field13::d0 {
                                for d1 in 0..packs::PING33::field13::d1 {
                                    for d2 in 0..packs::PING33::field13::d2 {
                                        if let Some(src) = src.field13(d0, d1, d2) {
                                            dst.set(src, d0, d1, d2);
                                        }
                                    }
                                }
                            }
                        }
                        if let Some(src) = src.WWWWWWWW() {
                            dst.WWWWWWWW().set(src);
                        }
                        if let Some(src) = src.bit_field2() {
                            dst.bit_field2().set(src);
                        }

                        if src.Field_Bits_exists_() {
                            dst.0.set_field(1241, 0);
                            let mut dst = dst.Field_Bits();
                            for d0 in 0..packs::PING33::Field_Bits::d0 {
                                for d1 in 0..packs::PING33::Field_Bits::d1 {
                                    for d2 in 0..packs::PING33::Field_Bits::d2 {
                                        dst.set(src.Field_Bits(d0, d1, d2), d0, d1, d2);
                                    }
                                }
                            }
                        }

                        src.SparseFixAllBits_exists_(crate::util_::FieldI__ad_hoc1500(dst.0));
                        if let Ok(mut dst) = dst.SparseFixAllBits() {
                            for d0 in 0..dst.d0() {
                                for d1 in 0..packs::PING33::SparseFixAllBits::d1 {
                                    for d2 in 0..packs::PING33::SparseFixAllBits::d2 {
                                        if let Some(src) = src.SparseFixAllBits(d0, d1, d2) {
                                            dst.set(src, d0, d1, d2);
                                        }
                                    }
                                }
                            }
                        }

                        src.FixAllBits_exists_(crate::util_::FieldI__ad_hoc1501(dst.0));
                        if let Ok(mut dst) = dst.FixAllBits() {
                            for d0 in 0..dst.d0() {
                                for d1 in 0..packs::PING33::FixAllBits::d1 {
                                    for d2 in 0..packs::PING33::FixAllBits::d2 {
                                        dst.set(src.FixAllBits(d0, d1, d2), d0, d1, d2);
                                    }
                                }
                            }
                        }

                        src.VarAllBits_exists_(crate::util_::FieldI__ad_hoc1502(dst.0));
                        if let Ok(mut dst) = dst.VarAllBits() {
                            for d0 in 0..dst.d0() {
                                for d1 in 0..packs::PING33::VarAllBits::d1 {
                                    for d2 in 0..dst.d2() {
                                        dst.set(src.VarAllBits(d0, d1, d2), d0, d1, d2);
                                    }
                                }
                            }
                        }

                        src.SparseVarAllBits_exists_(crate::util_::FieldI__ad_hoc1503(dst.0));
                        if let Ok(mut dst) = dst.SparseVarAllBits() {
                            for d0 in 0..dst.d0() {
                                for d1 in 0..packs::PING33::SparseVarAllBits::d1 {
                                    for d2 in 0..dst.d2() {
                                        if let Some(src) = src.SparseVarAllBits(d0, d1, d2) {
                                            dst.set(src, d0, d1, d2);
                                        }
                                    }
                                }
                            }
                        }

                        src.VarEachBits_exists_(crate::util_::FieldI__ad_hoc1504(dst.0));
                        if let Ok(mut dst) = dst.VarEachBits() {
                            for d0 in 0..dst.d0() {
                                for d1 in 0..packs::PING33::VarEachBits::d1 {
                                    for d2 in 0..packs::PING33::VarEachBits::d2 {
                                        dst.set(src.VarEachBits(d0, d1, d2), d0, d1, d2);
                                    }
                                }
                            }
                        }

                        src.SparsVarEachBits_exists_(crate::util_::FieldI__ad_hoc1505(dst.0));
                        if let Ok(mut dst) = dst.SparsVarEachBits() {
                            for d0 in 0..dst.d0() {
                                for d1 in 0..packs::PING33::SparsVarEachBits::d1 {
                                    for d2 in 0..packs::PING33::SparsVarEachBits::d2 {
                                        if let Some(src) = src.SparsVarEachBits(d0, d1, d2) {
                                            dst.set(src, d0, d1, d2);
                                        }
                                    }
                                }
                            }
                        }
                        if let Some(src) = src.testBOOLX() {
                            dst.testBOOLX().set(src);
                        }
                        if let Some(src) = src.testBOOL2X() {
                            dst.testBOOL2X().set(src);
                        }
                        if let Some(src) = src.testBOOL3X() {
                            dst.testBOOL3X().set(src);
                        }
                        if let Some(src) = src.MMMMMM() {
                            dst.MMMMMM().set(src);
                        }

                        src.field44_exists_(crate::util_::FieldI__ad_hoc1509(dst.0));
                        if let Ok(mut dst) = dst.field44() {
                            for d0 in 0..packs::PING33::field44::d0 {
                                for d1 in 0..packs::PING33::field44::d1 {
                                    for d2 in 0..dst.d2() {
                                        dst.set(src.field44(d0, d1, d2), d0, d1, d2);
                                    }
                                }
                            }
                        }

                        src.field634_exists_(crate::util_::FieldI__ad_hoc1510(dst.0));
                        if let Ok(mut dst) = dst.field634() {
                            for d0 in 0..packs::PING33::field634::d0 {
                                for d1 in 0..packs::PING33::field634::d1 {
                                    for d2 in 0..dst.d2() {
                                        dst.set(src.field634(d0, d1, d2), d0, d1, d2);
                                    }
                                }
                            }
                        }

                        src.field33344_exists_(crate::util_::FieldI__ad_hoc1511(dst.0));
                        if let Ok(mut dst) = dst.field33344() {
                            for d0 in 0..packs::PING33::field33344::d0 {
                                for d1 in 0..packs::PING33::field33344::d1 {
                                    for d2 in 0..dst.d2() {
                                        if let Some(src) = src.field33344(d0, d1, d2) {
                                            dst.set(src, d0, d1, d2);
                                        }
                                    }
                                }
                            }
                        }

                        src.field333634_exists_(crate::util_::FieldI__ad_hoc1512(dst.0));
                        if let Ok(mut dst) = dst.field333634() {
                            for d0 in 0..packs::PING33::field333634::d0 {
                                for d1 in 0..packs::PING33::field333634::d1 {
                                    for d2 in 0..dst.d2() {
                                        if let Some(src) = src.field333634(d0, d1, d2) {
                                            dst.set(src, d0, d1, d2);
                                        }
                                    }
                                }
                            }
                        }

                        if src.field___exists_() {
                            dst.0.set_field(1256, 0);
                            let mut dst = dst.field__();
                            for d0 in 0..packs::PING33::field__::d0 {
                                for d1 in 0..packs::PING33::field__::d1 {
                                    for d2 in 0..packs::PING33::field__::d2 {
                                        if let Some(src) = src.field__(d0, d1, d2) {
                                            dst.set(src, d0, d1, d2);
                                        }
                                    }
                                }
                            }
                        }

                        src.field63_exists_(crate::util_::FieldI__ad_hoc1515(dst.0));
                        if let Ok(mut dst) = dst.field63() {
                            for d0 in 0..packs::PING33::field63::d0 {
                                for d1 in 0..packs::PING33::field63::d1 {
                                    for d2 in 0..dst.d2() {
                                        dst.set(src.field63(d0, d1, d2), d0, d1, d2);
                                    }
                                }
                            }
                        }

                        if src.uid2_exists_() {
                            dst.0.set_field(1258, 0);
                            let mut dst = dst.uid2();
                            for d0 in 0..packs::PING33::uid2::d0 {
                                if let Some(src) = src.uid2(d0) {
                                    dst.set(src, d0);
                                }
                            }
                        }

                        if src.field2_exists_() {
                            dst.0.set_field(1259, 0);
                            let mut dst = dst.field2();
                            for d0 in 0..packs::PING33::field2::d0 {
                                for d1 in 0..packs::PING33::field2::d1 {
                                    for d2 in 0..packs::PING33::field2::d2 {
                                        if let Some(src) = src.field2(d0, d1, d2) {
                                            dst.set(src, d0, d1, d2);
                                        }
                                    }
                                }
                            }
                        }

                        if src.field4_exists_() {
                            dst.0.set_field(1260, 0);
                            let mut dst = dst.field4();
                            for d0 in 0..packs::PING33::field4::d0 {
                                for d1 in 0..packs::PING33::field4::d1 {
                                    for d2 in 0..packs::PING33::field4::d2 {
                                        if let Some(src) = src.field4(d0, d1, d2) {
                                            dst.set(src, d0, d1, d2);
                                        }
                                    }
                                }
                            }
                        }
                        let len = src.stringtest1_item_exists_();
                        if 0 < len {
                            dst.0.set_field(1261, len as i32);

                            src.stringtest1(unsafe { dst.0.get_str().as_bytes_mut() });
                        }

                        src.stringtest2_exists_(crate::util_::FieldI__ad_hoc1520(dst.0));
                        if let Ok(mut dst) = dst.stringtest2() {
                            for d0 in 0..packs::PING33::stringtest2::d0 {
                                for d1 in 0..packs::PING33::stringtest2::d1 {
                                    for d2 in 0..dst.d2() {
                                        let len = src.stringtest2_item_exists_(d0, d1, d2);
                                        if 0 < len {
                                            dst.0.set_item(d0 + d1 * 3 + d2 * 3 * 2, len as i32);
                                            src.stringtest2(unsafe { dst.0.get_str().as_bytes_mut() }, d0, d1, d2);
                                        }
                                    }
                                }
                            }
                        }
                        let len = src.stringtest3_item_exists_();
                        if 0 < len {
                            dst.0.set_field(1263, len as i32);

                            src.stringtest3(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                        let len = src.stringtest4_item_exists_();
                        if 0 < len {
                            dst.0.set_field(1264, len as i32);

                            src.stringtest4(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod TTTT {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2: usize = 3;
                    }

                    pub mod field6 {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2: usize = 3;
                    }

                    pub mod field1 {
                        pub const d0_max: usize = 7;
                        pub const d1: usize = 2;
                        pub const d2: usize = 3;
                    }

                    pub mod field12 {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2: usize = 3;
                    }

                    pub mod field13 {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2: usize = 3;
                    }

                    pub mod Field_Bits {
                        pub const d0: usize = 3;
                        pub const d1: usize = 3;
                        pub const d2: usize = 3;
                    }

                    pub mod SparseFixAllBits {
                        pub const d0_max: usize = 3;
                        pub const d1: usize = 3;
                        pub const d2: usize = 3;
                    }

                    pub mod FixAllBits {
                        pub const d0_max: usize = 3;
                        pub const d1: usize = 3;
                        pub const d2: usize = 3;
                    }

                    pub mod VarAllBits {
                        pub const d0_max: usize = 3;
                        pub const d1: usize = 3;
                        pub const d2_max: usize = 3;
                    }

                    pub mod SparseVarAllBits {
                        pub const d0_max: usize = 3;
                        pub const d1: usize = 3;
                        pub const d2_max: usize = 3;
                    }

                    pub mod VarEachBits {
                        pub const d0_max: usize = 3;
                        pub const d1: usize = 3;
                        pub const d2: usize = 3;
                    }

                    pub mod SparsVarEachBits {
                        pub const d0_max: usize = 3;
                        pub const d1: usize = 3;
                        pub const d2: usize = 3;
                    }

                    pub mod field44 {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2_max: usize = 3;
                    }

                    pub mod field634 {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2_max: usize = 3;
                    }

                    pub mod field33344 {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2_max: usize = 3;
                    }

                    pub mod field333634 {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2_max: usize = 3;
                    }

                    pub mod field__ {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2: usize = 3;
                    }

                    pub mod field63 {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2_max: usize = 3;
                    }

                    pub mod uid2 {
                        pub const d0: usize = 18;
                    }

                    pub mod field2 {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2: usize = 3;
                    }

                    pub mod field4 {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2: usize = 3;
                    }

                    pub mod stringtest1 {
                        pub const len_max: usize = 255usize;
                    }

                    pub mod stringtest2 {
                        pub const d0: usize = 3;
                        pub const d1: usize = 2;
                        pub const d2_max: usize = 3;
                        pub const len_max: usize = 255usize;
                    }

                    pub mod stringtest3 {
                        pub const len_max: usize = 255usize;
                    }

                    pub mod stringtest4 {
                        pub const len_max: usize = 255usize;
                    }

                    pub const const3: i32 = 56i32;
                    //56
                    pub const stati_cconst1: i32 = 1i32;
                    //1
                    pub const stati_cconst1D: f32 = 1.456f32;
                    //(float)1.456
                    pub const const3D: f32 = 56.555f32;//(float)56.555
                }

                /**
*Metrics typically displayed on a HUD for fixed wing aircraft */

                pub mod VFR_HUD {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::VFR_HUD) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn throttle(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn airspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 2, 4usize) as u32)
                        }
                        pub fn groundspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 6, 4usize) as u32)
                        }
                        pub fn heading(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 10, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn alt(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 12, 4usize) as u32)
                        }
                        pub fn climb(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 16, 4usize) as u32)
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.throttle(src.throttle());
                        dst.airspeed(src.airspeed());
                        dst.groundspeed(src.groundspeed());
                        dst.heading(src.heading());
                        dst.alt(src.alt());
                        dst.climb(src.climb());
                    }

                    pub trait DST_ {
                        fn throttle(&mut self, src: i16);
                        fn airspeed(&mut self, src: f32);
                        fn groundspeed(&mut self, src: f32);
                        fn heading(&mut self, src: i16);
                        fn alt(&mut self, src: f32);
                        fn climb(&mut self, src: f32);
                    }
                }

                /**
*GCS */

                pub mod RALLY_POINT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RALLY_POINT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn land_dir(&mut self) -> crate::util_::Item__ad_hoc2285 {
                            crate::util_::Item__ad_hoc2285(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2277 {
                            crate::util_::Item__ad_hoc2277(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2278 {
                            crate::util_::Item__ad_hoc2278(self.0)
                        }
                        pub fn idx(&mut self) -> crate::util_::Item__ad_hoc2279 {
                            crate::util_::Item__ad_hoc2279(self.0)
                        }
                        pub fn count(&mut self) -> crate::util_::Item__ad_hoc2280 {
                            crate::util_::Item__ad_hoc2280(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc2281 {
                            crate::util_::Item__ad_hoc2281(self.0)
                        }
                        pub fn lng(&mut self) -> crate::util_::Item__ad_hoc2282 {
                            crate::util_::Item__ad_hoc2282(self.0)
                        }
                        pub fn alt(&mut self) -> crate::util_::Item__ad_hoc2283 {
                            crate::util_::Item__ad_hoc2283(self.0)
                        }
                        pub fn break_alt(&mut self) -> crate::util_::Item__ad_hoc2284 {
                            crate::util_::Item__ad_hoc2284(self.0)
                        }
                        pub fn flags(&mut self) -> crate::util_::Item__ad_hoc645 {
                            crate::util_::Item__ad_hoc645(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.land_dir(src.land_dir().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.idx(src.idx().get());
                        dst.count(src.count().get());
                        dst.lat(src.lat().get());
                        dst.lng(src.lng().get());
                        dst.alt(src.alt().get());
                        dst.break_alt(src.break_alt().get());
                        if let Some(src) = src.flags().get() {
                            dst.flags(src);
                        }
                    }

                    pub trait DST_ {
                        fn land_dir(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn idx(&mut self, src: i8);
                        fn count(&mut self, src: i8);
                        fn lat(&mut self, src: i32);
                        fn lng(&mut self, src: i32);
                        fn alt(&mut self, src: i16);
                        fn break_alt(&mut self, src: i16);
                        fn flags(&mut self, src: packs::RALLY_FLAGS);
                    }

                    pub trait SRC_ {
                        fn land_dir(&mut self) -> i16;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn idx(&mut self) -> i8;
                        fn count(&mut self) -> i8;
                        fn lat(&mut self) -> i32;
                        fn lng(&mut self) -> i32;
                        fn alt(&mut self) -> i16;
                        fn break_alt(&mut self) -> i16;
                        fn flags(&mut self) -> Option<packs::RALLY_FLAGS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.land_dir().set(src.land_dir());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.idx().set(src.idx());
                        dst.count().set(src.count());
                        dst.lat().set(src.lat());
                        dst.lng().set(src.lng());
                        dst.alt().set(src.alt());
                        dst.break_alt().set(src.break_alt());
                        if let Some(src) = src.flags() {
                            dst.flags().set(src);
                        }
                    }
                }

                /**
*Set the mission item with sequence number seq as current item. This means that the MAV will continue to
*				 this mission item on the shortest path (not following the mission items in-between) */

                pub mod MISSION_SET_CURRENT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_SET_CURRENT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn seq(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 3, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.seq(src.seq());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                    }

                    pub trait DST_ {
                        fn seq(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }
                }

                /**
*Adaptive Controller tuning information */

                pub mod ADAP_TUNING {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::ADAP_TUNING) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn desired(&mut self) -> crate::util_::Item__ad_hoc2433 {
                            crate::util_::Item__ad_hoc2433(self.0)
                        }
                        pub fn achieved(&mut self) -> crate::util_::Item__ad_hoc2434 {
                            crate::util_::Item__ad_hoc2434(self.0)
                        }
                        pub fn error(&mut self) -> crate::util_::Item__ad_hoc2435 {
                            crate::util_::Item__ad_hoc2435(self.0)
                        }
                        pub fn theta(&mut self) -> crate::util_::Item__ad_hoc2436 {
                            crate::util_::Item__ad_hoc2436(self.0)
                        }
                        pub fn omega(&mut self) -> crate::util_::Item__ad_hoc2437 {
                            crate::util_::Item__ad_hoc2437(self.0)
                        }
                        pub fn sigma(&mut self) -> crate::util_::Item__ad_hoc2438 {
                            crate::util_::Item__ad_hoc2438(self.0)
                        }
                        pub fn theta_dot(&mut self) -> crate::util_::Item__ad_hoc2439 {
                            crate::util_::Item__ad_hoc2439(self.0)
                        }
                        pub fn omega_dot(&mut self) -> crate::util_::Item__ad_hoc2440 {
                            crate::util_::Item__ad_hoc2440(self.0)
                        }
                        pub fn sigma_dot(&mut self) -> crate::util_::Item__ad_hoc2441 {
                            crate::util_::Item__ad_hoc2441(self.0)
                        }
                        pub fn f(&mut self) -> crate::util_::Item__ad_hoc2442 {
                            crate::util_::Item__ad_hoc2442(self.0)
                        }
                        pub fn f_dot(&mut self) -> crate::util_::Item__ad_hoc2443 {
                            crate::util_::Item__ad_hoc2443(self.0)
                        }
                        pub fn u(&mut self) -> crate::util_::Item__ad_hoc2444 {
                            crate::util_::Item__ad_hoc2444(self.0)
                        }
                        pub fn axis(&mut self) -> crate::util_::Item__ad_hoc963 {
                            crate::util_::Item__ad_hoc963(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.desired(src.desired().get());
                        dst.achieved(src.achieved().get());
                        dst.error(src.error().get());
                        dst.theta(src.theta().get());
                        dst.omega(src.omega().get());
                        dst.sigma(src.sigma().get());
                        dst.theta_dot(src.theta_dot().get());
                        dst.omega_dot(src.omega_dot().get());
                        dst.sigma_dot(src.sigma_dot().get());
                        dst.f(src.f().get());
                        dst.f_dot(src.f_dot().get());
                        dst.u(src.u().get());
                        if let Some(src) = src.axis().get() {
                            dst.axis(src);
                        }
                    }

                    pub trait DST_ {
                        fn desired(&mut self, src: f32);
                        fn achieved(&mut self, src: f32);
                        fn error(&mut self, src: f32);
                        fn theta(&mut self, src: f32);
                        fn omega(&mut self, src: f32);
                        fn sigma(&mut self, src: f32);
                        fn theta_dot(&mut self, src: f32);
                        fn omega_dot(&mut self, src: f32);
                        fn sigma_dot(&mut self, src: f32);
                        fn f(&mut self, src: f32);
                        fn f_dot(&mut self, src: f32);
                        fn u(&mut self, src: f32);
                        fn axis(&mut self, src: packs::PID_TUNING_AXIS);
                    }

                    pub trait SRC_ {
                        fn desired(&mut self) -> f32;
                        fn achieved(&mut self) -> f32;
                        fn error(&mut self) -> f32;
                        fn theta(&mut self) -> f32;
                        fn omega(&mut self) -> f32;
                        fn sigma(&mut self) -> f32;
                        fn theta_dot(&mut self) -> f32;
                        fn omega_dot(&mut self) -> f32;
                        fn sigma_dot(&mut self) -> f32;
                        fn f(&mut self) -> f32;
                        fn f_dot(&mut self) -> f32;
                        fn u(&mut self) -> f32;
                        fn axis(&mut self) -> Option<packs::PID_TUNING_AXIS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.desired().set(src.desired());
                        dst.achieved().set(src.achieved());
                        dst.error().set(src.error());
                        dst.theta().set(src.theta());
                        dst.omega().set(src.omega());
                        dst.sigma().set(src.sigma());
                        dst.theta_dot().set(src.theta_dot());
                        dst.omega_dot().set(src.omega_dot());
                        dst.sigma_dot().set(src.sigma_dot());
                        dst.f().set(src.f());
                        dst.f_dot().set(src.f_dot());
                        dst.u().set(src.u());
                        if let Some(src) = src.axis() {
                            dst.axis().set(src);
                        }
                    }
                }

                /**
*Vibration levels and accelerometer clipping */

                pub mod VIBRATION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::VIBRATION) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn clipping_0(&mut self) -> crate::util_::Item__ad_hoc1929 {
                            crate::util_::Item__ad_hoc1929(self.0)
                        }
                        pub fn clipping_1(&mut self) -> crate::util_::Item__ad_hoc1930 {
                            crate::util_::Item__ad_hoc1930(self.0)
                        }
                        pub fn clipping_2(&mut self) -> crate::util_::Item__ad_hoc1931 {
                            crate::util_::Item__ad_hoc1931(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1925 {
                            crate::util_::Item__ad_hoc1925(self.0)
                        }
                        pub fn vibration_x(&mut self) -> crate::util_::Item__ad_hoc1926 {
                            crate::util_::Item__ad_hoc1926(self.0)
                        }
                        pub fn vibration_y(&mut self) -> crate::util_::Item__ad_hoc1927 {
                            crate::util_::Item__ad_hoc1927(self.0)
                        }
                        pub fn vibration_z(&mut self) -> crate::util_::Item__ad_hoc1928 {
                            crate::util_::Item__ad_hoc1928(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.clipping_0(src.clipping_0().get());
                        dst.clipping_1(src.clipping_1().get());
                        dst.clipping_2(src.clipping_2().get());
                        dst.time_usec(src.time_usec().get());
                        dst.vibration_x(src.vibration_x().get());
                        dst.vibration_y(src.vibration_y().get());
                        dst.vibration_z(src.vibration_z().get());
                    }

                    pub trait DST_ {
                        fn clipping_0(&mut self, src: i32);
                        fn clipping_1(&mut self, src: i32);
                        fn clipping_2(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                        fn vibration_x(&mut self, src: f32);
                        fn vibration_y(&mut self, src: f32);
                        fn vibration_z(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn clipping_0(&mut self) -> i32;
                        fn clipping_1(&mut self) -> i32;
                        fn clipping_2(&mut self) -> i32;
                        fn time_usec(&mut self) -> i64;
                        fn vibration_x(&mut self) -> f32;
                        fn vibration_y(&mut self) -> f32;
                        fn vibration_z(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.clipping_0().set(src.clipping_0());
                        dst.clipping_1().set(src.clipping_1());
                        dst.clipping_2().set(src.clipping_2());
                        dst.time_usec().set(src.time_usec());
                        dst.vibration_x().set(src.vibration_x());
                        dst.vibration_y().set(src.vibration_y());
                        dst.vibration_z().set(src.vibration_z());
                    }
                }

                /**
*Emit the value of a parameter. The inclusion of param_count and param_index in the message allows the
*				 recipient to keep track of received parameters and allows them to re-request missing parameters after
*				 a loss or timeout */

                pub mod PARAM_EXT_VALUE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PARAM_EXT_VALUE) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn param_count(&mut self) -> crate::util_::Item__ad_hoc2112 {
                            crate::util_::Item__ad_hoc2112(self.0)
                        }
                        pub fn param_index(&mut self) -> crate::util_::Item__ad_hoc2113 {
                            crate::util_::Item__ad_hoc2113(self.0)
                        }
                        pub fn param_id(&mut self) -> crate::util_::Item__ad_hoc2110 {
                            crate::util_::Item__ad_hoc2110(self.0)
                        }
                        pub fn param_value(&mut self) -> crate::util_::Item__ad_hoc2111 {
                            crate::util_::Item__ad_hoc2111(self.0)
                        }
                        pub fn param_type(&mut self) -> crate::util_::Item__ad_hoc411 {
                            crate::util_::Item__ad_hoc411(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.param_count(src.param_count().get());
                        dst.param_index(src.param_index().get());
                        if let Some(src) = src.param_id().get() {
                            dst.param_id(src);
                        }
                        if let Some(src) = src.param_value().get() {
                            dst.param_value(src);
                        }
                        if let Some(src) = src.param_type().get() {
                            dst.param_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn param_count(&mut self, src: i16);
                        fn param_index(&mut self, src: i16);
                        fn param_id(&mut self, src: &str);
                        fn param_value(&mut self, src: &str);
                        fn param_type(&mut self, src: packs::MAV_PARAM_EXT_TYPE);
                    }

                    pub trait SRC_ {
                        fn param_count(&mut self) -> i16;
                        fn param_index(&mut self) -> i16;
                        fn param_id_item_exists_(&mut self) -> usize;
                        fn param_id(&mut self, dst: &mut [u8]);
                        fn param_value_item_exists_(&mut self) -> usize;
                        fn param_value(&mut self, dst: &mut [u8]);
                        fn param_type(&mut self) -> Option<packs::MAV_PARAM_EXT_TYPE>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.param_count().set(src.param_count());
                        dst.param_index().set(src.param_index());
                        let len = src.param_id_item_exists_();
                        if 0 < len {
                            dst.0.set_field(35, len as i32);

                            src.param_id(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                        let len = src.param_value_item_exists_();
                        if 0 < len {
                            dst.0.set_field(36, len as i32);

                            src.param_value(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                        if let Some(src) = src.param_type() {
                            dst.param_type().set(src);
                        }
                    }

                    pub mod param_id {
                        pub const len_max: usize = 255usize;
                    }

                    pub mod param_value {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*2nd Battery status */

                pub mod BATTERY2 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::BATTERY2) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn voltage(&mut self) -> crate::util_::Item__ad_hoc2321 {
                            crate::util_::Item__ad_hoc2321(self.0)
                        }
                        pub fn current_battery(&mut self) -> crate::util_::Item__ad_hoc2322 {
                            crate::util_::Item__ad_hoc2322(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.voltage(src.voltage().get());
                        dst.current_battery(src.current_battery().get());
                    }

                    pub trait DST_ {
                        fn voltage(&mut self, src: i16);
                        fn current_battery(&mut self, src: i16);
                    }

                    pub trait SRC_ {
                        fn voltage(&mut self) -> i16;
                        fn current_battery(&mut self) -> i16;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.voltage().set(src.voltage());
                        dst.current_battery().set(src.current_battery());
                    }
                }

                /**
*Status of AP_Limits. Sent in extended status stream when AP_Limits is enabled */

                pub mod LIMITS_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LIMITS_STATUS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn breach_count(&mut self) -> crate::util_::Item__ad_hoc2247 {
                            crate::util_::Item__ad_hoc2247(self.0)
                        }
                        pub fn last_trigger(&mut self) -> crate::util_::Item__ad_hoc2243 {
                            crate::util_::Item__ad_hoc2243(self.0)
                        }
                        pub fn last_action(&mut self) -> crate::util_::Item__ad_hoc2244 {
                            crate::util_::Item__ad_hoc2244(self.0)
                        }
                        pub fn last_recovery(&mut self) -> crate::util_::Item__ad_hoc2245 {
                            crate::util_::Item__ad_hoc2245(self.0)
                        }
                        pub fn last_clear(&mut self) -> crate::util_::Item__ad_hoc2246 {
                            crate::util_::Item__ad_hoc2246(self.0)
                        }
                        pub fn limits_state(&mut self) -> crate::util_::Item__ad_hoc189 {
                            crate::util_::Item__ad_hoc189(self.0)
                        }
                        pub fn mods_enabled(&mut self) -> crate::util_::Item__ad_hoc188 {
                            crate::util_::Item__ad_hoc188(self.0)
                        }
                        pub fn mods_required(&mut self) -> crate::util_::Item__ad_hoc190 {
                            crate::util_::Item__ad_hoc190(self.0)
                        }
                        pub fn mods_triggered(&mut self) -> crate::util_::Item__ad_hoc191 {
                            crate::util_::Item__ad_hoc191(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.breach_count(src.breach_count().get());
                        dst.last_trigger(src.last_trigger().get());
                        dst.last_action(src.last_action().get());
                        dst.last_recovery(src.last_recovery().get());
                        dst.last_clear(src.last_clear().get());
                        if let Some(src) = src.limits_state().get() {
                            dst.limits_state(src);
                        }
                        if let Some(src) = src.mods_enabled().get() {
                            dst.mods_enabled(src);
                        }
                        if let Some(src) = src.mods_required().get() {
                            dst.mods_required(src);
                        }
                        if let Some(src) = src.mods_triggered().get() {
                            dst.mods_triggered(src);
                        }
                    }

                    pub trait DST_ {
                        fn breach_count(&mut self, src: i16);
                        fn last_trigger(&mut self, src: i32);
                        fn last_action(&mut self, src: i32);
                        fn last_recovery(&mut self, src: i32);
                        fn last_clear(&mut self, src: i32);
                        fn limits_state(&mut self, src: packs::LIMITS_STATE);
                        fn mods_enabled(&mut self, src: packs::LIMIT_MODULE);
                        fn mods_required(&mut self, src: packs::LIMIT_MODULE);
                        fn mods_triggered(&mut self, src: packs::LIMIT_MODULE);
                    }

                    pub trait SRC_ {
                        fn breach_count(&mut self) -> i16;
                        fn last_trigger(&mut self) -> i32;
                        fn last_action(&mut self) -> i32;
                        fn last_recovery(&mut self) -> i32;
                        fn last_clear(&mut self) -> i32;
                        fn limits_state(&mut self) -> Option<packs::LIMITS_STATE>;
                        fn mods_enabled(&mut self) -> Option<packs::LIMIT_MODULE>;
                        fn mods_required(&mut self) -> Option<packs::LIMIT_MODULE>;
                        fn mods_triggered(&mut self) -> Option<packs::LIMIT_MODULE>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.breach_count().set(src.breach_count());
                        dst.last_trigger().set(src.last_trigger());
                        dst.last_action().set(src.last_action());
                        dst.last_recovery().set(src.last_recovery());
                        dst.last_clear().set(src.last_clear());
                        if let Some(src) = src.limits_state() {
                            dst.limits_state().set(src);
                        }
                        if let Some(src) = src.mods_enabled() {
                            dst.mods_enabled().set(src);
                        }
                        if let Some(src) = src.mods_required() {
                            dst.mods_required().set(src);
                        }
                        if let Some(src) = src.mods_triggered() {
                            dst.mods_triggered().set(src);
                        }
                    }
                }

                /**
*Camera Capture Feedback */

                pub mod CAMERA_FEEDBACK {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::CAMERA_FEEDBACK) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn img_idx(&mut self) -> crate::util_::Item__ad_hoc2312 {
                            crate::util_::Item__ad_hoc2312(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc2309 {
                            crate::util_::Item__ad_hoc2309(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2310 {
                            crate::util_::Item__ad_hoc2310(self.0)
                        }
                        pub fn cam_idx(&mut self) -> crate::util_::Item__ad_hoc2311 {
                            crate::util_::Item__ad_hoc2311(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc2313 {
                            crate::util_::Item__ad_hoc2313(self.0)
                        }
                        pub fn lng(&mut self) -> crate::util_::Item__ad_hoc2314 {
                            crate::util_::Item__ad_hoc2314(self.0)
                        }
                        pub fn alt_msl(&mut self) -> crate::util_::Item__ad_hoc2315 {
                            crate::util_::Item__ad_hoc2315(self.0)
                        }
                        pub fn alt_rel(&mut self) -> crate::util_::Item__ad_hoc2316 {
                            crate::util_::Item__ad_hoc2316(self.0)
                        }
                        pub fn roll(&mut self) -> crate::util_::Item__ad_hoc2317 {
                            crate::util_::Item__ad_hoc2317(self.0)
                        }
                        pub fn pitch(&mut self) -> crate::util_::Item__ad_hoc2318 {
                            crate::util_::Item__ad_hoc2318(self.0)
                        }
                        pub fn yaw(&mut self) -> crate::util_::Item__ad_hoc2319 {
                            crate::util_::Item__ad_hoc2319(self.0)
                        }
                        pub fn foc_len(&mut self) -> crate::util_::Item__ad_hoc2320 {
                            crate::util_::Item__ad_hoc2320(self.0)
                        }
                        pub fn flags(&mut self) -> crate::util_::Item__ad_hoc4 {
                            crate::util_::Item__ad_hoc4(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.img_idx(src.img_idx().get());
                        dst.time_usec(src.time_usec().get());
                        dst.target_system(src.target_system().get());
                        dst.cam_idx(src.cam_idx().get());
                        dst.lat(src.lat().get());
                        dst.lng(src.lng().get());
                        dst.alt_msl(src.alt_msl().get());
                        dst.alt_rel(src.alt_rel().get());
                        dst.roll(src.roll().get());
                        dst.pitch(src.pitch().get());
                        dst.yaw(src.yaw().get());
                        dst.foc_len(src.foc_len().get());
                        if let Some(src) = src.flags().get() {
                            dst.flags(src);
                        }
                    }

                    pub trait DST_ {
                        fn img_idx(&mut self, src: i16);
                        fn time_usec(&mut self, src: i64);
                        fn target_system(&mut self, src: i8);
                        fn cam_idx(&mut self, src: i8);
                        fn lat(&mut self, src: i32);
                        fn lng(&mut self, src: i32);
                        fn alt_msl(&mut self, src: f32);
                        fn alt_rel(&mut self, src: f32);
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn foc_len(&mut self, src: f32);
                        fn flags(&mut self, src: packs::CAMERA_FEEDBACK_FLAGS);
                    }

                    pub trait SRC_ {
                        fn img_idx(&mut self) -> i16;
                        fn time_usec(&mut self) -> i64;
                        fn target_system(&mut self) -> i8;
                        fn cam_idx(&mut self) -> i8;
                        fn lat(&mut self) -> i32;
                        fn lng(&mut self) -> i32;
                        fn alt_msl(&mut self) -> f32;
                        fn alt_rel(&mut self) -> f32;
                        fn roll(&mut self) -> f32;
                        fn pitch(&mut self) -> f32;
                        fn yaw(&mut self) -> f32;
                        fn foc_len(&mut self) -> f32;
                        fn flags(&mut self) -> Option<packs::CAMERA_FEEDBACK_FLAGS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.img_idx().set(src.img_idx());
                        dst.time_usec().set(src.time_usec());
                        dst.target_system().set(src.target_system());
                        dst.cam_idx().set(src.cam_idx());
                        dst.lat().set(src.lat());
                        dst.lng().set(src.lng());
                        dst.alt_msl().set(src.alt_msl());
                        dst.alt_rel().set(src.alt_rel());
                        dst.roll().set(src.roll());
                        dst.pitch().set(src.pitch());
                        dst.yaw().set(src.yaw());
                        dst.foc_len().set(src.foc_len());
                        if let Some(src) = src.flags() {
                            dst.flags().set(src);
                        }
                    }
                }

                /**
*The global position, as returned by the Global Positioning System (GPS). This is
*				 NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame). */

                pub mod HIL_GPS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HIL_GPS) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn eph(&mut self) -> crate::util_::Item__ad_hoc1617 {
                            crate::util_::Item__ad_hoc1617(self.0)
                        }
                        pub fn epv(&mut self) -> crate::util_::Item__ad_hoc1618 {
                            crate::util_::Item__ad_hoc1618(self.0)
                        }
                        pub fn vel(&mut self) -> crate::util_::Item__ad_hoc1619 {
                            crate::util_::Item__ad_hoc1619(self.0)
                        }
                        pub fn cog(&mut self) -> crate::util_::Item__ad_hoc1623 {
                            crate::util_::Item__ad_hoc1623(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1612 {
                            crate::util_::Item__ad_hoc1612(self.0)
                        }
                        pub fn fix_type(&mut self) -> crate::util_::Item__ad_hoc1613 {
                            crate::util_::Item__ad_hoc1613(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc1614 {
                            crate::util_::Item__ad_hoc1614(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc1615 {
                            crate::util_::Item__ad_hoc1615(self.0)
                        }
                        pub fn alt(&mut self) -> crate::util_::Item__ad_hoc1616 {
                            crate::util_::Item__ad_hoc1616(self.0)
                        }
                        pub fn vn(&mut self) -> crate::util_::Item__ad_hoc1620 {
                            crate::util_::Item__ad_hoc1620(self.0)
                        }
                        pub fn ve(&mut self) -> crate::util_::Item__ad_hoc1621 {
                            crate::util_::Item__ad_hoc1621(self.0)
                        }
                        pub fn vd(&mut self) -> crate::util_::Item__ad_hoc1622 {
                            crate::util_::Item__ad_hoc1622(self.0)
                        }
                        pub fn satellites_visible(&mut self) -> crate::util_::Item__ad_hoc1624 {
                            crate::util_::Item__ad_hoc1624(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.eph(src.eph().get());
                        dst.epv(src.epv().get());
                        dst.vel(src.vel().get());
                        dst.cog(src.cog().get());
                        dst.time_usec(src.time_usec().get());
                        dst.fix_type(src.fix_type().get());
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                        dst.alt(src.alt().get());
                        dst.vn(src.vn().get());
                        dst.ve(src.ve().get());
                        dst.vd(src.vd().get());
                        dst.satellites_visible(src.satellites_visible().get());
                    }

                    pub trait DST_ {
                        fn eph(&mut self, src: i16);
                        fn epv(&mut self, src: i16);
                        fn vel(&mut self, src: i16);
                        fn cog(&mut self, src: i16);
                        fn time_usec(&mut self, src: i64);
                        fn fix_type(&mut self, src: i8);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn alt(&mut self, src: i32);
                        fn vn(&mut self, src: i16);
                        fn ve(&mut self, src: i16);
                        fn vd(&mut self, src: i16);
                        fn satellites_visible(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn eph(&mut self) -> i16;
                        fn epv(&mut self) -> i16;
                        fn vel(&mut self) -> i16;
                        fn cog(&mut self) -> i16;
                        fn time_usec(&mut self) -> i64;
                        fn fix_type(&mut self) -> i8;
                        fn lat(&mut self) -> i32;
                        fn lon(&mut self) -> i32;
                        fn alt(&mut self) -> i32;
                        fn vn(&mut self) -> i16;
                        fn ve(&mut self) -> i16;
                        fn vd(&mut self) -> i16;
                        fn satellites_visible(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.eph().set(src.eph());
                        dst.epv().set(src.epv());
                        dst.vel().set(src.vel());
                        dst.cog().set(src.cog());
                        dst.time_usec().set(src.time_usec());
                        dst.fix_type().set(src.fix_type());
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                        dst.alt().set(src.alt());
                        dst.vn().set(src.vn());
                        dst.ve().set(src.ve());
                        dst.vd().set(src.vd());
                        dst.satellites_visible().set(src.satellites_visible());
                    }
                }

                /**
*The state of the fixed wing navigation and position controller. */

                pub mod NAV_CONTROLLER_OUTPUT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::NAV_CONTROLLER_OUTPUT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn wp_dist(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn nav_roll(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 2, 4usize) as u32)
                        }
                        pub fn nav_pitch(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 6, 4usize) as u32)
                        }
                        pub fn nav_bearing(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 10, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn target_bearing(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 12, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn alt_error(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 14, 4usize) as u32)
                        }
                        pub fn aspd_error(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 18, 4usize) as u32)
                        }
                        pub fn xtrack_error(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 22, 4usize) as u32)
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.wp_dist(src.wp_dist());
                        dst.nav_roll(src.nav_roll());
                        dst.nav_pitch(src.nav_pitch());
                        dst.nav_bearing(src.nav_bearing());
                        dst.target_bearing(src.target_bearing());
                        dst.alt_error(src.alt_error());
                        dst.aspd_error(src.aspd_error());
                        dst.xtrack_error(src.xtrack_error());
                    }

                    pub trait DST_ {
                        fn wp_dist(&mut self, src: i16);
                        fn nav_roll(&mut self, src: f32);
                        fn nav_pitch(&mut self, src: f32);
                        fn nav_bearing(&mut self, src: i16);
                        fn target_bearing(&mut self, src: i16);
                        fn alt_error(&mut self, src: f32);
                        fn aspd_error(&mut self, src: f32);
                        fn xtrack_error(&mut self, src: f32);
                    }
                }

                /**
*Emit an encrypted signature / key identifying this system. PLEASE NOTE: This protocol has been kept simple,
*				 so transmitting the key requires an encrypted channel for true safety */

                pub mod AUTH_KEY {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::AUTH_KEY) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn key(&mut self) -> Option<&str> {
                            let src = &mut self.0;
                            if src.base.field_bit != 2 && !src.set_field(2, -1) { return None; }
                            Some(src.get_str())
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        if let Some(src) = src.key() {
                            dst.key(src);
                        }
                    }

                    pub trait DST_ {
                        fn key(&mut self, src: &str);
                    }

                    pub mod key {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Request a current fence point from MAV */

                pub mod FENCE_FETCH_POINT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::FENCE_FETCH_POINT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2210 {
                            crate::util_::Item__ad_hoc2210(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2211 {
                            crate::util_::Item__ad_hoc2211(self.0)
                        }
                        pub fn idx(&mut self) -> crate::util_::Item__ad_hoc2212 {
                            crate::util_::Item__ad_hoc2212(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.idx(src.idx().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn idx(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn idx(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.idx().set(src.idx());
                    }
                }

                /**
*Status generated by radio */

                pub mod RADIO {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RADIO) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn rxerrors(&mut self) -> crate::util_::Item__ad_hoc2241 {
                            crate::util_::Item__ad_hoc2241(self.0)
                        }
                        pub fn fixeD(&mut self) -> crate::util_::Item__ad_hoc2242 {
                            crate::util_::Item__ad_hoc2242(self.0)
                        }
                        pub fn rssi(&mut self) -> crate::util_::Item__ad_hoc2236 {
                            crate::util_::Item__ad_hoc2236(self.0)
                        }
                        pub fn remrssi(&mut self) -> crate::util_::Item__ad_hoc2237 {
                            crate::util_::Item__ad_hoc2237(self.0)
                        }
                        pub fn txbuf(&mut self) -> crate::util_::Item__ad_hoc2238 {
                            crate::util_::Item__ad_hoc2238(self.0)
                        }
                        pub fn noise(&mut self) -> crate::util_::Item__ad_hoc2239 {
                            crate::util_::Item__ad_hoc2239(self.0)
                        }
                        pub fn remnoise(&mut self) -> crate::util_::Item__ad_hoc2240 {
                            crate::util_::Item__ad_hoc2240(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.rxerrors(src.rxerrors().get());
                        dst.fixeD(src.fixeD().get());
                        dst.rssi(src.rssi().get());
                        dst.remrssi(src.remrssi().get());
                        dst.txbuf(src.txbuf().get());
                        dst.noise(src.noise().get());
                        dst.remnoise(src.remnoise().get());
                    }

                    pub trait DST_ {
                        fn rxerrors(&mut self, src: i16);
                        fn fixeD(&mut self, src: i16);
                        fn rssi(&mut self, src: i8);
                        fn remrssi(&mut self, src: i8);
                        fn txbuf(&mut self, src: i8);
                        fn noise(&mut self, src: i8);
                        fn remnoise(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn rxerrors(&mut self) -> i16;
                        fn fixeD(&mut self) -> i16;
                        fn rssi(&mut self) -> i8;
                        fn remrssi(&mut self) -> i8;
                        fn txbuf(&mut self) -> i8;
                        fn noise(&mut self) -> i8;
                        fn remnoise(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.rxerrors().set(src.rxerrors());
                        dst.fixeD().set(src.fixeD());
                        dst.rssi().set(src.rssi());
                        dst.remrssi().set(src.remrssi());
                        dst.txbuf().set(src.txbuf());
                        dst.noise().set(src.noise());
                        dst.remnoise().set(src.remnoise());
                    }
                }

                /**
*The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed,
*				 Z-axis down (aeronautical frame, NED / north-east-down convention */

                pub mod LOCAL_POSITION_NED_COV {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOCAL_POSITION_NED_COV) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 8, 4usize) as u32)
                        }
                        pub fn y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 12, 4usize) as u32)
                        }
                        pub fn z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 16, 4usize) as u32)
                        }
                        pub fn vx(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 20, 4usize) as u32)
                        }
                        pub fn vy(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 24, 4usize) as u32)
                        }
                        pub fn vz(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 28, 4usize) as u32)
                        }
                        pub fn ax(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 32, 4usize) as u32)
                        }
                        pub fn ay(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 36, 4usize) as u32)
                        }
                        pub fn az(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 40, 4usize) as u32)
                        }
                        pub fn covariance(&mut self) -> crate::util_::ItemArray__ad_hoc1245 {
                            let src = &mut self.0;

                            let len = 45 as usize;
                            let offset = 44;
                            let bytes = src.base.bytes;
                            crate::util_::ItemArray__ad_hoc1245 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                        pub fn estimator_type(&mut self) -> Option<packs::MAV_ESTIMATOR_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 1792 && !src.set_field(1792, -1) { return None; }

                            Some({ packs::MAV_ESTIMATOR_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i8).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec());
                        dst.x(src.x());
                        dst.y(src.y());
                        dst.z(src.z());
                        dst.vx(src.vx());
                        dst.vy(src.vy());
                        dst.vz(src.vz());
                        dst.ax(src.ax());
                        dst.ay(src.ay());
                        dst.az(src.az());
                        dst.covariance(&mut src.covariance());
                        if let Some(src) = src.estimator_type() {
                            dst.estimator_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn vx(&mut self, src: f32);
                        fn vy(&mut self, src: f32);
                        fn vz(&mut self, src: f32);
                        fn ax(&mut self, src: f32);
                        fn ay(&mut self, src: f32);
                        fn az(&mut self, src: f32);
                        fn covariance(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1245);
                        fn estimator_type(&mut self, src: packs::MAV_ESTIMATOR_TYPE);
                    }

                    pub mod covariance {
                        pub const len: usize = 45usize;
                    }
                }

                /**
*Airspeed auto-calibration */

                pub mod AIRSPEED_AUTOCAL {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::AIRSPEED_AUTOCAL) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn vx(&mut self) -> crate::util_::Item__ad_hoc2265 {
                            crate::util_::Item__ad_hoc2265(self.0)
                        }
                        pub fn vy(&mut self) -> crate::util_::Item__ad_hoc2266 {
                            crate::util_::Item__ad_hoc2266(self.0)
                        }
                        pub fn vz(&mut self) -> crate::util_::Item__ad_hoc2267 {
                            crate::util_::Item__ad_hoc2267(self.0)
                        }
                        pub fn diff_pressure(&mut self) -> crate::util_::Item__ad_hoc2268 {
                            crate::util_::Item__ad_hoc2268(self.0)
                        }
                        pub fn EAS2TAS(&mut self) -> crate::util_::Item__ad_hoc2269 {
                            crate::util_::Item__ad_hoc2269(self.0)
                        }
                        pub fn ratio(&mut self) -> crate::util_::Item__ad_hoc2270 {
                            crate::util_::Item__ad_hoc2270(self.0)
                        }
                        pub fn state_x(&mut self) -> crate::util_::Item__ad_hoc2271 {
                            crate::util_::Item__ad_hoc2271(self.0)
                        }
                        pub fn state_y(&mut self) -> crate::util_::Item__ad_hoc2272 {
                            crate::util_::Item__ad_hoc2272(self.0)
                        }
                        pub fn state_z(&mut self) -> crate::util_::Item__ad_hoc2273 {
                            crate::util_::Item__ad_hoc2273(self.0)
                        }
                        pub fn Pax(&mut self) -> crate::util_::Item__ad_hoc2274 {
                            crate::util_::Item__ad_hoc2274(self.0)
                        }
                        pub fn Pby(&mut self) -> crate::util_::Item__ad_hoc2275 {
                            crate::util_::Item__ad_hoc2275(self.0)
                        }
                        pub fn Pcz(&mut self) -> crate::util_::Item__ad_hoc2276 {
                            crate::util_::Item__ad_hoc2276(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.vx(src.vx().get());
                        dst.vy(src.vy().get());
                        dst.vz(src.vz().get());
                        dst.diff_pressure(src.diff_pressure().get());
                        dst.EAS2TAS(src.EAS2TAS().get());
                        dst.ratio(src.ratio().get());
                        dst.state_x(src.state_x().get());
                        dst.state_y(src.state_y().get());
                        dst.state_z(src.state_z().get());
                        dst.Pax(src.Pax().get());
                        dst.Pby(src.Pby().get());
                        dst.Pcz(src.Pcz().get());
                    }

                    pub trait DST_ {
                        fn vx(&mut self, src: f32);
                        fn vy(&mut self, src: f32);
                        fn vz(&mut self, src: f32);
                        fn diff_pressure(&mut self, src: f32);
                        fn EAS2TAS(&mut self, src: f32);
                        fn ratio(&mut self, src: f32);
                        fn state_x(&mut self, src: f32);
                        fn state_y(&mut self, src: f32);
                        fn state_z(&mut self, src: f32);
                        fn Pax(&mut self, src: f32);
                        fn Pby(&mut self, src: f32);
                        fn Pcz(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn vx(&mut self) -> f32;
                        fn vy(&mut self) -> f32;
                        fn vz(&mut self) -> f32;
                        fn diff_pressure(&mut self) -> f32;
                        fn EAS2TAS(&mut self) -> f32;
                        fn ratio(&mut self) -> f32;
                        fn state_x(&mut self) -> f32;
                        fn state_y(&mut self) -> f32;
                        fn state_z(&mut self) -> f32;
                        fn Pax(&mut self) -> f32;
                        fn Pby(&mut self) -> f32;
                        fn Pcz(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.vx().set(src.vx());
                        dst.vy().set(src.vy());
                        dst.vz().set(src.vz());
                        dst.diff_pressure().set(src.diff_pressure());
                        dst.EAS2TAS().set(src.EAS2TAS());
                        dst.ratio().set(src.ratio());
                        dst.state_x().set(src.state_x());
                        dst.state_y().set(src.state_y());
                        dst.state_z().set(src.state_z());
                        dst.Pax().set(src.Pax());
                        dst.Pby().set(src.Pby());
                        dst.Pcz().set(src.Pcz());
                    }
                }

                /**
*Motion capture attitude and position */

                pub mod ATT_POS_MOCAP {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::ATT_POS_MOCAP) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1779 {
                            crate::util_::Item__ad_hoc1779(self.0)
                        }
                        pub fn q(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1780 {
                            let dst = self.0;

                            let len = 4 as usize;
                            let offset = 8;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1780 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn x(&mut self) -> crate::util_::Item__ad_hoc1781 {
                            crate::util_::Item__ad_hoc1781(self.0)
                        }
                        pub fn y(&mut self) -> crate::util_::Item__ad_hoc1782 {
                            crate::util_::Item__ad_hoc1782(self.0)
                        }
                        pub fn z(&mut self) -> crate::util_::Item__ad_hoc1783 {
                            crate::util_::Item__ad_hoc1783(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec().get());
                        dst.q(&mut src.q(None));
                        dst.x(src.x().get());
                        dst.y(src.y().get());
                        dst.z(src.z().get());
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn q(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1780);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn time_usec(&mut self) -> i64;
                        fn q(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1780);
                        fn x(&mut self) -> f32;
                        fn y(&mut self) -> f32;
                        fn z(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_usec().set(src.time_usec());
                        src.q(&mut dst.q(None));
                        dst.x().set(src.x());
                        dst.y().set(src.y());
                        dst.z().set(src.z());
                    }

                    pub mod q {
                        pub const len: usize = 4usize;
                    }
                }

                /**
*Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING:
*				 They consume quite some bandwidth, so use only for important status and error messages. If implemented
*				 wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz) */

                pub mod STATUSTEXT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::STATUSTEXT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn severity(&mut self) -> crate::util_::Item__ad_hoc683 {
                            crate::util_::Item__ad_hoc683(self.0)
                        }
                        pub fn text(&mut self) -> crate::util_::Item__ad_hoc1991 {
                            crate::util_::Item__ad_hoc1991(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        if let Some(src) = src.severity().get() {
                            dst.severity(src);
                        }
                        if let Some(src) = src.text().get() {
                            dst.text(src);
                        }
                    }

                    pub trait DST_ {
                        fn severity(&mut self, src: packs::MAV_SEVERITY);
                        fn text(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn severity(&mut self) -> Option<packs::MAV_SEVERITY>;
                        fn text_item_exists_(&mut self) -> usize;
                        fn text(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        if let Some(src) = src.severity() {
                            dst.severity().set(src);
                        }
                        let len = src.text_item_exists_();
                        if 0 < len {
                            dst.0.set_field(3, len as i32);

                            src.text(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod text {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*A ping message either requesting or responding to a ping. This allows to measure the system latencies,
*				 including serial port, radio modem and UDP connections */

                pub mod PING {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PING) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn seq(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 4, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 12, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 13, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.seq(src.seq());
                        dst.time_usec(src.time_usec());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                    }

                    pub trait DST_ {
                        fn seq(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }
                }

                /**
*Request a GOPRO_COMMAND response from the GoPro */

                pub mod GOPRO_GET_REQUEST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GOPRO_GET_REQUEST) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2401 {
                            crate::util_::Item__ad_hoc2401(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2402 {
                            crate::util_::Item__ad_hoc2402(self.0)
                        }
                        pub fn cmd_id(&mut self) -> crate::util_::Item__ad_hoc107 {
                            crate::util_::Item__ad_hoc107(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        if let Some(src) = src.cmd_id().get() {
                            dst.cmd_id(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn cmd_id(&mut self, src: packs::GOPRO_COMMAND);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn cmd_id(&mut self) -> Option<packs::GOPRO_COMMAND>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        if let Some(src) = src.cmd_id() {
                            dst.cmd_id().set(src);
                        }
                    }
                }

                /**
*WIP: Information about the status of a capture */

                pub mod CAMERA_CAPTURE_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::CAMERA_CAPTURE_STATUS) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc2027 {
                            crate::util_::Item__ad_hoc2027(self.0)
                        }
                        pub fn recording_time_ms(&mut self) -> crate::util_::Item__ad_hoc2031 {
                            crate::util_::Item__ad_hoc2031(self.0)
                        }
                        pub fn image_status(&mut self) -> crate::util_::Item__ad_hoc2028 {
                            crate::util_::Item__ad_hoc2028(self.0)
                        }
                        pub fn video_status(&mut self) -> crate::util_::Item__ad_hoc2029 {
                            crate::util_::Item__ad_hoc2029(self.0)
                        }
                        pub fn image_interval(&mut self) -> crate::util_::Item__ad_hoc2030 {
                            crate::util_::Item__ad_hoc2030(self.0)
                        }
                        pub fn available_capacity(&mut self) -> crate::util_::Item__ad_hoc2032 {
                            crate::util_::Item__ad_hoc2032(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.recording_time_ms(src.recording_time_ms().get());
                        dst.image_status(src.image_status().get());
                        dst.video_status(src.video_status().get());
                        dst.image_interval(src.image_interval().get());
                        dst.available_capacity(src.available_capacity().get());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn recording_time_ms(&mut self, src: i32);
                        fn image_status(&mut self, src: i8);
                        fn video_status(&mut self, src: i8);
                        fn image_interval(&mut self, src: f32);
                        fn available_capacity(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn recording_time_ms(&mut self) -> i32;
                        fn image_status(&mut self) -> i8;
                        fn video_status(&mut self) -> i8;
                        fn image_interval(&mut self) -> f32;
                        fn available_capacity(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.recording_time_ms().set(src.recording_time_ms());
                        dst.image_status().set(src.image_status());
                        dst.video_status().set(src.video_status());
                        dst.image_interval().set(src.image_interval());
                        dst.available_capacity().set(src.available_capacity());
                    }
                }

                /**
*nt. */

                pub mod GLOBAL_POSITION_INT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GLOBAL_POSITION_INT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn hdg(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 2, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn lat(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 6, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn lon(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 10, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn alt(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 14, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn relative_alt(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 18, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn vx(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 22, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn vy(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 24, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn vz(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 26, 2 as usize) as i16;
                            (dst) as i16
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.hdg(src.hdg());
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.lat(src.lat());
                        dst.lon(src.lon());
                        dst.alt(src.alt());
                        dst.relative_alt(src.relative_alt());
                        dst.vx(src.vx());
                        dst.vy(src.vy());
                        dst.vz(src.vz());
                    }

                    pub trait DST_ {
                        fn hdg(&mut self, src: i16);
                        fn time_boot_ms(&mut self, src: i32);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn alt(&mut self, src: i32);
                        fn relative_alt(&mut self, src: i32);
                        fn vx(&mut self, src: i16);
                        fn vy(&mut self, src: i16);
                        fn vz(&mut self, src: i16);
                    }
                }

                pub mod ENCAPSULATED_DATA {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::ENCAPSULATED_DATA) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn seqnr(&mut self) -> crate::util_::Item__ad_hoc1749 {
                            crate::util_::Item__ad_hoc1749(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1750 {
                            let dst = self.0;

                            let len = 253 as usize;
                            let offset = 2;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1750 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.seqnr(src.seqnr().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn seqnr(&mut self, src: i16);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1750);
                    }

                    pub trait SRC_ {
                        fn seqnr(&mut self) -> i16;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1750);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.seqnr().set(src.seqnr());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 253usize;
                    }
                }

                /**
*GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position
*				 estimate of the sytem */

                pub mod GPS_INPUT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GPS_INPUT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_week(&mut self) -> crate::util_::Item__ad_hoc1887 {
                            crate::util_::Item__ad_hoc1887(self.0)
                        }
                        pub fn time_week_ms(&mut self) -> crate::util_::Item__ad_hoc1886 {
                            crate::util_::Item__ad_hoc1886(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1884 {
                            crate::util_::Item__ad_hoc1884(self.0)
                        }
                        pub fn gps_id(&mut self) -> crate::util_::Item__ad_hoc1885 {
                            crate::util_::Item__ad_hoc1885(self.0)
                        }
                        pub fn fix_type(&mut self) -> crate::util_::Item__ad_hoc1888 {
                            crate::util_::Item__ad_hoc1888(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc1889 {
                            crate::util_::Item__ad_hoc1889(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc1890 {
                            crate::util_::Item__ad_hoc1890(self.0)
                        }
                        pub fn alt(&mut self) -> crate::util_::Item__ad_hoc1891 {
                            crate::util_::Item__ad_hoc1891(self.0)
                        }
                        pub fn hdop(&mut self) -> crate::util_::Item__ad_hoc1892 {
                            crate::util_::Item__ad_hoc1892(self.0)
                        }
                        pub fn vdop(&mut self) -> crate::util_::Item__ad_hoc1893 {
                            crate::util_::Item__ad_hoc1893(self.0)
                        }
                        pub fn vn(&mut self) -> crate::util_::Item__ad_hoc1894 {
                            crate::util_::Item__ad_hoc1894(self.0)
                        }
                        pub fn ve(&mut self) -> crate::util_::Item__ad_hoc1895 {
                            crate::util_::Item__ad_hoc1895(self.0)
                        }
                        pub fn vd(&mut self) -> crate::util_::Item__ad_hoc1896 {
                            crate::util_::Item__ad_hoc1896(self.0)
                        }
                        pub fn speed_accuracy(&mut self) -> crate::util_::Item__ad_hoc1897 {
                            crate::util_::Item__ad_hoc1897(self.0)
                        }
                        pub fn horiz_accuracy(&mut self) -> crate::util_::Item__ad_hoc1898 {
                            crate::util_::Item__ad_hoc1898(self.0)
                        }
                        pub fn vert_accuracy(&mut self) -> crate::util_::Item__ad_hoc1899 {
                            crate::util_::Item__ad_hoc1899(self.0)
                        }
                        pub fn satellites_visible(&mut self) -> crate::util_::Item__ad_hoc1900 {
                            crate::util_::Item__ad_hoc1900(self.0)
                        }
                        pub fn ignore_flags(&mut self) -> crate::util_::Item__ad_hoc881 {
                            crate::util_::Item__ad_hoc881(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_week(src.time_week().get());
                        dst.time_week_ms(src.time_week_ms().get());
                        dst.time_usec(src.time_usec().get());
                        dst.gps_id(src.gps_id().get());
                        dst.fix_type(src.fix_type().get());
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                        dst.alt(src.alt().get());
                        dst.hdop(src.hdop().get());
                        dst.vdop(src.vdop().get());
                        dst.vn(src.vn().get());
                        dst.ve(src.ve().get());
                        dst.vd(src.vd().get());
                        dst.speed_accuracy(src.speed_accuracy().get());
                        dst.horiz_accuracy(src.horiz_accuracy().get());
                        dst.vert_accuracy(src.vert_accuracy().get());
                        dst.satellites_visible(src.satellites_visible().get());
                        if let Some(src) = src.ignore_flags().get() {
                            dst.ignore_flags(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_week(&mut self, src: i16);
                        fn time_week_ms(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                        fn gps_id(&mut self, src: i8);
                        fn fix_type(&mut self, src: i8);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn alt(&mut self, src: f32);
                        fn hdop(&mut self, src: f32);
                        fn vdop(&mut self, src: f32);
                        fn vn(&mut self, src: f32);
                        fn ve(&mut self, src: f32);
                        fn vd(&mut self, src: f32);
                        fn speed_accuracy(&mut self, src: f32);
                        fn horiz_accuracy(&mut self, src: f32);
                        fn vert_accuracy(&mut self, src: f32);
                        fn satellites_visible(&mut self, src: i8);
                        fn ignore_flags(&mut self, src: packs::GPS_INPUT_IGNORE_FLAGS);
                    }

                    pub trait SRC_ {
                        fn time_week(&mut self) -> i16;
                        fn time_week_ms(&mut self) -> i32;
                        fn time_usec(&mut self) -> i64;
                        fn gps_id(&mut self) -> i8;
                        fn fix_type(&mut self) -> i8;
                        fn lat(&mut self) -> i32;
                        fn lon(&mut self) -> i32;
                        fn alt(&mut self) -> f32;
                        fn hdop(&mut self) -> f32;
                        fn vdop(&mut self) -> f32;
                        fn vn(&mut self) -> f32;
                        fn ve(&mut self) -> f32;
                        fn vd(&mut self) -> f32;
                        fn speed_accuracy(&mut self) -> f32;
                        fn horiz_accuracy(&mut self) -> f32;
                        fn vert_accuracy(&mut self) -> f32;
                        fn satellites_visible(&mut self) -> i8;
                        fn ignore_flags(&mut self) -> Option<packs::GPS_INPUT_IGNORE_FLAGS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_week().set(src.time_week());
                        dst.time_week_ms().set(src.time_week_ms());
                        dst.time_usec().set(src.time_usec());
                        dst.gps_id().set(src.gps_id());
                        dst.fix_type().set(src.fix_type());
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                        dst.alt().set(src.alt());
                        dst.hdop().set(src.hdop());
                        dst.vdop().set(src.vdop());
                        dst.vn().set(src.vn());
                        dst.ve().set(src.ve());
                        dst.vd().set(src.vd());
                        dst.speed_accuracy().set(src.speed_accuracy());
                        dst.horiz_accuracy().set(src.horiz_accuracy());
                        dst.vert_accuracy().set(src.vert_accuracy());
                        dst.satellites_visible().set(src.satellites_visible());
                        if let Some(src) = src.ignore_flags() {
                            dst.ignore_flags().set(src);
                        }
                    }
                }

                /**
*Send a command with up to seven parameters to the MAV */

                pub mod COMMAND_LONG {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::COMMAND_LONG) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn confirmation(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn param1(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 3, 4usize) as u32)
                        }
                        pub fn param2(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 7, 4usize) as u32)
                        }
                        pub fn param3(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 11, 4usize) as u32)
                        }
                        pub fn param4(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 15, 4usize) as u32)
                        }
                        pub fn param5(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 19, 4usize) as u32)
                        }
                        pub fn param6(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 23, 4usize) as u32)
                        }
                        pub fn param7(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 27, 4usize) as u32)
                        }
                        pub fn command(&mut self) -> Option<packs::MAV_CMD> {
                            let src = &mut self.0;
                            if src.base.field_bit != 250 && !src.set_field(250, -1) { return None; }

                            Some({ packs::MAV_CMD::from_bits((sys::get_bits(src.base.bytes, src.BIT, 8)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.confirmation(src.confirmation());
                        dst.param1(src.param1());
                        dst.param2(src.param2());
                        dst.param3(src.param3());
                        dst.param4(src.param4());
                        dst.param5(src.param5());
                        dst.param6(src.param6());
                        dst.param7(src.param7());
                        if let Some(src) = src.command() {
                            dst.command(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn confirmation(&mut self, src: i8);
                        fn param1(&mut self, src: f32);
                        fn param2(&mut self, src: f32);
                        fn param3(&mut self, src: f32);
                        fn param4(&mut self, src: f32);
                        fn param5(&mut self, src: f32);
                        fn param6(&mut self, src: f32);
                        fn param7(&mut self, src: f32);
                        fn command(&mut self, src: packs::MAV_CMD);
                    }
                }

                /**
*Status of compassmot calibration */

                pub mod COMPASSMOT_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::COMPASSMOT_STATUS) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn throttle(&mut self) -> crate::util_::Item__ad_hoc2289 {
                            crate::util_::Item__ad_hoc2289(self.0)
                        }
                        pub fn interference(&mut self) -> crate::util_::Item__ad_hoc2291 {
                            crate::util_::Item__ad_hoc2291(self.0)
                        }
                        pub fn current(&mut self) -> crate::util_::Item__ad_hoc2290 {
                            crate::util_::Item__ad_hoc2290(self.0)
                        }
                        pub fn CompensationX(&mut self) -> crate::util_::Item__ad_hoc2292 {
                            crate::util_::Item__ad_hoc2292(self.0)
                        }
                        pub fn CompensationY(&mut self) -> crate::util_::Item__ad_hoc2293 {
                            crate::util_::Item__ad_hoc2293(self.0)
                        }
                        pub fn CompensationZ(&mut self) -> crate::util_::Item__ad_hoc2294 {
                            crate::util_::Item__ad_hoc2294(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.throttle(src.throttle().get());
                        dst.interference(src.interference().get());
                        dst.current(src.current().get());
                        dst.CompensationX(src.CompensationX().get());
                        dst.CompensationY(src.CompensationY().get());
                        dst.CompensationZ(src.CompensationZ().get());
                    }

                    pub trait DST_ {
                        fn throttle(&mut self, src: i16);
                        fn interference(&mut self, src: i16);
                        fn current(&mut self, src: f32);
                        fn CompensationX(&mut self, src: f32);
                        fn CompensationY(&mut self, src: f32);
                        fn CompensationZ(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn throttle(&mut self) -> i16;
                        fn interference(&mut self) -> i16;
                        fn current(&mut self) -> f32;
                        fn CompensationX(&mut self) -> f32;
                        fn CompensationY(&mut self) -> f32;
                        fn CompensationZ(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.throttle().set(src.throttle());
                        dst.interference().set(src.interference());
                        dst.current().set(src.current());
                        dst.CompensationX().set(src.CompensationX());
                        dst.CompensationY().set(src.CompensationY());
                        dst.CompensationZ().set(src.CompensationZ());
                    }
                }

                /**
*Request a chunk of a log */

                pub mod LOG_REQUEST_DATA {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOG_REQUEST_DATA) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn id(&mut self) -> crate::util_::Item__ad_hoc1674 {
                            crate::util_::Item__ad_hoc1674(self.0)
                        }
                        pub fn ofs(&mut self) -> crate::util_::Item__ad_hoc1675 {
                            crate::util_::Item__ad_hoc1675(self.0)
                        }
                        pub fn count(&mut self) -> crate::util_::Item__ad_hoc1676 {
                            crate::util_::Item__ad_hoc1676(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc1672 {
                            crate::util_::Item__ad_hoc1672(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc1673 {
                            crate::util_::Item__ad_hoc1673(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.id(src.id().get());
                        dst.ofs(src.ofs().get());
                        dst.count(src.count().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                    }

                    pub trait DST_ {
                        fn id(&mut self, src: i16);
                        fn ofs(&mut self, src: i32);
                        fn count(&mut self, src: i32);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn id(&mut self) -> i16;
                        fn ofs(&mut self) -> i32;
                        fn count(&mut self) -> i32;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.id().set(src.id());
                        dst.ofs().set(src.ofs());
                        dst.count().set(src.count());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                    }
                }

                /**
*The global position, as returned by the Global Positioning System (GPS). This is
*				 NOT the global position estimate of the system, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame). */

                pub mod GPS_RAW_INT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GPS_RAW_INT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn eph(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn epv(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn vel(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 4, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn cog(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 6, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 8, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn lat(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 16, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn lon(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 20, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn alt(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 24, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn satellites_visible(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 28, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn fix_type(&mut self) -> Option<packs::GPS_FIX_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 234 && !src.set_field(234, -1) { return None; }

                            Some({ packs::GPS_FIX_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                        pub fn alt_ellipsoid(&mut self) -> Option<i32> {
                            let src = &mut self.0;
                            if src.base.field_bit != 235 && !src.set_field(235, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 4 as usize) as i32;
                                (dst) as i32
                            })
                        }
                        pub fn h_acc(&mut self) -> Option<i32> {
                            let src = &mut self.0;
                            if src.base.field_bit != 236 && !src.set_field(236, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 4 as usize) as i32;
                                (dst) as i32
                            })
                        }
                        pub fn v_acc(&mut self) -> Option<i32> {
                            let src = &mut self.0;
                            if src.base.field_bit != 237 && !src.set_field(237, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 4 as usize) as i32;
                                (dst) as i32
                            })
                        }
                        pub fn vel_acc(&mut self) -> Option<i32> {
                            let src = &mut self.0;
                            if src.base.field_bit != 238 && !src.set_field(238, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 4 as usize) as i32;
                                (dst) as i32
                            })
                        }
                        pub fn hdg_acc(&mut self) -> Option<i32> {
                            let src = &mut self.0;
                            if src.base.field_bit != 239 && !src.set_field(239, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 4 as usize) as i32;
                                (dst) as i32
                            })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.eph(src.eph());
                        dst.epv(src.epv());
                        dst.vel(src.vel());
                        dst.cog(src.cog());
                        dst.time_usec(src.time_usec());
                        dst.lat(src.lat());
                        dst.lon(src.lon());
                        dst.alt(src.alt());
                        dst.satellites_visible(src.satellites_visible());
                        if let Some(src) = src.fix_type() {
                            dst.fix_type(src);
                        }
                        if let Some(src) = src.alt_ellipsoid() {
                            dst.alt_ellipsoid(src);
                        }
                        if let Some(src) = src.h_acc() {
                            dst.h_acc(src);
                        }
                        if let Some(src) = src.v_acc() {
                            dst.v_acc(src);
                        }
                        if let Some(src) = src.vel_acc() {
                            dst.vel_acc(src);
                        }
                        if let Some(src) = src.hdg_acc() {
                            dst.hdg_acc(src);
                        }
                    }

                    pub trait DST_ {
                        fn eph(&mut self, src: i16);
                        fn epv(&mut self, src: i16);
                        fn vel(&mut self, src: i16);
                        fn cog(&mut self, src: i16);
                        fn time_usec(&mut self, src: i64);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn alt(&mut self, src: i32);
                        fn satellites_visible(&mut self, src: i8);
                        fn fix_type(&mut self, src: packs::GPS_FIX_TYPE);
                        fn alt_ellipsoid(&mut self, src: i32);
                        fn h_acc(&mut self, src: i32);
                        fn v_acc(&mut self, src: i32);
                        fn vel_acc(&mut self, src: i32);
                        fn hdg_acc(&mut self, src: i32);
                    }
                }

                /**
*Camera Event */

                pub mod CAMERA_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::CAMERA_STATUS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn img_idx(&mut self) -> crate::util_::Item__ad_hoc2304 {
                            crate::util_::Item__ad_hoc2304(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc2301 {
                            crate::util_::Item__ad_hoc2301(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2302 {
                            crate::util_::Item__ad_hoc2302(self.0)
                        }
                        pub fn cam_idx(&mut self) -> crate::util_::Item__ad_hoc2303 {
                            crate::util_::Item__ad_hoc2303(self.0)
                        }
                        pub fn p1(&mut self) -> crate::util_::Item__ad_hoc2305 {
                            crate::util_::Item__ad_hoc2305(self.0)
                        }
                        pub fn p2(&mut self) -> crate::util_::Item__ad_hoc2306 {
                            crate::util_::Item__ad_hoc2306(self.0)
                        }
                        pub fn p3(&mut self) -> crate::util_::Item__ad_hoc2307 {
                            crate::util_::Item__ad_hoc2307(self.0)
                        }
                        pub fn p4(&mut self) -> crate::util_::Item__ad_hoc2308 {
                            crate::util_::Item__ad_hoc2308(self.0)
                        }
                        pub fn event_id(&mut self) -> crate::util_::Item__ad_hoc684 {
                            crate::util_::Item__ad_hoc684(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.img_idx(src.img_idx().get());
                        dst.time_usec(src.time_usec().get());
                        dst.target_system(src.target_system().get());
                        dst.cam_idx(src.cam_idx().get());
                        dst.p1(src.p1().get());
                        dst.p2(src.p2().get());
                        dst.p3(src.p3().get());
                        dst.p4(src.p4().get());
                        if let Some(src) = src.event_id().get() {
                            dst.event_id(src);
                        }
                    }

                    pub trait DST_ {
                        fn img_idx(&mut self, src: i16);
                        fn time_usec(&mut self, src: i64);
                        fn target_system(&mut self, src: i8);
                        fn cam_idx(&mut self, src: i8);
                        fn p1(&mut self, src: f32);
                        fn p2(&mut self, src: f32);
                        fn p3(&mut self, src: f32);
                        fn p4(&mut self, src: f32);
                        fn event_id(&mut self, src: packs::CAMERA_STATUS_TYPES);
                    }

                    pub trait SRC_ {
                        fn img_idx(&mut self) -> i16;
                        fn time_usec(&mut self) -> i64;
                        fn target_system(&mut self) -> i8;
                        fn cam_idx(&mut self) -> i8;
                        fn p1(&mut self) -> f32;
                        fn p2(&mut self) -> f32;
                        fn p3(&mut self) -> f32;
                        fn p4(&mut self) -> f32;
                        fn event_id(&mut self) -> Option<packs::CAMERA_STATUS_TYPES>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.img_idx().set(src.img_idx());
                        dst.time_usec().set(src.time_usec());
                        dst.target_system().set(src.target_system());
                        dst.cam_idx().set(src.cam_idx());
                        dst.p1().set(src.p1());
                        dst.p2().set(src.p2());
                        dst.p3().set(src.p3());
                        dst.p4().set(src.p4());
                        if let Some(src) = src.event_id() {
                            dst.event_id().set(src);
                        }
                    }
                }

                /**
*The scaled values of the RC channels received. (-100%) -10000, (0%) 0, (100%) 10000. Channels that are
*				 inactive should be set to UINT16_MAX */

                pub mod RC_CHANNELS_SCALED {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RC_CHANNELS_SCALED) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn port(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 4, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn chan1_scaled(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 5, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan2_scaled(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 7, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan3_scaled(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 9, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan4_scaled(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 11, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan5_scaled(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 13, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan6_scaled(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 15, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan7_scaled(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 17, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan8_scaled(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 19, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn rssi(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 21, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.port(src.port());
                        dst.chan1_scaled(src.chan1_scaled());
                        dst.chan2_scaled(src.chan2_scaled());
                        dst.chan3_scaled(src.chan3_scaled());
                        dst.chan4_scaled(src.chan4_scaled());
                        dst.chan5_scaled(src.chan5_scaled());
                        dst.chan6_scaled(src.chan6_scaled());
                        dst.chan7_scaled(src.chan7_scaled());
                        dst.chan8_scaled(src.chan8_scaled());
                        dst.rssi(src.rssi());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn port(&mut self, src: i8);
                        fn chan1_scaled(&mut self, src: i16);
                        fn chan2_scaled(&mut self, src: i16);
                        fn chan3_scaled(&mut self, src: i16);
                        fn chan4_scaled(&mut self, src: i16);
                        fn chan5_scaled(&mut self, src: i16);
                        fn chan6_scaled(&mut self, src: i16);
                        fn chan7_scaled(&mut self, src: i16);
                        fn chan8_scaled(&mut self, src: i16);
                        fn rssi(&mut self, src: i8);
                    }
                }

                /**
*WIP: Settings of a camera, can be requested using MAV_CMD_REQUEST_CAMERA_SETTINGS. */

                pub mod CAMERA_SETTINGS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::CAMERA_SETTINGS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc2017 {
                            crate::util_::Item__ad_hoc2017(self.0)
                        }
                        pub fn mode_id(&mut self) -> crate::util_::Item__ad_hoc84 {
                            crate::util_::Item__ad_hoc84(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        if let Some(src) = src.mode_id().get() {
                            dst.mode_id(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn mode_id(&mut self, src: packs::CAMERA_MODE);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn mode_id(&mut self) -> Option<packs::CAMERA_MODE>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        if let Some(src) = src.mode_id() {
                            dst.mode_id().set(src);
                        }
                    }
                }

                /**
*Read registers reply */

                pub mod DEVICE_OP_READ_REPLY {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DEVICE_OP_READ_REPLY) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn request_id(&mut self) -> crate::util_::Item__ad_hoc2417 {
                            crate::util_::Item__ad_hoc2417(self.0)
                        }
                        pub fn result(&mut self) -> crate::util_::Item__ad_hoc2418 {
                            crate::util_::Item__ad_hoc2418(self.0)
                        }
                        pub fn regstart(&mut self) -> crate::util_::Item__ad_hoc2419 {
                            crate::util_::Item__ad_hoc2419(self.0)
                        }
                        pub fn count(&mut self) -> crate::util_::Item__ad_hoc2420 {
                            crate::util_::Item__ad_hoc2420(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2421 {
                            let dst = self.0;

                            let len = 128 as usize;
                            let offset = 7;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2421 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.request_id(src.request_id().get());
                        dst.result(src.result().get());
                        dst.regstart(src.regstart().get());
                        dst.count(src.count().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn request_id(&mut self, src: i32);
                        fn result(&mut self, src: i8);
                        fn regstart(&mut self, src: i8);
                        fn count(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2421);
                    }

                    pub trait SRC_ {
                        fn request_id(&mut self) -> i32;
                        fn result(&mut self) -> i8;
                        fn regstart(&mut self) -> i8;
                        fn count(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2421);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.request_id().set(src.request_id());
                        dst.result().set(src.result());
                        dst.regstart().set(src.regstart());
                        dst.count().set(src.count());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 128usize;
                    }
                }

                /**
*The RAW pressure readings for the typical setup of one absolute pressure and one differential pressure
*				 sensor. The sensor values should be the raw, UNSCALED ADC values */

                pub mod RAW_PRESSURE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RAW_PRESSURE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn press_abs(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 8, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn press_diff1(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 10, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn press_diff2(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 12, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn temperature(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 14, 2 as usize) as i16;
                            (dst) as i16
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec());
                        dst.press_abs(src.press_abs());
                        dst.press_diff1(src.press_diff1());
                        dst.press_diff2(src.press_diff2());
                        dst.temperature(src.temperature());
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn press_abs(&mut self, src: i16);
                        fn press_diff1(&mut self, src: i16);
                        fn press_diff2(&mut self, src: i16);
                        fn temperature(&mut self, src: i16);
                    }
                }

                /**
*Control on-board Camera Control System to take shots. */

                pub mod DIGICAM_CONTROL {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DIGICAM_CONTROL) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2178 {
                            crate::util_::Item__ad_hoc2178(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2179 {
                            crate::util_::Item__ad_hoc2179(self.0)
                        }
                        pub fn session(&mut self) -> crate::util_::Item__ad_hoc2180 {
                            crate::util_::Item__ad_hoc2180(self.0)
                        }
                        pub fn zoom_pos(&mut self) -> crate::util_::Item__ad_hoc2181 {
                            crate::util_::Item__ad_hoc2181(self.0)
                        }
                        pub fn zoom_step(&mut self) -> crate::util_::Item__ad_hoc2182 {
                            crate::util_::Item__ad_hoc2182(self.0)
                        }
                        pub fn focus_lock(&mut self) -> crate::util_::Item__ad_hoc2183 {
                            crate::util_::Item__ad_hoc2183(self.0)
                        }
                        pub fn shot(&mut self) -> crate::util_::Item__ad_hoc2184 {
                            crate::util_::Item__ad_hoc2184(self.0)
                        }
                        pub fn command_id(&mut self) -> crate::util_::Item__ad_hoc2185 {
                            crate::util_::Item__ad_hoc2185(self.0)
                        }
                        pub fn extra_param(&mut self) -> crate::util_::Item__ad_hoc2186 {
                            crate::util_::Item__ad_hoc2186(self.0)
                        }
                        pub fn extra_value(&mut self) -> crate::util_::Item__ad_hoc2187 {
                            crate::util_::Item__ad_hoc2187(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.session(src.session().get());
                        dst.zoom_pos(src.zoom_pos().get());
                        dst.zoom_step(src.zoom_step().get());
                        dst.focus_lock(src.focus_lock().get());
                        dst.shot(src.shot().get());
                        dst.command_id(src.command_id().get());
                        dst.extra_param(src.extra_param().get());
                        dst.extra_value(src.extra_value().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn session(&mut self, src: i8);
                        fn zoom_pos(&mut self, src: i8);
                        fn zoom_step(&mut self, src: i8);
                        fn focus_lock(&mut self, src: i8);
                        fn shot(&mut self, src: i8);
                        fn command_id(&mut self, src: i8);
                        fn extra_param(&mut self, src: i8);
                        fn extra_value(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn session(&mut self) -> i8;
                        fn zoom_pos(&mut self) -> i8;
                        fn zoom_step(&mut self) -> i8;
                        fn focus_lock(&mut self) -> i8;
                        fn shot(&mut self) -> i8;
                        fn command_id(&mut self) -> i8;
                        fn extra_param(&mut self) -> i8;
                        fn extra_value(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.session().set(src.session());
                        dst.zoom_pos().set(src.zoom_pos());
                        dst.zoom_step().set(src.zoom_step());
                        dst.focus_lock().set(src.focus_lock());
                        dst.shot().set(src.shot());
                        dst.command_id().set(src.command_id());
                        dst.extra_param().set(src.extra_param());
                        dst.extra_value().set(src.extra_value());
                    }
                }

                /**
*Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite
*				 efficient way for testing new messages and getting experimental debug output */

                pub mod NAMED_VALUE_FLOAT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::NAMED_VALUE_FLOAT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc1985 {
                            crate::util_::Item__ad_hoc1985(self.0)
                        }
                        pub fn value(&mut self) -> crate::util_::Item__ad_hoc1987 {
                            crate::util_::Item__ad_hoc1987(self.0)
                        }
                        pub fn name(&mut self) -> crate::util_::Item__ad_hoc1986 {
                            crate::util_::Item__ad_hoc1986(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.value(src.value().get());
                        if let Some(src) = src.name().get() {
                            dst.name(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn value(&mut self, src: f32);
                        fn name(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn value(&mut self) -> f32;
                        fn name_item_exists_(&mut self) -> usize;
                        fn name(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.value().set(src.value());
                        let len = src.name_item_exists_();
                        if 0 < len {
                            dst.0.set_field(66, len as i32);

                            src.name(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod name {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Heartbeat from a HeroBus attached GoPro */

                pub mod GOPRO_HEARTBEAT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GOPRO_HEARTBEAT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn status(&mut self) -> crate::util_::Item__ad_hoc629 {
                            crate::util_::Item__ad_hoc629(self.0)
                        }
                        pub fn capture_mode(&mut self) -> crate::util_::Item__ad_hoc630 {
                            crate::util_::Item__ad_hoc630(self.0)
                        }
                        pub fn flags(&mut self) -> crate::util_::Item__ad_hoc628 {
                            crate::util_::Item__ad_hoc628(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        if let Some(src) = src.status().get() {
                            dst.status(src);
                        }
                        if let Some(src) = src.capture_mode().get() {
                            dst.capture_mode(src);
                        }
                        if let Some(src) = src.flags().get() {
                            dst.flags(src);
                        }
                    }

                    pub trait DST_ {
                        fn status(&mut self, src: packs::GOPRO_HEARTBEAT_STATUS);
                        fn capture_mode(&mut self, src: packs::GOPRO_CAPTURE_MODE);
                        fn flags(&mut self, src: packs::GOPRO_HEARTBEAT_FLAGS);
                    }

                    pub trait SRC_ {
                        fn status(&mut self) -> Option<packs::GOPRO_HEARTBEAT_STATUS>;
                        fn capture_mode(&mut self) -> Option<packs::GOPRO_CAPTURE_MODE>;
                        fn flags(&mut self) -> Option<packs::GOPRO_HEARTBEAT_FLAGS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        if let Some(src) = src.status() {
                            dst.status().set(src);
                        }
                        if let Some(src) = src.capture_mode() {
                            dst.capture_mode().set(src);
                        }
                        if let Some(src) = src.flags() {
                            dst.flags().set(src);
                        }
                    }
                }

                /**
*The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right). */

                pub mod ATTITUDE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::ATTITUDE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn roll(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 4, 4usize) as u32)
                        }
                        pub fn pitch(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 8, 4usize) as u32)
                        }
                        pub fn yaw(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 12, 4usize) as u32)
                        }
                        pub fn rollspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 16, 4usize) as u32)
                        }
                        pub fn pitchspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 20, 4usize) as u32)
                        }
                        pub fn yawspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 24, 4usize) as u32)
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.roll(src.roll());
                        dst.pitch(src.pitch());
                        dst.yaw(src.yaw());
                        dst.rollspeed(src.rollspeed());
                        dst.pitchspeed(src.pitchspeed());
                        dst.yawspeed(src.yawspeed());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn rollspeed(&mut self, src: f32);
                        fn pitchspeed(&mut self, src: f32);
                        fn yawspeed(&mut self, src: f32);
                    }
                }

                /**
*This message is sent to the MAV to write a partial list. If start index == end index, only one item will
*				 be transmitted / updated. If the start index is NOT 0 and above the current list size, this request should
*				 be REJECTED */

                pub mod MISSION_WRITE_PARTIAL_LIST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_WRITE_PARTIAL_LIST) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn start_index(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn end_index(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 4, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn mission_type(&mut self) -> Option<packs::MAV_MISSION_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 48 && !src.set_field(48, -1) { return None; }

                            Some({ packs::MAV_MISSION_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.start_index(src.start_index());
                        dst.end_index(src.end_index());
                        if let Some(src) = src.mission_type() {
                            dst.mission_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn start_index(&mut self, src: i16);
                        fn end_index(&mut self, src: i16);
                        fn mission_type(&mut self, src: packs::MAV_MISSION_TYPE);
                    }
                }

                /**
*Status of secondary AHRS filter if available */

                pub mod AHRS2 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::AHRS2) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn roll(&mut self) -> crate::util_::Item__ad_hoc2295 {
                            crate::util_::Item__ad_hoc2295(self.0)
                        }
                        pub fn pitch(&mut self) -> crate::util_::Item__ad_hoc2296 {
                            crate::util_::Item__ad_hoc2296(self.0)
                        }
                        pub fn yaw(&mut self) -> crate::util_::Item__ad_hoc2297 {
                            crate::util_::Item__ad_hoc2297(self.0)
                        }
                        pub fn altitude(&mut self) -> crate::util_::Item__ad_hoc2298 {
                            crate::util_::Item__ad_hoc2298(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc2299 {
                            crate::util_::Item__ad_hoc2299(self.0)
                        }
                        pub fn lng(&mut self) -> crate::util_::Item__ad_hoc2300 {
                            crate::util_::Item__ad_hoc2300(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.roll(src.roll().get());
                        dst.pitch(src.pitch().get());
                        dst.yaw(src.yaw().get());
                        dst.altitude(src.altitude().get());
                        dst.lat(src.lat().get());
                        dst.lng(src.lng().get());
                    }

                    pub trait DST_ {
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn altitude(&mut self, src: f32);
                        fn lat(&mut self, src: i32);
                        fn lng(&mut self, src: i32);
                    }

                    pub trait SRC_ {
                        fn roll(&mut self) -> f32;
                        fn pitch(&mut self) -> f32;
                        fn yaw(&mut self) -> f32;
                        fn altitude(&mut self) -> f32;
                        fn lat(&mut self) -> i32;
                        fn lng(&mut self) -> i32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.roll().set(src.roll());
                        dst.pitch().set(src.pitch());
                        dst.yaw().set(src.yaw());
                        dst.altitude().set(src.altitude());
                        dst.lat().set(src.lat());
                        dst.lng().set(src.lng());
                    }
                }

                /**
*Erase all logs */

                pub mod LOG_ERASE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOG_ERASE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc1681 {
                            crate::util_::Item__ad_hoc1681(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc1682 {
                            crate::util_::Item__ad_hoc1682(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                    }
                }

                /**
*Request for terrain data and terrain status */

                pub mod TERRAIN_REQUEST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::TERRAIN_REQUEST) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn grid_spacing(&mut self) -> crate::util_::Item__ad_hoc1759 {
                            crate::util_::Item__ad_hoc1759(self.0)
                        }
                        pub fn mask(&mut self) -> crate::util_::Item__ad_hoc1760 {
                            crate::util_::Item__ad_hoc1760(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc1757 {
                            crate::util_::Item__ad_hoc1757(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc1758 {
                            crate::util_::Item__ad_hoc1758(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.grid_spacing(src.grid_spacing().get());
                        dst.mask(src.mask().get());
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                    }

                    pub trait DST_ {
                        fn grid_spacing(&mut self, src: i16);
                        fn mask(&mut self, src: i64);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                    }

                    pub trait SRC_ {
                        fn grid_spacing(&mut self) -> i16;
                        fn mask(&mut self) -> i64;
                        fn lat(&mut self) -> i32;
                        fn lon(&mut self) -> i32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.grid_spacing().set(src.grid_spacing());
                        dst.mask().set(src.mask());
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                    }
                }

                /**
*Message with some status from APM to GCS about camera or antenna mount */

                pub mod MOUNT_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MOUNT_STATUS) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2199 {
                            crate::util_::Item__ad_hoc2199(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2200 {
                            crate::util_::Item__ad_hoc2200(self.0)
                        }
                        pub fn pointing_a(&mut self) -> crate::util_::Item__ad_hoc2201 {
                            crate::util_::Item__ad_hoc2201(self.0)
                        }
                        pub fn pointing_b(&mut self) -> crate::util_::Item__ad_hoc2202 {
                            crate::util_::Item__ad_hoc2202(self.0)
                        }
                        pub fn pointing_c(&mut self) -> crate::util_::Item__ad_hoc2203 {
                            crate::util_::Item__ad_hoc2203(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.pointing_a(src.pointing_a().get());
                        dst.pointing_b(src.pointing_b().get());
                        dst.pointing_c(src.pointing_c().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn pointing_a(&mut self, src: i32);
                        fn pointing_b(&mut self, src: i32);
                        fn pointing_c(&mut self, src: i32);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn pointing_a(&mut self) -> i32;
                        fn pointing_b(&mut self) -> i32;
                        fn pointing_c(&mut self) -> i32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.pointing_a().set(src.pointing_a());
                        dst.pointing_b().set(src.pointing_b());
                        dst.pointing_c().set(src.pointing_c());
                    }
                }

                /**
*Setpoint in roll, pitch, yaw and thrust from the operator */

                pub mod MANUAL_SETPOINT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MANUAL_SETPOINT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn roll(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 4, 4usize) as u32)
                        }
                        pub fn pitch(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 8, 4usize) as u32)
                        }
                        pub fn yaw(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 12, 4usize) as u32)
                        }
                        pub fn thrust(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 16, 4usize) as u32)
                        }
                        pub fn mode_switch(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 20, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn manual_override_switch(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 21, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.roll(src.roll());
                        dst.pitch(src.pitch());
                        dst.yaw(src.yaw());
                        dst.thrust(src.thrust());
                        dst.mode_switch(src.mode_switch());
                        dst.manual_override_switch(src.manual_override_switch());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn thrust(&mut self, src: f32);
                        fn mode_switch(&mut self, src: i8);
                        fn manual_override_switch(&mut self, src: i8);
                    }
                }

                /**
*PID tuning information */

                pub mod PID_TUNING {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PID_TUNING) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn desired(&mut self) -> crate::util_::Item__ad_hoc2373 {
                            crate::util_::Item__ad_hoc2373(self.0)
                        }
                        pub fn achieved(&mut self) -> crate::util_::Item__ad_hoc2374 {
                            crate::util_::Item__ad_hoc2374(self.0)
                        }
                        pub fn FF(&mut self) -> crate::util_::Item__ad_hoc2375 {
                            crate::util_::Item__ad_hoc2375(self.0)
                        }
                        pub fn P(&mut self) -> crate::util_::Item__ad_hoc2376 {
                            crate::util_::Item__ad_hoc2376(self.0)
                        }
                        pub fn I(&mut self) -> crate::util_::Item__ad_hoc2377 {
                            crate::util_::Item__ad_hoc2377(self.0)
                        }
                        pub fn D(&mut self) -> crate::util_::Item__ad_hoc2378 {
                            crate::util_::Item__ad_hoc2378(self.0)
                        }
                        pub fn axis(&mut self) -> crate::util_::Item__ad_hoc104 {
                            crate::util_::Item__ad_hoc104(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.desired(src.desired().get());
                        dst.achieved(src.achieved().get());
                        dst.FF(src.FF().get());
                        dst.P(src.P().get());
                        dst.I(src.I().get());
                        dst.D(src.D().get());
                        if let Some(src) = src.axis().get() {
                            dst.axis(src);
                        }
                    }

                    pub trait DST_ {
                        fn desired(&mut self, src: f32);
                        fn achieved(&mut self, src: f32);
                        fn FF(&mut self, src: f32);
                        fn P(&mut self, src: f32);
                        fn I(&mut self, src: f32);
                        fn D(&mut self, src: f32);
                        fn axis(&mut self, src: packs::PID_TUNING_AXIS);
                    }

                    pub trait SRC_ {
                        fn desired(&mut self) -> f32;
                        fn achieved(&mut self) -> f32;
                        fn FF(&mut self) -> f32;
                        fn P(&mut self) -> f32;
                        fn I(&mut self) -> f32;
                        fn D(&mut self) -> f32;
                        fn axis(&mut self) -> Option<packs::PID_TUNING_AXIS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.desired().set(src.desired());
                        dst.achieved().set(src.achieved());
                        dst.FF().set(src.FF());
                        dst.P().set(src.P());
                        dst.I().set(src.I());
                        dst.D().set(src.D());
                        if let Some(src) = src.axis() {
                            dst.axis().set(src);
                        }
                    }
                }

                /**
*Read out the safety zone the MAV currently assumes. */

                pub mod SAFETY_ALLOWED_AREA {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SAFETY_ALLOWED_AREA) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn p1x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 0, 4usize) as u32)
                        }
                        pub fn p1y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 4, 4usize) as u32)
                        }
                        pub fn p1z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 8, 4usize) as u32)
                        }
                        pub fn p2x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 12, 4usize) as u32)
                        }
                        pub fn p2y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 16, 4usize) as u32)
                        }
                        pub fn p2z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 20, 4usize) as u32)
                        }
                        pub fn frame(&mut self) -> Option<packs::MAV_FRAME> {
                            let src = &mut self.0;
                            if src.base.field_bit != 192 && !src.set_field(192, -1) { return None; }

                            Some({ packs::MAV_FRAME::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.p1x(src.p1x());
                        dst.p1y(src.p1y());
                        dst.p1z(src.p1z());
                        dst.p2x(src.p2x());
                        dst.p2y(src.p2y());
                        dst.p2z(src.p2z());
                        if let Some(src) = src.frame() {
                            dst.frame(src);
                        }
                    }

                    pub trait DST_ {
                        fn p1x(&mut self, src: f32);
                        fn p1y(&mut self, src: f32);
                        fn p1z(&mut self, src: f32);
                        fn p2x(&mut self, src: f32);
                        fn p2y(&mut self, src: f32);
                        fn p2z(&mut self, src: f32);
                        fn frame(&mut self, src: packs::MAV_FRAME);
                    }
                }

                /**
*Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor) */

                pub mod OPTICAL_FLOW_RAD {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::OPTICAL_FLOW_RAD) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn integration_time_us(&mut self) -> crate::util_::Item__ad_hoc1551 {
                            crate::util_::Item__ad_hoc1551(self.0)
                        }
                        pub fn time_delta_distance_us(&mut self) -> crate::util_::Item__ad_hoc1559 {
                            crate::util_::Item__ad_hoc1559(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1549 {
                            crate::util_::Item__ad_hoc1549(self.0)
                        }
                        pub fn sensor_id(&mut self) -> crate::util_::Item__ad_hoc1550 {
                            crate::util_::Item__ad_hoc1550(self.0)
                        }
                        pub fn integrated_x(&mut self) -> crate::util_::Item__ad_hoc1552 {
                            crate::util_::Item__ad_hoc1552(self.0)
                        }
                        pub fn integrated_y(&mut self) -> crate::util_::Item__ad_hoc1553 {
                            crate::util_::Item__ad_hoc1553(self.0)
                        }
                        pub fn integrated_xgyro(&mut self) -> crate::util_::Item__ad_hoc1554 {
                            crate::util_::Item__ad_hoc1554(self.0)
                        }
                        pub fn integrated_ygyro(&mut self) -> crate::util_::Item__ad_hoc1555 {
                            crate::util_::Item__ad_hoc1555(self.0)
                        }
                        pub fn integrated_zgyro(&mut self) -> crate::util_::Item__ad_hoc1556 {
                            crate::util_::Item__ad_hoc1556(self.0)
                        }
                        pub fn temperature(&mut self) -> crate::util_::Item__ad_hoc1557 {
                            crate::util_::Item__ad_hoc1557(self.0)
                        }
                        pub fn quality(&mut self) -> crate::util_::Item__ad_hoc1558 {
                            crate::util_::Item__ad_hoc1558(self.0)
                        }
                        pub fn distance(&mut self) -> crate::util_::Item__ad_hoc1560 {
                            crate::util_::Item__ad_hoc1560(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.integration_time_us(src.integration_time_us().get());
                        dst.time_delta_distance_us(src.time_delta_distance_us().get());
                        dst.time_usec(src.time_usec().get());
                        dst.sensor_id(src.sensor_id().get());
                        dst.integrated_x(src.integrated_x().get());
                        dst.integrated_y(src.integrated_y().get());
                        dst.integrated_xgyro(src.integrated_xgyro().get());
                        dst.integrated_ygyro(src.integrated_ygyro().get());
                        dst.integrated_zgyro(src.integrated_zgyro().get());
                        dst.temperature(src.temperature().get());
                        dst.quality(src.quality().get());
                        dst.distance(src.distance().get());
                    }

                    pub trait DST_ {
                        fn integration_time_us(&mut self, src: i32);
                        fn time_delta_distance_us(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                        fn sensor_id(&mut self, src: i8);
                        fn integrated_x(&mut self, src: f32);
                        fn integrated_y(&mut self, src: f32);
                        fn integrated_xgyro(&mut self, src: f32);
                        fn integrated_ygyro(&mut self, src: f32);
                        fn integrated_zgyro(&mut self, src: f32);
                        fn temperature(&mut self, src: i16);
                        fn quality(&mut self, src: i8);
                        fn distance(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn integration_time_us(&mut self) -> i32;
                        fn time_delta_distance_us(&mut self) -> i32;
                        fn time_usec(&mut self) -> i64;
                        fn sensor_id(&mut self) -> i8;
                        fn integrated_x(&mut self) -> f32;
                        fn integrated_y(&mut self) -> f32;
                        fn integrated_xgyro(&mut self) -> f32;
                        fn integrated_ygyro(&mut self) -> f32;
                        fn integrated_zgyro(&mut self) -> f32;
                        fn temperature(&mut self) -> i16;
                        fn quality(&mut self) -> i8;
                        fn distance(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.integration_time_us().set(src.integration_time_us());
                        dst.time_delta_distance_us().set(src.time_delta_distance_us());
                        dst.time_usec().set(src.time_usec());
                        dst.sensor_id().set(src.sensor_id());
                        dst.integrated_x().set(src.integrated_x());
                        dst.integrated_y().set(src.integrated_y());
                        dst.integrated_xgyro().set(src.integrated_xgyro());
                        dst.integrated_ygyro().set(src.integrated_ygyro());
                        dst.integrated_zgyro().set(src.integrated_zgyro());
                        dst.temperature().set(src.temperature());
                        dst.quality().set(src.quality());
                        dst.distance().set(src.distance());
                    }
                }

                /**
*Reply to LOG_REQUEST_DATA */

                pub mod LOG_DATA {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOG_DATA) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn id(&mut self) -> crate::util_::Item__ad_hoc1677 {
                            crate::util_::Item__ad_hoc1677(self.0)
                        }
                        pub fn ofs(&mut self) -> crate::util_::Item__ad_hoc1678 {
                            crate::util_::Item__ad_hoc1678(self.0)
                        }
                        pub fn count(&mut self) -> crate::util_::Item__ad_hoc1679 {
                            crate::util_::Item__ad_hoc1679(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1680 {
                            let dst = self.0;

                            let len = 90 as usize;
                            let offset = 7;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1680 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.id(src.id().get());
                        dst.ofs(src.ofs().get());
                        dst.count(src.count().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn id(&mut self, src: i16);
                        fn ofs(&mut self, src: i32);
                        fn count(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1680);
                    }

                    pub trait SRC_ {
                        fn id(&mut self) -> i16;
                        fn ofs(&mut self) -> i32;
                        fn count(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1680);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.id().set(src.id());
                        dst.ofs().set(src.ofs());
                        dst.count().set(src.count());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 90usize;
                    }
                }

                /**
*Delete all mission items at once. */

                pub mod MISSION_CLEAR_ALL {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_CLEAR_ALL) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn mission_type(&mut self) -> Option<packs::MAV_MISSION_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 16 && !src.set_field(16, -1) { return None; }

                            Some({ packs::MAV_MISSION_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        if let Some(src) = src.mission_type() {
                            dst.mission_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn mission_type(&mut self, src: packs::MAV_MISSION_TYPE);
                    }
                }

                /**
*Status of third AHRS filter if available. This is for ANU research group (Ali and Sean) */

                pub mod AHRS3 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::AHRS3) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn roll(&mut self) -> crate::util_::Item__ad_hoc2323 {
                            crate::util_::Item__ad_hoc2323(self.0)
                        }
                        pub fn pitch(&mut self) -> crate::util_::Item__ad_hoc2324 {
                            crate::util_::Item__ad_hoc2324(self.0)
                        }
                        pub fn yaw(&mut self) -> crate::util_::Item__ad_hoc2325 {
                            crate::util_::Item__ad_hoc2325(self.0)
                        }
                        pub fn altitude(&mut self) -> crate::util_::Item__ad_hoc2326 {
                            crate::util_::Item__ad_hoc2326(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc2327 {
                            crate::util_::Item__ad_hoc2327(self.0)
                        }
                        pub fn lng(&mut self) -> crate::util_::Item__ad_hoc2328 {
                            crate::util_::Item__ad_hoc2328(self.0)
                        }
                        pub fn v1(&mut self) -> crate::util_::Item__ad_hoc2329 {
                            crate::util_::Item__ad_hoc2329(self.0)
                        }
                        pub fn v2(&mut self) -> crate::util_::Item__ad_hoc2330 {
                            crate::util_::Item__ad_hoc2330(self.0)
                        }
                        pub fn v3(&mut self) -> crate::util_::Item__ad_hoc2331 {
                            crate::util_::Item__ad_hoc2331(self.0)
                        }
                        pub fn v4(&mut self) -> crate::util_::Item__ad_hoc2332 {
                            crate::util_::Item__ad_hoc2332(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.roll(src.roll().get());
                        dst.pitch(src.pitch().get());
                        dst.yaw(src.yaw().get());
                        dst.altitude(src.altitude().get());
                        dst.lat(src.lat().get());
                        dst.lng(src.lng().get());
                        dst.v1(src.v1().get());
                        dst.v2(src.v2().get());
                        dst.v3(src.v3().get());
                        dst.v4(src.v4().get());
                    }

                    pub trait DST_ {
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn altitude(&mut self, src: f32);
                        fn lat(&mut self, src: i32);
                        fn lng(&mut self, src: i32);
                        fn v1(&mut self, src: f32);
                        fn v2(&mut self, src: f32);
                        fn v3(&mut self, src: f32);
                        fn v4(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn roll(&mut self) -> f32;
                        fn pitch(&mut self) -> f32;
                        fn yaw(&mut self) -> f32;
                        fn altitude(&mut self) -> f32;
                        fn lat(&mut self) -> i32;
                        fn lng(&mut self) -> i32;
                        fn v1(&mut self) -> f32;
                        fn v2(&mut self) -> f32;
                        fn v3(&mut self) -> f32;
                        fn v4(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.roll().set(src.roll());
                        dst.pitch().set(src.pitch());
                        dst.yaw().set(src.yaw());
                        dst.altitude().set(src.altitude());
                        dst.lat().set(src.lat());
                        dst.lng().set(src.lng());
                        dst.v1().set(src.v1());
                        dst.v2().set(src.v2());
                        dst.v3().set(src.v3());
                        dst.v4().set(src.v4());
                    }
                }

                pub mod VICON_POSITION_ESTIMATE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::VICON_POSITION_ESTIMATE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn usec(&mut self) -> crate::util_::Item__ad_hoc1527 {
                            crate::util_::Item__ad_hoc1527(self.0)
                        }
                        pub fn x(&mut self) -> crate::util_::Item__ad_hoc1528 {
                            crate::util_::Item__ad_hoc1528(self.0)
                        }
                        pub fn y(&mut self) -> crate::util_::Item__ad_hoc1529 {
                            crate::util_::Item__ad_hoc1529(self.0)
                        }
                        pub fn z(&mut self) -> crate::util_::Item__ad_hoc1530 {
                            crate::util_::Item__ad_hoc1530(self.0)
                        }
                        pub fn roll(&mut self) -> crate::util_::Item__ad_hoc1531 {
                            crate::util_::Item__ad_hoc1531(self.0)
                        }
                        pub fn pitch(&mut self) -> crate::util_::Item__ad_hoc1532 {
                            crate::util_::Item__ad_hoc1532(self.0)
                        }
                        pub fn yaw(&mut self) -> crate::util_::Item__ad_hoc1533 {
                            crate::util_::Item__ad_hoc1533(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.usec(src.usec().get());
                        dst.x(src.x().get());
                        dst.y(src.y().get());
                        dst.z(src.z().get());
                        dst.roll(src.roll().get());
                        dst.pitch(src.pitch().get());
                        dst.yaw(src.yaw().get());
                    }

                    pub trait DST_ {
                        fn usec(&mut self, src: i64);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn usec(&mut self) -> i64;
                        fn x(&mut self) -> f32;
                        fn y(&mut self) -> f32;
                        fn z(&mut self) -> f32;
                        fn roll(&mut self) -> f32;
                        fn pitch(&mut self) -> f32;
                        fn yaw(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.usec().set(src.usec());
                        dst.x().set(src.x());
                        dst.y().set(src.y());
                        dst.z().set(src.z());
                        dst.roll().set(src.roll());
                        dst.pitch().set(src.pitch());
                        dst.yaw().set(src.yaw());
                    }
                }

                /**
*RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */

                pub mod GPS2_RTK {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GPS2_RTK) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn wn(&mut self) -> crate::util_::Item__ad_hoc1721 {
                            crate::util_::Item__ad_hoc1721(self.0)
                        }
                        pub fn time_last_baseline_ms(&mut self) -> crate::util_::Item__ad_hoc1719 {
                            crate::util_::Item__ad_hoc1719(self.0)
                        }
                        pub fn tow(&mut self) -> crate::util_::Item__ad_hoc1722 {
                            crate::util_::Item__ad_hoc1722(self.0)
                        }
                        pub fn accuracy(&mut self) -> crate::util_::Item__ad_hoc1730 {
                            crate::util_::Item__ad_hoc1730(self.0)
                        }
                        pub fn rtk_receiver_id(&mut self) -> crate::util_::Item__ad_hoc1720 {
                            crate::util_::Item__ad_hoc1720(self.0)
                        }
                        pub fn rtk_health(&mut self) -> crate::util_::Item__ad_hoc1723 {
                            crate::util_::Item__ad_hoc1723(self.0)
                        }
                        pub fn rtk_rate(&mut self) -> crate::util_::Item__ad_hoc1724 {
                            crate::util_::Item__ad_hoc1724(self.0)
                        }
                        pub fn nsats(&mut self) -> crate::util_::Item__ad_hoc1725 {
                            crate::util_::Item__ad_hoc1725(self.0)
                        }
                        pub fn baseline_coords_type(&mut self) -> crate::util_::Item__ad_hoc1726 {
                            crate::util_::Item__ad_hoc1726(self.0)
                        }
                        pub fn baseline_a_mm(&mut self) -> crate::util_::Item__ad_hoc1727 {
                            crate::util_::Item__ad_hoc1727(self.0)
                        }
                        pub fn baseline_b_mm(&mut self) -> crate::util_::Item__ad_hoc1728 {
                            crate::util_::Item__ad_hoc1728(self.0)
                        }
                        pub fn baseline_c_mm(&mut self) -> crate::util_::Item__ad_hoc1729 {
                            crate::util_::Item__ad_hoc1729(self.0)
                        }
                        pub fn iar_num_hypotheses(&mut self) -> crate::util_::Item__ad_hoc1731 {
                            crate::util_::Item__ad_hoc1731(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.wn(src.wn().get());
                        dst.time_last_baseline_ms(src.time_last_baseline_ms().get());
                        dst.tow(src.tow().get());
                        dst.accuracy(src.accuracy().get());
                        dst.rtk_receiver_id(src.rtk_receiver_id().get());
                        dst.rtk_health(src.rtk_health().get());
                        dst.rtk_rate(src.rtk_rate().get());
                        dst.nsats(src.nsats().get());
                        dst.baseline_coords_type(src.baseline_coords_type().get());
                        dst.baseline_a_mm(src.baseline_a_mm().get());
                        dst.baseline_b_mm(src.baseline_b_mm().get());
                        dst.baseline_c_mm(src.baseline_c_mm().get());
                        dst.iar_num_hypotheses(src.iar_num_hypotheses().get());
                    }

                    pub trait DST_ {
                        fn wn(&mut self, src: i16);
                        fn time_last_baseline_ms(&mut self, src: i32);
                        fn tow(&mut self, src: i32);
                        fn accuracy(&mut self, src: i32);
                        fn rtk_receiver_id(&mut self, src: i8);
                        fn rtk_health(&mut self, src: i8);
                        fn rtk_rate(&mut self, src: i8);
                        fn nsats(&mut self, src: i8);
                        fn baseline_coords_type(&mut self, src: i8);
                        fn baseline_a_mm(&mut self, src: i32);
                        fn baseline_b_mm(&mut self, src: i32);
                        fn baseline_c_mm(&mut self, src: i32);
                        fn iar_num_hypotheses(&mut self, src: i32);
                    }

                    pub trait SRC_ {
                        fn wn(&mut self) -> i16;
                        fn time_last_baseline_ms(&mut self) -> i32;
                        fn tow(&mut self) -> i32;
                        fn accuracy(&mut self) -> i32;
                        fn rtk_receiver_id(&mut self) -> i8;
                        fn rtk_health(&mut self) -> i8;
                        fn rtk_rate(&mut self) -> i8;
                        fn nsats(&mut self) -> i8;
                        fn baseline_coords_type(&mut self) -> i8;
                        fn baseline_a_mm(&mut self) -> i32;
                        fn baseline_b_mm(&mut self) -> i32;
                        fn baseline_c_mm(&mut self) -> i32;
                        fn iar_num_hypotheses(&mut self) -> i32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.wn().set(src.wn());
                        dst.time_last_baseline_ms().set(src.time_last_baseline_ms());
                        dst.tow().set(src.tow());
                        dst.accuracy().set(src.accuracy());
                        dst.rtk_receiver_id().set(src.rtk_receiver_id());
                        dst.rtk_health().set(src.rtk_health());
                        dst.rtk_rate().set(src.rtk_rate());
                        dst.nsats().set(src.nsats());
                        dst.baseline_coords_type().set(src.baseline_coords_type());
                        dst.baseline_a_mm().set(src.baseline_a_mm());
                        dst.baseline_b_mm().set(src.baseline_b_mm());
                        dst.baseline_c_mm().set(src.baseline_c_mm());
                        dst.iar_num_hypotheses().set(src.iar_num_hypotheses());
                    }
                }

                /**
*Reports results of completed compass calibration. Sent until MAG_CAL_ACK received. */

                pub mod MAG_CAL_REPORT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MAG_CAL_REPORT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn compass_id(&mut self) -> crate::util_::Item__ad_hoc2355 {
                            crate::util_::Item__ad_hoc2355(self.0)
                        }
                        pub fn cal_mask(&mut self) -> crate::util_::Item__ad_hoc2356 {
                            crate::util_::Item__ad_hoc2356(self.0)
                        }
                        pub fn autosaved(&mut self) -> crate::util_::Item__ad_hoc2357 {
                            crate::util_::Item__ad_hoc2357(self.0)
                        }
                        pub fn fitness(&mut self) -> crate::util_::Item__ad_hoc2358 {
                            crate::util_::Item__ad_hoc2358(self.0)
                        }
                        pub fn ofs_x(&mut self) -> crate::util_::Item__ad_hoc2359 {
                            crate::util_::Item__ad_hoc2359(self.0)
                        }
                        pub fn ofs_y(&mut self) -> crate::util_::Item__ad_hoc2360 {
                            crate::util_::Item__ad_hoc2360(self.0)
                        }
                        pub fn ofs_z(&mut self) -> crate::util_::Item__ad_hoc2361 {
                            crate::util_::Item__ad_hoc2361(self.0)
                        }
                        pub fn diag_x(&mut self) -> crate::util_::Item__ad_hoc2362 {
                            crate::util_::Item__ad_hoc2362(self.0)
                        }
                        pub fn diag_y(&mut self) -> crate::util_::Item__ad_hoc2363 {
                            crate::util_::Item__ad_hoc2363(self.0)
                        }
                        pub fn diag_z(&mut self) -> crate::util_::Item__ad_hoc2364 {
                            crate::util_::Item__ad_hoc2364(self.0)
                        }
                        pub fn offdiag_x(&mut self) -> crate::util_::Item__ad_hoc2365 {
                            crate::util_::Item__ad_hoc2365(self.0)
                        }
                        pub fn offdiag_y(&mut self) -> crate::util_::Item__ad_hoc2366 {
                            crate::util_::Item__ad_hoc2366(self.0)
                        }
                        pub fn offdiag_z(&mut self) -> crate::util_::Item__ad_hoc2367 {
                            crate::util_::Item__ad_hoc2367(self.0)
                        }
                        pub fn cal_status(&mut self) -> crate::util_::Item__ad_hoc83 {
                            crate::util_::Item__ad_hoc83(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.compass_id(src.compass_id().get());
                        dst.cal_mask(src.cal_mask().get());
                        dst.autosaved(src.autosaved().get());
                        dst.fitness(src.fitness().get());
                        dst.ofs_x(src.ofs_x().get());
                        dst.ofs_y(src.ofs_y().get());
                        dst.ofs_z(src.ofs_z().get());
                        dst.diag_x(src.diag_x().get());
                        dst.diag_y(src.diag_y().get());
                        dst.diag_z(src.diag_z().get());
                        dst.offdiag_x(src.offdiag_x().get());
                        dst.offdiag_y(src.offdiag_y().get());
                        dst.offdiag_z(src.offdiag_z().get());
                        if let Some(src) = src.cal_status().get() {
                            dst.cal_status(src);
                        }
                    }

                    pub trait DST_ {
                        fn compass_id(&mut self, src: i8);
                        fn cal_mask(&mut self, src: i8);
                        fn autosaved(&mut self, src: i8);
                        fn fitness(&mut self, src: f32);
                        fn ofs_x(&mut self, src: f32);
                        fn ofs_y(&mut self, src: f32);
                        fn ofs_z(&mut self, src: f32);
                        fn diag_x(&mut self, src: f32);
                        fn diag_y(&mut self, src: f32);
                        fn diag_z(&mut self, src: f32);
                        fn offdiag_x(&mut self, src: f32);
                        fn offdiag_y(&mut self, src: f32);
                        fn offdiag_z(&mut self, src: f32);
                        fn cal_status(&mut self, src: packs::MAG_CAL_STATUS);
                    }

                    pub trait SRC_ {
                        fn compass_id(&mut self) -> i8;
                        fn cal_mask(&mut self) -> i8;
                        fn autosaved(&mut self) -> i8;
                        fn fitness(&mut self) -> f32;
                        fn ofs_x(&mut self) -> f32;
                        fn ofs_y(&mut self) -> f32;
                        fn ofs_z(&mut self) -> f32;
                        fn diag_x(&mut self) -> f32;
                        fn diag_y(&mut self) -> f32;
                        fn diag_z(&mut self) -> f32;
                        fn offdiag_x(&mut self) -> f32;
                        fn offdiag_y(&mut self) -> f32;
                        fn offdiag_z(&mut self) -> f32;
                        fn cal_status(&mut self) -> Option<packs::MAG_CAL_STATUS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.compass_id().set(src.compass_id());
                        dst.cal_mask().set(src.cal_mask());
                        dst.autosaved().set(src.autosaved());
                        dst.fitness().set(src.fitness());
                        dst.ofs_x().set(src.ofs_x());
                        dst.ofs_y().set(src.ofs_y());
                        dst.ofs_z().set(src.ofs_z());
                        dst.diag_x().set(src.diag_x());
                        dst.diag_y().set(src.diag_y());
                        dst.diag_z().set(src.diag_z());
                        dst.offdiag_x().set(src.offdiag_x());
                        dst.offdiag_y().set(src.offdiag_y());
                        dst.offdiag_z().set(src.offdiag_z());
                        if let Some(src) = src.cal_status() {
                            dst.cal_status().set(src);
                        }
                    }
                }

                /**
*Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END
*				 is called */

                pub mod LOG_REQUEST_LIST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOG_REQUEST_LIST) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn start(&mut self) -> crate::util_::Item__ad_hoc1665 {
                            crate::util_::Item__ad_hoc1665(self.0)
                        }
                        pub fn end(&mut self) -> crate::util_::Item__ad_hoc1666 {
                            crate::util_::Item__ad_hoc1666(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc1663 {
                            crate::util_::Item__ad_hoc1663(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc1664 {
                            crate::util_::Item__ad_hoc1664(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.start(src.start().get());
                        dst.end(src.end().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                    }

                    pub trait DST_ {
                        fn start(&mut self, src: i16);
                        fn end(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn start(&mut self) -> i16;
                        fn end(&mut self) -> i16;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.start().set(src.start());
                        dst.end().set(src.end());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                    }
                }

                /**
*The pressure readings for the typical setup of one absolute and differential pressure sensor. The units
*				 are as specified in each field */

                pub mod SCALED_PRESSURE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SCALED_PRESSURE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn press_abs(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 4, 4usize) as u32)
                        }
                        pub fn press_diff(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 8, 4usize) as u32)
                        }
                        pub fn temperature(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 12, 2 as usize) as i16;
                            (dst) as i16
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.press_abs(src.press_abs());
                        dst.press_diff(src.press_diff());
                        dst.temperature(src.temperature());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn press_abs(&mut self, src: f32);
                        fn press_diff(&mut self, src: f32);
                        fn temperature(&mut self, src: i16);
                    }
                }

                /**
*Message implementing parts of the V2 payload specs in V1 frames for transitional support. */

                pub mod V2_EXTENSION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::V2_EXTENSION) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn message_type(&mut self) -> crate::util_::Item__ad_hoc1974 {
                            crate::util_::Item__ad_hoc1974(self.0)
                        }
                        pub fn target_network(&mut self) -> crate::util_::Item__ad_hoc1971 {
                            crate::util_::Item__ad_hoc1971(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc1972 {
                            crate::util_::Item__ad_hoc1972(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc1973 {
                            crate::util_::Item__ad_hoc1973(self.0)
                        }
                        pub fn payload(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1975 {
                            let dst = self.0;

                            let len = 249 as usize;
                            let offset = 5;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1975 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.message_type(src.message_type().get());
                        dst.target_network(src.target_network().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.payload(&mut src.payload(None));
                    }

                    pub trait DST_ {
                        fn message_type(&mut self, src: i16);
                        fn target_network(&mut self, src: i8);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn payload(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1975);
                    }

                    pub trait SRC_ {
                        fn message_type(&mut self) -> i16;
                        fn target_network(&mut self) -> i8;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn payload(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1975);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.message_type().set(src.message_type());
                        dst.target_network().set(src.target_network());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        src.payload(&mut dst.payload(None));
                    }

                    pub mod payload {
                        pub const len: usize = 249usize;
                    }
                }

                /**
*The heartbeat message shows that a system is present and responding. The type of the MAV and Autopilot
*				 hardware allow the receiving system to treat further messages from this system appropriate (e.g. by laying
*				 out the user interface based on the autopilot) */

                pub mod HEARTBEAT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HEARTBEAT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn custom_mode(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn mavlink_version(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 4, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn typE(&mut self) -> Option<packs::MAV_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 42 && !src.set_field(42, -1) { return None; }

                            Some({ packs::MAV_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 5)) as i8).unwrap() })
                        }
                        pub fn autopilot(&mut self) -> Option<packs::MAV_AUTOPILOT> {
                            let src = &mut self.0;
                            if src.base.field_bit != 43 && !src.set_field(43, -1) { return None; }

                            Some({ packs::MAV_AUTOPILOT::from_bits((sys::get_bits(src.base.bytes, src.BIT, 5)) as i8).unwrap() })
                        }
                        pub fn base_mode(&mut self) -> Option<packs::MAV_MODE_FLAG> {
                            let src = &mut self.0;
                            if src.base.field_bit != 44 && !src.set_field(44, -1) { return None; }

                            Some({ packs::MAV_MODE_FLAG::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i32).unwrap() })
                        }
                        pub fn system_status(&mut self) -> Option<packs::MAV_STATE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 45 && !src.set_field(45, -1) { return None; }

                            Some({ packs::MAV_STATE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.custom_mode(src.custom_mode());
                        dst.mavlink_version(src.mavlink_version());
                        if let Some(src) = src.typE() {
                            dst.typE(src);
                        }
                        if let Some(src) = src.autopilot() {
                            dst.autopilot(src);
                        }
                        if let Some(src) = src.base_mode() {
                            dst.base_mode(src);
                        }
                        if let Some(src) = src.system_status() {
                            dst.system_status(src);
                        }
                    }

                    pub trait DST_ {
                        fn custom_mode(&mut self, src: i32);
                        fn mavlink_version(&mut self, src: i8);
                        fn typE(&mut self, src: packs::MAV_TYPE);
                        fn autopilot(&mut self, src: packs::MAV_AUTOPILOT);
                        fn base_mode(&mut self, src: packs::MAV_MODE_FLAG);
                        fn system_status(&mut self, src: packs::MAV_STATE);
                    }
                }

                /**
*Bind a RC channel to a parameter. The parameter should change accoding to the RC channel value. */

                pub mod PARAM_MAP_RC {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PARAM_MAP_RC) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn param_index(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn parameter_rc_channel_index(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 4, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn param_value0(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 5, 4usize) as u32)
                        }
                        pub fn scale(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 9, 4usize) as u32)
                        }
                        pub fn param_value_min(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 13, 4usize) as u32)
                        }
                        pub fn param_value_max(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 17, 4usize) as u32)
                        }

                        pub fn param_id(&mut self) -> Option<&str> {
                            let src = &mut self.0;
                            if src.base.field_bit != 170 && !src.set_field(170, -1) { return None; }
                            Some(src.get_str())
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.param_index(src.param_index());
                        dst.parameter_rc_channel_index(src.parameter_rc_channel_index());
                        dst.param_value0(src.param_value0());
                        dst.scale(src.scale());
                        dst.param_value_min(src.param_value_min());
                        dst.param_value_max(src.param_value_max());
                        if let Some(src) = src.param_id() {
                            dst.param_id(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn param_index(&mut self, src: i16);
                        fn parameter_rc_channel_index(&mut self, src: i8);
                        fn param_value0(&mut self, src: f32);
                        fn scale(&mut self, src: f32);
                        fn param_value_min(&mut self, src: f32);
                        fn param_value_max(&mut self, src: f32);
                        fn param_id(&mut self, src: &str);
                    }

                    pub mod param_id {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Power supply status */

                pub mod POWER_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::POWER_STATUS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn Vcc(&mut self) -> crate::util_::Item__ad_hoc1700 {
                            crate::util_::Item__ad_hoc1700(self.0)
                        }
                        pub fn Vservo(&mut self) -> crate::util_::Item__ad_hoc1701 {
                            crate::util_::Item__ad_hoc1701(self.0)
                        }
                        pub fn flags(&mut self) -> crate::util_::Item__ad_hoc140 {
                            crate::util_::Item__ad_hoc140(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.Vcc(src.Vcc().get());
                        dst.Vservo(src.Vservo().get());
                        if let Some(src) = src.flags().get() {
                            dst.flags(src);
                        }
                    }

                    pub trait DST_ {
                        fn Vcc(&mut self, src: i16);
                        fn Vservo(&mut self, src: i16);
                        fn flags(&mut self, src: packs::MAV_POWER_STATUS);
                    }

                    pub trait SRC_ {
                        fn Vcc(&mut self) -> i16;
                        fn Vservo(&mut self) -> i16;
                        fn flags(&mut self) -> Option<packs::MAV_POWER_STATUS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.Vcc().set(src.Vcc());
                        dst.Vservo().set(src.Vservo());
                        if let Some(src) = src.flags() {
                            dst.flags().set(src);
                        }
                    }
                }

                /**
*Send a block of log data to remote location */

                pub mod REMOTE_LOG_DATA_BLOCK {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::REMOTE_LOG_DATA_BLOCK) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2335 {
                            crate::util_::Item__ad_hoc2335(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2336 {
                            crate::util_::Item__ad_hoc2336(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2337 {
                            let dst = &mut self.0;

                            let len = 200 as usize;
                            let offset = 2;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc2337 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn seqno(&mut self) -> crate::util_::Item__ad_hoc219 {
                            crate::util_::Item__ad_hoc219(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.daTa(&mut src.daTa(None));
                        if let Some(src) = src.seqno().get() {
                            dst.seqno(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2337);
                        fn seqno(&mut self, src: packs::MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2337);
                        fn seqno(&mut self) -> Option<packs::MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        src.daTa(&mut dst.daTa(None));
                        if let Some(src) = src.seqno() {
                            dst.seqno().set(src);
                        }
                    }

                    pub mod daTa {
                        pub const len: usize = 200usize;
                    }
                }

                /**
*A message containing logged data which requires a LOGGING_ACK to be sent back */

                pub mod LOGGING_DATA_ACKED {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOGGING_DATA_ACKED) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn sequence(&mut self) -> crate::util_::Item__ad_hoc2060 {
                            crate::util_::Item__ad_hoc2060(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2058 {
                            crate::util_::Item__ad_hoc2058(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2059 {
                            crate::util_::Item__ad_hoc2059(self.0)
                        }
                        pub fn length(&mut self) -> crate::util_::Item__ad_hoc2061 {
                            crate::util_::Item__ad_hoc2061(self.0)
                        }
                        pub fn first_message_offset(&mut self) -> crate::util_::Item__ad_hoc2062 {
                            crate::util_::Item__ad_hoc2062(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2063 {
                            let dst = self.0;

                            let len = 249 as usize;
                            let offset = 6;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2063 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.sequence(src.sequence().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.length(src.length().get());
                        dst.first_message_offset(src.first_message_offset().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn sequence(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn length(&mut self, src: i8);
                        fn first_message_offset(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2063);
                    }

                    pub trait SRC_ {
                        fn sequence(&mut self) -> i16;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn length(&mut self) -> i8;
                        fn first_message_offset(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2063);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.sequence().set(src.sequence());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.length().set(src.length());
                        dst.first_message_offset().set(src.first_message_offset());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 249usize;
                    }
                }

                /**
*Request that the vehicle report terrain height at the given location. Used by GCS to check if vehicle
*				 has all terrain data needed for a mission */

                pub mod TERRAIN_CHECK {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::TERRAIN_CHECK) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc1766 {
                            crate::util_::Item__ad_hoc1766(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc1767 {
                            crate::util_::Item__ad_hoc1767(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                    }

                    pub trait DST_ {
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                    }

                    pub trait SRC_ {
                        fn lat(&mut self) -> i32;
                        fn lon(&mut self) -> i32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                    }
                }

                /**
*Message to configure a camera mount, directional antenna, etc. */

                pub mod MOUNT_CONFIGURE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MOUNT_CONFIGURE) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2188 {
                            crate::util_::Item__ad_hoc2188(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2189 {
                            crate::util_::Item__ad_hoc2189(self.0)
                        }
                        pub fn stab_roll(&mut self) -> crate::util_::Item__ad_hoc2190 {
                            crate::util_::Item__ad_hoc2190(self.0)
                        }
                        pub fn stab_pitch(&mut self) -> crate::util_::Item__ad_hoc2191 {
                            crate::util_::Item__ad_hoc2191(self.0)
                        }
                        pub fn stab_yaw(&mut self) -> crate::util_::Item__ad_hoc2192 {
                            crate::util_::Item__ad_hoc2192(self.0)
                        }
                        pub fn mount_mode(&mut self) -> crate::util_::Item__ad_hoc106 {
                            crate::util_::Item__ad_hoc106(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.stab_roll(src.stab_roll().get());
                        dst.stab_pitch(src.stab_pitch().get());
                        dst.stab_yaw(src.stab_yaw().get());
                        if let Some(src) = src.mount_mode().get() {
                            dst.mount_mode(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn stab_roll(&mut self, src: i8);
                        fn stab_pitch(&mut self, src: i8);
                        fn stab_yaw(&mut self, src: i8);
                        fn mount_mode(&mut self, src: packs::MAV_MOUNT_MODE);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn stab_roll(&mut self) -> i8;
                        fn stab_pitch(&mut self) -> i8;
                        fn stab_yaw(&mut self) -> i8;
                        fn mount_mode(&mut self) -> Option<packs::MAV_MOUNT_MODE>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.stab_roll().set(src.stab_roll());
                        dst.stab_pitch().set(src.stab_pitch());
                        dst.stab_yaw().set(src.stab_yaw());
                        if let Some(src) = src.mount_mode() {
                            dst.mount_mode().set(src);
                        }
                    }
                }

                /**
*Request the information of the mission item with the sequence number seq. The response of the system to
*				 this message should be a MISSION_ITEM_INT message. http:qgroundcontrol.org/mavlink/waypoint_protoco */

                pub mod MISSION_REQUEST_INT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_REQUEST_INT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn seq(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 3, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn mission_type(&mut self) -> Option<packs::MAV_MISSION_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 32 && !src.set_field(32, -1) { return None; }

                            Some({ packs::MAV_MISSION_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.seq(src.seq());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        if let Some(src) = src.mission_type() {
                            dst.mission_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn seq(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn mission_type(&mut self, src: packs::MAV_MISSION_TYPE);
                    }
                }

                /**
*The offset in X, Y, Z and yaw between the LOCAL_POSITION_NED messages of MAV X and the global coordinate
*				 frame in NED coordinates. Coordinate frame is right-handed, Z-axis down (aeronautical frame, NED / north-east-down
*				 convention */

                pub mod LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 4, 4usize) as u32)
                        }
                        pub fn y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 8, 4usize) as u32)
                        }
                        pub fn z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 12, 4usize) as u32)
                        }
                        pub fn roll(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 16, 4usize) as u32)
                        }
                        pub fn pitch(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 20, 4usize) as u32)
                        }
                        pub fn yaw(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 24, 4usize) as u32)
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.x(src.x());
                        dst.y(src.y());
                        dst.z(src.z());
                        dst.roll(src.roll());
                        dst.pitch(src.pitch());
                        dst.yaw(src.yaw());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                    }
                }

                /**
*Report status of a command. Includes feedback whether the command was executed. */

                pub mod COMMAND_ACK {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::COMMAND_ACK) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn command(&mut self) -> Option<packs::MAV_CMD> {
                            let src = &mut self.0;
                            if src.base.field_bit != 2 && !src.set_field(2, -1) { return None; }

                            Some({ packs::MAV_CMD::from_bits((sys::get_bits(src.base.bytes, src.BIT, 8)) as i32).unwrap() })
                        }
                        pub fn result(&mut self) -> Option<packs::MAV_RESULT> {
                            let src = &mut self.0;
                            if src.base.field_bit != 3 && !src.set_field(3, -1) { return None; }

                            Some({ packs::MAV_RESULT::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i8).unwrap() })
                        }
                        pub fn progress(&mut self) -> Option<i8> {
                            let src = &mut self.0;
                            if src.base.field_bit != 4 && !src.set_field(4, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 1 as usize) as i8;
                                (dst) as i8
                            })
                        }
                        pub fn result_param2(&mut self) -> Option<i32> {
                            let src = &mut self.0;
                            if src.base.field_bit != 5 && !src.set_field(5, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 4 as usize) as i32;
                                (dst) as i32
                            })
                        }
                        pub fn target_system(&mut self) -> Option<i8> {
                            let src = &mut self.0;
                            if src.base.field_bit != 6 && !src.set_field(6, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 1 as usize) as i8;
                                (dst) as i8
                            })
                        }
                        pub fn target_component(&mut self) -> Option<i8> {
                            let src = &mut self.0;
                            if src.base.field_bit != 7 && !src.set_field(7, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 1 as usize) as i8;
                                (dst) as i8
                            })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        if let Some(src) = src.command() {
                            dst.command(src);
                        }
                        if let Some(src) = src.result() {
                            dst.result(src);
                        }
                        if let Some(src) = src.progress() {
                            dst.progress(src);
                        }
                        if let Some(src) = src.result_param2() {
                            dst.result_param2(src);
                        }
                        if let Some(src) = src.target_system() {
                            dst.target_system(src);
                        }
                        if let Some(src) = src.target_component() {
                            dst.target_component(src);
                        }
                    }

                    pub trait DST_ {
                        fn command(&mut self, src: packs::MAV_CMD);
                        fn result(&mut self, src: packs::MAV_RESULT);
                        fn progress(&mut self, src: i8);
                        fn result_param2(&mut self, src: i32);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }
                }

                /**
*THIS INTERFACE IS DEPRECATED. USE MESSAGE_INTERVAL INSTEAD. */

                pub mod DATA_STREAM {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DATA_STREAM) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn message_rate(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn stream_id(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn on_off(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 3, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.message_rate(src.message_rate());
                        dst.stream_id(src.stream_id());
                        dst.on_off(src.on_off());
                    }

                    pub trait DST_ {
                        fn message_rate(&mut self, src: i16);
                        fn stream_id(&mut self, src: i8);
                        fn on_off(&mut self, src: i8);
                    }
                }

                /**
*Request the information of the mission item with the sequence number seq. The response of the system to
*				 this message should be a MISSION_ITEM message. http:qgroundcontrol.org/mavlink/waypoint_protoco */

                pub mod MISSION_REQUEST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_REQUEST) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn seq(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 3, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn mission_type(&mut self) -> Option<packs::MAV_MISSION_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 32 && !src.set_field(32, -1) { return None; }

                            Some({ packs::MAV_MISSION_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.seq(src.seq());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        if let Some(src) = src.mission_type() {
                            dst.mission_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn seq(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn mission_type(&mut self, src: packs::MAV_MISSION_TYPE);
                    }
                }

                /**
*Response from a TERRAIN_CHECK request */

                pub mod TERRAIN_REPORT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::TERRAIN_REPORT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn spacing(&mut self) -> crate::util_::Item__ad_hoc1770 {
                            crate::util_::Item__ad_hoc1770(self.0)
                        }
                        pub fn pending(&mut self) -> crate::util_::Item__ad_hoc1773 {
                            crate::util_::Item__ad_hoc1773(self.0)
                        }
                        pub fn loaded(&mut self) -> crate::util_::Item__ad_hoc1774 {
                            crate::util_::Item__ad_hoc1774(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc1768 {
                            crate::util_::Item__ad_hoc1768(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc1769 {
                            crate::util_::Item__ad_hoc1769(self.0)
                        }
                        pub fn terrain_height(&mut self) -> crate::util_::Item__ad_hoc1771 {
                            crate::util_::Item__ad_hoc1771(self.0)
                        }
                        pub fn current_height(&mut self) -> crate::util_::Item__ad_hoc1772 {
                            crate::util_::Item__ad_hoc1772(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.spacing(src.spacing().get());
                        dst.pending(src.pending().get());
                        dst.loaded(src.loaded().get());
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                        dst.terrain_height(src.terrain_height().get());
                        dst.current_height(src.current_height().get());
                    }

                    pub trait DST_ {
                        fn spacing(&mut self, src: i16);
                        fn pending(&mut self, src: i16);
                        fn loaded(&mut self, src: i16);
                        fn lat(&mut self, src: i32);
                        fn lon(&mut self, src: i32);
                        fn terrain_height(&mut self, src: f32);
                        fn current_height(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn spacing(&mut self) -> i16;
                        fn pending(&mut self) -> i16;
                        fn loaded(&mut self) -> i16;
                        fn lat(&mut self) -> i32;
                        fn lon(&mut self) -> i32;
                        fn terrain_height(&mut self) -> f32;
                        fn current_height(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.spacing().set(src.spacing());
                        dst.pending().set(src.pending());
                        dst.loaded().set(src.loaded());
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                        dst.terrain_height().set(src.terrain_height());
                        dst.current_height().set(src.current_height());
                    }
                }

                /**
*The position the system will return to and land on. The position is set automatically by the system during
*				 the takeoff in case it was not explicitely set by the operator before or after. The global and local
*				 positions encode the position in the respective coordinate frames, while the q parameter encodes the
*				 orientation of the surface. Under normal conditions it describes the heading and terrain slope, which
*				 can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which
*				 the system should fly in normal flight mode and then perform a landing sequence along the vector */

                pub mod SET_HOME_POSITION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SET_HOME_POSITION) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc1943 {
                            crate::util_::Item__ad_hoc1943(self.0)
                        }
                        pub fn latitude(&mut self) -> crate::util_::Item__ad_hoc1944 {
                            crate::util_::Item__ad_hoc1944(self.0)
                        }
                        pub fn longitude(&mut self) -> crate::util_::Item__ad_hoc1945 {
                            crate::util_::Item__ad_hoc1945(self.0)
                        }
                        pub fn altitude(&mut self) -> crate::util_::Item__ad_hoc1946 {
                            crate::util_::Item__ad_hoc1946(self.0)
                        }
                        pub fn x(&mut self) -> crate::util_::Item__ad_hoc1947 {
                            crate::util_::Item__ad_hoc1947(self.0)
                        }
                        pub fn y(&mut self) -> crate::util_::Item__ad_hoc1948 {
                            crate::util_::Item__ad_hoc1948(self.0)
                        }
                        pub fn z(&mut self) -> crate::util_::Item__ad_hoc1949 {
                            crate::util_::Item__ad_hoc1949(self.0)
                        }
                        pub fn q(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc1950 {
                            let dst = &mut self.0;

                            let len = 4 as usize;
                            let offset = 25;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc1950 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn approach_x(&mut self) -> crate::util_::Item__ad_hoc1951 {
                            crate::util_::Item__ad_hoc1951(self.0)
                        }
                        pub fn approach_y(&mut self) -> crate::util_::Item__ad_hoc1952 {
                            crate::util_::Item__ad_hoc1952(self.0)
                        }
                        pub fn approach_z(&mut self) -> crate::util_::Item__ad_hoc1953 {
                            crate::util_::Item__ad_hoc1953(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1954 {
                            crate::util_::Item__ad_hoc1954(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.latitude(src.latitude().get());
                        dst.longitude(src.longitude().get());
                        dst.altitude(src.altitude().get());
                        dst.x(src.x().get());
                        dst.y(src.y().get());
                        dst.z(src.z().get());
                        dst.q(&mut src.q(None));
                        dst.approach_x(src.approach_x().get());
                        dst.approach_y(src.approach_y().get());
                        dst.approach_z(src.approach_z().get());
                        if let Some(src) = src.time_usec().get() {
                            dst.time_usec(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn latitude(&mut self, src: i32);
                        fn longitude(&mut self, src: i32);
                        fn altitude(&mut self, src: i32);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn q(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1950);
                        fn approach_x(&mut self, src: f32);
                        fn approach_y(&mut self, src: f32);
                        fn approach_z(&mut self, src: f32);
                        fn time_usec(&mut self, src: i64);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn latitude(&mut self) -> i32;
                        fn longitude(&mut self) -> i32;
                        fn altitude(&mut self) -> i32;
                        fn x(&mut self) -> f32;
                        fn y(&mut self) -> f32;
                        fn z(&mut self) -> f32;
                        fn q(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1950);
                        fn approach_x(&mut self) -> f32;
                        fn approach_y(&mut self) -> f32;
                        fn approach_z(&mut self) -> f32;
                        fn time_usec(&mut self) -> Option<i64>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.latitude().set(src.latitude());
                        dst.longitude().set(src.longitude());
                        dst.altitude().set(src.altitude());
                        dst.x().set(src.x());
                        dst.y().set(src.y());
                        dst.z().set(src.z());
                        src.q(&mut dst.q(None));
                        dst.approach_x().set(src.approach_x());
                        dst.approach_y().set(src.approach_y());
                        dst.approach_z().set(src.approach_z());
                        if let Some(src) = src.time_usec() {
                            dst.time_usec().set(src);
                        }
                    }

                    pub mod q {
                        pub const len: usize = 4usize;
                    }
                }

                pub mod SwitchModeCommand {
                    use super::*;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { transmute(&crate::util_::SwitchModeCommand) };
                }

                /**
*Sent from simulation to autopilot. The RAW values of the RC channels received. The standard PPM modulation
*				 is as follows: 1000 microseconds: 0%, 2000 microseconds: 100%. Individual receivers/transmitters might
*				 violate this specification */

                pub mod HIL_RC_INPUTS_RAW {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HIL_RC_INPUTS_RAW) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn chan1_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan2_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 2, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan3_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 4, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan4_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 6, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan5_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 8, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan6_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 10, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan7_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 12, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan8_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 14, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan9_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 16, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan10_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 18, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan11_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 20, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan12_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 22, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 24, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn rssi(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 32, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.chan1_raw(src.chan1_raw());
                        dst.chan2_raw(src.chan2_raw());
                        dst.chan3_raw(src.chan3_raw());
                        dst.chan4_raw(src.chan4_raw());
                        dst.chan5_raw(src.chan5_raw());
                        dst.chan6_raw(src.chan6_raw());
                        dst.chan7_raw(src.chan7_raw());
                        dst.chan8_raw(src.chan8_raw());
                        dst.chan9_raw(src.chan9_raw());
                        dst.chan10_raw(src.chan10_raw());
                        dst.chan11_raw(src.chan11_raw());
                        dst.chan12_raw(src.chan12_raw());
                        dst.time_usec(src.time_usec());
                        dst.rssi(src.rssi());
                    }

                    pub trait DST_ {
                        fn chan1_raw(&mut self, src: i16);
                        fn chan2_raw(&mut self, src: i16);
                        fn chan3_raw(&mut self, src: i16);
                        fn chan4_raw(&mut self, src: i16);
                        fn chan5_raw(&mut self, src: i16);
                        fn chan6_raw(&mut self, src: i16);
                        fn chan7_raw(&mut self, src: i16);
                        fn chan8_raw(&mut self, src: i16);
                        fn chan9_raw(&mut self, src: i16);
                        fn chan10_raw(&mut self, src: i16);
                        fn chan11_raw(&mut self, src: i16);
                        fn chan12_raw(&mut self, src: i16);
                        fn time_usec(&mut self, src: i64);
                        fn rssi(&mut self, src: i8);
                    }
                }

                /**
*The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described
*				 unit */

                pub mod SCALED_IMU3 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SCALED_IMU3) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc1732 {
                            crate::util_::Item__ad_hoc1732(self.0)
                        }
                        pub fn xacc(&mut self) -> crate::util_::Item__ad_hoc1733 {
                            crate::util_::Item__ad_hoc1733(self.0)
                        }
                        pub fn yacc(&mut self) -> crate::util_::Item__ad_hoc1734 {
                            crate::util_::Item__ad_hoc1734(self.0)
                        }
                        pub fn zacc(&mut self) -> crate::util_::Item__ad_hoc1735 {
                            crate::util_::Item__ad_hoc1735(self.0)
                        }
                        pub fn xgyro(&mut self) -> crate::util_::Item__ad_hoc1736 {
                            crate::util_::Item__ad_hoc1736(self.0)
                        }
                        pub fn ygyro(&mut self) -> crate::util_::Item__ad_hoc1737 {
                            crate::util_::Item__ad_hoc1737(self.0)
                        }
                        pub fn zgyro(&mut self) -> crate::util_::Item__ad_hoc1738 {
                            crate::util_::Item__ad_hoc1738(self.0)
                        }
                        pub fn xmag(&mut self) -> crate::util_::Item__ad_hoc1739 {
                            crate::util_::Item__ad_hoc1739(self.0)
                        }
                        pub fn ymag(&mut self) -> crate::util_::Item__ad_hoc1740 {
                            crate::util_::Item__ad_hoc1740(self.0)
                        }
                        pub fn zmag(&mut self) -> crate::util_::Item__ad_hoc1741 {
                            crate::util_::Item__ad_hoc1741(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.xacc(src.xacc().get());
                        dst.yacc(src.yacc().get());
                        dst.zacc(src.zacc().get());
                        dst.xgyro(src.xgyro().get());
                        dst.ygyro(src.ygyro().get());
                        dst.zgyro(src.zgyro().get());
                        dst.xmag(src.xmag().get());
                        dst.ymag(src.ymag().get());
                        dst.zmag(src.zmag().get());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn xacc(&mut self, src: i16);
                        fn yacc(&mut self, src: i16);
                        fn zacc(&mut self, src: i16);
                        fn xgyro(&mut self, src: i16);
                        fn ygyro(&mut self, src: i16);
                        fn zgyro(&mut self, src: i16);
                        fn xmag(&mut self, src: i16);
                        fn ymag(&mut self, src: i16);
                        fn zmag(&mut self, src: i16);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn xacc(&mut self) -> i16;
                        fn yacc(&mut self) -> i16;
                        fn zacc(&mut self) -> i16;
                        fn xgyro(&mut self) -> i16;
                        fn ygyro(&mut self) -> i16;
                        fn zgyro(&mut self) -> i16;
                        fn xmag(&mut self) -> i16;
                        fn ymag(&mut self) -> i16;
                        fn zmag(&mut self) -> i16;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.xacc().set(src.xacc());
                        dst.yacc().set(src.yacc());
                        dst.zacc().set(src.zacc());
                        dst.xgyro().set(src.xgyro());
                        dst.ygyro().set(src.ygyro());
                        dst.zgyro().set(src.zgyro());
                        dst.xmag().set(src.xmag());
                        dst.ymag().set(src.ymag());
                        dst.zmag().set(src.zmag());
                    }
                }

                /**
*THIS INTERFACE IS DEPRECATED. USE COMMAND_LONG with MAV_CMD_DO_SET_MODE INSTEAD. Set the system mode,
*				 as defined by enum MAV_MODE. There is no target component id as the mode is by definition for the overall
*				 aircraft, not only for one component */

                pub mod SET_MODE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SET_MODE) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn custom_mode(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 4, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn base_mode(&mut self) -> Option<packs::MAV_MODE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 40 && !src.set_field(40, -1) { return None; }

                            Some({ packs::MAV_MODE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.custom_mode(src.custom_mode());
                        dst.target_system(src.target_system());
                        if let Some(src) = src.base_mode() {
                            dst.base_mode(src);
                        }
                    }

                    pub trait DST_ {
                        fn custom_mode(&mut self, src: i32);
                        fn target_system(&mut self, src: i8);
                        fn base_mode(&mut self, src: packs::MAV_MODE);
                    }
                }

                /**
*Message to control a camera mount, directional antenna, etc. */

                pub mod MOUNT_CONTROL {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MOUNT_CONTROL) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2193 {
                            crate::util_::Item__ad_hoc2193(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2194 {
                            crate::util_::Item__ad_hoc2194(self.0)
                        }
                        pub fn input_a(&mut self) -> crate::util_::Item__ad_hoc2195 {
                            crate::util_::Item__ad_hoc2195(self.0)
                        }
                        pub fn input_b(&mut self) -> crate::util_::Item__ad_hoc2196 {
                            crate::util_::Item__ad_hoc2196(self.0)
                        }
                        pub fn input_c(&mut self) -> crate::util_::Item__ad_hoc2197 {
                            crate::util_::Item__ad_hoc2197(self.0)
                        }
                        pub fn save_position(&mut self) -> crate::util_::Item__ad_hoc2198 {
                            crate::util_::Item__ad_hoc2198(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.input_a(src.input_a().get());
                        dst.input_b(src.input_b().get());
                        dst.input_c(src.input_c().get());
                        dst.save_position(src.save_position().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn input_a(&mut self, src: i32);
                        fn input_b(&mut self, src: i32);
                        fn input_c(&mut self, src: i32);
                        fn save_position(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn input_a(&mut self) -> i32;
                        fn input_b(&mut self) -> i32;
                        fn input_c(&mut self) -> i32;
                        fn save_position(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.input_a().set(src.input_a());
                        dst.input_b().set(src.input_b());
                        dst.input_c().set(src.input_c());
                        dst.save_position().set(src.save_position());
                    }
                }

                /**
*Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot.
*				 This should match the commands sent in SET_POSITION_TARGET_GLOBAL_INT if the vehicle is being controlled
*				 this way */

                pub mod POSITION_TARGET_GLOBAL_INT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::POSITION_TARGET_GLOBAL_INT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn type_mask(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn lat_int(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 6, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn lon_int(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 10, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn alt(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 14, 4usize) as u32)
                        }
                        pub fn vx(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 18, 4usize) as u32)
                        }
                        pub fn vy(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 22, 4usize) as u32)
                        }
                        pub fn vz(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 26, 4usize) as u32)
                        }
                        pub fn afx(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 30, 4usize) as u32)
                        }
                        pub fn afy(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 34, 4usize) as u32)
                        }
                        pub fn afz(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 38, 4usize) as u32)
                        }
                        pub fn yaw(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 42, 4usize) as u32)
                        }
                        pub fn yaw_rate(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 46, 4usize) as u32)
                        }
                        pub fn coordinate_frame(&mut self) -> Option<packs::MAV_FRAME> {
                            let src = &mut self.0;
                            if src.base.field_bit != 400 && !src.set_field(400, -1) { return None; }

                            Some({ packs::MAV_FRAME::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.type_mask(src.type_mask());
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.lat_int(src.lat_int());
                        dst.lon_int(src.lon_int());
                        dst.alt(src.alt());
                        dst.vx(src.vx());
                        dst.vy(src.vy());
                        dst.vz(src.vz());
                        dst.afx(src.afx());
                        dst.afy(src.afy());
                        dst.afz(src.afz());
                        dst.yaw(src.yaw());
                        dst.yaw_rate(src.yaw_rate());
                        if let Some(src) = src.coordinate_frame() {
                            dst.coordinate_frame(src);
                        }
                    }

                    pub trait DST_ {
                        fn type_mask(&mut self, src: i16);
                        fn time_boot_ms(&mut self, src: i32);
                        fn lat_int(&mut self, src: i32);
                        fn lon_int(&mut self, src: i32);
                        fn alt(&mut self, src: f32);
                        fn vx(&mut self, src: f32);
                        fn vy(&mut self, src: f32);
                        fn vz(&mut self, src: f32);
                        fn afx(&mut self, src: f32);
                        fn afy(&mut self, src: f32);
                        fn afz(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn yaw_rate(&mut self, src: f32);
                        fn coordinate_frame(&mut self, src: packs::MAV_FRAME);
                    }
                }

                /**
*Control vehicle LEDs */

                pub mod LED_CONTROL {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LED_CONTROL) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2341 {
                            crate::util_::Item__ad_hoc2341(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2342 {
                            crate::util_::Item__ad_hoc2342(self.0)
                        }
                        pub fn instance(&mut self) -> crate::util_::Item__ad_hoc2343 {
                            crate::util_::Item__ad_hoc2343(self.0)
                        }
                        pub fn pattern(&mut self) -> crate::util_::Item__ad_hoc2344 {
                            crate::util_::Item__ad_hoc2344(self.0)
                        }
                        pub fn custom_len(&mut self) -> crate::util_::Item__ad_hoc2345 {
                            crate::util_::Item__ad_hoc2345(self.0)
                        }
                        pub fn custom_bytes(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2346 {
                            let dst = self.0;

                            let len = 24 as usize;
                            let offset = 5;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2346 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.instance(src.instance().get());
                        dst.pattern(src.pattern().get());
                        dst.custom_len(src.custom_len().get());
                        dst.custom_bytes(&mut src.custom_bytes(None));
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn instance(&mut self, src: i8);
                        fn pattern(&mut self, src: i8);
                        fn custom_len(&mut self, src: i8);
                        fn custom_bytes(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2346);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn instance(&mut self) -> i8;
                        fn pattern(&mut self) -> i8;
                        fn custom_len(&mut self) -> i8;
                        fn custom_bytes(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2346);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.instance().set(src.instance());
                        dst.pattern().set(src.pattern());
                        dst.custom_len().set(src.custom_len());
                        src.custom_bytes(&mut dst.custom_bytes(None));
                    }

                    pub mod custom_bytes {
                        pub const len: usize = 24usize;
                    }
                }

                /**
*Status of simulation environment, if used */

                pub mod SIM_STATE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SIM_STATE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn q1(&mut self) -> crate::util_::Item__ad_hoc1576 {
                            crate::util_::Item__ad_hoc1576(self.0)
                        }
                        pub fn q2(&mut self) -> crate::util_::Item__ad_hoc1577 {
                            crate::util_::Item__ad_hoc1577(self.0)
                        }
                        pub fn q3(&mut self) -> crate::util_::Item__ad_hoc1578 {
                            crate::util_::Item__ad_hoc1578(self.0)
                        }
                        pub fn q4(&mut self) -> crate::util_::Item__ad_hoc1579 {
                            crate::util_::Item__ad_hoc1579(self.0)
                        }
                        pub fn roll(&mut self) -> crate::util_::Item__ad_hoc1580 {
                            crate::util_::Item__ad_hoc1580(self.0)
                        }
                        pub fn pitch(&mut self) -> crate::util_::Item__ad_hoc1581 {
                            crate::util_::Item__ad_hoc1581(self.0)
                        }
                        pub fn yaw(&mut self) -> crate::util_::Item__ad_hoc1582 {
                            crate::util_::Item__ad_hoc1582(self.0)
                        }
                        pub fn xacc(&mut self) -> crate::util_::Item__ad_hoc1583 {
                            crate::util_::Item__ad_hoc1583(self.0)
                        }
                        pub fn yacc(&mut self) -> crate::util_::Item__ad_hoc1584 {
                            crate::util_::Item__ad_hoc1584(self.0)
                        }
                        pub fn zacc(&mut self) -> crate::util_::Item__ad_hoc1585 {
                            crate::util_::Item__ad_hoc1585(self.0)
                        }
                        pub fn xgyro(&mut self) -> crate::util_::Item__ad_hoc1586 {
                            crate::util_::Item__ad_hoc1586(self.0)
                        }
                        pub fn ygyro(&mut self) -> crate::util_::Item__ad_hoc1587 {
                            crate::util_::Item__ad_hoc1587(self.0)
                        }
                        pub fn zgyro(&mut self) -> crate::util_::Item__ad_hoc1588 {
                            crate::util_::Item__ad_hoc1588(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc1589 {
                            crate::util_::Item__ad_hoc1589(self.0)
                        }
                        pub fn lon(&mut self) -> crate::util_::Item__ad_hoc1590 {
                            crate::util_::Item__ad_hoc1590(self.0)
                        }
                        pub fn alt(&mut self) -> crate::util_::Item__ad_hoc1591 {
                            crate::util_::Item__ad_hoc1591(self.0)
                        }
                        pub fn std_dev_horz(&mut self) -> crate::util_::Item__ad_hoc1592 {
                            crate::util_::Item__ad_hoc1592(self.0)
                        }
                        pub fn std_dev_vert(&mut self) -> crate::util_::Item__ad_hoc1593 {
                            crate::util_::Item__ad_hoc1593(self.0)
                        }
                        pub fn vn(&mut self) -> crate::util_::Item__ad_hoc1594 {
                            crate::util_::Item__ad_hoc1594(self.0)
                        }
                        pub fn ve(&mut self) -> crate::util_::Item__ad_hoc1595 {
                            crate::util_::Item__ad_hoc1595(self.0)
                        }
                        pub fn vd(&mut self) -> crate::util_::Item__ad_hoc1596 {
                            crate::util_::Item__ad_hoc1596(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.q1(src.q1().get());
                        dst.q2(src.q2().get());
                        dst.q3(src.q3().get());
                        dst.q4(src.q4().get());
                        dst.roll(src.roll().get());
                        dst.pitch(src.pitch().get());
                        dst.yaw(src.yaw().get());
                        dst.xacc(src.xacc().get());
                        dst.yacc(src.yacc().get());
                        dst.zacc(src.zacc().get());
                        dst.xgyro(src.xgyro().get());
                        dst.ygyro(src.ygyro().get());
                        dst.zgyro(src.zgyro().get());
                        dst.lat(src.lat().get());
                        dst.lon(src.lon().get());
                        dst.alt(src.alt().get());
                        dst.std_dev_horz(src.std_dev_horz().get());
                        dst.std_dev_vert(src.std_dev_vert().get());
                        dst.vn(src.vn().get());
                        dst.ve(src.ve().get());
                        dst.vd(src.vd().get());
                    }

                    pub trait DST_ {
                        fn q1(&mut self, src: f32);
                        fn q2(&mut self, src: f32);
                        fn q3(&mut self, src: f32);
                        fn q4(&mut self, src: f32);
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn xacc(&mut self, src: f32);
                        fn yacc(&mut self, src: f32);
                        fn zacc(&mut self, src: f32);
                        fn xgyro(&mut self, src: f32);
                        fn ygyro(&mut self, src: f32);
                        fn zgyro(&mut self, src: f32);
                        fn lat(&mut self, src: f32);
                        fn lon(&mut self, src: f32);
                        fn alt(&mut self, src: f32);
                        fn std_dev_horz(&mut self, src: f32);
                        fn std_dev_vert(&mut self, src: f32);
                        fn vn(&mut self, src: f32);
                        fn ve(&mut self, src: f32);
                        fn vd(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn q1(&mut self) -> f32;
                        fn q2(&mut self) -> f32;
                        fn q3(&mut self) -> f32;
                        fn q4(&mut self) -> f32;
                        fn roll(&mut self) -> f32;
                        fn pitch(&mut self) -> f32;
                        fn yaw(&mut self) -> f32;
                        fn xacc(&mut self) -> f32;
                        fn yacc(&mut self) -> f32;
                        fn zacc(&mut self) -> f32;
                        fn xgyro(&mut self) -> f32;
                        fn ygyro(&mut self) -> f32;
                        fn zgyro(&mut self) -> f32;
                        fn lat(&mut self) -> f32;
                        fn lon(&mut self) -> f32;
                        fn alt(&mut self) -> f32;
                        fn std_dev_horz(&mut self) -> f32;
                        fn std_dev_vert(&mut self) -> f32;
                        fn vn(&mut self) -> f32;
                        fn ve(&mut self) -> f32;
                        fn vd(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.q1().set(src.q1());
                        dst.q2().set(src.q2());
                        dst.q3().set(src.q3());
                        dst.q4().set(src.q4());
                        dst.roll().set(src.roll());
                        dst.pitch().set(src.pitch());
                        dst.yaw().set(src.yaw());
                        dst.xacc().set(src.xacc());
                        dst.yacc().set(src.yacc());
                        dst.zacc().set(src.zacc());
                        dst.xgyro().set(src.xgyro());
                        dst.ygyro().set(src.ygyro());
                        dst.zgyro().set(src.zgyro());
                        dst.lat().set(src.lat());
                        dst.lon().set(src.lon());
                        dst.alt().set(src.alt());
                        dst.std_dev_horz().set(src.std_dev_horz());
                        dst.std_dev_vert().set(src.std_dev_vert());
                        dst.vn().set(src.vn());
                        dst.ve().set(src.ve());
                        dst.vd().set(src.vd());
                    }
                }

                /**
*Configure AP SSID and Password. */

                pub mod WIFI_CONFIG_AP {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::WIFI_CONFIG_AP) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn ssid(&mut self) -> crate::util_::Item__ad_hoc2084 {
                            crate::util_::Item__ad_hoc2084(self.0)
                        }
                        pub fn password(&mut self) -> crate::util_::Item__ad_hoc2085 {
                            crate::util_::Item__ad_hoc2085(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        if let Some(src) = src.ssid().get() {
                            dst.ssid(src);
                        }
                        if let Some(src) = src.password().get() {
                            dst.password(src);
                        }
                    }

                    pub trait DST_ {
                        fn ssid(&mut self, src: &str);
                        fn password(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn ssid_item_exists_(&mut self) -> usize;
                        fn ssid(&mut self, dst: &mut [u8]);
                        fn password_item_exists_(&mut self) -> usize;
                        fn password(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        let len = src.ssid_item_exists_();
                        if 0 < len {
                            dst.0.set_field(2, len as i32);

                            src.ssid(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                        let len = src.password_item_exists_();
                        if 0 < len {
                            dst.0.set_field(3, len as i32);

                            src.password(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod ssid {
                        pub const len_max: usize = 255usize;
                    }

                    pub mod password {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Data packet, size 96 */

                pub mod DATA96 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DATA96) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn typE(&mut self) -> crate::util_::Item__ad_hoc2260 {
                            crate::util_::Item__ad_hoc2260(self.0)
                        }
                        pub fn len(&mut self) -> crate::util_::Item__ad_hoc2261 {
                            crate::util_::Item__ad_hoc2261(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2262 {
                            let dst = self.0;

                            let len = 96 as usize;
                            let offset = 2;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2262 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.typE(src.typE().get());
                        dst.len(src.len().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn typE(&mut self, src: i8);
                        fn len(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2262);
                    }

                    pub trait SRC_ {
                        fn typE(&mut self) -> i8;
                        fn len(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2262);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.typE().set(src.typE());
                        dst.len().set(src.len());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 96usize;
                    }
                }

                /**
*WIP: Information about flight since last arming */

                pub mod FLIGHT_INFORMATION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::FLIGHT_INFORMATION) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc2044 {
                            crate::util_::Item__ad_hoc2044(self.0)
                        }
                        pub fn arming_time_utc(&mut self) -> crate::util_::Item__ad_hoc2045 {
                            crate::util_::Item__ad_hoc2045(self.0)
                        }
                        pub fn takeoff_time_utc(&mut self) -> crate::util_::Item__ad_hoc2046 {
                            crate::util_::Item__ad_hoc2046(self.0)
                        }
                        pub fn flight_uuid(&mut self) -> crate::util_::Item__ad_hoc2047 {
                            crate::util_::Item__ad_hoc2047(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.arming_time_utc(src.arming_time_utc().get());
                        dst.takeoff_time_utc(src.takeoff_time_utc().get());
                        dst.flight_uuid(src.flight_uuid().get());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn arming_time_utc(&mut self, src: i64);
                        fn takeoff_time_utc(&mut self, src: i64);
                        fn flight_uuid(&mut self, src: i64);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn arming_time_utc(&mut self) -> i64;
                        fn takeoff_time_utc(&mut self) -> i64;
                        fn flight_uuid(&mut self) -> i64;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.arming_time_utc().set(src.arming_time_utc());
                        dst.takeoff_time_utc().set(src.takeoff_time_utc());
                        dst.flight_uuid().set(src.flight_uuid());
                    }
                }

                /**
*The RAW values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds:
*				 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification */

                pub mod RC_CHANNELS_RAW {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RC_CHANNELS_RAW) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn chan1_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan2_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 2, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan3_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 4, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan4_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 6, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan5_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 8, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan6_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 10, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan7_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 12, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan8_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 14, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 16, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn port(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 20, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn rssi(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 21, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.chan1_raw(src.chan1_raw());
                        dst.chan2_raw(src.chan2_raw());
                        dst.chan3_raw(src.chan3_raw());
                        dst.chan4_raw(src.chan4_raw());
                        dst.chan5_raw(src.chan5_raw());
                        dst.chan6_raw(src.chan6_raw());
                        dst.chan7_raw(src.chan7_raw());
                        dst.chan8_raw(src.chan8_raw());
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.port(src.port());
                        dst.rssi(src.rssi());
                    }

                    pub trait DST_ {
                        fn chan1_raw(&mut self, src: i16);
                        fn chan2_raw(&mut self, src: i16);
                        fn chan3_raw(&mut self, src: i16);
                        fn chan4_raw(&mut self, src: i16);
                        fn chan5_raw(&mut self, src: i16);
                        fn chan6_raw(&mut self, src: i16);
                        fn chan7_raw(&mut self, src: i16);
                        fn chan8_raw(&mut self, src: i16);
                        fn time_boot_ms(&mut self, src: i32);
                        fn port(&mut self, src: i8);
                        fn rssi(&mut self, src: i8);
                    }
                }

                /**
*The RAW values of the servo outputs (for RC input from the remote, use the RC_CHANNELS messages). The
*				 standard PPM modulation is as follows: 1000 microseconds: 0%, 2000 microseconds: 100% */

                pub mod SERVO_OUTPUT_RAW {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SERVO_OUTPUT_RAW) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn servo1_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn servo2_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn servo3_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 4, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn servo4_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 6, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn servo5_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 8, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn servo6_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 10, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn servo7_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 12, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn servo8_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 14, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn time_usec(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 16, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn port(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 20, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn servo9_raw(&mut self) -> Option<i16> {
                            let src = &mut self.0;
                            if src.base.field_bit != 168 && !src.set_field(168, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 2 as usize) as i16;
                                (dst) as i16
                            })
                        }
                        pub fn servo10_raw(&mut self) -> Option<i16> {
                            let src = &mut self.0;
                            if src.base.field_bit != 169 && !src.set_field(169, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 2 as usize) as i16;
                                (dst) as i16
                            })
                        }
                        pub fn servo11_raw(&mut self) -> Option<i16> {
                            let src = &mut self.0;
                            if src.base.field_bit != 170 && !src.set_field(170, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 2 as usize) as i16;
                                (dst) as i16
                            })
                        }
                        pub fn servo12_raw(&mut self) -> Option<i16> {
                            let src = &mut self.0;
                            if src.base.field_bit != 171 && !src.set_field(171, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 2 as usize) as i16;
                                (dst) as i16
                            })
                        }
                        pub fn servo13_raw(&mut self) -> Option<i16> {
                            let src = &mut self.0;
                            if src.base.field_bit != 172 && !src.set_field(172, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 2 as usize) as i16;
                                (dst) as i16
                            })
                        }
                        pub fn servo14_raw(&mut self) -> Option<i16> {
                            let src = &mut self.0;
                            if src.base.field_bit != 173 && !src.set_field(173, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 2 as usize) as i16;
                                (dst) as i16
                            })
                        }
                        pub fn servo15_raw(&mut self) -> Option<i16> {
                            let src = &mut self.0;
                            if src.base.field_bit != 174 && !src.set_field(174, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 2 as usize) as i16;
                                (dst) as i16
                            })
                        }
                        pub fn servo16_raw(&mut self) -> Option<i16> {
                            let src = &mut self.0;
                            if src.base.field_bit != 175 && !src.set_field(175, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 2 as usize) as i16;
                                (dst) as i16
                            })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.servo1_raw(src.servo1_raw());
                        dst.servo2_raw(src.servo2_raw());
                        dst.servo3_raw(src.servo3_raw());
                        dst.servo4_raw(src.servo4_raw());
                        dst.servo5_raw(src.servo5_raw());
                        dst.servo6_raw(src.servo6_raw());
                        dst.servo7_raw(src.servo7_raw());
                        dst.servo8_raw(src.servo8_raw());
                        dst.time_usec(src.time_usec());
                        dst.port(src.port());
                        if let Some(src) = src.servo9_raw() {
                            dst.servo9_raw(src);
                        }
                        if let Some(src) = src.servo10_raw() {
                            dst.servo10_raw(src);
                        }
                        if let Some(src) = src.servo11_raw() {
                            dst.servo11_raw(src);
                        }
                        if let Some(src) = src.servo12_raw() {
                            dst.servo12_raw(src);
                        }
                        if let Some(src) = src.servo13_raw() {
                            dst.servo13_raw(src);
                        }
                        if let Some(src) = src.servo14_raw() {
                            dst.servo14_raw(src);
                        }
                        if let Some(src) = src.servo15_raw() {
                            dst.servo15_raw(src);
                        }
                        if let Some(src) = src.servo16_raw() {
                            dst.servo16_raw(src);
                        }
                    }

                    pub trait DST_ {
                        fn servo1_raw(&mut self, src: i16);
                        fn servo2_raw(&mut self, src: i16);
                        fn servo3_raw(&mut self, src: i16);
                        fn servo4_raw(&mut self, src: i16);
                        fn servo5_raw(&mut self, src: i16);
                        fn servo6_raw(&mut self, src: i16);
                        fn servo7_raw(&mut self, src: i16);
                        fn servo8_raw(&mut self, src: i16);
                        fn time_usec(&mut self, src: i32);
                        fn port(&mut self, src: i8);
                        fn servo9_raw(&mut self, src: i16);
                        fn servo10_raw(&mut self, src: i16);
                        fn servo11_raw(&mut self, src: i16);
                        fn servo12_raw(&mut self, src: i16);
                        fn servo13_raw(&mut self, src: i16);
                        fn servo14_raw(&mut self, src: i16);
                        fn servo15_raw(&mut self, src: i16);
                        fn servo16_raw(&mut self, src: i16);
                    }
                }

                /**
*state of APM memory */

                pub mod MEMINFO {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MEMINFO) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn brkval(&mut self) -> crate::util_::Item__ad_hoc2158 {
                            crate::util_::Item__ad_hoc2158(self.0)
                        }
                        pub fn freemem(&mut self) -> crate::util_::Item__ad_hoc2159 {
                            crate::util_::Item__ad_hoc2159(self.0)
                        }
                        pub fn freemem32(&mut self) -> crate::util_::Item__ad_hoc2160 {
                            crate::util_::Item__ad_hoc2160(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.brkval(src.brkval().get());
                        dst.freemem(src.freemem().get());
                        if let Some(src) = src.freemem32().get() {
                            dst.freemem32(src);
                        }
                    }

                    pub trait DST_ {
                        fn brkval(&mut self, src: i16);
                        fn freemem(&mut self, src: i16);
                        fn freemem32(&mut self, src: i32);
                    }

                    pub trait SRC_ {
                        fn brkval(&mut self) -> i16;
                        fn freemem(&mut self) -> i16;
                        fn freemem32(&mut self) -> Option<i32>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.brkval().set(src.brkval());
                        dst.freemem().set(src.freemem());
                        if let Some(src) = src.freemem32() {
                            dst.freemem32().set(src);
                        }
                    }
                }

                /**
*A certain mission item has been reached. The system will either hold this position (or circle on the orbit)
*				 or (if the autocontinue on the WP was set) continue to the next waypoint */

                pub mod MISSION_ITEM_REACHED {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_ITEM_REACHED) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn seq(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.seq(src.seq());
                    }

                    pub trait DST_ {
                        fn seq(&mut self, src: i16);
                    }
                }

                /**
*An ack for a LOGGING_DATA_ACKED message */

                pub mod LOGGING_ACK {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOGGING_ACK) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn sequence(&mut self) -> crate::util_::Item__ad_hoc2066 {
                            crate::util_::Item__ad_hoc2066(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2064 {
                            crate::util_::Item__ad_hoc2064(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2065 {
                            crate::util_::Item__ad_hoc2065(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.sequence(src.sequence().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                    }

                    pub trait DST_ {
                        fn sequence(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn sequence(&mut self) -> i16;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.sequence().set(src.sequence());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                    }
                }

                pub mod VISION_SPEED_ESTIMATE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::VISION_SPEED_ESTIMATE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn usec(&mut self) -> crate::util_::Item__ad_hoc1523 {
                            crate::util_::Item__ad_hoc1523(self.0)
                        }
                        pub fn x(&mut self) -> crate::util_::Item__ad_hoc1524 {
                            crate::util_::Item__ad_hoc1524(self.0)
                        }
                        pub fn y(&mut self) -> crate::util_::Item__ad_hoc1525 {
                            crate::util_::Item__ad_hoc1525(self.0)
                        }
                        pub fn z(&mut self) -> crate::util_::Item__ad_hoc1526 {
                            crate::util_::Item__ad_hoc1526(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.usec(src.usec().get());
                        dst.x(src.x().get());
                        dst.y(src.y().get());
                        dst.z(src.z().get());
                    }

                    pub trait DST_ {
                        fn usec(&mut self, src: i64);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn usec(&mut self) -> i64;
                        fn x(&mut self) -> f32;
                        fn y(&mut self) -> f32;
                        fn z(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.usec().set(src.usec());
                        dst.x().set(src.x());
                        dst.y().set(src.y());
                        dst.z().set(src.z());
                    }
                }

                pub mod DEBUG_VECT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DEBUG_VECT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1981 {
                            crate::util_::Item__ad_hoc1981(self.0)
                        }
                        pub fn x(&mut self) -> crate::util_::Item__ad_hoc1982 {
                            crate::util_::Item__ad_hoc1982(self.0)
                        }
                        pub fn y(&mut self) -> crate::util_::Item__ad_hoc1983 {
                            crate::util_::Item__ad_hoc1983(self.0)
                        }
                        pub fn z(&mut self) -> crate::util_::Item__ad_hoc1984 {
                            crate::util_::Item__ad_hoc1984(self.0)
                        }
                        pub fn name(&mut self) -> crate::util_::Item__ad_hoc1980 {
                            crate::util_::Item__ad_hoc1980(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec().get());
                        dst.x(src.x().get());
                        dst.y(src.y().get());
                        dst.z(src.z().get());
                        if let Some(src) = src.name().get() {
                            dst.name(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn name(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn time_usec(&mut self) -> i64;
                        fn x(&mut self) -> f32;
                        fn y(&mut self) -> f32;
                        fn z(&mut self) -> f32;
                        fn name_item_exists_(&mut self) -> usize;
                        fn name(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_usec().set(src.time_usec());
                        dst.x().set(src.x());
                        dst.y().set(src.y());
                        dst.z().set(src.z());
                        let len = src.name_item_exists_();
                        if 0 < len {
                            dst.0.set_field(162, len as i32);

                            src.name(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod name {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Stop log transfer and resume normal logging */

                pub mod LOG_REQUEST_END {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOG_REQUEST_END) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc1683 {
                            crate::util_::Item__ad_hoc1683(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc1684 {
                            crate::util_::Item__ad_hoc1684(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                    }
                }

                /**
*Ack message during waypoint handling. The type field states if this message is a positive ack (type=0)
*				 or if an error happened (type=non-zero) */

                pub mod MISSION_ACK {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_ACK) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn typE(&mut self) -> Option<packs::MAV_MISSION_RESULT> {
                            let src = &mut self.0;
                            if src.base.field_bit != 18 && !src.set_field(18, -1) { return None; }

                            Some({ packs::MAV_MISSION_RESULT::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                        pub fn mission_type(&mut self) -> Option<packs::MAV_MISSION_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 19 && !src.set_field(19, -1) { return None; }

                            Some({ packs::MAV_MISSION_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        if let Some(src) = src.typE() {
                            dst.typE(src);
                        }
                        if let Some(src) = src.mission_type() {
                            dst.mission_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn typE(&mut self, src: packs::MAV_MISSION_RESULT);
                        fn mission_type(&mut self, src: packs::MAV_MISSION_TYPE);
                    }
                }

                /**
*Accept / deny control of this MAV */

                pub mod CHANGE_OPERATOR_CONTROL_ACK {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::CHANGE_OPERATOR_CONTROL_ACK) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn gcs_system_id(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn control_request(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn ack(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.gcs_system_id(src.gcs_system_id());
                        dst.control_request(src.control_request());
                        dst.ack(src.ack());
                    }

                    pub trait DST_ {
                        fn gcs_system_id(&mut self, src: i8);
                        fn control_request(&mut self, src: i8);
                        fn ack(&mut self, src: i8);
                    }
                }

                /**
*Message that announces the sequence number of the current active mission item. The MAV will fly towards
*				 this mission item */

                pub mod MISSION_CURRENT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_CURRENT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn seq(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.seq(src.seq());
                    }

                    pub trait DST_ {
                        fn seq(&mut self, src: i16);
                    }
                }

                /**
*The system time is the time of the master clock, typically the computer clock of the main onboard computer */

                pub mod SYSTEM_TIME {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SYSTEM_TIME) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn time_unix_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 4, 8 as usize) as i64;
                            (dst) as i64
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.time_unix_usec(src.time_unix_usec());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn time_unix_usec(&mut self, src: i64);
                    }
                }

                /**
*Camera-IMU triggering and synchronisation message. */

                pub mod CAMERA_TRIGGER {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::CAMERA_TRIGGER) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn seq(&mut self) -> crate::util_::Item__ad_hoc1611 {
                            crate::util_::Item__ad_hoc1611(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1610 {
                            crate::util_::Item__ad_hoc1610(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.seq(src.seq().get());
                        dst.time_usec(src.time_usec().get());
                    }

                    pub trait DST_ {
                        fn seq(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                    }

                    pub trait SRC_ {
                        fn seq(&mut self) -> i32;
                        fn time_usec(&mut self) -> i64;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.seq().set(src.seq());
                        dst.time_usec().set(src.time_usec());
                    }
                }

                /**
*Response from a GOPRO_COMMAND set request */

                pub mod GOPRO_SET_RESPONSE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GOPRO_SET_RESPONSE) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn cmd_id(&mut self) -> crate::util_::Item__ad_hoc882 {
                            crate::util_::Item__ad_hoc882(self.0)
                        }
                        pub fn status(&mut self) -> crate::util_::Item__ad_hoc883 {
                            crate::util_::Item__ad_hoc883(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        if let Some(src) = src.cmd_id().get() {
                            dst.cmd_id(src);
                        }
                        if let Some(src) = src.status().get() {
                            dst.status(src);
                        }
                    }

                    pub trait DST_ {
                        fn cmd_id(&mut self, src: packs::GOPRO_COMMAND);
                        fn status(&mut self, src: packs::GOPRO_REQUEST_STATUS);
                    }

                    pub trait SRC_ {
                        fn cmd_id(&mut self) -> Option<packs::GOPRO_COMMAND>;
                        fn status(&mut self) -> Option<packs::GOPRO_REQUEST_STATUS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        if let Some(src) = src.cmd_id() {
                            dst.cmd_id().set(src);
                        }
                        if let Some(src) = src.status() {
                            dst.status().set(src);
                        }
                    }
                }

                pub mod VISION_POSITION_ESTIMATE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::VISION_POSITION_ESTIMATE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 8, 4usize) as u32)
                        }
                        pub fn y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 12, 4usize) as u32)
                        }
                        pub fn z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 16, 4usize) as u32)
                        }
                        pub fn roll(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 20, 4usize) as u32)
                        }
                        pub fn pitch(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 24, 4usize) as u32)
                        }
                        pub fn yaw(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 28, 4usize) as u32)
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.usec(src.usec());
                        dst.x(src.x());
                        dst.y(src.y());
                        dst.z(src.z());
                        dst.roll(src.roll());
                        dst.pitch(src.pitch());
                        dst.yaw(src.yaw());
                    }

                    pub trait DST_ {
                        fn usec(&mut self, src: i64);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                    }
                }

                /**
*This message provides an API for manually controlling the vehicle using standard joystick axes nomenclature,
*				 along with a joystick-like input device. Unused axes can be disabled an buttons are also transmit as
*				 boolean values of their */

                pub mod MANUAL_CONTROL {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MANUAL_CONTROL) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn buttons(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn target(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn x(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 3, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn y(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 5, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn z(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 7, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn r(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 9, 2 as usize) as i16;
                            (dst) as i16
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.buttons(src.buttons());
                        dst.target(src.target());
                        dst.x(src.x());
                        dst.y(src.y());
                        dst.z(src.z());
                        dst.r(src.r());
                    }

                    pub trait DST_ {
                        fn buttons(&mut self, src: i16);
                        fn target(&mut self, src: i8);
                        fn x(&mut self, src: i16);
                        fn y(&mut self, src: i16);
                        fn z(&mut self, src: i16);
                        fn r(&mut self, src: i16);
                    }
                }

                /**
*The PPM values of the RC channels received. The standard PPM modulation is as follows: 1000 microseconds:
*				 0%, 2000 microseconds: 100%. Individual receivers/transmitters might violate this specification */

                pub mod RC_CHANNELS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RC_CHANNELS) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn chan1_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan2_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 2, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan3_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 4, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan4_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 6, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan5_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 8, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan6_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 10, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan7_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 12, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan8_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 14, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan9_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 16, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan10_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 18, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan11_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 20, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan12_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 22, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan13_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 24, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan14_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 26, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan15_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 28, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan16_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 30, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan17_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 32, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn chan18_raw(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 34, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 36, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn chancount(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 40, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn rssi(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 41, 1 as usize) as i8;
                            (dst) as i8
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.chan1_raw(src.chan1_raw());
                        dst.chan2_raw(src.chan2_raw());
                        dst.chan3_raw(src.chan3_raw());
                        dst.chan4_raw(src.chan4_raw());
                        dst.chan5_raw(src.chan5_raw());
                        dst.chan6_raw(src.chan6_raw());
                        dst.chan7_raw(src.chan7_raw());
                        dst.chan8_raw(src.chan8_raw());
                        dst.chan9_raw(src.chan9_raw());
                        dst.chan10_raw(src.chan10_raw());
                        dst.chan11_raw(src.chan11_raw());
                        dst.chan12_raw(src.chan12_raw());
                        dst.chan13_raw(src.chan13_raw());
                        dst.chan14_raw(src.chan14_raw());
                        dst.chan15_raw(src.chan15_raw());
                        dst.chan16_raw(src.chan16_raw());
                        dst.chan17_raw(src.chan17_raw());
                        dst.chan18_raw(src.chan18_raw());
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.chancount(src.chancount());
                        dst.rssi(src.rssi());
                    }

                    pub trait DST_ {
                        fn chan1_raw(&mut self, src: i16);
                        fn chan2_raw(&mut self, src: i16);
                        fn chan3_raw(&mut self, src: i16);
                        fn chan4_raw(&mut self, src: i16);
                        fn chan5_raw(&mut self, src: i16);
                        fn chan6_raw(&mut self, src: i16);
                        fn chan7_raw(&mut self, src: i16);
                        fn chan8_raw(&mut self, src: i16);
                        fn chan9_raw(&mut self, src: i16);
                        fn chan10_raw(&mut self, src: i16);
                        fn chan11_raw(&mut self, src: i16);
                        fn chan12_raw(&mut self, src: i16);
                        fn chan13_raw(&mut self, src: i16);
                        fn chan14_raw(&mut self, src: i16);
                        fn chan15_raw(&mut self, src: i16);
                        fn chan16_raw(&mut self, src: i16);
                        fn chan17_raw(&mut self, src: i16);
                        fn chan18_raw(&mut self, src: i16);
                        fn time_boot_ms(&mut self, src: i32);
                        fn chancount(&mut self, src: i8);
                        fn rssi(&mut self, src: i8);
                    }
                }

                /**
*WIP: Version and capability of protocol version. This message is the response to REQUEST_PROTOCOL_VERSION
*				 and is used as part of the handshaking to establish which MAVLink version should be used on the network.
*				 Every node should respond to REQUEST_PROTOCOL_VERSION to enable the handshaking. Library implementers
*				 should consider adding this into the default decoding state machine to allow the protocol core to respond
*				 directly */

                pub mod PROTOCOL_VERSION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PROTOCOL_VERSION) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn version(&mut self) -> crate::util_::Item__ad_hoc2086 {
                            crate::util_::Item__ad_hoc2086(self.0)
                        }
                        pub fn min_version(&mut self) -> crate::util_::Item__ad_hoc2087 {
                            crate::util_::Item__ad_hoc2087(self.0)
                        }
                        pub fn max_version(&mut self) -> crate::util_::Item__ad_hoc2088 {
                            crate::util_::Item__ad_hoc2088(self.0)
                        }
                        pub fn spec_version_hash(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2089 {
                            let dst = self.0;

                            let len = 8 as usize;
                            let offset = 6;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2089 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn library_version_hash(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2090 {
                            let dst = self.0;

                            let len = 8 as usize;
                            let offset = 14;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2090 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.version(src.version().get());
                        dst.min_version(src.min_version().get());
                        dst.max_version(src.max_version().get());
                        dst.spec_version_hash(&mut src.spec_version_hash(None));
                        dst.library_version_hash(&mut src.library_version_hash(None));
                    }

                    pub trait DST_ {
                        fn version(&mut self, src: i16);
                        fn min_version(&mut self, src: i16);
                        fn max_version(&mut self, src: i16);
                        fn spec_version_hash(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2089);
                        fn library_version_hash(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2090);
                    }

                    pub trait SRC_ {
                        fn version(&mut self) -> i16;
                        fn min_version(&mut self) -> i16;
                        fn max_version(&mut self) -> i16;
                        fn spec_version_hash(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2089);
                        fn library_version_hash(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2090);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.version().set(src.version());
                        dst.min_version().set(src.min_version());
                        dst.max_version().set(src.max_version());
                        src.spec_version_hash(&mut dst.spec_version_hash(None));
                        src.library_version_hash(&mut dst.library_version_hash(None));
                    }

                    pub mod spec_version_hash {
                        pub const len: usize = 8usize;
                    }

                    pub mod library_version_hash {
                        pub const len: usize = 8usize;
                    }
                }

                /**
*Request a current rally point from MAV. MAV should respond with a RALLY_POINT message. MAV should not
*				 respond if the request is invalid */

                pub mod RALLY_FETCH_POINT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RALLY_FETCH_POINT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2286 {
                            crate::util_::Item__ad_hoc2286(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2287 {
                            crate::util_::Item__ad_hoc2287(self.0)
                        }
                        pub fn idx(&mut self) -> crate::util_::Item__ad_hoc2288 {
                            crate::util_::Item__ad_hoc2288(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.idx(src.idx().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn idx(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn idx(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.idx().set(src.idx());
                    }
                }

                /**
*Emit the value of a onboard parameter. The inclusion of param_count and param_index in the message allows
*				 the recipient to keep track of received parameters and allows him to re-request missing parameters after
*				 a loss or timeout */

                pub mod PARAM_VALUE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PARAM_VALUE) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn param_count(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn param_index(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn param_value(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 4, 4usize) as u32)
                        }

                        pub fn param_id(&mut self) -> Option<&str> {
                            let src = &mut self.0;
                            if src.base.field_bit != 66 && !src.set_field(66, -1) { return None; }
                            Some(src.get_str())
                        }
                        pub fn param_type(&mut self) -> Option<packs::MAV_PARAM_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 67 && !src.set_field(67, -1) { return None; }

                            Some({ packs::MAV_PARAM_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.param_count(src.param_count());
                        dst.param_index(src.param_index());
                        dst.param_value(src.param_value());
                        if let Some(src) = src.param_id() {
                            dst.param_id(src);
                        }
                        if let Some(src) = src.param_type() {
                            dst.param_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn param_count(&mut self, src: i16);
                        fn param_index(&mut self, src: i16);
                        fn param_value(&mut self, src: f32);
                        fn param_id(&mut self, src: &str);
                        fn param_type(&mut self, src: packs::MAV_PARAM_TYPE);
                    }

                    pub mod param_id {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Battery information */

                pub mod BATTERY_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::BATTERY_STATUS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn voltages(&mut self, src: Option<&mut dyn Iterator<Item=i16>>) -> crate::util_::ItemArray__ad_hoc1838 {
                            let dst = &mut self.0;

                            let len = 10 as usize;
                            let offset = 0;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc1838 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn id(&mut self) -> crate::util_::Item__ad_hoc1836 {
                            crate::util_::Item__ad_hoc1836(self.0)
                        }
                        pub fn temperature(&mut self) -> crate::util_::Item__ad_hoc1837 {
                            crate::util_::Item__ad_hoc1837(self.0)
                        }
                        pub fn current_battery(&mut self) -> crate::util_::Item__ad_hoc1839 {
                            crate::util_::Item__ad_hoc1839(self.0)
                        }
                        pub fn current_consumed(&mut self) -> crate::util_::Item__ad_hoc1840 {
                            crate::util_::Item__ad_hoc1840(self.0)
                        }
                        pub fn energy_consumed(&mut self) -> crate::util_::Item__ad_hoc1841 {
                            crate::util_::Item__ad_hoc1841(self.0)
                        }
                        pub fn battery_remaining(&mut self) -> crate::util_::Item__ad_hoc1842 {
                            crate::util_::Item__ad_hoc1842(self.0)
                        }
                        pub fn battery_function(&mut self) -> crate::util_::Item__ad_hoc58 {
                            crate::util_::Item__ad_hoc58(self.0)
                        }
                        pub fn typE(&mut self) -> crate::util_::Item__ad_hoc59 {
                            crate::util_::Item__ad_hoc59(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.voltages(&mut src.voltages(None));
                        dst.id(src.id().get());
                        dst.temperature(src.temperature().get());
                        dst.current_battery(src.current_battery().get());
                        dst.current_consumed(src.current_consumed().get());
                        dst.energy_consumed(src.energy_consumed().get());
                        dst.battery_remaining(src.battery_remaining().get());
                        if let Some(src) = src.battery_function().get() {
                            dst.battery_function(src);
                        }
                        if let Some(src) = src.typE().get() {
                            dst.typE(src);
                        }
                    }

                    pub trait DST_ {
                        fn voltages(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1838);
                        fn id(&mut self, src: i8);
                        fn temperature(&mut self, src: i16);
                        fn current_battery(&mut self, src: i16);
                        fn current_consumed(&mut self, src: i32);
                        fn energy_consumed(&mut self, src: i32);
                        fn battery_remaining(&mut self, src: i8);
                        fn battery_function(&mut self, src: packs::MAV_BATTERY_FUNCTION);
                        fn typE(&mut self, src: packs::MAV_BATTERY_TYPE);
                    }

                    pub trait SRC_ {
                        fn voltages(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1838);
                        fn id(&mut self) -> i8;
                        fn temperature(&mut self) -> i16;
                        fn current_battery(&mut self) -> i16;
                        fn current_consumed(&mut self) -> i32;
                        fn energy_consumed(&mut self) -> i32;
                        fn battery_remaining(&mut self) -> i8;
                        fn battery_function(&mut self) -> Option<packs::MAV_BATTERY_FUNCTION>;
                        fn typE(&mut self) -> Option<packs::MAV_BATTERY_TYPE>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        src.voltages(&mut dst.voltages(None));
                        dst.id().set(src.id());
                        dst.temperature().set(src.temperature());
                        dst.current_battery().set(src.current_battery());
                        dst.current_consumed().set(src.current_consumed());
                        dst.energy_consumed().set(src.energy_consumed());
                        dst.battery_remaining().set(src.battery_remaining());
                        if let Some(src) = src.battery_function() {
                            dst.battery_function().set(src);
                        }
                        if let Some(src) = src.typE() {
                            dst.typE().set(src);
                        }
                    }

                    pub mod voltages {
                        pub const len: usize = 10usize;
                    }
                }

                /**
*Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or
*				 telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages
*				 or change the devices settings. A message with zero bytes can be used to change just the baudrate */

                pub mod SERIAL_CONTROL {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SERIAL_CONTROL) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn timeout(&mut self) -> crate::util_::Item__ad_hoc1702 {
                            crate::util_::Item__ad_hoc1702(self.0)
                        }
                        pub fn baudrate(&mut self) -> crate::util_::Item__ad_hoc1703 {
                            crate::util_::Item__ad_hoc1703(self.0)
                        }
                        pub fn count(&mut self) -> crate::util_::Item__ad_hoc1704 {
                            crate::util_::Item__ad_hoc1704(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1705 {
                            let dst = &mut self.0;

                            let len = 70 as usize;
                            let offset = 7;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc1705 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn device(&mut self) -> crate::util_::Item__ad_hoc706 {
                            crate::util_::Item__ad_hoc706(self.0)
                        }
                        pub fn flags(&mut self) -> crate::util_::Item__ad_hoc705 {
                            crate::util_::Item__ad_hoc705(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.timeout(src.timeout().get());
                        dst.baudrate(src.baudrate().get());
                        dst.count(src.count().get());
                        dst.daTa(&mut src.daTa(None));
                        if let Some(src) = src.device().get() {
                            dst.device(src);
                        }
                        if let Some(src) = src.flags().get() {
                            dst.flags(src);
                        }
                    }

                    pub trait DST_ {
                        fn timeout(&mut self, src: i16);
                        fn baudrate(&mut self, src: i32);
                        fn count(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1705);
                        fn device(&mut self, src: packs::SERIAL_CONTROL_DEV);
                        fn flags(&mut self, src: packs::SERIAL_CONTROL_FLAG);
                    }

                    pub trait SRC_ {
                        fn timeout(&mut self) -> i16;
                        fn baudrate(&mut self) -> i32;
                        fn count(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1705);
                        fn device(&mut self) -> Option<packs::SERIAL_CONTROL_DEV>;
                        fn flags(&mut self) -> Option<packs::SERIAL_CONTROL_FLAG>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.timeout().set(src.timeout());
                        dst.baudrate().set(src.baudrate());
                        dst.count().set(src.count());
                        src.daTa(&mut dst.daTa(None));
                        if let Some(src) = src.device() {
                            dst.device().set(src);
                        }
                        if let Some(src) = src.flags() {
                            dst.flags().set(src);
                        }
                    }

                    pub mod daTa {
                        pub const len: usize = 70usize;
                    }
                }

                /**
*Sets a desired vehicle position in a local north-east-down coordinate frame. Used by an external controller
*				 to command the vehicle (manual controller or other system) */

                pub mod SET_POSITION_TARGET_LOCAL_NED {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SET_POSITION_TARGET_LOCAL_NED) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn type_mask(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 6, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 7, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 8, 4usize) as u32)
                        }
                        pub fn y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 12, 4usize) as u32)
                        }
                        pub fn z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 16, 4usize) as u32)
                        }
                        pub fn vx(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 20, 4usize) as u32)
                        }
                        pub fn vy(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 24, 4usize) as u32)
                        }
                        pub fn vz(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 28, 4usize) as u32)
                        }
                        pub fn afx(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 32, 4usize) as u32)
                        }
                        pub fn afy(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 36, 4usize) as u32)
                        }
                        pub fn afz(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 40, 4usize) as u32)
                        }
                        pub fn yaw(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 44, 4usize) as u32)
                        }
                        pub fn yaw_rate(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 48, 4usize) as u32)
                        }
                        pub fn coordinate_frame(&mut self) -> Option<packs::MAV_FRAME> {
                            let src = &mut self.0;
                            if src.base.field_bit != 416 && !src.set_field(416, -1) { return None; }

                            Some({ packs::MAV_FRAME::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.type_mask(src.type_mask());
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.x(src.x());
                        dst.y(src.y());
                        dst.z(src.z());
                        dst.vx(src.vx());
                        dst.vy(src.vy());
                        dst.vz(src.vz());
                        dst.afx(src.afx());
                        dst.afy(src.afy());
                        dst.afz(src.afz());
                        dst.yaw(src.yaw());
                        dst.yaw_rate(src.yaw_rate());
                        if let Some(src) = src.coordinate_frame() {
                            dst.coordinate_frame(src);
                        }
                    }

                    pub trait DST_ {
                        fn type_mask(&mut self, src: i16);
                        fn time_boot_ms(&mut self, src: i32);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn vx(&mut self, src: f32);
                        fn vy(&mut self, src: f32);
                        fn vz(&mut self, src: f32);
                        fn afx(&mut self, src: f32);
                        fn afy(&mut self, src: f32);
                        fn afz(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn yaw_rate(&mut self, src: f32);
                        fn coordinate_frame(&mut self, src: packs::MAV_FRAME);
                    }
                }

                pub mod MOUNT_ORIENTATION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MOUNT_ORIENTATION) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc2048 {
                            crate::util_::Item__ad_hoc2048(self.0)
                        }
                        pub fn roll(&mut self) -> crate::util_::Item__ad_hoc2049 {
                            crate::util_::Item__ad_hoc2049(self.0)
                        }
                        pub fn pitch(&mut self) -> crate::util_::Item__ad_hoc2050 {
                            crate::util_::Item__ad_hoc2050(self.0)
                        }
                        pub fn yaw(&mut self) -> crate::util_::Item__ad_hoc2051 {
                            crate::util_::Item__ad_hoc2051(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.roll(src.roll().get());
                        dst.pitch(src.pitch().get());
                        dst.yaw(src.yaw().get());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn roll(&mut self) -> f32;
                        fn pitch(&mut self) -> f32;
                        fn yaw(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.roll().set(src.roll());
                        dst.pitch().set(src.pitch());
                        dst.yaw().set(src.yaw());
                    }
                }

                /**
*As local waypoints exist, the global waypoint reference allows to transform between the local coordinate
*				 frame and the global (GPS) coordinate frame. This can be necessary when e.g. in- and outdoor settings
*				 are connected and the MAV should move from in- to outdoor */

                pub mod SET_GPS_GLOBAL_ORIGIN {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SET_GPS_GLOBAL_ORIGIN) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn latitude(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn longitude(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 5, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn altitude(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 9, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn time_usec(&mut self) -> Option<i64> {
                            let src = &mut self.0;
                            if src.base.field_bit != 104 && !src.set_field(104, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 8 as usize) as i64;
                                (dst) as i64
                            })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.latitude(src.latitude());
                        dst.longitude(src.longitude());
                        dst.altitude(src.altitude());
                        if let Some(src) = src.time_usec() {
                            dst.time_usec(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn latitude(&mut self, src: i32);
                        fn longitude(&mut self, src: i32);
                        fn altitude(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                    }
                }

                /**
*Set a parameter value. In order to deal with message loss (and retransmission of PARAM_EXT_SET), when
*				 setting a parameter value and the new value is the same as the current value, you will immediately get
*				 a PARAM_ACK_ACCEPTED response. If the current state is PARAM_ACK_IN_PROGRESS, you will accordingly receive
*				 a PARAM_ACK_IN_PROGRESS in response */

                pub mod PARAM_EXT_SET {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PARAM_EXT_SET) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2114 {
                            crate::util_::Item__ad_hoc2114(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2115 {
                            crate::util_::Item__ad_hoc2115(self.0)
                        }
                        pub fn param_id(&mut self) -> crate::util_::Item__ad_hoc2116 {
                            crate::util_::Item__ad_hoc2116(self.0)
                        }
                        pub fn param_value(&mut self) -> crate::util_::Item__ad_hoc2117 {
                            crate::util_::Item__ad_hoc2117(self.0)
                        }
                        pub fn param_type(&mut self) -> crate::util_::Item__ad_hoc152 {
                            crate::util_::Item__ad_hoc152(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        if let Some(src) = src.param_id().get() {
                            dst.param_id(src);
                        }
                        if let Some(src) = src.param_value().get() {
                            dst.param_value(src);
                        }
                        if let Some(src) = src.param_type().get() {
                            dst.param_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn param_id(&mut self, src: &str);
                        fn param_value(&mut self, src: &str);
                        fn param_type(&mut self, src: packs::MAV_PARAM_EXT_TYPE);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn param_id_item_exists_(&mut self) -> usize;
                        fn param_id(&mut self, dst: &mut [u8]);
                        fn param_value_item_exists_(&mut self) -> usize;
                        fn param_value(&mut self, dst: &mut [u8]);
                        fn param_type(&mut self) -> Option<packs::MAV_PARAM_EXT_TYPE>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        let len = src.param_id_item_exists_();
                        if 0 < len {
                            dst.0.set_field(19, len as i32);

                            src.param_id(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                        let len = src.param_value_item_exists_();
                        if 0 < len {
                            dst.0.set_field(20, len as i32);

                            src.param_value(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                        if let Some(src) = src.param_type() {
                            dst.param_type().set(src);
                        }
                    }

                    pub mod param_id {
                        pub const len_max: usize = 255usize;
                    }

                    pub mod param_value {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Version and capability of autopilot software */

                pub mod AUTOPILOT_VERSION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::AUTOPILOT_VERSION) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn vendor_id(&mut self) -> crate::util_::Item__ad_hoc1850 {
                            crate::util_::Item__ad_hoc1850(self.0)
                        }
                        pub fn product_id(&mut self) -> crate::util_::Item__ad_hoc1851 {
                            crate::util_::Item__ad_hoc1851(self.0)
                        }
                        pub fn flight_sw_version(&mut self) -> crate::util_::Item__ad_hoc1843 {
                            crate::util_::Item__ad_hoc1843(self.0)
                        }
                        pub fn middleware_sw_version(&mut self) -> crate::util_::Item__ad_hoc1844 {
                            crate::util_::Item__ad_hoc1844(self.0)
                        }
                        pub fn os_sw_version(&mut self) -> crate::util_::Item__ad_hoc1845 {
                            crate::util_::Item__ad_hoc1845(self.0)
                        }
                        pub fn board_version(&mut self) -> crate::util_::Item__ad_hoc1846 {
                            crate::util_::Item__ad_hoc1846(self.0)
                        }
                        pub fn uid(&mut self) -> crate::util_::Item__ad_hoc1852 {
                            crate::util_::Item__ad_hoc1852(self.0)
                        }
                        pub fn flight_custom_version(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1847 {
                            let dst = &mut self.0;

                            let len = 8 as usize;
                            let offset = 28;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc1847 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn middleware_custom_version(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1848 {
                            let dst = &mut self.0;

                            let len = 8 as usize;
                            let offset = 36;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc1848 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn os_custom_version(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1849 {
                            let dst = &mut self.0;

                            let len = 8 as usize;
                            let offset = 44;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc1849 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn capabilities(&mut self) -> crate::util_::Item__ad_hoc281 {
                            crate::util_::Item__ad_hoc281(self.0)
                        }
                        pub fn uid2(&mut self) -> crate::util_::FieldI__ad_hoc1853 {
                            crate::util_::FieldI__ad_hoc1853(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.vendor_id(src.vendor_id().get());
                        dst.product_id(src.product_id().get());
                        dst.flight_sw_version(src.flight_sw_version().get());
                        dst.middleware_sw_version(src.middleware_sw_version().get());
                        dst.os_sw_version(src.os_sw_version().get());
                        dst.board_version(src.board_version().get());
                        dst.uid(src.uid().get());
                        dst.flight_custom_version(&mut src.flight_custom_version(None));
                        dst.middleware_custom_version(&mut src.middleware_custom_version(None));
                        dst.os_custom_version(&mut src.os_custom_version(None));
                        if let Some(src) = src.capabilities().get() {
                            dst.capabilities(src);
                        }

                        if let Some(mut src) = src.uid2().items() {
                            src.enumerate(0,
                                          |src, d0| {
                                              if let Some(uid2) = src.get(d0) {
                                                  dst.uid2(uid2, d0);
                                              }
                                          },
                            );
                        }
                    }

                    pub trait DST_ {
                        fn vendor_id(&mut self, src: i16);
                        fn product_id(&mut self, src: i16);
                        fn flight_sw_version(&mut self, src: i32);
                        fn middleware_sw_version(&mut self, src: i32);
                        fn os_sw_version(&mut self, src: i32);
                        fn board_version(&mut self, src: i32);
                        fn uid(&mut self, src: i64);
                        fn flight_custom_version(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1847);
                        fn middleware_custom_version(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1848);
                        fn os_custom_version(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1849);
                        fn capabilities(&mut self, src: packs::MAV_PROTOCOL_CAPABILITY);
                        fn uid2(&mut self, src: i8, d0: usize);
                    }

                    pub trait SRC_ {
                        fn vendor_id(&mut self) -> i16;
                        fn product_id(&mut self) -> i16;
                        fn flight_sw_version(&mut self) -> i32;
                        fn middleware_sw_version(&mut self) -> i32;
                        fn os_sw_version(&mut self) -> i32;
                        fn board_version(&mut self) -> i32;
                        fn uid(&mut self) -> i64;
                        fn flight_custom_version(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1847);
                        fn middleware_custom_version(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1848);
                        fn os_custom_version(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1849);
                        fn capabilities(&mut self) -> Option<packs::MAV_PROTOCOL_CAPABILITY>;
                        fn uid2_exists_(&mut self) -> bool;
                        fn uid2(&mut self, d0: usize) -> Option<i8>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.vendor_id().set(src.vendor_id());
                        dst.product_id().set(src.product_id());
                        dst.flight_sw_version().set(src.flight_sw_version());
                        dst.middleware_sw_version().set(src.middleware_sw_version());
                        dst.os_sw_version().set(src.os_sw_version());
                        dst.board_version().set(src.board_version());
                        dst.uid().set(src.uid());
                        src.flight_custom_version(&mut dst.flight_custom_version(None));
                        src.middleware_custom_version(&mut dst.middleware_custom_version(None));
                        src.os_custom_version(&mut dst.os_custom_version(None));
                        if let Some(src) = src.capabilities() {
                            dst.capabilities().set(src);
                        }

                        if src.uid2_exists_() {
                            dst.0.set_field(420, 0);
                            let mut dst = dst.uid2();
                            for d0 in 0..packs::AUTOPILOT_VERSION::uid2::d0 {
                                if let Some(src) = src.uid2(d0) {
                                    dst.set(src, d0);
                                }
                            }
                        }
                    }

                    pub mod flight_custom_version {
                        pub const len: usize = 8usize;
                    }

                    pub mod middleware_custom_version {
                        pub const len: usize = 8usize;
                    }

                    pub mod os_custom_version {
                        pub const len: usize = 8usize;
                    }

                    pub mod uid2 {
                        pub const d0: usize = 18;
                    }
                }

                /**
*Request the overall list of mission items from the system/component. */

                pub mod MISSION_REQUEST_LIST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_REQUEST_LIST) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn mission_type(&mut self) -> Option<packs::MAV_MISSION_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 16 && !src.set_field(16, -1) { return None; }

                            Some({ packs::MAV_MISSION_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        if let Some(src) = src.mission_type() {
                            dst.mission_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn mission_type(&mut self, src: packs::MAV_MISSION_TYPE);
                    }
                }

                /**
*Status of simulation environment, if used */

                pub mod SIMSTATE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SIMSTATE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn roll(&mut self) -> crate::util_::Item__ad_hoc2223 {
                            crate::util_::Item__ad_hoc2223(self.0)
                        }
                        pub fn pitch(&mut self) -> crate::util_::Item__ad_hoc2224 {
                            crate::util_::Item__ad_hoc2224(self.0)
                        }
                        pub fn yaw(&mut self) -> crate::util_::Item__ad_hoc2225 {
                            crate::util_::Item__ad_hoc2225(self.0)
                        }
                        pub fn xacc(&mut self) -> crate::util_::Item__ad_hoc2226 {
                            crate::util_::Item__ad_hoc2226(self.0)
                        }
                        pub fn yacc(&mut self) -> crate::util_::Item__ad_hoc2227 {
                            crate::util_::Item__ad_hoc2227(self.0)
                        }
                        pub fn zacc(&mut self) -> crate::util_::Item__ad_hoc2228 {
                            crate::util_::Item__ad_hoc2228(self.0)
                        }
                        pub fn xgyro(&mut self) -> crate::util_::Item__ad_hoc2229 {
                            crate::util_::Item__ad_hoc2229(self.0)
                        }
                        pub fn ygyro(&mut self) -> crate::util_::Item__ad_hoc2230 {
                            crate::util_::Item__ad_hoc2230(self.0)
                        }
                        pub fn zgyro(&mut self) -> crate::util_::Item__ad_hoc2231 {
                            crate::util_::Item__ad_hoc2231(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc2232 {
                            crate::util_::Item__ad_hoc2232(self.0)
                        }
                        pub fn lng(&mut self) -> crate::util_::Item__ad_hoc2233 {
                            crate::util_::Item__ad_hoc2233(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.roll(src.roll().get());
                        dst.pitch(src.pitch().get());
                        dst.yaw(src.yaw().get());
                        dst.xacc(src.xacc().get());
                        dst.yacc(src.yacc().get());
                        dst.zacc(src.zacc().get());
                        dst.xgyro(src.xgyro().get());
                        dst.ygyro(src.ygyro().get());
                        dst.zgyro(src.zgyro().get());
                        dst.lat(src.lat().get());
                        dst.lng(src.lng().get());
                    }

                    pub trait DST_ {
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn xacc(&mut self, src: f32);
                        fn yacc(&mut self, src: f32);
                        fn zacc(&mut self, src: f32);
                        fn xgyro(&mut self, src: f32);
                        fn ygyro(&mut self, src: f32);
                        fn zgyro(&mut self, src: f32);
                        fn lat(&mut self, src: i32);
                        fn lng(&mut self, src: i32);
                    }

                    pub trait SRC_ {
                        fn roll(&mut self) -> f32;
                        fn pitch(&mut self) -> f32;
                        fn yaw(&mut self) -> f32;
                        fn xacc(&mut self) -> f32;
                        fn yacc(&mut self) -> f32;
                        fn zacc(&mut self) -> f32;
                        fn xgyro(&mut self) -> f32;
                        fn ygyro(&mut self) -> f32;
                        fn zgyro(&mut self) -> f32;
                        fn lat(&mut self) -> i32;
                        fn lng(&mut self) -> i32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.roll().set(src.roll());
                        dst.pitch().set(src.pitch());
                        dst.yaw().set(src.yaw());
                        dst.xacc().set(src.xacc());
                        dst.yacc().set(src.yacc());
                        dst.zacc().set(src.zacc());
                        dst.xgyro().set(src.xgyro());
                        dst.ygyro().set(src.ygyro());
                        dst.zgyro().set(src.zgyro());
                        dst.lat().set(src.lat());
                        dst.lng().set(src.lng());
                    }
                }

                /**
*WIP: Message that sets video stream settings */

                pub mod SET_VIDEO_STREAM_SETTINGS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SET_VIDEO_STREAM_SETTINGS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn resolution_h(&mut self) -> crate::util_::Item__ad_hoc2079 {
                            crate::util_::Item__ad_hoc2079(self.0)
                        }
                        pub fn resolution_v(&mut self) -> crate::util_::Item__ad_hoc2080 {
                            crate::util_::Item__ad_hoc2080(self.0)
                        }
                        pub fn rotation(&mut self) -> crate::util_::Item__ad_hoc2082 {
                            crate::util_::Item__ad_hoc2082(self.0)
                        }
                        pub fn bitrate(&mut self) -> crate::util_::Item__ad_hoc2081 {
                            crate::util_::Item__ad_hoc2081(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2075 {
                            crate::util_::Item__ad_hoc2075(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2076 {
                            crate::util_::Item__ad_hoc2076(self.0)
                        }
                        pub fn camera_id(&mut self) -> crate::util_::Item__ad_hoc2077 {
                            crate::util_::Item__ad_hoc2077(self.0)
                        }
                        pub fn framerate(&mut self) -> crate::util_::Item__ad_hoc2078 {
                            crate::util_::Item__ad_hoc2078(self.0)
                        }
                        pub fn uri(&mut self) -> crate::util_::Item__ad_hoc2083 {
                            crate::util_::Item__ad_hoc2083(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.resolution_h(src.resolution_h().get());
                        dst.resolution_v(src.resolution_v().get());
                        dst.rotation(src.rotation().get());
                        dst.bitrate(src.bitrate().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.camera_id(src.camera_id().get());
                        dst.framerate(src.framerate().get());
                        if let Some(src) = src.uri().get() {
                            dst.uri(src);
                        }
                    }

                    pub trait DST_ {
                        fn resolution_h(&mut self, src: i16);
                        fn resolution_v(&mut self, src: i16);
                        fn rotation(&mut self, src: i16);
                        fn bitrate(&mut self, src: i32);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn camera_id(&mut self, src: i8);
                        fn framerate(&mut self, src: f32);
                        fn uri(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn resolution_h(&mut self) -> i16;
                        fn resolution_v(&mut self) -> i16;
                        fn rotation(&mut self) -> i16;
                        fn bitrate(&mut self) -> i32;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn camera_id(&mut self) -> i8;
                        fn framerate(&mut self) -> f32;
                        fn uri_item_exists_(&mut self) -> usize;
                        fn uri(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.resolution_h().set(src.resolution_h());
                        dst.resolution_v().set(src.resolution_v());
                        dst.rotation().set(src.rotation());
                        dst.bitrate().set(src.bitrate());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.camera_id().set(src.camera_id());
                        dst.framerate().set(src.framerate());
                        let len = src.uri_item_exists_();
                        if 0 < len {
                            dst.0.set_field(138, len as i32);

                            src.uri(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod uri {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Control vehicle tone generation (buzzer) */

                pub mod PLAY_TUNE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PLAY_TUNE) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2002 {
                            crate::util_::Item__ad_hoc2002(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2003 {
                            crate::util_::Item__ad_hoc2003(self.0)
                        }
                        pub fn tune(&mut self) -> crate::util_::Item__ad_hoc2004 {
                            crate::util_::Item__ad_hoc2004(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        if let Some(src) = src.tune().get() {
                            dst.tune(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn tune(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn tune_item_exists_(&mut self) -> usize;
                        fn tune(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        let len = src.tune_item_exists_();
                        if 0 < len {
                            dst.0.set_field(18, len as i32);

                            src.tune(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod tune {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Configure on-board Camera Control System. */

                pub mod DIGICAM_CONFIGURE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DIGICAM_CONFIGURE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn shutter_speed(&mut self) -> crate::util_::Item__ad_hoc2170 {
                            crate::util_::Item__ad_hoc2170(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2167 {
                            crate::util_::Item__ad_hoc2167(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2168 {
                            crate::util_::Item__ad_hoc2168(self.0)
                        }
                        pub fn mode(&mut self) -> crate::util_::Item__ad_hoc2169 {
                            crate::util_::Item__ad_hoc2169(self.0)
                        }
                        pub fn aperture(&mut self) -> crate::util_::Item__ad_hoc2171 {
                            crate::util_::Item__ad_hoc2171(self.0)
                        }
                        pub fn iso(&mut self) -> crate::util_::Item__ad_hoc2172 {
                            crate::util_::Item__ad_hoc2172(self.0)
                        }
                        pub fn exposure_type(&mut self) -> crate::util_::Item__ad_hoc2173 {
                            crate::util_::Item__ad_hoc2173(self.0)
                        }
                        pub fn command_id(&mut self) -> crate::util_::Item__ad_hoc2174 {
                            crate::util_::Item__ad_hoc2174(self.0)
                        }
                        pub fn engine_cut_off(&mut self) -> crate::util_::Item__ad_hoc2175 {
                            crate::util_::Item__ad_hoc2175(self.0)
                        }
                        pub fn extra_param(&mut self) -> crate::util_::Item__ad_hoc2176 {
                            crate::util_::Item__ad_hoc2176(self.0)
                        }
                        pub fn extra_value(&mut self) -> crate::util_::Item__ad_hoc2177 {
                            crate::util_::Item__ad_hoc2177(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.shutter_speed(src.shutter_speed().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.mode(src.mode().get());
                        dst.aperture(src.aperture().get());
                        dst.iso(src.iso().get());
                        dst.exposure_type(src.exposure_type().get());
                        dst.command_id(src.command_id().get());
                        dst.engine_cut_off(src.engine_cut_off().get());
                        dst.extra_param(src.extra_param().get());
                        dst.extra_value(src.extra_value().get());
                    }

                    pub trait DST_ {
                        fn shutter_speed(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn mode(&mut self, src: i8);
                        fn aperture(&mut self, src: i8);
                        fn iso(&mut self, src: i8);
                        fn exposure_type(&mut self, src: i8);
                        fn command_id(&mut self, src: i8);
                        fn engine_cut_off(&mut self, src: i8);
                        fn extra_param(&mut self, src: i8);
                        fn extra_value(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn shutter_speed(&mut self) -> i16;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn mode(&mut self) -> i8;
                        fn aperture(&mut self) -> i8;
                        fn iso(&mut self) -> i8;
                        fn exposure_type(&mut self) -> i8;
                        fn command_id(&mut self) -> i8;
                        fn engine_cut_off(&mut self) -> i8;
                        fn extra_param(&mut self) -> i8;
                        fn extra_value(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.shutter_speed().set(src.shutter_speed());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.mode().set(src.mode());
                        dst.aperture().set(src.aperture());
                        dst.iso().set(src.iso());
                        dst.exposure_type().set(src.exposure_type());
                        dst.command_id().set(src.command_id());
                        dst.engine_cut_off().set(src.engine_cut_off());
                        dst.extra_param().set(src.extra_param());
                        dst.extra_value().set(src.extra_value());
                    }
                }

                /**
*Barometer readings for 3rd barometer */

                pub mod SCALED_PRESSURE3 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SCALED_PRESSURE3) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc1804 {
                            crate::util_::Item__ad_hoc1804(self.0)
                        }
                        pub fn press_abs(&mut self) -> crate::util_::Item__ad_hoc1805 {
                            crate::util_::Item__ad_hoc1805(self.0)
                        }
                        pub fn press_diff(&mut self) -> crate::util_::Item__ad_hoc1806 {
                            crate::util_::Item__ad_hoc1806(self.0)
                        }
                        pub fn temperature(&mut self) -> crate::util_::Item__ad_hoc1807 {
                            crate::util_::Item__ad_hoc1807(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.press_abs(src.press_abs().get());
                        dst.press_diff(src.press_diff().get());
                        dst.temperature(src.temperature().get());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn press_abs(&mut self, src: f32);
                        fn press_diff(&mut self, src: f32);
                        fn temperature(&mut self, src: i16);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn press_abs(&mut self) -> f32;
                        fn press_diff(&mut self) -> f32;
                        fn temperature(&mut self) -> i16;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.press_abs().set(src.press_abs());
                        dst.press_diff().set(src.press_diff());
                        dst.temperature().set(src.temperature());
                    }
                }

                /**
*Request a partial list of mission items from the system/component. http:qgroundcontrol.org/mavlink/waypoint_protocol.
*				 If start and end index are the same, just send one waypoint */

                pub mod MISSION_REQUEST_PARTIAL_LIST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_REQUEST_PARTIAL_LIST) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn start_index(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn end_index(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 4, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn mission_type(&mut self) -> Option<packs::MAV_MISSION_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 48 && !src.set_field(48, -1) { return None; }

                            Some({ packs::MAV_MISSION_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.start_index(src.start_index());
                        dst.end_index(src.end_index());
                        if let Some(src) = src.mission_type() {
                            dst.mission_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn start_index(&mut self, src: i16);
                        fn end_index(&mut self, src: i16);
                        fn mission_type(&mut self, src: packs::MAV_MISSION_TYPE);
                    }
                }

                /**
*Response from a PARAM_EXT_SET message. */

                pub mod PARAM_EXT_ACK {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::PARAM_EXT_ACK) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn param_id(&mut self) -> crate::util_::Item__ad_hoc2118 {
                            crate::util_::Item__ad_hoc2118(self.0)
                        }
                        pub fn param_value(&mut self) -> crate::util_::Item__ad_hoc2119 {
                            crate::util_::Item__ad_hoc2119(self.0)
                        }
                        pub fn param_type(&mut self) -> crate::util_::Item__ad_hoc233 {
                            crate::util_::Item__ad_hoc233(self.0)
                        }
                        pub fn param_result(&mut self) -> crate::util_::Item__ad_hoc234 {
                            crate::util_::Item__ad_hoc234(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        if let Some(src) = src.param_id().get() {
                            dst.param_id(src);
                        }
                        if let Some(src) = src.param_value().get() {
                            dst.param_value(src);
                        }
                        if let Some(src) = src.param_type().get() {
                            dst.param_type(src);
                        }
                        if let Some(src) = src.param_result().get() {
                            dst.param_result(src);
                        }
                    }

                    pub trait DST_ {
                        fn param_id(&mut self, src: &str);
                        fn param_value(&mut self, src: &str);
                        fn param_type(&mut self, src: packs::MAV_PARAM_EXT_TYPE);
                        fn param_result(&mut self, src: packs::PARAM_ACK);
                    }

                    pub trait SRC_ {
                        fn param_id_item_exists_(&mut self) -> usize;
                        fn param_id(&mut self, dst: &mut [u8]);
                        fn param_value_item_exists_(&mut self) -> usize;
                        fn param_value(&mut self, dst: &mut [u8]);
                        fn param_type(&mut self) -> Option<packs::MAV_PARAM_EXT_TYPE>;
                        fn param_result(&mut self) -> Option<packs::PARAM_ACK>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        let len = src.param_id_item_exists_();
                        if 0 < len {
                            dst.0.set_field(3, len as i32);

                            src.param_id(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                        let len = src.param_value_item_exists_();
                        if 0 < len {
                            dst.0.set_field(4, len as i32);

                            src.param_value(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                        if let Some(src) = src.param_type() {
                            dst.param_type().set(src);
                        }
                        if let Some(src) = src.param_result() {
                            dst.param_result().set(src);
                        }
                    }

                    pub mod param_id {
                        pub const len_max: usize = 255usize;
                    }

                    pub mod param_value {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*General information describing a particular UAVCAN node. Please refer to the definition of the UAVCAN
*				 service "uavcan.protocol.GetNodeInfo" for the background information. This message should be emitted
*				 by the system whenever a new node appears online, or an existing node reboots. Additionally, it can be
*				 emitted upon request from the other end of the MAVLink channel (see MAV_CMD_UAVCAN_GET_NODE_INFO). It
*				 is also not prohibited to emit this message unconditionally at a low frequency. The UAVCAN specification
*				 is available at http:uavcan.org */

                pub mod UAVCAN_NODE_INFO {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::UAVCAN_NODE_INFO) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn uptime_sec(&mut self) -> crate::util_::Item__ad_hoc2096 {
                            crate::util_::Item__ad_hoc2096(self.0)
                        }
                        pub fn sw_vcs_commit(&mut self) -> crate::util_::Item__ad_hoc2103 {
                            crate::util_::Item__ad_hoc2103(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc2095 {
                            crate::util_::Item__ad_hoc2095(self.0)
                        }
                        pub fn hw_version_major(&mut self) -> crate::util_::Item__ad_hoc2098 {
                            crate::util_::Item__ad_hoc2098(self.0)
                        }
                        pub fn hw_version_minor(&mut self) -> crate::util_::Item__ad_hoc2099 {
                            crate::util_::Item__ad_hoc2099(self.0)
                        }
                        pub fn hw_unique_id(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2100 {
                            let dst = &mut self.0;

                            let len = 16 as usize;
                            let offset = 18;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc2100 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn sw_version_major(&mut self) -> crate::util_::Item__ad_hoc2101 {
                            crate::util_::Item__ad_hoc2101(self.0)
                        }
                        pub fn sw_version_minor(&mut self) -> crate::util_::Item__ad_hoc2102 {
                            crate::util_::Item__ad_hoc2102(self.0)
                        }
                        pub fn name(&mut self) -> crate::util_::Item__ad_hoc2097 {
                            crate::util_::Item__ad_hoc2097(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.uptime_sec(src.uptime_sec().get());
                        dst.sw_vcs_commit(src.sw_vcs_commit().get());
                        dst.time_usec(src.time_usec().get());
                        dst.hw_version_major(src.hw_version_major().get());
                        dst.hw_version_minor(src.hw_version_minor().get());
                        dst.hw_unique_id(&mut src.hw_unique_id(None));
                        dst.sw_version_major(src.sw_version_major().get());
                        dst.sw_version_minor(src.sw_version_minor().get());
                        if let Some(src) = src.name().get() {
                            dst.name(src);
                        }
                    }

                    pub trait DST_ {
                        fn uptime_sec(&mut self, src: i32);
                        fn sw_vcs_commit(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                        fn hw_version_major(&mut self, src: i8);
                        fn hw_version_minor(&mut self, src: i8);
                        fn hw_unique_id(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2100);
                        fn sw_version_major(&mut self, src: i8);
                        fn sw_version_minor(&mut self, src: i8);
                        fn name(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn uptime_sec(&mut self) -> i32;
                        fn sw_vcs_commit(&mut self) -> i32;
                        fn time_usec(&mut self) -> i64;
                        fn hw_version_major(&mut self) -> i8;
                        fn hw_version_minor(&mut self) -> i8;
                        fn hw_unique_id(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2100);
                        fn sw_version_major(&mut self) -> i8;
                        fn sw_version_minor(&mut self) -> i8;
                        fn name_item_exists_(&mut self) -> usize;
                        fn name(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.uptime_sec().set(src.uptime_sec());
                        dst.sw_vcs_commit().set(src.sw_vcs_commit());
                        dst.time_usec().set(src.time_usec());
                        dst.hw_version_major().set(src.hw_version_major());
                        dst.hw_version_minor().set(src.hw_version_minor());
                        src.hw_unique_id(&mut dst.hw_unique_id(None));
                        dst.sw_version_major().set(src.sw_version_major());
                        dst.sw_version_minor().set(src.sw_version_minor());
                        let len = src.name_item_exists_();
                        if 0 < len {
                            dst.0.set_field(290, len as i32);

                            src.name(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod hw_unique_id {
                        pub const len: usize = 16usize;
                    }

                    pub mod name {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Data packet, size 16 */

                pub mod DATA16 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DATA16) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn typE(&mut self) -> crate::util_::Item__ad_hoc2251 {
                            crate::util_::Item__ad_hoc2251(self.0)
                        }
                        pub fn len(&mut self) -> crate::util_::Item__ad_hoc2252 {
                            crate::util_::Item__ad_hoc2252(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2253 {
                            let dst = self.0;

                            let len = 16 as usize;
                            let offset = 2;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2253 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.typE(src.typE().get());
                        dst.len(src.len().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn typE(&mut self, src: i8);
                        fn len(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2253);
                    }

                    pub trait SRC_ {
                        fn typE(&mut self) -> i8;
                        fn len(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2253);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.typE().set(src.typE());
                        dst.len().set(src.len());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 16usize;
                    }
                }

                /**
*Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the magnetometer offsets */

                pub mod SET_MAG_OFFSETS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SET_MAG_OFFSETS) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2153 {
                            crate::util_::Item__ad_hoc2153(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2154 {
                            crate::util_::Item__ad_hoc2154(self.0)
                        }
                        pub fn mag_ofs_x(&mut self) -> crate::util_::Item__ad_hoc2155 {
                            crate::util_::Item__ad_hoc2155(self.0)
                        }
                        pub fn mag_ofs_y(&mut self) -> crate::util_::Item__ad_hoc2156 {
                            crate::util_::Item__ad_hoc2156(self.0)
                        }
                        pub fn mag_ofs_z(&mut self) -> crate::util_::Item__ad_hoc2157 {
                            crate::util_::Item__ad_hoc2157(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.mag_ofs_x(src.mag_ofs_x().get());
                        dst.mag_ofs_y(src.mag_ofs_y().get());
                        dst.mag_ofs_z(src.mag_ofs_z().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn mag_ofs_x(&mut self, src: i16);
                        fn mag_ofs_y(&mut self, src: i16);
                        fn mag_ofs_z(&mut self, src: i16);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn mag_ofs_x(&mut self) -> i16;
                        fn mag_ofs_y(&mut self) -> i16;
                        fn mag_ofs_z(&mut self) -> i16;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.mag_ofs_x().set(src.mag_ofs_x());
                        dst.mag_ofs_y().set(src.mag_ofs_y());
                        dst.mag_ofs_z().set(src.mag_ofs_z());
                    }
                }

                /**
*raw ADC output */

                pub mod AP_ADC {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::AP_ADC) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn adc1(&mut self) -> crate::util_::Item__ad_hoc2161 {
                            crate::util_::Item__ad_hoc2161(self.0)
                        }
                        pub fn adc2(&mut self) -> crate::util_::Item__ad_hoc2162 {
                            crate::util_::Item__ad_hoc2162(self.0)
                        }
                        pub fn adc3(&mut self) -> crate::util_::Item__ad_hoc2163 {
                            crate::util_::Item__ad_hoc2163(self.0)
                        }
                        pub fn adc4(&mut self) -> crate::util_::Item__ad_hoc2164 {
                            crate::util_::Item__ad_hoc2164(self.0)
                        }
                        pub fn adc5(&mut self) -> crate::util_::Item__ad_hoc2165 {
                            crate::util_::Item__ad_hoc2165(self.0)
                        }
                        pub fn adc6(&mut self) -> crate::util_::Item__ad_hoc2166 {
                            crate::util_::Item__ad_hoc2166(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.adc1(src.adc1().get());
                        dst.adc2(src.adc2().get());
                        dst.adc3(src.adc3().get());
                        dst.adc4(src.adc4().get());
                        dst.adc5(src.adc5().get());
                        dst.adc6(src.adc6().get());
                    }

                    pub trait DST_ {
                        fn adc1(&mut self, src: i16);
                        fn adc2(&mut self, src: i16);
                        fn adc3(&mut self, src: i16);
                        fn adc4(&mut self, src: i16);
                        fn adc5(&mut self, src: i16);
                        fn adc6(&mut self, src: i16);
                    }

                    pub trait SRC_ {
                        fn adc1(&mut self) -> i16;
                        fn adc2(&mut self) -> i16;
                        fn adc3(&mut self) -> i16;
                        fn adc4(&mut self) -> i16;
                        fn adc5(&mut self) -> i16;
                        fn adc6(&mut self) -> i16;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.adc1().set(src.adc1());
                        dst.adc2().set(src.adc2());
                        dst.adc3().set(src.adc3());
                        dst.adc4().set(src.adc4());
                        dst.adc5().set(src.adc5());
                        dst.adc6().set(src.adc6());
                    }
                }

                /**
*Wind estimation */

                pub mod WIND {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::WIND) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn direction(&mut self) -> crate::util_::Item__ad_hoc2248 {
                            crate::util_::Item__ad_hoc2248(self.0)
                        }
                        pub fn speed(&mut self) -> crate::util_::Item__ad_hoc2249 {
                            crate::util_::Item__ad_hoc2249(self.0)
                        }
                        pub fn speed_z(&mut self) -> crate::util_::Item__ad_hoc2250 {
                            crate::util_::Item__ad_hoc2250(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.direction(src.direction().get());
                        dst.speed(src.speed().get());
                        dst.speed_z(src.speed_z().get());
                    }

                    pub trait DST_ {
                        fn direction(&mut self, src: f32);
                        fn speed(&mut self, src: f32);
                        fn speed_z(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn direction(&mut self) -> f32;
                        fn speed(&mut self) -> f32;
                        fn speed_z(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.direction().set(src.direction());
                        dst.speed().set(src.speed());
                        dst.speed_z().set(src.speed_z());
                    }
                }

                /**
*Request the autopilot version from the system/component. */

                pub mod AUTOPILOT_VERSION_REQUEST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::AUTOPILOT_VERSION_REQUEST) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2333 {
                            crate::util_::Item__ad_hoc2333(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2334 {
                            crate::util_::Item__ad_hoc2334(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                    }
                }

                /**
*The filtered local position (e.g. fused computer vision and accelerometers). Coordinate frame is right-handed,
*				 Z-axis down (aeronautical frame, NED / north-east-down convention */

                pub mod LOCAL_POSITION_NED {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOCAL_POSITION_NED) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 4, 4usize) as u32)
                        }
                        pub fn y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 8, 4usize) as u32)
                        }
                        pub fn z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 12, 4usize) as u32)
                        }
                        pub fn vx(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 16, 4usize) as u32)
                        }
                        pub fn vy(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 20, 4usize) as u32)
                        }
                        pub fn vz(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 24, 4usize) as u32)
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.x(src.x());
                        dst.y(src.y());
                        dst.z(src.z());
                        dst.vx(src.vx());
                        dst.vy(src.vy());
                        dst.vz(src.vz());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn vx(&mut self, src: f32);
                        fn vy(&mut self, src: f32);
                        fn vz(&mut self, src: f32);
                    }
                }

                pub mod DATA_TRANSMISSION_HANDSHAKE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DATA_TRANSMISSION_HANDSHAKE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn width(&mut self) -> crate::util_::Item__ad_hoc1744 {
                            crate::util_::Item__ad_hoc1744(self.0)
                        }
                        pub fn height(&mut self) -> crate::util_::Item__ad_hoc1745 {
                            crate::util_::Item__ad_hoc1745(self.0)
                        }
                        pub fn packets(&mut self) -> crate::util_::Item__ad_hoc1746 {
                            crate::util_::Item__ad_hoc1746(self.0)
                        }
                        pub fn size(&mut self) -> crate::util_::Item__ad_hoc1743 {
                            crate::util_::Item__ad_hoc1743(self.0)
                        }
                        pub fn typE(&mut self) -> crate::util_::Item__ad_hoc1742 {
                            crate::util_::Item__ad_hoc1742(self.0)
                        }
                        pub fn payload(&mut self) -> crate::util_::Item__ad_hoc1747 {
                            crate::util_::Item__ad_hoc1747(self.0)
                        }
                        pub fn jpg_quality(&mut self) -> crate::util_::Item__ad_hoc1748 {
                            crate::util_::Item__ad_hoc1748(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.width(src.width().get());
                        dst.height(src.height().get());
                        dst.packets(src.packets().get());
                        dst.size(src.size().get());
                        dst.typE(src.typE().get());
                        dst.payload(src.payload().get());
                        dst.jpg_quality(src.jpg_quality().get());
                    }

                    pub trait DST_ {
                        fn width(&mut self, src: i16);
                        fn height(&mut self, src: i16);
                        fn packets(&mut self, src: i16);
                        fn size(&mut self, src: i32);
                        fn typE(&mut self, src: i8);
                        fn payload(&mut self, src: i8);
                        fn jpg_quality(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn width(&mut self) -> i16;
                        fn height(&mut self) -> i16;
                        fn packets(&mut self) -> i16;
                        fn size(&mut self) -> i32;
                        fn typE(&mut self) -> i8;
                        fn payload(&mut self) -> i8;
                        fn jpg_quality(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.width().set(src.width());
                        dst.height().set(src.height());
                        dst.packets().set(src.packets());
                        dst.size().set(src.size());
                        dst.typE().set(src.typE());
                        dst.payload().set(src.payload());
                        dst.jpg_quality().set(src.jpg_quality());
                    }
                }

                /**
*Once the MAV sets a new GPS-Local correspondence, this message announces the origin (0,0,0) positio */

                pub mod GPS_GLOBAL_ORIGIN {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GPS_GLOBAL_ORIGIN) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn latitude(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn longitude(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 4, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn altitude(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 8, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn time_usec(&mut self) -> Option<i64> {
                            let src = &mut self.0;
                            if src.base.field_bit != 96 && !src.set_field(96, -1) { return None; }

                            Some({
                                let dst = sys::get_bytes(src.base.bytes, src.BYTE, 8 as usize) as i64;
                                (dst) as i64
                            })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.latitude(src.latitude());
                        dst.longitude(src.longitude());
                        dst.altitude(src.altitude());
                        if let Some(src) = src.time_usec() {
                            dst.time_usec(src);
                        }
                    }

                    pub trait DST_ {
                        fn latitude(&mut self, src: i32);
                        fn longitude(&mut self, src: i32);
                        fn altitude(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                    }
                }

                /**
*The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to
*				 the described unit */

                pub mod SCALED_IMU2 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SCALED_IMU2) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc1653 {
                            crate::util_::Item__ad_hoc1653(self.0)
                        }
                        pub fn xacc(&mut self) -> crate::util_::Item__ad_hoc1654 {
                            crate::util_::Item__ad_hoc1654(self.0)
                        }
                        pub fn yacc(&mut self) -> crate::util_::Item__ad_hoc1655 {
                            crate::util_::Item__ad_hoc1655(self.0)
                        }
                        pub fn zacc(&mut self) -> crate::util_::Item__ad_hoc1656 {
                            crate::util_::Item__ad_hoc1656(self.0)
                        }
                        pub fn xgyro(&mut self) -> crate::util_::Item__ad_hoc1657 {
                            crate::util_::Item__ad_hoc1657(self.0)
                        }
                        pub fn ygyro(&mut self) -> crate::util_::Item__ad_hoc1658 {
                            crate::util_::Item__ad_hoc1658(self.0)
                        }
                        pub fn zgyro(&mut self) -> crate::util_::Item__ad_hoc1659 {
                            crate::util_::Item__ad_hoc1659(self.0)
                        }
                        pub fn xmag(&mut self) -> crate::util_::Item__ad_hoc1660 {
                            crate::util_::Item__ad_hoc1660(self.0)
                        }
                        pub fn ymag(&mut self) -> crate::util_::Item__ad_hoc1661 {
                            crate::util_::Item__ad_hoc1661(self.0)
                        }
                        pub fn zmag(&mut self) -> crate::util_::Item__ad_hoc1662 {
                            crate::util_::Item__ad_hoc1662(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.xacc(src.xacc().get());
                        dst.yacc(src.yacc().get());
                        dst.zacc(src.zacc().get());
                        dst.xgyro(src.xgyro().get());
                        dst.ygyro(src.ygyro().get());
                        dst.zgyro(src.zgyro().get());
                        dst.xmag(src.xmag().get());
                        dst.ymag(src.ymag().get());
                        dst.zmag(src.zmag().get());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn xacc(&mut self, src: i16);
                        fn yacc(&mut self, src: i16);
                        fn zacc(&mut self, src: i16);
                        fn xgyro(&mut self, src: i16);
                        fn ygyro(&mut self, src: i16);
                        fn zgyro(&mut self, src: i16);
                        fn xmag(&mut self, src: i16);
                        fn ymag(&mut self, src: i16);
                        fn zmag(&mut self, src: i16);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn xacc(&mut self) -> i16;
                        fn yacc(&mut self) -> i16;
                        fn zacc(&mut self) -> i16;
                        fn xgyro(&mut self) -> i16;
                        fn ygyro(&mut self) -> i16;
                        fn zgyro(&mut self) -> i16;
                        fn xmag(&mut self) -> i16;
                        fn ymag(&mut self) -> i16;
                        fn zmag(&mut self) -> i16;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.xacc().set(src.xacc());
                        dst.yacc().set(src.yacc());
                        dst.zacc().set(src.zacc());
                        dst.xgyro().set(src.xgyro());
                        dst.ygyro().set(src.ygyro());
                        dst.zgyro().set(src.zgyro());
                        dst.xmag().set(src.xmag());
                        dst.ymag().set(src.ymag());
                        dst.zmag().set(src.zmag());
                    }
                }

                /**
*The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion.
*				 Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0) */

                pub mod ATTITUDE_QUATERNION {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::ATTITUDE_QUATERNION) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn q1(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 4, 4usize) as u32)
                        }
                        pub fn q2(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 8, 4usize) as u32)
                        }
                        pub fn q3(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 12, 4usize) as u32)
                        }
                        pub fn q4(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 16, 4usize) as u32)
                        }
                        pub fn rollspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 20, 4usize) as u32)
                        }
                        pub fn pitchspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 24, 4usize) as u32)
                        }
                        pub fn yawspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 28, 4usize) as u32)
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.q1(src.q1());
                        dst.q2(src.q2());
                        dst.q3(src.q3());
                        dst.q4(src.q4());
                        dst.rollspeed(src.rollspeed());
                        dst.pitchspeed(src.pitchspeed());
                        dst.yawspeed(src.yawspeed());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn q1(&mut self, src: f32);
                        fn q2(&mut self, src: f32);
                        fn q3(&mut self, src: f32);
                        fn q4(&mut self, src: f32);
                        fn rollspeed(&mut self, src: f32);
                        fn pitchspeed(&mut self, src: f32);
                        fn yawspeed(&mut self, src: f32);
                    }
                }

                /**
*Data packet, size 64 */

                pub mod DATA64 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DATA64) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn typE(&mut self) -> crate::util_::Item__ad_hoc2257 {
                            crate::util_::Item__ad_hoc2257(self.0)
                        }
                        pub fn len(&mut self) -> crate::util_::Item__ad_hoc2258 {
                            crate::util_::Item__ad_hoc2258(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2259 {
                            let dst = self.0;

                            let len = 64 as usize;
                            let offset = 2;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2259 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.typE(src.typE().get());
                        dst.len(src.len().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn typE(&mut self, src: i8);
                        fn len(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2259);
                    }

                    pub trait SRC_ {
                        fn typE(&mut self) -> i8;
                        fn len(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2259);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.typE().set(src.typE());
                        dst.len().set(src.len());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 64usize;
                    }
                }

                /**
*Sent from autopilot to simulation. Hardware in the loop control outputs (replacement for HIL_CONTROLS */

                pub mod HIL_ACTUATOR_CONTROLS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HIL_ACTUATOR_CONTROLS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn flags(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 8, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn controls(&mut self) -> crate::util_::ItemArray__ad_hoc1461 {
                            let src = &mut self.0;

                            let len = 16 as usize;
                            let offset = 16;
                            let bytes = src.base.bytes;
                            crate::util_::ItemArray__ad_hoc1461 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                        pub fn mode(&mut self) -> Option<packs::MAV_MODE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 640 && !src.set_field(640, -1) { return None; }

                            Some({ packs::MAV_MODE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec());
                        dst.flags(src.flags());
                        dst.controls(&mut src.controls());
                        if let Some(src) = src.mode() {
                            dst.mode(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn flags(&mut self, src: i64);
                        fn controls(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1461);
                        fn mode(&mut self, src: packs::MAV_MODE);
                    }

                    pub mod controls {
                        pub const len: usize = 16usize;
                    }
                }

                /**
*Reports the current commanded vehicle position, velocity, and acceleration as specified by the autopilot.
*				 This should match the commands sent in SET_POSITION_TARGET_LOCAL_NED if the vehicle is being controlled
*				 this way */

                pub mod POSITION_TARGET_LOCAL_NED {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::POSITION_TARGET_LOCAL_NED) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn type_mask(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn time_boot_ms(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 6, 4usize) as u32)
                        }
                        pub fn y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 10, 4usize) as u32)
                        }
                        pub fn z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 14, 4usize) as u32)
                        }
                        pub fn vx(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 18, 4usize) as u32)
                        }
                        pub fn vy(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 22, 4usize) as u32)
                        }
                        pub fn vz(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 26, 4usize) as u32)
                        }
                        pub fn afx(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 30, 4usize) as u32)
                        }
                        pub fn afy(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 34, 4usize) as u32)
                        }
                        pub fn afz(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 38, 4usize) as u32)
                        }
                        pub fn yaw(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 42, 4usize) as u32)
                        }
                        pub fn yaw_rate(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 46, 4usize) as u32)
                        }
                        pub fn coordinate_frame(&mut self) -> Option<packs::MAV_FRAME> {
                            let src = &mut self.0;
                            if src.base.field_bit != 400 && !src.set_field(400, -1) { return None; }

                            Some({ packs::MAV_FRAME::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.type_mask(src.type_mask());
                        dst.time_boot_ms(src.time_boot_ms());
                        dst.x(src.x());
                        dst.y(src.y());
                        dst.z(src.z());
                        dst.vx(src.vx());
                        dst.vy(src.vy());
                        dst.vz(src.vz());
                        dst.afx(src.afx());
                        dst.afy(src.afy());
                        dst.afz(src.afz());
                        dst.yaw(src.yaw());
                        dst.yaw_rate(src.yaw_rate());
                        if let Some(src) = src.coordinate_frame() {
                            dst.coordinate_frame(src);
                        }
                    }

                    pub trait DST_ {
                        fn type_mask(&mut self, src: i16);
                        fn time_boot_ms(&mut self, src: i32);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn vx(&mut self, src: f32);
                        fn vy(&mut self, src: f32);
                        fn vz(&mut self, src: f32);
                        fn afx(&mut self, src: f32);
                        fn afy(&mut self, src: f32);
                        fn afz(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                        fn yaw_rate(&mut self, src: f32);
                        fn coordinate_frame(&mut self, src: packs::MAV_FRAME);
                    }
                }

                /**
*3 axis gimbal mesuraments */

                pub mod GIMBAL_REPORT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GIMBAL_REPORT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2379 {
                            crate::util_::Item__ad_hoc2379(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2380 {
                            crate::util_::Item__ad_hoc2380(self.0)
                        }
                        pub fn delta_time(&mut self) -> crate::util_::Item__ad_hoc2381 {
                            crate::util_::Item__ad_hoc2381(self.0)
                        }
                        pub fn delta_angle_x(&mut self) -> crate::util_::Item__ad_hoc2382 {
                            crate::util_::Item__ad_hoc2382(self.0)
                        }
                        pub fn delta_angle_y(&mut self) -> crate::util_::Item__ad_hoc2383 {
                            crate::util_::Item__ad_hoc2383(self.0)
                        }
                        pub fn delta_angle_z(&mut self) -> crate::util_::Item__ad_hoc2384 {
                            crate::util_::Item__ad_hoc2384(self.0)
                        }
                        pub fn delta_velocity_x(&mut self) -> crate::util_::Item__ad_hoc2385 {
                            crate::util_::Item__ad_hoc2385(self.0)
                        }
                        pub fn delta_velocity_y(&mut self) -> crate::util_::Item__ad_hoc2386 {
                            crate::util_::Item__ad_hoc2386(self.0)
                        }
                        pub fn delta_velocity_z(&mut self) -> crate::util_::Item__ad_hoc2387 {
                            crate::util_::Item__ad_hoc2387(self.0)
                        }
                        pub fn joint_roll(&mut self) -> crate::util_::Item__ad_hoc2388 {
                            crate::util_::Item__ad_hoc2388(self.0)
                        }
                        pub fn joint_el(&mut self) -> crate::util_::Item__ad_hoc2389 {
                            crate::util_::Item__ad_hoc2389(self.0)
                        }
                        pub fn joint_az(&mut self) -> crate::util_::Item__ad_hoc2390 {
                            crate::util_::Item__ad_hoc2390(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.delta_time(src.delta_time().get());
                        dst.delta_angle_x(src.delta_angle_x().get());
                        dst.delta_angle_y(src.delta_angle_y().get());
                        dst.delta_angle_z(src.delta_angle_z().get());
                        dst.delta_velocity_x(src.delta_velocity_x().get());
                        dst.delta_velocity_y(src.delta_velocity_y().get());
                        dst.delta_velocity_z(src.delta_velocity_z().get());
                        dst.joint_roll(src.joint_roll().get());
                        dst.joint_el(src.joint_el().get());
                        dst.joint_az(src.joint_az().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn delta_time(&mut self, src: f32);
                        fn delta_angle_x(&mut self, src: f32);
                        fn delta_angle_y(&mut self, src: f32);
                        fn delta_angle_z(&mut self, src: f32);
                        fn delta_velocity_x(&mut self, src: f32);
                        fn delta_velocity_y(&mut self, src: f32);
                        fn delta_velocity_z(&mut self, src: f32);
                        fn joint_roll(&mut self, src: f32);
                        fn joint_el(&mut self, src: f32);
                        fn joint_az(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn delta_time(&mut self) -> f32;
                        fn delta_angle_x(&mut self) -> f32;
                        fn delta_angle_y(&mut self) -> f32;
                        fn delta_angle_z(&mut self) -> f32;
                        fn delta_velocity_x(&mut self) -> f32;
                        fn delta_velocity_y(&mut self) -> f32;
                        fn delta_velocity_z(&mut self) -> f32;
                        fn joint_roll(&mut self) -> f32;
                        fn joint_el(&mut self) -> f32;
                        fn joint_az(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.delta_time().set(src.delta_time());
                        dst.delta_angle_x().set(src.delta_angle_x());
                        dst.delta_angle_y().set(src.delta_angle_y());
                        dst.delta_angle_z().set(src.delta_angle_z());
                        dst.delta_velocity_x().set(src.delta_velocity_x());
                        dst.delta_velocity_y().set(src.delta_velocity_y());
                        dst.delta_velocity_z().set(src.delta_velocity_z());
                        dst.joint_roll().set(src.joint_roll());
                        dst.joint_el().set(src.joint_el());
                        dst.joint_az().set(src.joint_az());
                    }
                }

                /**
*Write registers for a device */

                pub mod DEVICE_OP_WRITE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DEVICE_OP_WRITE) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn request_id(&mut self) -> crate::util_::Item__ad_hoc2424 {
                            crate::util_::Item__ad_hoc2424(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2422 {
                            crate::util_::Item__ad_hoc2422(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2423 {
                            crate::util_::Item__ad_hoc2423(self.0)
                        }
                        pub fn bus(&mut self) -> crate::util_::Item__ad_hoc2425 {
                            crate::util_::Item__ad_hoc2425(self.0)
                        }
                        pub fn address(&mut self) -> crate::util_::Item__ad_hoc2426 {
                            crate::util_::Item__ad_hoc2426(self.0)
                        }
                        pub fn regstart(&mut self) -> crate::util_::Item__ad_hoc2428 {
                            crate::util_::Item__ad_hoc2428(self.0)
                        }
                        pub fn count(&mut self) -> crate::util_::Item__ad_hoc2429 {
                            crate::util_::Item__ad_hoc2429(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2430 {
                            let dst = &mut self.0;

                            let len = 128 as usize;
                            let offset = 10;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc2430 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn bustype(&mut self) -> crate::util_::Item__ad_hoc285 {
                            crate::util_::Item__ad_hoc285(self.0)
                        }
                        pub fn busname(&mut self) -> crate::util_::Item__ad_hoc2427 {
                            crate::util_::Item__ad_hoc2427(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.request_id(src.request_id().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.bus(src.bus().get());
                        dst.address(src.address().get());
                        dst.regstart(src.regstart().get());
                        dst.count(src.count().get());
                        dst.daTa(&mut src.daTa(None));
                        if let Some(src) = src.bustype().get() {
                            dst.bustype(src);
                        }
                        if let Some(src) = src.busname().get() {
                            dst.busname(src);
                        }
                    }

                    pub trait DST_ {
                        fn request_id(&mut self, src: i32);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn bus(&mut self, src: i8);
                        fn address(&mut self, src: i8);
                        fn regstart(&mut self, src: i8);
                        fn count(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2430);
                        fn bustype(&mut self, src: packs::DEVICE_OP_BUSTYPE);
                        fn busname(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn request_id(&mut self) -> i32;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn bus(&mut self) -> i8;
                        fn address(&mut self) -> i8;
                        fn regstart(&mut self) -> i8;
                        fn count(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2430);
                        fn bustype(&mut self) -> Option<packs::DEVICE_OP_BUSTYPE>;
                        fn busname_item_exists_(&mut self) -> usize;
                        fn busname(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.request_id().set(src.request_id());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.bus().set(src.bus());
                        dst.address().set(src.address());
                        dst.regstart().set(src.regstart());
                        dst.count().set(src.count());
                        src.daTa(&mut dst.daTa(None));
                        if let Some(src) = src.bustype() {
                            dst.bustype().set(src);
                        }
                        let len = src.busname_item_exists_();
                        if 0 < len {
                            dst.0.set_field(1107, len as i32);

                            src.busname(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod daTa {
                        pub const len: usize = 128usize;
                    }

                    pub mod busname {
                        pub const len_max: usize = 255usize;
                    }
                }

                pub mod DISTANCE_SENSOR {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DISTANCE_SENSOR) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn min_distance(&mut self) -> crate::util_::Item__ad_hoc1752 {
                            crate::util_::Item__ad_hoc1752(self.0)
                        }
                        pub fn max_distance(&mut self) -> crate::util_::Item__ad_hoc1753 {
                            crate::util_::Item__ad_hoc1753(self.0)
                        }
                        pub fn current_distance(&mut self) -> crate::util_::Item__ad_hoc1754 {
                            crate::util_::Item__ad_hoc1754(self.0)
                        }
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc1751 {
                            crate::util_::Item__ad_hoc1751(self.0)
                        }
                        pub fn id(&mut self) -> crate::util_::Item__ad_hoc1755 {
                            crate::util_::Item__ad_hoc1755(self.0)
                        }
                        pub fn covariance(&mut self) -> crate::util_::Item__ad_hoc1756 {
                            crate::util_::Item__ad_hoc1756(self.0)
                        }
                        pub fn typE(&mut self) -> crate::util_::Item__ad_hoc244 {
                            crate::util_::Item__ad_hoc244(self.0)
                        }
                        pub fn orientation(&mut self) -> crate::util_::Item__ad_hoc243 {
                            crate::util_::Item__ad_hoc243(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.min_distance(src.min_distance().get());
                        dst.max_distance(src.max_distance().get());
                        dst.current_distance(src.current_distance().get());
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.id(src.id().get());
                        dst.covariance(src.covariance().get());
                        if let Some(src) = src.typE().get() {
                            dst.typE(src);
                        }
                        if let Some(src) = src.orientation().get() {
                            dst.orientation(src);
                        }
                    }

                    pub trait DST_ {
                        fn min_distance(&mut self, src: i16);
                        fn max_distance(&mut self, src: i16);
                        fn current_distance(&mut self, src: i16);
                        fn time_boot_ms(&mut self, src: i32);
                        fn id(&mut self, src: i8);
                        fn covariance(&mut self, src: i8);
                        fn typE(&mut self, src: packs::MAV_DISTANCE_SENSOR);
                        fn orientation(&mut self, src: packs::MAV_SENSOR_ORIENTATION);
                    }

                    pub trait SRC_ {
                        fn min_distance(&mut self) -> i16;
                        fn max_distance(&mut self) -> i16;
                        fn current_distance(&mut self) -> i16;
                        fn time_boot_ms(&mut self) -> i32;
                        fn id(&mut self) -> i8;
                        fn covariance(&mut self) -> i8;
                        fn typE(&mut self) -> Option<packs::MAV_DISTANCE_SENSOR>;
                        fn orientation(&mut self) -> Option<packs::MAV_SENSOR_ORIENTATION>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.min_distance().set(src.min_distance());
                        dst.max_distance().set(src.max_distance());
                        dst.current_distance().set(src.current_distance());
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.id().set(src.id());
                        dst.covariance().set(src.covariance());
                        if let Some(src) = src.typE() {
                            dst.typE().set(src);
                        }
                        if let Some(src) = src.orientation() {
                            dst.orientation().set(src);
                        }
                    }
                }

                /**
*Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor) */

                pub mod HIL_OPTICAL_FLOW {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HIL_OPTICAL_FLOW) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn integration_time_us(&mut self) -> crate::util_::Item__ad_hoc1627 {
                            crate::util_::Item__ad_hoc1627(self.0)
                        }
                        pub fn time_delta_distance_us(&mut self) -> crate::util_::Item__ad_hoc1635 {
                            crate::util_::Item__ad_hoc1635(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1625 {
                            crate::util_::Item__ad_hoc1625(self.0)
                        }
                        pub fn sensor_id(&mut self) -> crate::util_::Item__ad_hoc1626 {
                            crate::util_::Item__ad_hoc1626(self.0)
                        }
                        pub fn integrated_x(&mut self) -> crate::util_::Item__ad_hoc1628 {
                            crate::util_::Item__ad_hoc1628(self.0)
                        }
                        pub fn integrated_y(&mut self) -> crate::util_::Item__ad_hoc1629 {
                            crate::util_::Item__ad_hoc1629(self.0)
                        }
                        pub fn integrated_xgyro(&mut self) -> crate::util_::Item__ad_hoc1630 {
                            crate::util_::Item__ad_hoc1630(self.0)
                        }
                        pub fn integrated_ygyro(&mut self) -> crate::util_::Item__ad_hoc1631 {
                            crate::util_::Item__ad_hoc1631(self.0)
                        }
                        pub fn integrated_zgyro(&mut self) -> crate::util_::Item__ad_hoc1632 {
                            crate::util_::Item__ad_hoc1632(self.0)
                        }
                        pub fn temperature(&mut self) -> crate::util_::Item__ad_hoc1633 {
                            crate::util_::Item__ad_hoc1633(self.0)
                        }
                        pub fn quality(&mut self) -> crate::util_::Item__ad_hoc1634 {
                            crate::util_::Item__ad_hoc1634(self.0)
                        }
                        pub fn distance(&mut self) -> crate::util_::Item__ad_hoc1636 {
                            crate::util_::Item__ad_hoc1636(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.integration_time_us(src.integration_time_us().get());
                        dst.time_delta_distance_us(src.time_delta_distance_us().get());
                        dst.time_usec(src.time_usec().get());
                        dst.sensor_id(src.sensor_id().get());
                        dst.integrated_x(src.integrated_x().get());
                        dst.integrated_y(src.integrated_y().get());
                        dst.integrated_xgyro(src.integrated_xgyro().get());
                        dst.integrated_ygyro(src.integrated_ygyro().get());
                        dst.integrated_zgyro(src.integrated_zgyro().get());
                        dst.temperature(src.temperature().get());
                        dst.quality(src.quality().get());
                        dst.distance(src.distance().get());
                    }

                    pub trait DST_ {
                        fn integration_time_us(&mut self, src: i32);
                        fn time_delta_distance_us(&mut self, src: i32);
                        fn time_usec(&mut self, src: i64);
                        fn sensor_id(&mut self, src: i8);
                        fn integrated_x(&mut self, src: f32);
                        fn integrated_y(&mut self, src: f32);
                        fn integrated_xgyro(&mut self, src: f32);
                        fn integrated_ygyro(&mut self, src: f32);
                        fn integrated_zgyro(&mut self, src: f32);
                        fn temperature(&mut self, src: i16);
                        fn quality(&mut self, src: i8);
                        fn distance(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn integration_time_us(&mut self) -> i32;
                        fn time_delta_distance_us(&mut self) -> i32;
                        fn time_usec(&mut self) -> i64;
                        fn sensor_id(&mut self) -> i8;
                        fn integrated_x(&mut self) -> f32;
                        fn integrated_y(&mut self) -> f32;
                        fn integrated_xgyro(&mut self) -> f32;
                        fn integrated_ygyro(&mut self) -> f32;
                        fn integrated_zgyro(&mut self) -> f32;
                        fn temperature(&mut self) -> i16;
                        fn quality(&mut self) -> i8;
                        fn distance(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.integration_time_us().set(src.integration_time_us());
                        dst.time_delta_distance_us().set(src.time_delta_distance_us());
                        dst.time_usec().set(src.time_usec());
                        dst.sensor_id().set(src.sensor_id());
                        dst.integrated_x().set(src.integrated_x());
                        dst.integrated_y().set(src.integrated_y());
                        dst.integrated_xgyro().set(src.integrated_xgyro());
                        dst.integrated_ygyro().set(src.integrated_ygyro());
                        dst.integrated_zgyro().set(src.integrated_zgyro());
                        dst.temperature().set(src.temperature());
                        dst.quality().set(src.quality());
                        dst.distance().set(src.distance());
                    }
                }

                /**
*Barometer readings for 2nd barometer */

                pub mod SCALED_PRESSURE2 {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SCALED_PRESSURE2) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc1775 {
                            crate::util_::Item__ad_hoc1775(self.0)
                        }
                        pub fn press_abs(&mut self) -> crate::util_::Item__ad_hoc1776 {
                            crate::util_::Item__ad_hoc1776(self.0)
                        }
                        pub fn press_diff(&mut self) -> crate::util_::Item__ad_hoc1777 {
                            crate::util_::Item__ad_hoc1777(self.0)
                        }
                        pub fn temperature(&mut self) -> crate::util_::Item__ad_hoc1778 {
                            crate::util_::Item__ad_hoc1778(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.press_abs(src.press_abs().get());
                        dst.press_diff(src.press_diff().get());
                        dst.temperature(src.temperature().get());
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn press_abs(&mut self, src: f32);
                        fn press_diff(&mut self, src: f32);
                        fn temperature(&mut self, src: i16);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn press_abs(&mut self) -> f32;
                        fn press_diff(&mut self) -> f32;
                        fn temperature(&mut self) -> i16;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.press_abs().set(src.press_abs());
                        dst.press_diff().set(src.press_diff());
                        dst.temperature().set(src.temperature());
                    }
                }

                pub mod WIND_COV {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::WIND_COV) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1875 {
                            crate::util_::Item__ad_hoc1875(self.0)
                        }
                        pub fn wind_x(&mut self) -> crate::util_::Item__ad_hoc1876 {
                            crate::util_::Item__ad_hoc1876(self.0)
                        }
                        pub fn wind_y(&mut self) -> crate::util_::Item__ad_hoc1877 {
                            crate::util_::Item__ad_hoc1877(self.0)
                        }
                        pub fn wind_z(&mut self) -> crate::util_::Item__ad_hoc1878 {
                            crate::util_::Item__ad_hoc1878(self.0)
                        }
                        pub fn var_horiz(&mut self) -> crate::util_::Item__ad_hoc1879 {
                            crate::util_::Item__ad_hoc1879(self.0)
                        }
                        pub fn var_vert(&mut self) -> crate::util_::Item__ad_hoc1880 {
                            crate::util_::Item__ad_hoc1880(self.0)
                        }
                        pub fn wind_alt(&mut self) -> crate::util_::Item__ad_hoc1881 {
                            crate::util_::Item__ad_hoc1881(self.0)
                        }
                        pub fn horiz_accuracy(&mut self) -> crate::util_::Item__ad_hoc1882 {
                            crate::util_::Item__ad_hoc1882(self.0)
                        }
                        pub fn vert_accuracy(&mut self) -> crate::util_::Item__ad_hoc1883 {
                            crate::util_::Item__ad_hoc1883(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec().get());
                        dst.wind_x(src.wind_x().get());
                        dst.wind_y(src.wind_y().get());
                        dst.wind_z(src.wind_z().get());
                        dst.var_horiz(src.var_horiz().get());
                        dst.var_vert(src.var_vert().get());
                        dst.wind_alt(src.wind_alt().get());
                        dst.horiz_accuracy(src.horiz_accuracy().get());
                        dst.vert_accuracy(src.vert_accuracy().get());
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn wind_x(&mut self, src: f32);
                        fn wind_y(&mut self, src: f32);
                        fn wind_z(&mut self, src: f32);
                        fn var_horiz(&mut self, src: f32);
                        fn var_vert(&mut self, src: f32);
                        fn wind_alt(&mut self, src: f32);
                        fn horiz_accuracy(&mut self, src: f32);
                        fn vert_accuracy(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn time_usec(&mut self) -> i64;
                        fn wind_x(&mut self) -> f32;
                        fn wind_y(&mut self) -> f32;
                        fn wind_z(&mut self) -> f32;
                        fn var_horiz(&mut self) -> f32;
                        fn var_vert(&mut self) -> f32;
                        fn wind_alt(&mut self) -> f32;
                        fn horiz_accuracy(&mut self) -> f32;
                        fn vert_accuracy(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_usec().set(src.time_usec());
                        dst.wind_x().set(src.wind_x());
                        dst.wind_y().set(src.wind_y());
                        dst.wind_z().set(src.wind_z());
                        dst.var_horiz().set(src.var_horiz());
                        dst.var_vert().set(src.var_vert());
                        dst.wind_alt().set(src.wind_alt());
                        dst.horiz_accuracy().set(src.horiz_accuracy());
                        dst.vert_accuracy().set(src.vert_accuracy());
                    }
                }

                /**
*Request to control this MAV */

                pub mod CHANGE_OPERATOR_CONTROL {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::CHANGE_OPERATOR_CONTROL) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn control_request(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn version(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 1 as usize) as i8;
                            (dst) as i8
                        }

                        pub fn passkey(&mut self) -> Option<&str> {
                            let src = &mut self.0;
                            if src.base.field_bit != 26 && !src.set_field(26, -1) { return None; }
                            Some(src.get_str())
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.control_request(src.control_request());
                        dst.version(src.version());
                        if let Some(src) = src.passkey() {
                            dst.passkey(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn control_request(&mut self, src: i8);
                        fn version(&mut self, src: i8);
                        fn passkey(&mut self, src: &str);
                    }

                    pub mod passkey {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Request to set a GOPRO_COMMAND with a desired */

                pub mod GOPRO_SET_REQUEST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GOPRO_SET_REQUEST) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2404 {
                            crate::util_::Item__ad_hoc2404(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2405 {
                            crate::util_::Item__ad_hoc2405(self.0)
                        }
                        pub fn value(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2406 {
                            let dst = &mut self.0;

                            let len = 4 as usize;
                            let offset = 2;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc2406 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn cmd_id(&mut self) -> crate::util_::Item__ad_hoc17 {
                            crate::util_::Item__ad_hoc17(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.value(&mut src.value(None));
                        if let Some(src) = src.cmd_id().get() {
                            dst.cmd_id(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn value(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2406);
                        fn cmd_id(&mut self, src: packs::GOPRO_COMMAND);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn value(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2406);
                        fn cmd_id(&mut self) -> Option<packs::GOPRO_COMMAND>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        src.value(&mut dst.value(None));
                        if let Some(src) = src.cmd_id() {
                            dst.cmd_id().set(src);
                        }
                    }

                    pub mod value {
                        pub const len: usize = 4usize;
                    }
                }

                /**
*The general system state. If the system is following the MAVLink standard, the system state is mainly
*				 defined by three orthogonal states/modes: The system mode, which is either LOCKED (motors shut down and
*				 locked), MANUAL (system under RC control), GUIDED (system with autonomous position control, position
*				 setpoint controlled manually) or AUTO (system guided by path/waypoint planner). The NAV_MODE defined
*				 the current flight state: LIFTOFF (often an open-loop maneuver), LANDING, WAYPOINTS or VECTOR. This represents
*				 the internal navigation state machine. The system status shows whether the system is currently active
*				 or not and if an emergency occured. During the CRITICAL and EMERGENCY states the MAV is still considered
*				 to be active, but should start emergency procedures autonomously. After a failure occured it should first
*				 move from active to critical to allow manual intervention and then move to emergency after a certain
*				 timeout */

                pub mod SYS_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::SYS_STATUS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn load(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn voltage_battery(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn drop_rate_comm(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 4, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn errors_comm(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 6, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn errors_count1(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 8, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn errors_count2(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 10, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn errors_count3(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 12, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn errors_count4(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 14, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn current_battery(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 16, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn battery_remaining(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 18, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn onboard_control_sensors_present(&mut self) -> Option<packs::MAV_SYS_STATUS_SENSOR> {
                            let src = &mut self.0;
                            if src.base.field_bit != 154 && !src.set_field(154, -1) { return None; }

                            Some({ packs::MAV_SYS_STATUS_SENSOR::from_bits((sys::get_bits(src.base.bytes, src.BIT, 5)) as i32).unwrap() })
                        }
                        pub fn onboard_control_sensors_enabled(&mut self) -> Option<packs::MAV_SYS_STATUS_SENSOR> {
                            let src = &mut self.0;
                            if src.base.field_bit != 155 && !src.set_field(155, -1) { return None; }

                            Some({ packs::MAV_SYS_STATUS_SENSOR::from_bits((sys::get_bits(src.base.bytes, src.BIT, 5)) as i32).unwrap() })
                        }
                        pub fn onboard_control_sensors_health(&mut self) -> Option<packs::MAV_SYS_STATUS_SENSOR> {
                            let src = &mut self.0;
                            if src.base.field_bit != 156 && !src.set_field(156, -1) { return None; }

                            Some({ packs::MAV_SYS_STATUS_SENSOR::from_bits((sys::get_bits(src.base.bytes, src.BIT, 5)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.load(src.load());
                        dst.voltage_battery(src.voltage_battery());
                        dst.drop_rate_comm(src.drop_rate_comm());
                        dst.errors_comm(src.errors_comm());
                        dst.errors_count1(src.errors_count1());
                        dst.errors_count2(src.errors_count2());
                        dst.errors_count3(src.errors_count3());
                        dst.errors_count4(src.errors_count4());
                        dst.current_battery(src.current_battery());
                        dst.battery_remaining(src.battery_remaining());
                        if let Some(src) = src.onboard_control_sensors_present() {
                            dst.onboard_control_sensors_present(src);
                        }
                        if let Some(src) = src.onboard_control_sensors_enabled() {
                            dst.onboard_control_sensors_enabled(src);
                        }
                        if let Some(src) = src.onboard_control_sensors_health() {
                            dst.onboard_control_sensors_health(src);
                        }
                    }

                    pub trait DST_ {
                        fn load(&mut self, src: i16);
                        fn voltage_battery(&mut self, src: i16);
                        fn drop_rate_comm(&mut self, src: i16);
                        fn errors_comm(&mut self, src: i16);
                        fn errors_count1(&mut self, src: i16);
                        fn errors_count2(&mut self, src: i16);
                        fn errors_count3(&mut self, src: i16);
                        fn errors_count4(&mut self, src: i16);
                        fn current_battery(&mut self, src: i16);
                        fn battery_remaining(&mut self, src: i8);
                        fn onboard_control_sensors_present(&mut self, src: packs::MAV_SYS_STATUS_SENSOR);
                        fn onboard_control_sensors_enabled(&mut self, src: packs::MAV_SYS_STATUS_SENSOR);
                        fn onboard_control_sensors_health(&mut self, src: packs::MAV_SYS_STATUS_SENSOR);
                    }
                }

                /**
*Message encoding a mission item. This message is emitted to announce
*				 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See also http:qgroundcontrol.org/mavlink/waypoint_protocol. */

                pub mod MISSION_ITEM {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_ITEM) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn seq(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 3, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn current(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 4, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn autocontinue(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 5, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn param1(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 6, 4usize) as u32)
                        }
                        pub fn param2(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 10, 4usize) as u32)
                        }
                        pub fn param3(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 14, 4usize) as u32)
                        }
                        pub fn param4(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 18, 4usize) as u32)
                        }
                        pub fn x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 22, 4usize) as u32)
                        }
                        pub fn y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 26, 4usize) as u32)
                        }
                        pub fn z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 30, 4usize) as u32)
                        }
                        pub fn frame(&mut self) -> Option<packs::MAV_FRAME> {
                            let src = &mut self.0;
                            if src.base.field_bit != 274 && !src.set_field(274, -1) { return None; }

                            Some({ packs::MAV_FRAME::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                        pub fn command(&mut self) -> Option<packs::MAV_CMD> {
                            let src = &mut self.0;
                            if src.base.field_bit != 275 && !src.set_field(275, -1) { return None; }

                            Some({ packs::MAV_CMD::from_bits((sys::get_bits(src.base.bytes, src.BIT, 8)) as i32).unwrap() })
                        }
                        pub fn mission_type(&mut self) -> Option<packs::MAV_MISSION_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 276 && !src.set_field(276, -1) { return None; }

                            Some({ packs::MAV_MISSION_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.seq(src.seq());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.current(src.current());
                        dst.autocontinue(src.autocontinue());
                        dst.param1(src.param1());
                        dst.param2(src.param2());
                        dst.param3(src.param3());
                        dst.param4(src.param4());
                        dst.x(src.x());
                        dst.y(src.y());
                        dst.z(src.z());
                        if let Some(src) = src.frame() {
                            dst.frame(src);
                        }
                        if let Some(src) = src.command() {
                            dst.command(src);
                        }
                        if let Some(src) = src.mission_type() {
                            dst.mission_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn seq(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn current(&mut self, src: i8);
                        fn autocontinue(&mut self, src: i8);
                        fn param1(&mut self, src: f32);
                        fn param2(&mut self, src: f32);
                        fn param3(&mut self, src: f32);
                        fn param4(&mut self, src: f32);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn frame(&mut self, src: packs::MAV_FRAME);
                        fn command(&mut self, src: packs::MAV_CMD);
                        fn mission_type(&mut self, src: packs::MAV_MISSION_TYPE);
                    }
                }

                /**
*The RAW IMU readings for the usual 9DOF sensor setup. This message should always contain the true raw
*				 values without any scaling to allow data capture and system debugging */

                pub mod RAW_IMU {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RAW_IMU) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn xacc(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 8, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn yacc(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 10, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn zacc(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 12, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn xgyro(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 14, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn ygyro(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 16, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn zgyro(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 18, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn xmag(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 20, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn ymag(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 22, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn zmag(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 24, 2 as usize) as i16;
                            (dst) as i16
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec());
                        dst.xacc(src.xacc());
                        dst.yacc(src.yacc());
                        dst.zacc(src.zacc());
                        dst.xgyro(src.xgyro());
                        dst.ygyro(src.ygyro());
                        dst.zgyro(src.zgyro());
                        dst.xmag(src.xmag());
                        dst.ymag(src.ymag());
                        dst.zmag(src.zmag());
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn xacc(&mut self, src: i16);
                        fn yacc(&mut self, src: i16);
                        fn zacc(&mut self, src: i16);
                        fn xgyro(&mut self, src: i16);
                        fn ygyro(&mut self, src: i16);
                        fn zgyro(&mut self, src: i16);
                        fn xmag(&mut self, src: i16);
                        fn ymag(&mut self, src: i16);
                        fn zmag(&mut self, src: i16);
                    }
                }

                /**
*Message encoding a command with parameters as scaled integers. Scaling depends on the actual command value */

                pub mod COMMAND_INT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::COMMAND_INT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 1, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn current(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn autocontinue(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 3, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn param1(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 4, 4usize) as u32)
                        }
                        pub fn param2(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 8, 4usize) as u32)
                        }
                        pub fn param3(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 12, 4usize) as u32)
                        }
                        pub fn param4(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 16, 4usize) as u32)
                        }
                        pub fn x(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 20, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn y(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 24, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 28, 4usize) as u32)
                        }
                        pub fn frame(&mut self) -> Option<packs::MAV_FRAME> {
                            let src = &mut self.0;
                            if src.base.field_bit != 258 && !src.set_field(258, -1) { return None; }

                            Some({ packs::MAV_FRAME::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                        pub fn command(&mut self) -> Option<packs::MAV_CMD> {
                            let src = &mut self.0;
                            if src.base.field_bit != 259 && !src.set_field(259, -1) { return None; }

                            Some({ packs::MAV_CMD::from_bits((sys::get_bits(src.base.bytes, src.BIT, 8)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.current(src.current());
                        dst.autocontinue(src.autocontinue());
                        dst.param1(src.param1());
                        dst.param2(src.param2());
                        dst.param3(src.param3());
                        dst.param4(src.param4());
                        dst.x(src.x());
                        dst.y(src.y());
                        dst.z(src.z());
                        if let Some(src) = src.frame() {
                            dst.frame(src);
                        }
                        if let Some(src) = src.command() {
                            dst.command(src);
                        }
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn current(&mut self, src: i8);
                        fn autocontinue(&mut self, src: i8);
                        fn param1(&mut self, src: f32);
                        fn param2(&mut self, src: f32);
                        fn param3(&mut self, src: f32);
                        fn param4(&mut self, src: f32);
                        fn x(&mut self, src: i32);
                        fn y(&mut self, src: i32);
                        fn z(&mut self, src: f32);
                        fn frame(&mut self, src: packs::MAV_FRAME);
                        fn command(&mut self, src: packs::MAV_CMD);
                    }
                }

                /**
*Optical flow from a flow sensor (e.g. optical mouse sensor) */

                pub mod OPTICAL_FLOW {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::OPTICAL_FLOW) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn sensor_id(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 8, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn flow_x(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 9, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn flow_y(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 11, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn flow_comp_m_x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 13, 4usize) as u32)
                        }
                        pub fn flow_comp_m_y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 17, 4usize) as u32)
                        }
                        pub fn quality(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 21, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn ground_distance(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 22, 4usize) as u32)
                        }
                        pub fn flow_rate_x(&mut self) -> Option<f32> {
                            let src = &mut self.0;
                            if src.base.field_bit != 208 && !src.set_field(208, -1) { return None; }

                            Some({ f32::from_bits(sys::get_bytes(src.base.bytes, src.BYTE, 4usize) as u32) })
                        }
                        pub fn flow_rate_y(&mut self) -> Option<f32> {
                            let src = &mut self.0;
                            if src.base.field_bit != 209 && !src.set_field(209, -1) { return None; }

                            Some({ f32::from_bits(sys::get_bytes(src.base.bytes, src.BYTE, 4usize) as u32) })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec());
                        dst.sensor_id(src.sensor_id());
                        dst.flow_x(src.flow_x());
                        dst.flow_y(src.flow_y());
                        dst.flow_comp_m_x(src.flow_comp_m_x());
                        dst.flow_comp_m_y(src.flow_comp_m_y());
                        dst.quality(src.quality());
                        dst.ground_distance(src.ground_distance());
                        if let Some(src) = src.flow_rate_x() {
                            dst.flow_rate_x(src);
                        }
                        if let Some(src) = src.flow_rate_y() {
                            dst.flow_rate_y(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn sensor_id(&mut self, src: i8);
                        fn flow_x(&mut self, src: i16);
                        fn flow_y(&mut self, src: i16);
                        fn flow_comp_m_x(&mut self, src: f32);
                        fn flow_comp_m_y(&mut self, src: f32);
                        fn quality(&mut self, src: i8);
                        fn ground_distance(&mut self, src: f32);
                        fn flow_rate_x(&mut self, src: f32);
                        fn flow_rate_y(&mut self, src: f32);
                    }
                }

                /**
*Message encoding a mission item. This message is emitted to announce
*				 the presence of a mission item and to set a mission item on the system. The mission item can be either in x, y, z meters (type: LOCAL) or x:lat, y:lon, z:altitude. Local frame is Z-down, right handed (NED), global frame is Z-up, right handed (ENU). See alsohttp:qgroundcontrol.org/mavlink/waypoint_protocol. */

                pub mod MISSION_ITEM_INT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MISSION_ITEM_INT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn seq(&mut self) -> i16 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 0, 2 as usize) as i16;
                            (dst) as i16
                        }
                        pub fn target_system(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 2, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn target_component(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 3, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn current(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 4, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn autocontinue(&mut self) -> i8 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 5, 1 as usize) as i8;
                            (dst) as i8
                        }
                        pub fn param1(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 6, 4usize) as u32)
                        }
                        pub fn param2(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 10, 4usize) as u32)
                        }
                        pub fn param3(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 14, 4usize) as u32)
                        }
                        pub fn param4(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 18, 4usize) as u32)
                        }
                        pub fn x(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 22, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn y(&mut self) -> i32 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(src.base.bytes, 26, 4 as usize) as i32;
                            (dst) as i32
                        }
                        pub fn z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(src.base.bytes, 30, 4usize) as u32)
                        }
                        pub fn frame(&mut self) -> Option<packs::MAV_FRAME> {
                            let src = &mut self.0;
                            if src.base.field_bit != 274 && !src.set_field(274, -1) { return None; }

                            Some({ packs::MAV_FRAME::from_bits((sys::get_bits(src.base.bytes, src.BIT, 4)) as i8).unwrap() })
                        }
                        pub fn command(&mut self) -> Option<packs::MAV_CMD> {
                            let src = &mut self.0;
                            if src.base.field_bit != 275 && !src.set_field(275, -1) { return None; }

                            Some({ packs::MAV_CMD::from_bits((sys::get_bits(src.base.bytes, src.BIT, 8)) as i32).unwrap() })
                        }
                        pub fn mission_type(&mut self) -> Option<packs::MAV_MISSION_TYPE> {
                            let src = &mut self.0;
                            if src.base.field_bit != 276 && !src.set_field(276, -1) { return None; }

                            Some({ packs::MAV_MISSION_TYPE::from_bits((sys::get_bits(src.base.bytes, src.BIT, 3)) as i32).unwrap() })
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.seq(src.seq());
                        dst.target_system(src.target_system());
                        dst.target_component(src.target_component());
                        dst.current(src.current());
                        dst.autocontinue(src.autocontinue());
                        dst.param1(src.param1());
                        dst.param2(src.param2());
                        dst.param3(src.param3());
                        dst.param4(src.param4());
                        dst.x(src.x());
                        dst.y(src.y());
                        dst.z(src.z());
                        if let Some(src) = src.frame() {
                            dst.frame(src);
                        }
                        if let Some(src) = src.command() {
                            dst.command(src);
                        }
                        if let Some(src) = src.mission_type() {
                            dst.mission_type(src);
                        }
                    }

                    pub trait DST_ {
                        fn seq(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn current(&mut self, src: i8);
                        fn autocontinue(&mut self, src: i8);
                        fn param1(&mut self, src: f32);
                        fn param2(&mut self, src: f32);
                        fn param3(&mut self, src: f32);
                        fn param4(&mut self, src: f32);
                        fn x(&mut self, src: i32);
                        fn y(&mut self, src: i32);
                        fn z(&mut self, src: f32);
                        fn frame(&mut self, src: packs::MAV_FRAME);
                        fn command(&mut self, src: packs::MAV_CMD);
                        fn mission_type(&mut self, src: packs::MAV_MISSION_TYPE);
                    }
                }

                /**
*camera vision based attitude and position deltas */

                pub mod VISION_POSITION_DELTA {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::VISION_POSITION_DELTA) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc2445 {
                            crate::util_::Item__ad_hoc2445(self.0)
                        }
                        pub fn time_delta_usec(&mut self) -> crate::util_::Item__ad_hoc2446 {
                            crate::util_::Item__ad_hoc2446(self.0)
                        }
                        pub fn angle_delta(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc2447 {
                            let dst = self.0;

                            let len = 3 as usize;
                            let offset = 16;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2447 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn position_delta(&mut self, src: Option<&mut dyn Iterator<Item=f32>>) -> crate::util_::ItemArray__ad_hoc2448 {
                            let dst = self.0;

                            let len = 3 as usize;
                            let offset = 28;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2448 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn confidence(&mut self) -> crate::util_::Item__ad_hoc2449 {
                            crate::util_::Item__ad_hoc2449(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec().get());
                        dst.time_delta_usec(src.time_delta_usec().get());
                        dst.angle_delta(&mut src.angle_delta(None));
                        dst.position_delta(&mut src.position_delta(None));
                        dst.confidence(src.confidence().get());
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn time_delta_usec(&mut self, src: i64);
                        fn angle_delta(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2447);
                        fn position_delta(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2448);
                        fn confidence(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn time_usec(&mut self) -> i64;
                        fn time_delta_usec(&mut self) -> i64;
                        fn angle_delta(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2447);
                        fn position_delta(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2448);
                        fn confidence(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_usec().set(src.time_usec());
                        dst.time_delta_usec().set(src.time_delta_usec());
                        src.angle_delta(&mut dst.angle_delta(None));
                        src.position_delta(&mut dst.position_delta(None));
                        dst.confidence().set(src.confidence());
                    }

                    pub mod angle_delta {
                        pub const len: usize = 3usize;
                    }

                    pub mod position_delta {
                        pub const len: usize = 3usize;
                    }
                }

                /**
*A message containing logged data (see also MAV_CMD_LOGGING_START) */

                pub mod LOGGING_DATA {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::LOGGING_DATA) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn sequence(&mut self) -> crate::util_::Item__ad_hoc2054 {
                            crate::util_::Item__ad_hoc2054(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2052 {
                            crate::util_::Item__ad_hoc2052(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2053 {
                            crate::util_::Item__ad_hoc2053(self.0)
                        }
                        pub fn length(&mut self) -> crate::util_::Item__ad_hoc2055 {
                            crate::util_::Item__ad_hoc2055(self.0)
                        }
                        pub fn first_message_offset(&mut self) -> crate::util_::Item__ad_hoc2056 {
                            crate::util_::Item__ad_hoc2056(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2057 {
                            let dst = self.0;

                            let len = 249 as usize;
                            let offset = 6;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc2057 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.sequence(src.sequence().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.length(src.length().get());
                        dst.first_message_offset(src.first_message_offset().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn sequence(&mut self, src: i16);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn length(&mut self, src: i8);
                        fn first_message_offset(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2057);
                    }

                    pub trait SRC_ {
                        fn sequence(&mut self) -> i16;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn length(&mut self) -> i8;
                        fn first_message_offset(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2057);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.sequence().set(src.sequence());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.length().set(src.length());
                        dst.first_message_offset().set(src.first_message_offset());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 249usize;
                    }
                }

                /**
*Read registers for a device */

                pub mod DEVICE_OP_READ {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::DEVICE_OP_READ) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn request_id(&mut self) -> crate::util_::Item__ad_hoc2411 {
                            crate::util_::Item__ad_hoc2411(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2409 {
                            crate::util_::Item__ad_hoc2409(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2410 {
                            crate::util_::Item__ad_hoc2410(self.0)
                        }
                        pub fn bus(&mut self) -> crate::util_::Item__ad_hoc2412 {
                            crate::util_::Item__ad_hoc2412(self.0)
                        }
                        pub fn address(&mut self) -> crate::util_::Item__ad_hoc2413 {
                            crate::util_::Item__ad_hoc2413(self.0)
                        }
                        pub fn regstart(&mut self) -> crate::util_::Item__ad_hoc2415 {
                            crate::util_::Item__ad_hoc2415(self.0)
                        }
                        pub fn count(&mut self) -> crate::util_::Item__ad_hoc2416 {
                            crate::util_::Item__ad_hoc2416(self.0)
                        }
                        pub fn bustype(&mut self) -> crate::util_::Item__ad_hoc248 {
                            crate::util_::Item__ad_hoc248(self.0)
                        }
                        pub fn busname(&mut self) -> crate::util_::Item__ad_hoc2414 {
                            crate::util_::Item__ad_hoc2414(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.request_id(src.request_id().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.bus(src.bus().get());
                        dst.address(src.address().get());
                        dst.regstart(src.regstart().get());
                        dst.count(src.count().get());
                        if let Some(src) = src.bustype().get() {
                            dst.bustype(src);
                        }
                        if let Some(src) = src.busname().get() {
                            dst.busname(src);
                        }
                    }

                    pub trait DST_ {
                        fn request_id(&mut self, src: i32);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn bus(&mut self, src: i8);
                        fn address(&mut self, src: i8);
                        fn regstart(&mut self, src: i8);
                        fn count(&mut self, src: i8);
                        fn bustype(&mut self, src: packs::DEVICE_OP_BUSTYPE);
                        fn busname(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn request_id(&mut self) -> i32;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn bus(&mut self) -> i8;
                        fn address(&mut self) -> i8;
                        fn regstart(&mut self) -> i8;
                        fn count(&mut self) -> i8;
                        fn bustype(&mut self) -> Option<packs::DEVICE_OP_BUSTYPE>;
                        fn busname_item_exists_(&mut self) -> usize;
                        fn busname(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.request_id().set(src.request_id());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.bus().set(src.bus());
                        dst.address().set(src.address());
                        dst.regstart().set(src.regstart());
                        dst.count().set(src.count());
                        if let Some(src) = src.bustype() {
                            dst.bustype().set(src);
                        }
                        let len = src.busname_item_exists_();
                        if 0 < len {
                            dst.0.set_field(83, len as i32);

                            src.busname(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod busname {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*Reports progress of compass calibration. */

                pub mod MAG_CAL_PROGRESS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::MAG_CAL_PROGRESS) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn compass_id(&mut self) -> crate::util_::Item__ad_hoc2347 {
                            crate::util_::Item__ad_hoc2347(self.0)
                        }
                        pub fn cal_mask(&mut self) -> crate::util_::Item__ad_hoc2348 {
                            crate::util_::Item__ad_hoc2348(self.0)
                        }
                        pub fn attempt(&mut self) -> crate::util_::Item__ad_hoc2349 {
                            crate::util_::Item__ad_hoc2349(self.0)
                        }
                        pub fn completion_pct(&mut self) -> crate::util_::Item__ad_hoc2350 {
                            crate::util_::Item__ad_hoc2350(self.0)
                        }
                        pub fn completion_mask(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2351 {
                            let dst = &mut self.0;

                            let len = 10 as usize;
                            let offset = 4;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc2351 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn direction_x(&mut self) -> crate::util_::Item__ad_hoc2352 {
                            crate::util_::Item__ad_hoc2352(self.0)
                        }
                        pub fn direction_y(&mut self) -> crate::util_::Item__ad_hoc2353 {
                            crate::util_::Item__ad_hoc2353(self.0)
                        }
                        pub fn direction_z(&mut self) -> crate::util_::Item__ad_hoc2354 {
                            crate::util_::Item__ad_hoc2354(self.0)
                        }
                        pub fn cal_status(&mut self) -> crate::util_::Item__ad_hoc141 {
                            crate::util_::Item__ad_hoc141(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.compass_id(src.compass_id().get());
                        dst.cal_mask(src.cal_mask().get());
                        dst.attempt(src.attempt().get());
                        dst.completion_pct(src.completion_pct().get());
                        dst.completion_mask(&mut src.completion_mask(None));
                        dst.direction_x(src.direction_x().get());
                        dst.direction_y(src.direction_y().get());
                        dst.direction_z(src.direction_z().get());
                        if let Some(src) = src.cal_status().get() {
                            dst.cal_status(src);
                        }
                    }

                    pub trait DST_ {
                        fn compass_id(&mut self, src: i8);
                        fn cal_mask(&mut self, src: i8);
                        fn attempt(&mut self, src: i8);
                        fn completion_pct(&mut self, src: i8);
                        fn completion_mask(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2351);
                        fn direction_x(&mut self, src: f32);
                        fn direction_y(&mut self, src: f32);
                        fn direction_z(&mut self, src: f32);
                        fn cal_status(&mut self, src: packs::MAG_CAL_STATUS);
                    }

                    pub trait SRC_ {
                        fn compass_id(&mut self) -> i8;
                        fn cal_mask(&mut self) -> i8;
                        fn attempt(&mut self) -> i8;
                        fn completion_pct(&mut self) -> i8;
                        fn completion_mask(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2351);
                        fn direction_x(&mut self) -> f32;
                        fn direction_y(&mut self) -> f32;
                        fn direction_z(&mut self) -> f32;
                        fn cal_status(&mut self) -> Option<packs::MAG_CAL_STATUS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.compass_id().set(src.compass_id());
                        dst.cal_mask().set(src.cal_mask());
                        dst.attempt().set(src.attempt());
                        dst.completion_pct().set(src.completion_pct());
                        src.completion_mask(&mut dst.completion_mask(None));
                        dst.direction_x().set(src.direction_x());
                        dst.direction_y().set(src.direction_y());
                        dst.direction_z().set(src.direction_z());
                        if let Some(src) = src.cal_status() {
                            dst.cal_status().set(src);
                        }
                    }

                    pub mod completion_mask {
                        pub const len: usize = 10usize;
                    }
                }

                /**
*The IMU readings in SI units in NED body frame */

                pub mod HIGHRES_IMU {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::HIGHRES_IMU) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn fields_updated(&mut self) -> crate::util_::Item__ad_hoc1548 {
                            crate::util_::Item__ad_hoc1548(self.0)
                        }
                        pub fn time_usec(&mut self) -> crate::util_::Item__ad_hoc1534 {
                            crate::util_::Item__ad_hoc1534(self.0)
                        }
                        pub fn xacc(&mut self) -> crate::util_::Item__ad_hoc1535 {
                            crate::util_::Item__ad_hoc1535(self.0)
                        }
                        pub fn yacc(&mut self) -> crate::util_::Item__ad_hoc1536 {
                            crate::util_::Item__ad_hoc1536(self.0)
                        }
                        pub fn zacc(&mut self) -> crate::util_::Item__ad_hoc1537 {
                            crate::util_::Item__ad_hoc1537(self.0)
                        }
                        pub fn xgyro(&mut self) -> crate::util_::Item__ad_hoc1538 {
                            crate::util_::Item__ad_hoc1538(self.0)
                        }
                        pub fn ygyro(&mut self) -> crate::util_::Item__ad_hoc1539 {
                            crate::util_::Item__ad_hoc1539(self.0)
                        }
                        pub fn zgyro(&mut self) -> crate::util_::Item__ad_hoc1540 {
                            crate::util_::Item__ad_hoc1540(self.0)
                        }
                        pub fn xmag(&mut self) -> crate::util_::Item__ad_hoc1541 {
                            crate::util_::Item__ad_hoc1541(self.0)
                        }
                        pub fn ymag(&mut self) -> crate::util_::Item__ad_hoc1542 {
                            crate::util_::Item__ad_hoc1542(self.0)
                        }
                        pub fn zmag(&mut self) -> crate::util_::Item__ad_hoc1543 {
                            crate::util_::Item__ad_hoc1543(self.0)
                        }
                        pub fn abs_pressure(&mut self) -> crate::util_::Item__ad_hoc1544 {
                            crate::util_::Item__ad_hoc1544(self.0)
                        }
                        pub fn diff_pressure(&mut self) -> crate::util_::Item__ad_hoc1545 {
                            crate::util_::Item__ad_hoc1545(self.0)
                        }
                        pub fn pressure_alt(&mut self) -> crate::util_::Item__ad_hoc1546 {
                            crate::util_::Item__ad_hoc1546(self.0)
                        }
                        pub fn temperature(&mut self) -> crate::util_::Item__ad_hoc1547 {
                            crate::util_::Item__ad_hoc1547(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.fields_updated(src.fields_updated().get());
                        dst.time_usec(src.time_usec().get());
                        dst.xacc(src.xacc().get());
                        dst.yacc(src.yacc().get());
                        dst.zacc(src.zacc().get());
                        dst.xgyro(src.xgyro().get());
                        dst.ygyro(src.ygyro().get());
                        dst.zgyro(src.zgyro().get());
                        dst.xmag(src.xmag().get());
                        dst.ymag(src.ymag().get());
                        dst.zmag(src.zmag().get());
                        dst.abs_pressure(src.abs_pressure().get());
                        dst.diff_pressure(src.diff_pressure().get());
                        dst.pressure_alt(src.pressure_alt().get());
                        dst.temperature(src.temperature().get());
                    }

                    pub trait DST_ {
                        fn fields_updated(&mut self, src: i16);
                        fn time_usec(&mut self, src: i64);
                        fn xacc(&mut self, src: f32);
                        fn yacc(&mut self, src: f32);
                        fn zacc(&mut self, src: f32);
                        fn xgyro(&mut self, src: f32);
                        fn ygyro(&mut self, src: f32);
                        fn zgyro(&mut self, src: f32);
                        fn xmag(&mut self, src: f32);
                        fn ymag(&mut self, src: f32);
                        fn zmag(&mut self, src: f32);
                        fn abs_pressure(&mut self, src: f32);
                        fn diff_pressure(&mut self, src: f32);
                        fn pressure_alt(&mut self, src: f32);
                        fn temperature(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn fields_updated(&mut self) -> i16;
                        fn time_usec(&mut self) -> i64;
                        fn xacc(&mut self) -> f32;
                        fn yacc(&mut self) -> f32;
                        fn zacc(&mut self) -> f32;
                        fn xgyro(&mut self) -> f32;
                        fn ygyro(&mut self) -> f32;
                        fn zgyro(&mut self) -> f32;
                        fn xmag(&mut self) -> f32;
                        fn ymag(&mut self) -> f32;
                        fn zmag(&mut self) -> f32;
                        fn abs_pressure(&mut self) -> f32;
                        fn diff_pressure(&mut self) -> f32;
                        fn pressure_alt(&mut self) -> f32;
                        fn temperature(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.fields_updated().set(src.fields_updated());
                        dst.time_usec().set(src.time_usec());
                        dst.xacc().set(src.xacc());
                        dst.yacc().set(src.yacc());
                        dst.zacc().set(src.zacc());
                        dst.xgyro().set(src.xgyro());
                        dst.ygyro().set(src.ygyro());
                        dst.zgyro().set(src.zgyro());
                        dst.xmag().set(src.xmag());
                        dst.ymag().set(src.ymag());
                        dst.zmag().set(src.zmag());
                        dst.abs_pressure().set(src.abs_pressure());
                        dst.diff_pressure().set(src.diff_pressure());
                        dst.pressure_alt().set(src.pressure_alt());
                        dst.temperature().set(src.temperature());
                    }
                }

                /**
*Provides state for additional features */

                pub mod EXTENDED_SYS_STATE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::EXTENDED_SYS_STATE) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn vtol_state(&mut self) -> crate::util_::Item__ad_hoc19 {
                            crate::util_::Item__ad_hoc19(self.0)
                        }
                        pub fn landed_state(&mut self) -> crate::util_::Item__ad_hoc20 {
                            crate::util_::Item__ad_hoc20(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        if let Some(src) = src.vtol_state().get() {
                            dst.vtol_state(src);
                        }
                        if let Some(src) = src.landed_state().get() {
                            dst.landed_state(src);
                        }
                    }

                    pub trait DST_ {
                        fn vtol_state(&mut self, src: packs::MAV_VTOL_STATE);
                        fn landed_state(&mut self, src: packs::MAV_LANDED_STATE);
                    }

                    pub trait SRC_ {
                        fn vtol_state(&mut self) -> Option<packs::MAV_VTOL_STATE>;
                        fn landed_state(&mut self) -> Option<packs::MAV_LANDED_STATE>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        if let Some(src) = src.vtol_state() {
                            dst.vtol_state().set(src);
                        }
                        if let Some(src) = src.landed_state() {
                            dst.landed_state().set(src);
                        }
                    }
                }

                /**
*Dynamic data used to generate ADS-B out transponder data (send at 5Hz) */

                pub mod UAVIONIX_ADSB_OUT_DYNAMIC {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::UAVIONIX_ADSB_OUT_DYNAMIC) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn accuracyVert(&mut self) -> crate::util_::Item__ad_hoc2135 {
                            crate::util_::Item__ad_hoc2135(self.0)
                        }
                        pub fn accuracyVel(&mut self) -> crate::util_::Item__ad_hoc2136 {
                            crate::util_::Item__ad_hoc2136(self.0)
                        }
                        pub fn squawk(&mut self) -> crate::util_::Item__ad_hoc2140 {
                            crate::util_::Item__ad_hoc2140(self.0)
                        }
                        pub fn utcTime(&mut self) -> crate::util_::Item__ad_hoc2128 {
                            crate::util_::Item__ad_hoc2128(self.0)
                        }
                        pub fn accuracyHor(&mut self) -> crate::util_::Item__ad_hoc2134 {
                            crate::util_::Item__ad_hoc2134(self.0)
                        }
                        pub fn gpsLat(&mut self) -> crate::util_::Item__ad_hoc2129 {
                            crate::util_::Item__ad_hoc2129(self.0)
                        }
                        pub fn gpsLon(&mut self) -> crate::util_::Item__ad_hoc2130 {
                            crate::util_::Item__ad_hoc2130(self.0)
                        }
                        pub fn gpsAlt(&mut self) -> crate::util_::Item__ad_hoc2131 {
                            crate::util_::Item__ad_hoc2131(self.0)
                        }
                        pub fn numSats(&mut self) -> crate::util_::Item__ad_hoc2132 {
                            crate::util_::Item__ad_hoc2132(self.0)
                        }
                        pub fn baroAltMSL(&mut self) -> crate::util_::Item__ad_hoc2133 {
                            crate::util_::Item__ad_hoc2133(self.0)
                        }
                        pub fn velVert(&mut self) -> crate::util_::Item__ad_hoc2137 {
                            crate::util_::Item__ad_hoc2137(self.0)
                        }
                        pub fn velNS(&mut self) -> crate::util_::Item__ad_hoc2138 {
                            crate::util_::Item__ad_hoc2138(self.0)
                        }
                        pub fn VelEW(&mut self) -> crate::util_::Item__ad_hoc2139 {
                            crate::util_::Item__ad_hoc2139(self.0)
                        }
                        pub fn gpsFix(&mut self) -> crate::util_::Item__ad_hoc587 {
                            crate::util_::Item__ad_hoc587(self.0)
                        }
                        pub fn emergencyStatus(&mut self) -> crate::util_::Item__ad_hoc585 {
                            crate::util_::Item__ad_hoc585(self.0)
                        }
                        pub fn state(&mut self) -> crate::util_::Item__ad_hoc586 {
                            crate::util_::Item__ad_hoc586(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.accuracyVert(src.accuracyVert().get());
                        dst.accuracyVel(src.accuracyVel().get());
                        dst.squawk(src.squawk().get());
                        dst.utcTime(src.utcTime().get());
                        dst.accuracyHor(src.accuracyHor().get());
                        dst.gpsLat(src.gpsLat().get());
                        dst.gpsLon(src.gpsLon().get());
                        dst.gpsAlt(src.gpsAlt().get());
                        dst.numSats(src.numSats().get());
                        dst.baroAltMSL(src.baroAltMSL().get());
                        dst.velVert(src.velVert().get());
                        dst.velNS(src.velNS().get());
                        dst.VelEW(src.VelEW().get());
                        if let Some(src) = src.gpsFix().get() {
                            dst.gpsFix(src);
                        }
                        if let Some(src) = src.emergencyStatus().get() {
                            dst.emergencyStatus(src);
                        }
                        if let Some(src) = src.state().get() {
                            dst.state(src);
                        }
                    }

                    pub trait DST_ {
                        fn accuracyVert(&mut self, src: i16);
                        fn accuracyVel(&mut self, src: i16);
                        fn squawk(&mut self, src: i16);
                        fn utcTime(&mut self, src: i32);
                        fn accuracyHor(&mut self, src: i32);
                        fn gpsLat(&mut self, src: i32);
                        fn gpsLon(&mut self, src: i32);
                        fn gpsAlt(&mut self, src: i32);
                        fn numSats(&mut self, src: i8);
                        fn baroAltMSL(&mut self, src: i32);
                        fn velVert(&mut self, src: i16);
                        fn velNS(&mut self, src: i16);
                        fn VelEW(&mut self, src: i16);
                        fn gpsFix(&mut self, src: packs::UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX);
                        fn emergencyStatus(&mut self, src: packs::UAVIONIX_ADSB_EMERGENCY_STATUS);
                        fn state(&mut self, src: packs::UAVIONIX_ADSB_OUT_DYNAMIC_STATE);
                    }

                    pub trait SRC_ {
                        fn accuracyVert(&mut self) -> i16;
                        fn accuracyVel(&mut self) -> i16;
                        fn squawk(&mut self) -> i16;
                        fn utcTime(&mut self) -> i32;
                        fn accuracyHor(&mut self) -> i32;
                        fn gpsLat(&mut self) -> i32;
                        fn gpsLon(&mut self) -> i32;
                        fn gpsAlt(&mut self) -> i32;
                        fn numSats(&mut self) -> i8;
                        fn baroAltMSL(&mut self) -> i32;
                        fn velVert(&mut self) -> i16;
                        fn velNS(&mut self) -> i16;
                        fn VelEW(&mut self) -> i16;
                        fn gpsFix(&mut self) -> Option<packs::UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX>;
                        fn emergencyStatus(&mut self) -> Option<packs::UAVIONIX_ADSB_EMERGENCY_STATUS>;
                        fn state(&mut self) -> Option<packs::UAVIONIX_ADSB_OUT_DYNAMIC_STATE>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.accuracyVert().set(src.accuracyVert());
                        dst.accuracyVel().set(src.accuracyVel());
                        dst.squawk().set(src.squawk());
                        dst.utcTime().set(src.utcTime());
                        dst.accuracyHor().set(src.accuracyHor());
                        dst.gpsLat().set(src.gpsLat());
                        dst.gpsLon().set(src.gpsLon());
                        dst.gpsAlt().set(src.gpsAlt());
                        dst.numSats().set(src.numSats());
                        dst.baroAltMSL().set(src.baroAltMSL());
                        dst.velVert().set(src.velVert());
                        dst.velNS().set(src.velNS());
                        dst.VelEW().set(src.VelEW());
                        if let Some(src) = src.gpsFix() {
                            dst.gpsFix().set(src);
                        }
                        if let Some(src) = src.emergencyStatus() {
                            dst.emergencyStatus().set(src);
                        }
                        if let Some(src) = src.state() {
                            dst.state().set(src);
                        }
                    }
                }

                /**
*Response from a GOPRO_COMMAND get request */

                pub mod GOPRO_GET_RESPONSE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GOPRO_GET_RESPONSE) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn value(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc2403 {
                            let dst = &mut self.0;

                            let len = 4 as usize;
                            let offset = 0;
                            let bytes = dst.base.bytes;
                            let mut array = crate::util_::ItemArray__ad_hoc2403 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn cmd_id(&mut self) -> crate::util_::Item__ad_hoc426 {
                            crate::util_::Item__ad_hoc426(self.0)
                        }
                        pub fn status(&mut self) -> crate::util_::Item__ad_hoc425 {
                            crate::util_::Item__ad_hoc425(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.value(&mut src.value(None));
                        if let Some(src) = src.cmd_id().get() {
                            dst.cmd_id(src);
                        }
                        if let Some(src) = src.status().get() {
                            dst.status(src);
                        }
                    }

                    pub trait DST_ {
                        fn value(&mut self, src: &mut crate::util_::ItemArray__ad_hoc2403);
                        fn cmd_id(&mut self, src: packs::GOPRO_COMMAND);
                        fn status(&mut self, src: packs::GOPRO_REQUEST_STATUS);
                    }

                    pub trait SRC_ {
                        fn value(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc2403);
                        fn cmd_id(&mut self) -> Option<packs::GOPRO_COMMAND>;
                        fn status(&mut self) -> Option<packs::GOPRO_REQUEST_STATUS>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        src.value(&mut dst.value(None));
                        if let Some(src) = src.cmd_id() {
                            dst.cmd_id().set(src);
                        }
                        if let Some(src) = src.status() {
                            dst.status().set(src);
                        }
                    }

                    pub mod value {
                        pub const len: usize = 4usize;
                    }
                }

                /**
*data for injecting into the onboard GPS (used for DGPS) */

                pub mod GPS_INJECT_DATA {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GPS_INJECT_DATA) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc1685 {
                            crate::util_::Item__ad_hoc1685(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc1686 {
                            crate::util_::Item__ad_hoc1686(self.0)
                        }
                        pub fn len(&mut self) -> crate::util_::Item__ad_hoc1687 {
                            crate::util_::Item__ad_hoc1687(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1688 {
                            let dst = self.0;

                            let len = 110 as usize;
                            let offset = 3;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1688 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.len(src.len().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn len(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1688);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn len(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1688);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.len().set(src.len());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 110usize;
                    }
                }

                /**
*Transceiver heartbeat with health report (updated every 10s) */

                pub mod UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn rfHealth(&mut self) -> crate::util_::Item__ad_hoc377 {
                            crate::util_::Item__ad_hoc377(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        if let Some(src) = src.rfHealth().get() {
                            dst.rfHealth(src);
                        }
                    }

                    pub trait DST_ {
                        fn rfHealth(&mut self, src: packs::UAVIONIX_ADSB_RF_HEALTH);
                    }

                    pub trait SRC_ {
                        fn rfHealth(&mut self) -> Option<packs::UAVIONIX_ADSB_RF_HEALTH>;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        if let Some(src) = src.rfHealth() {
                            dst.rfHealth().set(src);
                        }
                    }
                }

                /**
*The attitude in the aeronautical frame (right-handed, Z-down, X-front, Y-right), expressed as quaternion.
*				 Quaternion order is w, x, y, z and a zero rotation would be expressed as (1 0 0 0) */

                pub mod ATTITUDE_QUATERNION_COV {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::ATTITUDE_QUATERNION_COV) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn time_usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn q(&mut self) -> crate::util_::ItemArray__ad_hoc1213 {
                            let src = self.0;

                            let len = 4 as usize;
                            let offset = 8;
                            let bytes = src;
                            crate::util_::ItemArray__ad_hoc1213 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                        pub fn rollspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 24, 4usize) as u32)
                        }
                        pub fn pitchspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 28, 4usize) as u32)
                        }
                        pub fn yawspeed(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 32, 4usize) as u32)
                        }
                        pub fn covariance(&mut self) -> crate::util_::ItemArray__ad_hoc1217 {
                            let src = self.0;

                            let len = 9 as usize;
                            let offset = 36;
                            let bytes = src;
                            crate::util_::ItemArray__ad_hoc1217 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            }
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_usec(src.time_usec());
                        dst.q(&mut src.q());
                        dst.rollspeed(src.rollspeed());
                        dst.pitchspeed(src.pitchspeed());
                        dst.yawspeed(src.yawspeed());
                        dst.covariance(&mut src.covariance());
                    }

                    pub trait DST_ {
                        fn time_usec(&mut self, src: i64);
                        fn q(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1213);
                        fn rollspeed(&mut self, src: f32);
                        fn pitchspeed(&mut self, src: f32);
                        fn yawspeed(&mut self, src: f32);
                        fn covariance(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1217);
                    }

                    pub mod q {
                        pub const len: usize = 4usize;
                    }

                    pub mod covariance {
                        pub const len: usize = 9usize;
                    }
                }

                /**
*Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite
*				 efficient way for testing new messages and getting experimental debug output */

                pub mod NAMED_VALUE_INT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::NAMED_VALUE_INT) };

                    pub struct Data_<'a>(pub &'a mut sys::Cursor);

                    impl<'a> Data_<'a> {
                        pub fn time_boot_ms(&mut self) -> crate::util_::Item__ad_hoc1988 {
                            crate::util_::Item__ad_hoc1988(self.0)
                        }
                        pub fn value(&mut self) -> crate::util_::Item__ad_hoc1990 {
                            crate::util_::Item__ad_hoc1990(self.0)
                        }
                        pub fn name(&mut self) -> crate::util_::Item__ad_hoc1989 {
                            crate::util_::Item__ad_hoc1989(self.0)
                        }
                    }

                    impl<'a> crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Data_<'a> {
                        fn pack(mut self) -> *mut sys::Pack {
                            let pack = self.0.base.pack;
                            self.0.base.pack = ::std::ptr::null_mut();
                            self.0.base.meta = ::std::ptr::null_mut();
                            self.0.base.bytes = ::std::ptr::null_mut();
                            pack
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.time_boot_ms(src.time_boot_ms().get());
                        dst.value(src.value().get());
                        if let Some(src) = src.name().get() {
                            dst.name(src);
                        }
                    }

                    pub trait DST_ {
                        fn time_boot_ms(&mut self, src: i32);
                        fn value(&mut self, src: i32);
                        fn name(&mut self, src: &str);
                    }

                    pub trait SRC_ {
                        fn time_boot_ms(&mut self) -> i32;
                        fn value(&mut self) -> i32;
                        fn name_item_exists_(&mut self) -> usize;
                        fn name(&mut self, dst: &mut [u8]);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.time_boot_ms().set(src.time_boot_ms());
                        dst.value().set(src.value());
                        let len = src.name_item_exists_();
                        if 0 < len {
                            dst.0.set_field(66, len as i32);

                            src.name(unsafe { dst.0.get_str().as_bytes_mut() });
                        }
                    }

                    pub mod name {
                        pub const len_max: usize = 255usize;
                    }
                }

                /**
*RPM sensor output */

                pub mod RPM {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RPM) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn rpm1(&mut self) -> crate::util_::Item__ad_hoc2407 {
                            crate::util_::Item__ad_hoc2407(self.0)
                        }
                        pub fn rpm2(&mut self) -> crate::util_::Item__ad_hoc2408 {
                            crate::util_::Item__ad_hoc2408(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.rpm1(src.rpm1().get());
                        dst.rpm2(src.rpm2().get());
                    }

                    pub trait DST_ {
                        fn rpm1(&mut self, src: f32);
                        fn rpm2(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn rpm1(&mut self) -> f32;
                        fn rpm2(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.rpm1().set(src.rpm1());
                        dst.rpm2().set(src.rpm2());
                    }
                }

                /**
*RTCM message for injecting into the onboard GPS (used for DGPS) */

                pub mod GPS_RTCM_DATA {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GPS_RTCM_DATA) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn flags(&mut self) -> crate::util_::Item__ad_hoc1901 {
                            crate::util_::Item__ad_hoc1901(self.0)
                        }
                        pub fn len(&mut self) -> crate::util_::Item__ad_hoc1902 {
                            crate::util_::Item__ad_hoc1902(self.0)
                        }
                        pub fn daTa(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1903 {
                            let dst = self.0;

                            let len = 180 as usize;
                            let offset = 2;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1903 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.flags(src.flags().get());
                        dst.len(src.len().get());
                        dst.daTa(&mut src.daTa(None));
                    }

                    pub trait DST_ {
                        fn flags(&mut self, src: i8);
                        fn len(&mut self, src: i8);
                        fn daTa(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1903);
                    }

                    pub trait SRC_ {
                        fn flags(&mut self) -> i8;
                        fn len(&mut self) -> i8;
                        fn daTa(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1903);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.flags().set(src.flags());
                        dst.len().set(src.len());
                        src.daTa(&mut dst.daTa(None));
                    }

                    pub mod daTa {
                        pub const len: usize = 180usize;
                    }
                }

                pub mod GLOBAL_VISION_POSITION_ESTIMATE {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::GLOBAL_VISION_POSITION_ESTIMATE) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn usec(&mut self) -> i64 {
                            let src = &mut self.0;
                            let dst = sys::get_bytes(self.0, 0, 8 as usize) as i64;
                            (dst) as i64
                        }
                        pub fn x(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 8, 4usize) as u32)
                        }
                        pub fn y(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 12, 4usize) as u32)
                        }
                        pub fn z(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 16, 4usize) as u32)
                        }
                        pub fn roll(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 20, 4usize) as u32)
                        }
                        pub fn pitch(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 24, 4usize) as u32)
                        }
                        pub fn yaw(&mut self) -> f32 {
                            let src = &mut self.0;
                            f32::from_bits(sys::get_bytes(self.0, 28, 4usize) as u32)
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.usec(src.usec());
                        dst.x(src.x());
                        dst.y(src.y());
                        dst.z(src.z());
                        dst.roll(src.roll());
                        dst.pitch(src.pitch());
                        dst.yaw(src.yaw());
                    }

                    pub trait DST_ {
                        fn usec(&mut self, src: i64);
                        fn x(&mut self, src: f32);
                        fn y(&mut self, src: f32);
                        fn z(&mut self, src: f32);
                        fn roll(&mut self, src: f32);
                        fn pitch(&mut self, src: f32);
                        fn yaw(&mut self, src: f32);
                    }
                }

                /**
*File transfer message */

                pub mod FILE_TRANSFER_PROTOCOL {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::FILE_TRANSFER_PROTOCOL) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_network(&mut self) -> crate::util_::Item__ad_hoc1604 {
                            crate::util_::Item__ad_hoc1604(self.0)
                        }
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc1605 {
                            crate::util_::Item__ad_hoc1605(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc1606 {
                            crate::util_::Item__ad_hoc1606(self.0)
                        }
                        pub fn payload(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1607 {
                            let dst = self.0;

                            let len = 251 as usize;
                            let offset = 3;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1607 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_network(src.target_network().get());
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.payload(&mut src.payload(None));
                    }

                    pub trait DST_ {
                        fn target_network(&mut self, src: i8);
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn payload(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1607);
                    }

                    pub trait SRC_ {
                        fn target_network(&mut self) -> i8;
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn payload(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1607);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_network().set(src.target_network());
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        src.payload(&mut dst.payload(None));
                    }

                    pub mod payload {
                        pub const len: usize = 251usize;
                    }
                }

                /**
*Rangefinder reporting */

                pub mod RANGEFINDER {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RANGEFINDER) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn distance(&mut self) -> crate::util_::Item__ad_hoc2263 {
                            crate::util_::Item__ad_hoc2263(self.0)
                        }
                        pub fn voltage(&mut self) -> crate::util_::Item__ad_hoc2264 {
                            crate::util_::Item__ad_hoc2264(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.distance(src.distance().get());
                        dst.voltage(src.voltage().get());
                    }

                    pub trait DST_ {
                        fn distance(&mut self, src: f32);
                        fn voltage(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn distance(&mut self) -> f32;
                        fn voltage(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.distance().set(src.distance());
                        dst.voltage().set(src.voltage());
                    }
                }

                /**
*Status generated by radio and injected into MAVLink stream. */

                pub mod RADIO_STATUS {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RADIO_STATUS) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn rxerrors(&mut self) -> crate::util_::Item__ad_hoc1602 {
                            crate::util_::Item__ad_hoc1602(self.0)
                        }
                        pub fn fixeD(&mut self) -> crate::util_::Item__ad_hoc1603 {
                            crate::util_::Item__ad_hoc1603(self.0)
                        }
                        pub fn rssi(&mut self) -> crate::util_::Item__ad_hoc1597 {
                            crate::util_::Item__ad_hoc1597(self.0)
                        }
                        pub fn remrssi(&mut self) -> crate::util_::Item__ad_hoc1598 {
                            crate::util_::Item__ad_hoc1598(self.0)
                        }
                        pub fn txbuf(&mut self) -> crate::util_::Item__ad_hoc1599 {
                            crate::util_::Item__ad_hoc1599(self.0)
                        }
                        pub fn noise(&mut self) -> crate::util_::Item__ad_hoc1600 {
                            crate::util_::Item__ad_hoc1600(self.0)
                        }
                        pub fn remnoise(&mut self) -> crate::util_::Item__ad_hoc1601 {
                            crate::util_::Item__ad_hoc1601(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.rxerrors(src.rxerrors().get());
                        dst.fixeD(src.fixeD().get());
                        dst.rssi(src.rssi().get());
                        dst.remrssi(src.remrssi().get());
                        dst.txbuf(src.txbuf().get());
                        dst.noise(src.noise().get());
                        dst.remnoise(src.remnoise().get());
                    }

                    pub trait DST_ {
                        fn rxerrors(&mut self, src: i16);
                        fn fixeD(&mut self, src: i16);
                        fn rssi(&mut self, src: i8);
                        fn remrssi(&mut self, src: i8);
                        fn txbuf(&mut self, src: i8);
                        fn noise(&mut self, src: i8);
                        fn remnoise(&mut self, src: i8);
                    }

                    pub trait SRC_ {
                        fn rxerrors(&mut self) -> i16;
                        fn fixeD(&mut self) -> i16;
                        fn rssi(&mut self) -> i8;
                        fn remrssi(&mut self) -> i8;
                        fn txbuf(&mut self) -> i8;
                        fn noise(&mut self) -> i8;
                        fn remnoise(&mut self) -> i8;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.rxerrors().set(src.rxerrors());
                        dst.fixeD().set(src.fixeD());
                        dst.rssi().set(src.rssi());
                        dst.remrssi().set(src.remrssi());
                        dst.txbuf().set(src.txbuf());
                        dst.noise().set(src.noise());
                        dst.remnoise().set(src.remnoise());
                    }
                }

                /**
*GCS */

                pub mod FENCE_POINT {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::FENCE_POINT) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn target_system(&mut self) -> crate::util_::Item__ad_hoc2204 {
                            crate::util_::Item__ad_hoc2204(self.0)
                        }
                        pub fn target_component(&mut self) -> crate::util_::Item__ad_hoc2205 {
                            crate::util_::Item__ad_hoc2205(self.0)
                        }
                        pub fn idx(&mut self) -> crate::util_::Item__ad_hoc2206 {
                            crate::util_::Item__ad_hoc2206(self.0)
                        }
                        pub fn count(&mut self) -> crate::util_::Item__ad_hoc2207 {
                            crate::util_::Item__ad_hoc2207(self.0)
                        }
                        pub fn lat(&mut self) -> crate::util_::Item__ad_hoc2208 {
                            crate::util_::Item__ad_hoc2208(self.0)
                        }
                        pub fn lng(&mut self) -> crate::util_::Item__ad_hoc2209 {
                            crate::util_::Item__ad_hoc2209(self.0)
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.target_system(src.target_system().get());
                        dst.target_component(src.target_component().get());
                        dst.idx(src.idx().get());
                        dst.count(src.count().get());
                        dst.lat(src.lat().get());
                        dst.lng(src.lng().get());
                    }

                    pub trait DST_ {
                        fn target_system(&mut self, src: i8);
                        fn target_component(&mut self, src: i8);
                        fn idx(&mut self, src: i8);
                        fn count(&mut self, src: i8);
                        fn lat(&mut self, src: f32);
                        fn lng(&mut self, src: f32);
                    }

                    pub trait SRC_ {
                        fn target_system(&mut self) -> i8;
                        fn target_component(&mut self) -> i8;
                        fn idx(&mut self) -> i8;
                        fn count(&mut self) -> i8;
                        fn lat(&mut self) -> f32;
                        fn lng(&mut self) -> f32;
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.target_system().set(src.target_system());
                        dst.target_component().set(src.target_component());
                        dst.idx().set(src.idx());
                        dst.count().set(src.count());
                        dst.lat().set(src.lat());
                        dst.lng().set(src.lng());
                    }
                }

                /**
*The autopilot is requesting a resource (file, binary, other type of data) */

                pub mod RESOURCE_REQUEST {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    pub static meta_: &sys::Meta = unsafe { ::std::mem::transmute(&crate::util_::RESOURCE_REQUEST) };

                    pub struct Pack_(pub *mut sys::Pack);

                    impl Pack_ {
                        pub fn data(&self) -> Data_ {
                            Data_(unsafe { (*self.0).bytes.as_mut_ptr() })
                        }
                    }

                    pub struct Data_(pub *mut u8);

                    impl Data_ {
                        pub fn request_id(&mut self) -> crate::util_::Item__ad_hoc1799 {
                            crate::util_::Item__ad_hoc1799(self.0)
                        }
                        pub fn uri_type(&mut self) -> crate::util_::Item__ad_hoc1800 {
                            crate::util_::Item__ad_hoc1800(self.0)
                        }
                        pub fn uri(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1801 {
                            let dst = self.0;

                            let len = 120 as usize;
                            let offset = 2;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1801 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                        pub fn transfer_type(&mut self) -> crate::util_::Item__ad_hoc1802 {
                            crate::util_::Item__ad_hoc1802(self.0)
                        }
                        pub fn storage(&mut self, src: Option<&mut dyn Iterator<Item=i8>>) -> crate::util_::ItemArray__ad_hoc1803 {
                            let dst = self.0;

                            let len = 120 as usize;
                            let offset = 123;
                            let bytes = dst;
                            let mut array = crate::util_::ItemArray__ad_hoc1803 {
                                bytes,
                                len,
                                offset,
                                index: !0,
                            };
                            if let Some(src) = src {
                                for i in 0..len {
                                    if let Some(val) = src.next() {
                                        array.set(i, val);
                                    } else { break; }
                                }
                            }
                            array
                        }
                    }

                    impl crate::com::company::demo::CommunicationChannel::ITransmittable::Pack for Pack_ {
                        fn pack(self) -> *mut sys::Pack {
                            self.0
                        }
                    }


                    pub fn push_<DST: DST_>(src: &mut Data_, dst: &mut DST)
                    {
                        dst.request_id(src.request_id().get());
                        dst.uri_type(src.uri_type().get());
                        dst.uri(&mut src.uri(None));
                        dst.transfer_type(src.transfer_type().get());
                        dst.storage(&mut src.storage(None));
                    }

                    pub trait DST_ {
                        fn request_id(&mut self, src: i8);
                        fn uri_type(&mut self, src: i8);
                        fn uri(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1801);
                        fn transfer_type(&mut self, src: i8);
                        fn storage(&mut self, src: &mut crate::util_::ItemArray__ad_hoc1803);
                    }

                    pub trait SRC_ {
                        fn request_id(&mut self) -> i8;
                        fn uri_type(&mut self) -> i8;
                        fn uri(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1801);
                        fn transfer_type(&mut self) -> i8;
                        fn storage(&mut self, dst: &mut crate::util_::ItemArray__ad_hoc1803);
                    }

                    pub fn pull_<SRC: SRC_>(src: &mut SRC, dst: &mut Data_)
                    {
                        dst.request_id().set(src.request_id());
                        dst.uri_type().set(src.uri_type());
                        src.uri(&mut dst.uri(None));
                        dst.transfer_type().set(src.transfer_type());
                        src.storage(&mut dst.storage(None));
                    }

                    pub mod uri {
                        pub const len: usize = 120usize;
                    }

                    pub mod storage {
                        pub const len: usize = 120usize;
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum PID_TUNING_AXIS {
                    PID_TUNING_ROLL = 1,
                    PID_TUNING_PITCH = 2,
                    PID_TUNING_YAW = 3,
                    PID_TUNING_ACCZ = 4,
                    PID_TUNING_STEER = 5,
                    PID_TUNING_LANDING = 6,
                }

                impl PID_TUNING_AXIS {
                    pub fn from_bits(src: i8) -> Option<PID_TUNING_AXIS> {
                        match src
                        {
                            1 => Some(PID_TUNING_AXIS::PID_TUNING_ROLL),
                            2 => Some(PID_TUNING_AXIS::PID_TUNING_PITCH),
                            3 => Some(PID_TUNING_AXIS::PID_TUNING_YAW),
                            4 => Some(PID_TUNING_AXIS::PID_TUNING_ACCZ),
                            5 => Some(PID_TUNING_AXIS::PID_TUNING_STEER),
                            6 => Some(PID_TUNING_AXIS::PID_TUNING_LANDING),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Flags in EKF_STATUS message */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum ESTIMATOR_STATUS_FLAGS {
                    ESTIMATOR_ATTITUDE = 1,
                    //True if the attitude estimate is good
                    ESTIMATOR_VELOCITY_HORIZ = 2,
                    //True if the horizontal velocity estimate is good
                    ESTIMATOR_VELOCITY_VERT = 4,
                    //True if the  vertical velocity estimate is good
                    ESTIMATOR_POS_HORIZ_REL = 8,
                    //True if the horizontal position (relative) estimate is good
                    ESTIMATOR_POS_HORIZ_ABS = 16,
                    //True if the horizontal position (absolute) estimate is good
                    ESTIMATOR_POS_VERT_ABS = 32,
                    //True if the vertical position (absolute) estimate is good
                    ESTIMATOR_POS_VERT_AGL = 64,
                    //True if the vertical position (above ground) estimate is good
                    /**
*True if the EKF is in a constant position mode and is not using external measurements (eg GPS or optical
*			 flow */
                    ESTIMATOR_CONST_POS_MODE = 128,
                    ESTIMATOR_PRED_POS_HORIZ_REL = 256,
                    //True if the EKF has sufficient data to enter a mode that will provide a (relative) position estimat
                    ESTIMATOR_PRED_POS_HORIZ_ABS = 512,
                    //True if the EKF has sufficient data to enter a mode that will provide a (absolute) position estimat
                    ESTIMATOR_GPS_GLITCH = 1024,//True if the EKF has detected a GPS glitch
                }

                impl ESTIMATOR_STATUS_FLAGS {
                    pub fn from_bits(src: i32) -> Option<ESTIMATOR_STATUS_FLAGS> {
                        match src
                        {
                            0 => {
                                return Some(ESTIMATOR_STATUS_FLAGS::ESTIMATOR_ATTITUDE);
                            }
                            1 => {
                                return Some(ESTIMATOR_STATUS_FLAGS::ESTIMATOR_VELOCITY_HORIZ);
                            }
                            2 => {
                                return Some(ESTIMATOR_STATUS_FLAGS::ESTIMATOR_VELOCITY_VERT);
                            }
                            3 => {
                                return Some(ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_HORIZ_REL);
                            }
                            4 => {
                                return Some(ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_HORIZ_ABS);
                            }
                            5 => {
                                return Some(ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_VERT_ABS);
                            }
                            6 => {
                                return Some(ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_VERT_AGL);
                            }
                            7 => {
                                return Some(ESTIMATOR_STATUS_FLAGS::ESTIMATOR_CONST_POS_MODE);
                            }
                            8 => {
                                return Some(ESTIMATOR_STATUS_FLAGS::ESTIMATOR_PRED_POS_HORIZ_REL);
                            }
                            9 => {
                                return Some(ESTIMATOR_STATUS_FLAGS::ESTIMATOR_PRED_POS_HORIZ_ABS);
                            }
                            10 => {
                                return Some(ESTIMATOR_STATUS_FLAGS::ESTIMATOR_GPS_GLITCH);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            ESTIMATOR_STATUS_FLAGS::ESTIMATOR_ATTITUDE => {
                                return 0;
                            }
                            ESTIMATOR_STATUS_FLAGS::ESTIMATOR_VELOCITY_HORIZ => {
                                return 1;
                            }
                            ESTIMATOR_STATUS_FLAGS::ESTIMATOR_VELOCITY_VERT => {
                                return 2;
                            }
                            ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_HORIZ_REL => {
                                return 3;
                            }
                            ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_HORIZ_ABS => {
                                return 4;
                            }
                            ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_VERT_ABS => {
                                return 5;
                            }
                            ESTIMATOR_STATUS_FLAGS::ESTIMATOR_POS_VERT_AGL => {
                                return 6;
                            }
                            ESTIMATOR_STATUS_FLAGS::ESTIMATOR_CONST_POS_MODE => {
                                return 7;
                            }
                            ESTIMATOR_STATUS_FLAGS::ESTIMATOR_PRED_POS_HORIZ_REL => {
                                return 8;
                            }
                            ESTIMATOR_STATUS_FLAGS::ESTIMATOR_PRED_POS_HORIZ_ABS => {
                                return 9;
                            }
                            ESTIMATOR_STATUS_FLAGS::ESTIMATOR_GPS_GLITCH => {
                                return 10;
                            }
                        }
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_TYPE {
                    GENERIC = 0,
                    //Generic micro air vehicle.
                    FIXED_WING = 1,
                    //Fixed wing aircraft.
                    QUADROTOR = 2,
                    //Quadrotor
                    COAXIAL = 3,
                    //Coaxial helicopter
                    HELICOPTER = 4,
                    //Normal helicopter with tail rotor.
                    ANTENNA_TRACKER = 5,
                    //Ground installation
                    GCS = 6,
                    //Operator control unit / ground control station
                    AIRSHIP = 7,
                    //Airship, controlled
                    FREE_BALLOON = 8,
                    //Free balloon, uncontrolled
                    ROCKET = 9,
                    //Rocket
                    GROUND_ROVER = 10,
                    //Ground rover
                    SURFACE_BOAT = 11,
                    //Surface vessel, boat, ship
                    SUBMARINE = 12,
                    //Submarine
                    HEXAROTOR = 13,
                    //Hexarotor
                    OCTOROTOR = 14,
                    //Octorotor
                    TRICOPTER = 15,
                    //Tricopter
                    FLAPPING_WING = 16,
                    //Flapping wing
                    KITE = 17,
                    //Kite
                    ONBOARD_CONTROLLER = 18,
                    //Onboard companion controller
                    VTOL_DUOROTOR = 19,
                    //Two-rotor VTOL using control surfaces in vertical operation in addition. Tailsitter.
                    VTOL_QUADROTOR = 20,
                    //Quad-rotor VTOL using a V-shaped quad config in vertical operation. Tailsitter.
                    VTOL_TILTROTOR = 21,
                    //Tiltrotor VTOL
                    VTOL_RESERVED2 = 22,
                    //VTOL reserved 2
                    VTOL_RESERVED3 = 23,
                    //VTOL reserved 3
                    VTOL_RESERVED4 = 24,
                    //VTOL reserved 4
                    VTOL_RESERVED5 = 25,
                    //VTOL reserved 5
                    GIMBAL = 26,
                    //Onboard gimbal
                    ADSB = 27,
                    //Onboard ADSB peripheral
                    PARAFOIL = 28,//Steerable, nonrigid airfoil
                }

                impl MAV_TYPE {
                    pub fn from_bits(src: i8) -> Option<MAV_TYPE> {
                        match src
                        {
                            0 => Some(MAV_TYPE::GENERIC),
                            1 => Some(MAV_TYPE::FIXED_WING),
                            2 => Some(MAV_TYPE::QUADROTOR),
                            3 => Some(MAV_TYPE::COAXIAL),
                            4 => Some(MAV_TYPE::HELICOPTER),
                            5 => Some(MAV_TYPE::ANTENNA_TRACKER),
                            6 => Some(MAV_TYPE::GCS),
                            7 => Some(MAV_TYPE::AIRSHIP),
                            8 => Some(MAV_TYPE::FREE_BALLOON),
                            9 => Some(MAV_TYPE::ROCKET),
                            10 => Some(MAV_TYPE::GROUND_ROVER),
                            11 => Some(MAV_TYPE::SURFACE_BOAT),
                            12 => Some(MAV_TYPE::SUBMARINE),
                            13 => Some(MAV_TYPE::HEXAROTOR),
                            14 => Some(MAV_TYPE::OCTOROTOR),
                            15 => Some(MAV_TYPE::TRICOPTER),
                            16 => Some(MAV_TYPE::FLAPPING_WING),
                            17 => Some(MAV_TYPE::KITE),
                            18 => Some(MAV_TYPE::ONBOARD_CONTROLLER),
                            19 => Some(MAV_TYPE::VTOL_DUOROTOR),
                            20 => Some(MAV_TYPE::VTOL_QUADROTOR),
                            21 => Some(MAV_TYPE::VTOL_TILTROTOR),
                            22 => Some(MAV_TYPE::VTOL_RESERVED2),
                            23 => Some(MAV_TYPE::VTOL_RESERVED3),
                            24 => Some(MAV_TYPE::VTOL_RESERVED4),
                            25 => Some(MAV_TYPE::VTOL_RESERVED5),
                            26 => Some(MAV_TYPE::GIMBAL),
                            27 => Some(MAV_TYPE::ADSB),
                            28 => Some(MAV_TYPE::PARAFOIL),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum GOPRO_CAPTURE_MODE {
                    GOPRO_CAPTURE_MODE_VIDEO = 0,
                    //Video mode
                    GOPRO_CAPTURE_MODE_PHOTO = 1,
                    //Photo mode
                    GOPRO_CAPTURE_MODE_BURST = 2,
                    //Burst mode, hero 3+ only
                    GOPRO_CAPTURE_MODE_TIME_LAPSE = 3,
                    //Time lapse mode, hero 3+ only
                    GOPRO_CAPTURE_MODE_MULTI_SHOT = 4,
                    //Multi shot mode, hero 4 only
                    GOPRO_CAPTURE_MODE_PLAYBACK = 5,
                    //Playback mode, hero 4 only, silver only except when LCD or HDMI is connected to black
                    GOPRO_CAPTURE_MODE_SETUP = 6,
                    //Playback mode, hero 4 only
                    GOPRO_CAPTURE_MODE_UNKNOWN = 255,//Mode not yet known
                }

                impl GOPRO_CAPTURE_MODE {
                    pub fn from_bits(src: i32) -> Option<GOPRO_CAPTURE_MODE> {
                        match src
                        {
                            0 => {
                                return Some(GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_VIDEO);
                            }
                            1 => {
                                return Some(GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_PHOTO);
                            }
                            2 => {
                                return Some(GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_BURST);
                            }
                            3 => {
                                return Some(GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_TIME_LAPSE);
                            }
                            4 => {
                                return Some(GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_MULTI_SHOT);
                            }
                            5 => {
                                return Some(GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_PLAYBACK);
                            }
                            6 => {
                                return Some(GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_SETUP);
                            }
                            7 => {
                                return Some(GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_UNKNOWN);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_VIDEO => {
                                return 0;
                            }
                            GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_PHOTO => {
                                return 1;
                            }
                            GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_BURST => {
                                return 2;
                            }
                            GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_TIME_LAPSE => {
                                return 3;
                            }
                            GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_MULTI_SHOT => {
                                return 4;
                            }
                            GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_PLAYBACK => {
                                return 5;
                            }
                            GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_SETUP => {
                                return 6;
                            }
                            GOPRO_CAPTURE_MODE::GOPRO_CAPTURE_MODE_UNKNOWN => {
                                return 7;
                            }
                        }
                    }
                }

                /**
*Micro air vehicle / autopilot classes. This identifies the individual model. */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_AUTOPILOT {
                    GENERIC = 0,
                    //Generic autopilot, full support for everything
                    RESERVED = 1,
                    //Reserved for future use.
                    SLUGS = 2,
                    //SLUGS autopilot, http:slugsuav.soe.ucsc.edu
                    ARDUPILOTMEGA = 3,
                    //ArduPilotMega / ArduCopter, http:diydrones.com
                    OPENPILOT = 4,
                    //OpenPilot, http:openpilot.org
                    GENERIC_WAYPOINTS_ONLY = 5,
                    //Generic autopilot only supporting simple waypoints
                    GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY = 6,
                    //Generic autopilot supporting waypoints and other simple navigation commands
                    GENERIC_MISSION_FULL = 7,
                    //Generic autopilot supporting the full mission command set
                    INVALID = 8,
                    //No valid autopilot, e.g. a GCS or other MAVLink component
                    PPZ = 9,
                    //PPZ UAV - http:nongnu.org/paparazzi
                    UDB = 10,
                    //UAV Dev Board
                    FP = 11,
                    //FlexiPilot
                    PX4 = 12,
                    //PX4 Autopilot - http:pixhawk.ethz.ch/px4/
                    SMACCMPILOT = 13,
                    //SMACCMPilot - http:smaccmpilot.org
                    AUTOQUAD = 14,
                    //AutoQuad -- http:autoquad.org
                    ARMAZILA = 15,
                    //Armazila -- http:armazila.com
                    AEROB = 16,
                    //Aerob -- http:aerob.ru
                    ASLUAV = 17,
                    //ASLUAV autopilot -- http:www.asl.ethz.ch
                    SMARTAP = 18,//SmartAP Autopilot - http:sky-drones.com
                }

                impl MAV_AUTOPILOT {
                    pub fn from_bits(src: i8) -> Option<MAV_AUTOPILOT> {
                        match src
                        {
                            0 => Some(MAV_AUTOPILOT::GENERIC),
                            1 => Some(MAV_AUTOPILOT::RESERVED),
                            2 => Some(MAV_AUTOPILOT::SLUGS),
                            3 => Some(MAV_AUTOPILOT::ARDUPILOTMEGA),
                            4 => Some(MAV_AUTOPILOT::OPENPILOT),
                            5 => Some(MAV_AUTOPILOT::GENERIC_WAYPOINTS_ONLY),
                            6 => Some(MAV_AUTOPILOT::GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY),
                            7 => Some(MAV_AUTOPILOT::GENERIC_MISSION_FULL),
                            8 => Some(MAV_AUTOPILOT::INVALID),
                            9 => Some(MAV_AUTOPILOT::PPZ),
                            10 => Some(MAV_AUTOPILOT::UDB),
                            11 => Some(MAV_AUTOPILOT::FP),
                            12 => Some(MAV_AUTOPILOT::PX4),
                            13 => Some(MAV_AUTOPILOT::SMACCMPILOT),
                            14 => Some(MAV_AUTOPILOT::AUTOQUAD),
                            15 => Some(MAV_AUTOPILOT::ARMAZILA),
                            16 => Some(MAV_AUTOPILOT::AEROB),
                            17 => Some(MAV_AUTOPILOT::ASLUAV),
                            18 => Some(MAV_AUTOPILOT::SMARTAP),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Enumeration of battery functions */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_BATTERY_FUNCTION {
                    MAV_BATTERY_FUNCTION_UNKNOWN = 0,
                    //Battery function is unknown
                    MAV_BATTERY_FUNCTION_ALL = 1,
                    //Battery supports all flight systems
                    MAV_BATTERY_FUNCTION_PROPULSION = 2,
                    //Battery for the propulsion system
                    MAV_BATTERY_FUNCTION_AVIONICS = 3,
                    //Avionics battery
                    MAV_BATTERY_TYPE_PAYLOAD = 4,//Payload battery
                }

                impl MAV_BATTERY_FUNCTION {
                    pub fn from_bits(src: i8) -> Option<MAV_BATTERY_FUNCTION> {
                        match src
                        {
                            0 => Some(MAV_BATTERY_FUNCTION::MAV_BATTERY_FUNCTION_UNKNOWN),
                            1 => Some(MAV_BATTERY_FUNCTION::MAV_BATTERY_FUNCTION_ALL),
                            2 => Some(MAV_BATTERY_FUNCTION::MAV_BATTERY_FUNCTION_PROPULSION),
                            3 => Some(MAV_BATTERY_FUNCTION::MAV_BATTERY_FUNCTION_AVIONICS),
                            4 => Some(MAV_BATTERY_FUNCTION::MAV_BATTERY_TYPE_PAYLOAD),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Type of landing target */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum LANDING_TARGET_TYPE {
                    LANDING_TARGET_TYPE_LIGHT_BEACON = 0,
                    //Landing target signaled by light beacon (ex: IR-LOCK)
                    LANDING_TARGET_TYPE_RADIO_BEACON = 1,
                    //Landing target signaled by radio beacon (ex: ILS, NDB)
                    LANDING_TARGET_TYPE_VISION_FIDUCIAL = 2,
                    //Landing target represented by a fiducial marker (ex: ARTag)
                    LANDING_TARGET_TYPE_VISION_OTHER = 3,//Landing target represented by a pre-defined visual shape/feature (ex: X-marker, H-marker, square)
                }

                impl LANDING_TARGET_TYPE {
                    pub fn from_bits(src: i8) -> Option<LANDING_TARGET_TYPE> {
                        match src
                        {
                            0 => Some(LANDING_TARGET_TYPE::LANDING_TARGET_TYPE_LIGHT_BEACON),
                            1 => Some(LANDING_TARGET_TYPE::LANDING_TARGET_TYPE_RADIO_BEACON),
                            2 => Some(LANDING_TARGET_TYPE::LANDING_TARGET_TYPE_VISION_FIDUCIAL),
                            3 => Some(LANDING_TARGET_TYPE::LANDING_TARGET_TYPE_VISION_OTHER),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum LIMIT_MODULE {
                    LIMIT_GPSLOCK = 1,
                    //pre-initialization
                    LIMIT_GEOFENCE = 2,
                    //disabled
                    LIMIT_ALTITUDE = 4,//checking limits
                }

                impl LIMIT_MODULE {
                    pub fn from_bits(src: i32) -> Option<LIMIT_MODULE> {
                        match src
                        {
                            0 => {
                                return Some(LIMIT_MODULE::LIMIT_GPSLOCK);
                            }
                            1 => {
                                return Some(LIMIT_MODULE::LIMIT_GEOFENCE);
                            }
                            2 => {
                                return Some(LIMIT_MODULE::LIMIT_ALTITUDE);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            LIMIT_MODULE::LIMIT_GPSLOCK => {
                                return 0;
                            }
                            LIMIT_MODULE::LIMIT_GEOFENCE => {
                                return 1;
                            }
                            LIMIT_MODULE::LIMIT_ALTITUDE => {
                                return 2;
                            }
                        }
                    }
                }

                /**
*Enumeration of landed detector states */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_LANDED_STATE {
                    MAV_LANDED_STATE_UNDEFINED = 0,
                    //MAV landed state is unknown
                    MAV_LANDED_STATE_ON_GROUND = 1,
                    //MAV is landed (on ground)
                    MAV_LANDED_STATE_IN_AIR = 2,
                    //MAV is in air
                    MAV_LANDED_STATE_TAKEOFF = 3,
                    //MAV currently taking off
                    MAV_LANDED_STATE_LANDING = 4,//MAV currently landing
                }

                impl MAV_LANDED_STATE {
                    pub fn from_bits(src: i8) -> Option<MAV_LANDED_STATE> {
                        match src
                        {
                            0 => Some(MAV_LANDED_STATE::MAV_LANDED_STATE_UNDEFINED),
                            1 => Some(MAV_LANDED_STATE::MAV_LANDED_STATE_ON_GROUND),
                            2 => Some(MAV_LANDED_STATE::MAV_LANDED_STATE_IN_AIR),
                            3 => Some(MAV_LANDED_STATE::MAV_LANDED_STATE_TAKEOFF),
                            4 => Some(MAV_LANDED_STATE::MAV_LANDED_STATE_LANDING),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Specifies the datatype of a MAVLink parameter. */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_PARAM_TYPE {
                    MAV_PARAM_TYPE_UINT8 = 1,
                    //8-bit unsigned integer
                    MAV_PARAM_TYPE_INT8 = 2,
                    //8-bit signed integer
                    MAV_PARAM_TYPE_UINT16 = 3,
                    //16-bit unsigned integer
                    MAV_PARAM_TYPE_INT16 = 4,
                    //16-bit signed integer
                    MAV_PARAM_TYPE_UINT32 = 5,
                    //32-bit unsigned integer
                    MAV_PARAM_TYPE_INT32 = 6,
                    //32-bit signed integer
                    MAV_PARAM_TYPE_UINT64 = 7,
                    //64-bit unsigned integer
                    MAV_PARAM_TYPE_INT64 = 8,
                    //64-bit signed integer
                    MAV_PARAM_TYPE_REAL32 = 9,
                    //32-bit floating-point
                    MAV_PARAM_TYPE_REAL64 = 10,//64-bit floating-point
                }

                impl MAV_PARAM_TYPE {
                    pub fn from_bits(src: i8) -> Option<MAV_PARAM_TYPE> {
                        match src
                        {
                            1 => Some(MAV_PARAM_TYPE::MAV_PARAM_TYPE_UINT8),
                            2 => Some(MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8),
                            3 => Some(MAV_PARAM_TYPE::MAV_PARAM_TYPE_UINT16),
                            4 => Some(MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16),
                            5 => Some(MAV_PARAM_TYPE::MAV_PARAM_TYPE_UINT32),
                            6 => Some(MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT32),
                            7 => Some(MAV_PARAM_TYPE::MAV_PARAM_TYPE_UINT64),
                            8 => Some(MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT64),
                            9 => Some(MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32),
                            10 => Some(MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL64),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Emergency status encoding */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum UAVIONIX_ADSB_EMERGENCY_STATUS {
                    UAVIONIX_ADSB_OUT_NO_EMERGENCY = 0,
                    UAVIONIX_ADSB_OUT_GENERAL_EMERGENCY = 1,
                    UAVIONIX_ADSB_OUT_LIFEGUARD_EMERGENCY = 2,
                    UAVIONIX_ADSB_OUT_MINIMUM_FUEL_EMERGENCY = 3,
                    UAVIONIX_ADSB_OUT_NO_COMM_EMERGENCY = 4,
                    UAVIONIX_ADSB_OUT_UNLAWFUL_INTERFERANCE_EMERGENCY = 5,
                    UAVIONIX_ADSB_OUT_DOWNED_AIRCRAFT_EMERGENCY = 6,
                    UAVIONIX_ADSB_OUT_RESERVED = 7,
                }

                impl UAVIONIX_ADSB_EMERGENCY_STATUS {
                    pub fn from_bits(src: i8) -> Option<UAVIONIX_ADSB_EMERGENCY_STATUS> {
                        match src
                        {
                            0 => Some(UAVIONIX_ADSB_EMERGENCY_STATUS::UAVIONIX_ADSB_OUT_NO_EMERGENCY),
                            1 => Some(UAVIONIX_ADSB_EMERGENCY_STATUS::UAVIONIX_ADSB_OUT_GENERAL_EMERGENCY),
                            2 => Some(UAVIONIX_ADSB_EMERGENCY_STATUS::UAVIONIX_ADSB_OUT_LIFEGUARD_EMERGENCY),
                            3 => Some(UAVIONIX_ADSB_EMERGENCY_STATUS::UAVIONIX_ADSB_OUT_MINIMUM_FUEL_EMERGENCY),
                            4 => Some(UAVIONIX_ADSB_EMERGENCY_STATUS::UAVIONIX_ADSB_OUT_NO_COMM_EMERGENCY),
                            5 => Some(UAVIONIX_ADSB_EMERGENCY_STATUS::UAVIONIX_ADSB_OUT_UNLAWFUL_INTERFERANCE_EMERGENCY),
                            6 => Some(UAVIONIX_ADSB_EMERGENCY_STATUS::UAVIONIX_ADSB_OUT_DOWNED_AIRCRAFT_EMERGENCY),
                            7 => Some(UAVIONIX_ADSB_EMERGENCY_STATUS::UAVIONIX_ADSB_OUT_RESERVED),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Indicates the severity level, generally used for status messages to indicate their relative urgency. Based
*		 on RFC-5424 using expanded definitions at: http:www.kiwisyslog.com/kb/info:-syslog-message-levels/ */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_SEVERITY {
                    MAV_SEVERITY_EMERGENCY = 0,
                    //System is unusable. This is a "panic" condition.
                    MAV_SEVERITY_ALERT = 1,
                    //Action should be taken immediately. Indicates error in non-critical systems.
                    MAV_SEVERITY_CRITICAL = 2,
                    //Action must be taken immediately. Indicates failure in a primary system.
                    MAV_SEVERITY_ERROR = 3,
                    //Indicates an error in secondary/redundant systems.
                    /**
*Indicates about a possible future error if this is not resolved within a given timeframe. Example would
*			 be a low battery warning */
                    MAV_SEVERITY_WARNING = 4,
                    /**
*An unusual event has occured, though not an error condition. This should be investigated for the root
*			 cause */
                    MAV_SEVERITY_NOTICE = 5,
                    MAV_SEVERITY_INFO = 6,
                    //Normal operational messages. Useful for logging. No action is required for these messages.
                    MAV_SEVERITY_DEBUG = 7,//Useful non-operational messages that can assist in debugging. These should not occur during normal operation
                }

                impl MAV_SEVERITY {
                    pub fn from_bits(src: i8) -> Option<MAV_SEVERITY> {
                        match src
                        {
                            0 => Some(MAV_SEVERITY::MAV_SEVERITY_EMERGENCY),
                            1 => Some(MAV_SEVERITY::MAV_SEVERITY_ALERT),
                            2 => Some(MAV_SEVERITY::MAV_SEVERITY_CRITICAL),
                            3 => Some(MAV_SEVERITY::MAV_SEVERITY_ERROR),
                            4 => Some(MAV_SEVERITY::MAV_SEVERITY_WARNING),
                            5 => Some(MAV_SEVERITY::MAV_SEVERITY_NOTICE),
                            6 => Some(MAV_SEVERITY::MAV_SEVERITY_INFO),
                            7 => Some(MAV_SEVERITY::MAV_SEVERITY_DEBUG),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*These defines are predefined OR-combined mode flags. There is no need to use values from this enum, but it
*		 simplifies the use of the mode flags. Note that manual input is enabled in all modes as a safety override. */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum MAV_MODE {
                    PREFLIGHT = 0,
                    //System is not ready to fly, booting, calibrating, etc. No flag is set.
                    MANUAL_DISARMED = 64,
                    //System is allowed to be active, under manual (RC) control, no stabilization
                    MAV_MODE_TEST_DISARMED = 66,
                    //UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only
                    STABILIZE_DISARMED = 80,
                    //System is allowed to be active, under assisted RC control.
                    GUIDED_DISARMED = 88,
                    //System is allowed to be active, under autonomous control, manual setpoint
                    /**
*System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard
*			 and not pre-programmed by waypoints */
                    MAV_MODE_AUTO_DISARMED = 92,
                    MANUAL_ARMED = 192,
                    //System is allowed to be active, under manual (RC) control, no stabilization
                    MAV_MODE_TEST_ARMED = 194,
                    //UNDEFINED mode. This solely depends on the autopilot - use with caution, intended for developers only
                    STABILIZE_ARMED = 208,
                    //System is allowed to be active, under assisted RC control.
                    GUIDED_ARMED = 216,
                    //System is allowed to be active, under autonomous control, manual setpoint
                    /**
*System is allowed to be active, under autonomous control and navigation (the trajectory is decided onboard
*			 and not pre-programmed by waypoints */
                    MAV_MODE_AUTO_ARMED = 220,
                }

                impl MAV_MODE {
                    pub fn from_bits(src: i32) -> Option<MAV_MODE> {
                        match src
                        {
                            0 => {
                                return Some(MAV_MODE::PREFLIGHT);
                            }
                            1 => {
                                return Some(MAV_MODE::MANUAL_DISARMED);
                            }
                            2 => {
                                return Some(MAV_MODE::MAV_MODE_TEST_DISARMED);
                            }
                            3 => {
                                return Some(MAV_MODE::STABILIZE_DISARMED);
                            }
                            4 => {
                                return Some(MAV_MODE::GUIDED_DISARMED);
                            }
                            5 => {
                                return Some(MAV_MODE::MAV_MODE_AUTO_DISARMED);
                            }
                            6 => {
                                return Some(MAV_MODE::MANUAL_ARMED);
                            }
                            7 => {
                                return Some(MAV_MODE::MAV_MODE_TEST_ARMED);
                            }
                            8 => {
                                return Some(MAV_MODE::STABILIZE_ARMED);
                            }
                            9 => {
                                return Some(MAV_MODE::GUIDED_ARMED);
                            }
                            10 => {
                                return Some(MAV_MODE::MAV_MODE_AUTO_ARMED);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            MAV_MODE::PREFLIGHT => {
                                return 0;
                            }
                            MAV_MODE::MANUAL_DISARMED => {
                                return 1;
                            }
                            MAV_MODE::MAV_MODE_TEST_DISARMED => {
                                return 2;
                            }
                            MAV_MODE::STABILIZE_DISARMED => {
                                return 3;
                            }
                            MAV_MODE::GUIDED_DISARMED => {
                                return 4;
                            }
                            MAV_MODE::MAV_MODE_AUTO_DISARMED => {
                                return 5;
                            }
                            MAV_MODE::MANUAL_ARMED => {
                                return 6;
                            }
                            MAV_MODE::MAV_MODE_TEST_ARMED => {
                                return 7;
                            }
                            MAV_MODE::STABILIZE_ARMED => {
                                return 8;
                            }
                            MAV_MODE::GUIDED_ARMED => {
                                return 9;
                            }
                            MAV_MODE::MAV_MODE_AUTO_ARMED => {
                                return 10;
                            }
                        }
                    }
                }

                /**
*Enumeration of the ADSB altimeter types */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum ADSB_ALTITUDE_TYPE {
                    ADSB_ALTITUDE_TYPE_PRESSURE_QNH = 0,
                    //Altitude reported from a Baro source using QNH reference
                    ADSB_ALTITUDE_TYPE_GEOMETRIC = 1,//Altitude reported from a GNSS source
                }

                impl ADSB_ALTITUDE_TYPE {
                    pub fn from_bits(src: i8) -> Option<ADSB_ALTITUDE_TYPE> {
                        match src
                        {
                            0 => Some(ADSB_ALTITUDE_TYPE::ADSB_ALTITUDE_TYPE_PRESSURE_QNH),
                            1 => Some(ADSB_ALTITUDE_TYPE::ADSB_ALTITUDE_TYPE_GEOMETRIC),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Type of mission items being requested/sent in mission protocol. */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum MAV_MISSION_TYPE {
                    MAV_MISSION_TYPE_MISSION = 0,
                    //Items are mission commands for main mission.
                    MAV_MISSION_TYPE_FENCE = 1,
                    //Specifies GeoFence area(s). Items are MAV_CMD_FENCE_ GeoFence items.
                    /**
*Specifies the rally points for the vehicle. Rally points are alternative RTL points. Items are MAV_CMD_RALLY_POINT
*			 rally point items */
                    MAV_MISSION_TYPE_RALLY = 2,
                    MAV_MISSION_TYPE_ALL = 255,//Only used in MISSION_CLEAR_ALL to clear all mission types.
                }

                impl MAV_MISSION_TYPE {
                    pub fn from_bits(src: i32) -> Option<MAV_MISSION_TYPE> {
                        match src
                        {
                            0 => {
                                return Some(MAV_MISSION_TYPE::MAV_MISSION_TYPE_MISSION);
                            }
                            1 => {
                                return Some(MAV_MISSION_TYPE::MAV_MISSION_TYPE_FENCE);
                            }
                            2 => {
                                return Some(MAV_MISSION_TYPE::MAV_MISSION_TYPE_RALLY);
                            }
                            3 => {
                                return Some(MAV_MISSION_TYPE::MAV_MISSION_TYPE_ALL);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            MAV_MISSION_TYPE::MAV_MISSION_TYPE_MISSION => {
                                return 0;
                            }
                            MAV_MISSION_TYPE::MAV_MISSION_TYPE_FENCE => {
                                return 1;
                            }
                            MAV_MISSION_TYPE::MAV_MISSION_TYPE_RALLY => {
                                return 2;
                            }
                            MAV_MISSION_TYPE::MAV_MISSION_TYPE_ALL => {
                                return 3;
                            }
                        }
                    }
                }

                /**
*Enumeration of distance sensor types */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_DISTANCE_SENSOR {
                    MAV_DISTANCE_SENSOR_LASER = 0,
                    //Laser rangefinder, e.g. LightWare SF02/F or PulsedLight units
                    MAV_DISTANCE_SENSOR_ULTRASOUND = 1,
                    //Ultrasound rangefinder, e.g. MaxBotix units
                    MAV_DISTANCE_SENSOR_INFRARED = 2,
                    //Infrared rangefinder, e.g. Sharp units
                    MAV_DISTANCE_SENSOR_RADAR = 3,
                    //Radar type, e.g. uLanding units
                    MAV_DISTANCE_SENSOR_UNKNOWN = 4,//Broken or unknown type, e.g. analog units
                }

                impl MAV_DISTANCE_SENSOR {
                    pub fn from_bits(src: i8) -> Option<MAV_DISTANCE_SENSOR> {
                        match src
                        {
                            0 => Some(MAV_DISTANCE_SENSOR::MAV_DISTANCE_SENSOR_LASER),
                            1 => Some(MAV_DISTANCE_SENSOR::MAV_DISTANCE_SENSOR_ULTRASOUND),
                            2 => Some(MAV_DISTANCE_SENSOR::MAV_DISTANCE_SENSOR_INFRARED),
                            3 => Some(MAV_DISTANCE_SENSOR::MAV_DISTANCE_SENSOR_RADAR),
                            4 => Some(MAV_DISTANCE_SENSOR::MAV_DISTANCE_SENSOR_UNKNOWN),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Enumeration of VTOL states */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_VTOL_STATE {
                    MAV_VTOL_STATE_UNDEFINED = 0,
                    //MAV is not configured as VTOL
                    MAV_VTOL_STATE_TRANSITION_TO_FW = 1,
                    //VTOL is in transition from multicopter to fixed-wing
                    MAV_VTOL_STATE_TRANSITION_TO_MC = 2,
                    //VTOL is in transition from fixed-wing to multicopter
                    MAV_VTOL_STATE_MC = 3,
                    //VTOL is in multicopter state
                    MAV_VTOL_STATE_FW = 4,//VTOL is in fixed-wing state
                }

                impl MAV_VTOL_STATE {
                    pub fn from_bits(src: i8) -> Option<MAV_VTOL_STATE> {
                        match src
                        {
                            0 => Some(MAV_VTOL_STATE::MAV_VTOL_STATE_UNDEFINED),
                            1 => Some(MAV_VTOL_STATE::MAV_VTOL_STATE_TRANSITION_TO_FW),
                            2 => Some(MAV_VTOL_STATE::MAV_VTOL_STATE_TRANSITION_TO_MC),
                            3 => Some(MAV_VTOL_STATE::MAV_VTOL_STATE_MC),
                            4 => Some(MAV_VTOL_STATE::MAV_VTOL_STATE_FW),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Type of GPS fix */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum GPS_FIX_TYPE {
                    GPS_FIX_TYPE_NO_GPS = 0,
                    //No GPS connected
                    GPS_FIX_TYPE_NO_FIX = 1,
                    //No position information, GPS is connected
                    GPS_FIX_TYPE_2D_FIX = 2,
                    //2D position
                    GPS_FIX_TYPE_3D_FIX = 3,
                    //3D position
                    GPS_FIX_TYPE_DGPS = 4,
                    //DGPS/SBAS aided 3D position
                    GPS_FIX_TYPE_RTK_FLOAT = 5,
                    //RTK float, 3D position
                    GPS_FIX_TYPE_RTK_FIXED = 6,
                    //RTK Fixed, 3D position
                    GPS_FIX_TYPE_STATIC = 7,
                    //Static fixed, typically used for base stations
                    GPS_FIX_TYPE_PPP = 8,//PPP, 3D position.
                }

                impl GPS_FIX_TYPE {
                    pub fn from_bits(src: i8) -> Option<GPS_FIX_TYPE> {
                        match src
                        {
                            0 => Some(GPS_FIX_TYPE::GPS_FIX_TYPE_NO_GPS),
                            1 => Some(GPS_FIX_TYPE::GPS_FIX_TYPE_NO_FIX),
                            2 => Some(GPS_FIX_TYPE::GPS_FIX_TYPE_2D_FIX),
                            3 => Some(GPS_FIX_TYPE::GPS_FIX_TYPE_3D_FIX),
                            4 => Some(GPS_FIX_TYPE::GPS_FIX_TYPE_DGPS),
                            5 => Some(GPS_FIX_TYPE::GPS_FIX_TYPE_RTK_FLOAT),
                            6 => Some(GPS_FIX_TYPE::GPS_FIX_TYPE_RTK_FIXED),
                            7 => Some(GPS_FIX_TYPE::GPS_FIX_TYPE_STATIC),
                            8 => Some(GPS_FIX_TYPE::GPS_FIX_TYPE_PPP),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Specifies the datatype of a MAVLink extended parameter. */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_PARAM_EXT_TYPE {
                    MAV_PARAM_EXT_TYPE_UINT8 = 1,
                    //8-bit unsigned integer
                    MAV_PARAM_EXT_TYPE_INT8 = 2,
                    //8-bit signed integer
                    MAV_PARAM_EXT_TYPE_UINT16 = 3,
                    //16-bit unsigned integer
                    MAV_PARAM_EXT_TYPE_INT16 = 4,
                    //16-bit signed integer
                    MAV_PARAM_EXT_TYPE_UINT32 = 5,
                    //32-bit unsigned integer
                    MAV_PARAM_EXT_TYPE_INT32 = 6,
                    //32-bit signed integer
                    MAV_PARAM_EXT_TYPE_UINT64 = 7,
                    //64-bit unsigned integer
                    MAV_PARAM_EXT_TYPE_INT64 = 8,
                    //64-bit signed integer
                    MAV_PARAM_EXT_TYPE_REAL32 = 9,
                    //32-bit floating-point
                    MAV_PARAM_EXT_TYPE_REAL64 = 10,
                    //64-bit floating-point
                    MAV_PARAM_EXT_TYPE_CUSTOM = 11,//Custom Type
                }

                impl MAV_PARAM_EXT_TYPE {
                    pub fn from_bits(src: i8) -> Option<MAV_PARAM_EXT_TYPE> {
                        match src
                        {
                            1 => Some(MAV_PARAM_EXT_TYPE::MAV_PARAM_EXT_TYPE_UINT8),
                            2 => Some(MAV_PARAM_EXT_TYPE::MAV_PARAM_EXT_TYPE_INT8),
                            3 => Some(MAV_PARAM_EXT_TYPE::MAV_PARAM_EXT_TYPE_UINT16),
                            4 => Some(MAV_PARAM_EXT_TYPE::MAV_PARAM_EXT_TYPE_INT16),
                            5 => Some(MAV_PARAM_EXT_TYPE::MAV_PARAM_EXT_TYPE_UINT32),
                            6 => Some(MAV_PARAM_EXT_TYPE::MAV_PARAM_EXT_TYPE_INT32),
                            7 => Some(MAV_PARAM_EXT_TYPE::MAV_PARAM_EXT_TYPE_UINT64),
                            8 => Some(MAV_PARAM_EXT_TYPE::MAV_PARAM_EXT_TYPE_INT64),
                            9 => Some(MAV_PARAM_EXT_TYPE::MAV_PARAM_EXT_TYPE_REAL32),
                            10 => Some(MAV_PARAM_EXT_TYPE::MAV_PARAM_EXT_TYPE_REAL64),
                            11 => Some(MAV_PARAM_EXT_TYPE::MAV_PARAM_EXT_TYPE_CUSTOM),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Enumeration of estimator types */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_ESTIMATOR_TYPE {
                    MAV_ESTIMATOR_TYPE_NAIVE = 1,
                    //This is a naive estimator without any real covariance feedback.
                    MAV_ESTIMATOR_TYPE_VISION = 2,
                    //Computer vision based estimate. Might be up to scale.
                    MAV_ESTIMATOR_TYPE_VIO = 3,
                    //Visual-inertial estimate.
                    MAV_ESTIMATOR_TYPE_GPS = 4,
                    //Plain GPS estimate.
                    MAV_ESTIMATOR_TYPE_GPS_INS = 5,//Estimator integrating GPS and inertial sensing.
                }

                impl MAV_ESTIMATOR_TYPE {
                    pub fn from_bits(src: i8) -> Option<MAV_ESTIMATOR_TYPE> {
                        match src
                        {
                            1 => Some(MAV_ESTIMATOR_TYPE::MAV_ESTIMATOR_TYPE_NAIVE),
                            2 => Some(MAV_ESTIMATOR_TYPE::MAV_ESTIMATOR_TYPE_VISION),
                            3 => Some(MAV_ESTIMATOR_TYPE::MAV_ESTIMATOR_TYPE_VIO),
                            4 => Some(MAV_ESTIMATOR_TYPE::MAV_ESTIMATOR_TYPE_GPS),
                            5 => Some(MAV_ESTIMATOR_TYPE::MAV_ESTIMATOR_TYPE_GPS_INS),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum CAMERA_FEEDBACK_FLAGS {
                    CAMERA_FEEDBACK_PHOTO = 0,
                    //Shooting photos, not video
                    CAMERA_FEEDBACK_VIDEO = 1,
                    //Shooting video, not stills
                    CAMERA_FEEDBACK_BADEXPOSURE = 2,
                    //Unable to achieve requested exposure (e.g. shutter speed too low)
                    CAMERA_FEEDBACK_CLOSEDLOOP = 3,
                    //Closed loop feedback from camera, we know for sure it has successfully taken a picture
                    /**
*Open loop camera, an image trigger has been requested but we can't know for sure it has successfully taken
*			 a pictur */
                    CAMERA_FEEDBACK_OPENLOOP = 4,
                }

                impl CAMERA_FEEDBACK_FLAGS {
                    pub fn from_bits(src: i8) -> Option<CAMERA_FEEDBACK_FLAGS> {
                        match src
                        {
                            0 => Some(CAMERA_FEEDBACK_FLAGS::CAMERA_FEEDBACK_PHOTO),
                            1 => Some(CAMERA_FEEDBACK_FLAGS::CAMERA_FEEDBACK_VIDEO),
                            2 => Some(CAMERA_FEEDBACK_FLAGS::CAMERA_FEEDBACK_BADEXPOSURE),
                            3 => Some(CAMERA_FEEDBACK_FLAGS::CAMERA_FEEDBACK_CLOSEDLOOP),
                            4 => Some(CAMERA_FEEDBACK_FLAGS::CAMERA_FEEDBACK_OPENLOOP),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Generalized UAVCAN node health */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum UAVCAN_NODE_HEALTH {
                    UAVCAN_NODE_HEALTH_OK = 0,
                    //The node is functioning properly.
                    UAVCAN_NODE_HEALTH_WARNING = 1,
                    //A critical parameter went out of range or the node has encountered a minor failure.
                    UAVCAN_NODE_HEALTH_ERROR = 2,
                    //The node has encountered a major failure.
                    UAVCAN_NODE_HEALTH_CRITICAL = 3,//The node has suffered a fatal malfunction.
                }

                impl UAVCAN_NODE_HEALTH {
                    pub fn from_bits(src: i8) -> Option<UAVCAN_NODE_HEALTH> {
                        match src
                        {
                            0 => Some(UAVCAN_NODE_HEALTH::UAVCAN_NODE_HEALTH_OK),
                            1 => Some(UAVCAN_NODE_HEALTH::UAVCAN_NODE_HEALTH_WARNING),
                            2 => Some(UAVCAN_NODE_HEALTH::UAVCAN_NODE_HEALTH_ERROR),
                            3 => Some(UAVCAN_NODE_HEALTH::UAVCAN_NODE_HEALTH_CRITICAL),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Commands to be executed by the MAV. They can be executed on user request, or as part of a mission script.
*		 If the action is used in a mission, the parameter mapping to the waypoint/mission message is as follows:
*		 Param 1, Param 2, Param 3, Param 4, X: Param 5, Y:Param 6, Z:Param 7. This command list is similar what
*		 ARINC 424 is for commercial aircraft: A data format how to interpret waypoint/mission data */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum MAV_CMD {
                    /**
*Navigate to waypoint.
*					 1	Hold time in decimal seconds. (ignored by fixed wing, time to stay at waypoint for rotary wing)
*					 2	Acceptance radius in meters (if the sphere with this radius is hit, the waypoint counts as reached)
*					 3	0 to pass through the WP, if 	>	0 radius in meters to pass by WP. Positive value for clockwise orbit, negative value for counter-clockwise orbit. Allows trajectory control.
*					 4	Desired yaw angle at waypoint (rotary wing). NaN for unchanged.
*					 5	Latitude
*					 6	Longitude
*					 7	Altitude */
                    MAV_CMD_NAV_WAYPOINT = 16,
                    /**
*Loiter around this waypoint an unlimited amount of time
*			 1	Empty
*			 2	Empty
*			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
*			 4	Desired yaw angle.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
                    MAV_CMD_NAV_LOITER_UNLIM = 17,
                    /**
*Loiter around this waypoint for X turns
*			 1	Turns
*			 2	Empty
*			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
*			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
                    MAV_CMD_NAV_LOITER_TURNS = 18,
                    /**
*Loiter around this waypoint for X seconds
*			 1	Seconds (decimal)
*			 2	Empty
*			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
*			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location. Else, this is desired yaw angle
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
                    MAV_CMD_NAV_LOITER_TIME = 19,
                    /**
*Return to launch location
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_NAV_RETURN_TO_LAUNCH = 20,
                    /**
*Land at location
*			 1	Abort Alt
*			 2	Empty
*			 3	Empty
*			 4	Desired yaw angle. NaN for unchanged.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude (ground level) */
                    MAV_CMD_NAV_LAND = 21,
                    /**
*Takeoff from ground / hand
*			 1	Minimum pitch (if airspeed sensor present), desired pitch without sensor
*			 2	Empty
*			 3	Empty
*			 4	Yaw angle (if magnetometer present), ignored without magnetometer. NaN for unchanged.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
                    MAV_CMD_NAV_TAKEOFF = 22,
                    /**
*Land at local position (local frame only)
*			 1	Landing target number (if available)
*			 2	Maximum accepted offset from desired landing position [m] - computed magnitude from spherical coordinates: d = sqrt(x^2 + y^2 + z^2), which gives the maximum accepted distance between the desired landing position and the position where the vehicle is about to land
*			 3	Landing descend rate [ms^-1]
*			 4	Desired yaw angle [rad]
*			 5	Y-axis position [m]
*			 6	X-axis position [m]
*			 7	Z-axis / ground level position [m] */
                    MAV_CMD_NAV_LAND_LOCAL = 23,
                    /**
*Takeoff from local position (local frame only)
*			 1	Minimum pitch (if airspeed sensor present), desired pitch without sensor [rad]
*			 2	Empty
*			 3	Takeoff ascend rate [ms^-1]
*			 4	Yaw angle [rad] (if magnetometer or another yaw estimation source present), ignored without one of these
*			 5	Y-axis position [m]
*			 6	X-axis position [m]
*			 7	Z-axis position [m] */
                    MAV_CMD_NAV_TAKEOFF_LOCAL = 24,
                    /**
*Vehicle following, i.e. this waypoint represents the position of a moving vehicle
*			 1	Following logic to use (e.g. loitering or sinusoidal following) - depends on specific autopilot implementation
*			 2	Ground speed of vehicle to be followed
*			 3	Radius around waypoint, in meters. If positive loiter clockwise, else counter-clockwise
*			 4	Desired yaw angle.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
                    MAV_CMD_NAV_FOLLOW = 25,
                    /**
*Continue on the current course and climb/descend to specified altitude.  When the altitude is reached
*			 continue to the next command (i.e., don't proceed to the next command until the desired altitude is reached
*			 1	Climb or Descend (0 = Neutral, command completes when within 5m of this command's altitude, 1 = Climbing, command completes when at or above this command's altitude, 2 = Descending, command completes when at or below this command's altitude.
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Desired altitude in meters */
                    MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT = 30,
                    /**
*Begin loiter at the specified Latitude and Longitude.  If Lat=Lon=0, then loiter at the current position.
*			 Don't consider the navigation command complete (don't leave loiter) until the altitude has been reached.
*			 Additionally, if the Heading Required parameter is non-zero the  aircraft will not leave the loiter
*			 until heading toward the next waypoint.
*			 1	Heading Required (0 = False)
*			 2	Radius in meters. If positive loiter clockwise, negative counter-clockwise, 0 means no change to standard loiter.
*			 3	Empty
*			 4	Forward moving aircraft this sets exit xtrack location: 0 for center of loiter wp, 1 for exit location
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
                    MAV_CMD_NAV_LOITER_TO_ALT = 31,
                    /**
*Being following a target
*			 1	System ID (the system ID of the FOLLOW_TARGET beacon). Send 0 to disable follow-me and return to the default position hold mode
*			 2	RESERVED
*			 3	RESERVED
*			 4	altitude flag: 0: Keep current altitude, 1: keep altitude difference to target, 2: go to a fixed altitude above home
*			 5	altitude
*			 6	RESERVED
*			 7	TTL in seconds in which the MAV should go to the default position hold mode after a message rx timeout */
                    MAV_CMD_DO_FOLLOW = 32,
                    /**
*Reposition the MAV after a follow target command has been sent
*			 1	Camera q1 (where 0 is on the ray from the camera to the tracking device)
*			 2	Camera q2
*			 3	Camera q3
*			 4	Camera q4
*			 5	altitude offset from target (m)
*			 6	X offset from target (m)
*			 7	Y offset from target (m) */
                    MAV_CMD_DO_FOLLOW_REPOSITION = 33,
                    /**
*Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the
*			 vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras
*			 1	Region of intereset mode. (see MAV_ROI enum)
*			 2	Waypoint index/ target ID. (see MAV_ROI enum)
*			 3	ROI index (allows a vehicle to manage multiple ROI's)
*			 4	Empty
*			 5	x the location of the fixed ROI (see MAV_FRAME)
*			 6	y
*			 7	z */
                    MAV_CMD_NAV_ROI = 80,
                    /**
*Control autonomous path planning on the MAV.
*			 1	0: Disable local obstacle avoidance / local path planning (without resetting map), 1: Enable local path planning, 2: Enable and reset local path planning
*			 2	0: Disable full path planning (without resetting map), 1: Enable, 2: Enable and reset map/occupancy grid, 3: Enable and reset planned route, but not occupancy grid
*			 3	Empty
*			 4	Yaw angle at goal, in compass degrees, [0..360]
*			 5	Latitude/X of goal
*			 6	Longitude/Y of goal
*			 7	Altitude/Z of goal */
                    MAV_CMD_NAV_PATHPLANNING = 81,
                    /**
*Navigate to waypoint using a spline path.
*			 1	Hold time in decimal seconds. (ignored by fixed wing, time to stay at waypoint for rotary wing)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Latitude/X of goal
*			 6	Longitude/Y of goal
*			 7	Altitude/Z of goal */
                    MAV_CMD_NAV_SPLINE_WAYPOINT = 82,
                    /**
*Mission command to wait for an altitude or downwards vertical speed. This is meant for high altitude balloon
*			 launches, allowing the aircraft to be idle until either an altitude is reached or a negative vertical
*			 speed is reached (indicating early balloon burst). The wiggle time is how often to wiggle the control
*			 surfaces to prevent them seizing up
*			 1	altitude (m)
*			 2	descent speed (m/s)
*			 3	Wiggle Time (s)
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_NAV_ALTITUDE_WAIT = 83,
                    /**
*Takeoff from ground using VTOL mode
*			 1	Empty
*			 2	Front transition heading, see VTOL_TRANSITION_HEADING enum.
*			 3	Empty
*			 4	Yaw angle in degrees. NaN for unchanged.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
                    MAV_CMD_NAV_VTOL_TAKEOFF = 84,
                    /**
*Land using VTOL mode
*			 1	Empty
*			 2	Empty
*			 3	Approach altitude (with the same reference as the Altitude field). NaN if unspecified.
*			 4	Yaw angle in degrees. NaN for unchanged.
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude (ground level) */
                    MAV_CMD_NAV_VTOL_LAND = 85,
                    /**
*hand control over to an external controller
*			 1	On / Off (	>	0.5f on)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_NAV_GUIDED_ENABLE = 92,
                    /**
*Delay the next navigation command a number of seconds or until a specified time
*			 1	Delay in seconds (decimal, -1 to enable time-of-day fields)
*			 2	hour (24h format, UTC, -1 to ignore)
*			 3	minute (24h format, UTC, -1 to ignore)
*			 4	second (24h format, UTC)
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_NAV_DELAY = 93,
                    /**
*Descend and place payload.  Vehicle descends until it detects a hanging payload has reached the ground,
*			 the gripper is opened to release the payloa
*			 1	Maximum distance to descend (meters)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Latitude (deg * 1E7)
*			 6	Longitude (deg * 1E7)
*			 7	Altitude (meters) */
                    MAV_CMD_NAV_PAYLOAD_PLACE = 94,
                    /**
*NOP - This command is only used to mark the upper limit of the NAV/ACTION commands in the enumeratio
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_NAV_LAST = 95,
                    /**
*Delay mission state machine.
*			 1	Delay in seconds (decimal)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_CONDITION_DELAY = 112,
                    /**
*Ascend/descend at rate.  Delay mission state machine until desired altitude reached.
*			 1	Descent / Ascend rate (m/s)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Finish Altitude */
                    MAV_CMD_CONDITION_CHANGE_ALT = 113,
                    /**
*Delay mission state machine until within desired distance of next NAV point.
*			 1	Distance (meters)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_CONDITION_DISTANCE = 114,
                    /**
*Reach a certain target angle.
*			 1	target angle: [0-360], 0 is north
*			 2	speed during yaw change:[deg per second]
*			 3	direction: negative: counter clockwise, positive: clockwise [-1,1]
*			 4	relative offset or absolute angle: [ 1,0]
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_CONDITION_YAW = 115,
                    /**
*NOP - This command is only used to mark the upper limit of the CONDITION commands in the enumeratio
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_CONDITION_LAST = 159,
                    /**
*Set system mode.
*			 1	Mode, as defined by ENUM MAV_MODE
*			 2	Custom mode - this is system specific, please refer to the individual autopilot specifications for details.
*			 3	Custom sub mode - this is system specific, please refer to the individual autopilot specifications for details.
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_SET_MODE = 176,
                    /**
*Jump to the desired command in the mission list.  Repeat this action only the specified number of time
*			 1	Sequence number
*			 2	Repeat count
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_JUMP = 177,
                    /**
*Change speed and/or throttle set points.
*			 1	Speed type (0=Airspeed, 1=Ground Speed)
*			 2	Speed  (m/s, -1 indicates no change)
*			 3	Throttle  ( Percent, -1 indicates no change)
*			 4	absolute or relative [0,1]
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_CHANGE_SPEED = 178,
                    /**
*Changes the home location either to the current location or a specified location.
*			 1	Use current (1=use current location, 0=use specified location)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
                    MAV_CMD_DO_SET_HOME = 179,
                    /**
*Set a system parameter.  Caution!  Use of this command requires knowledge of the numeric enumeration value
*			 of the parameter
*			 1	Parameter number
*			 2	Parameter value
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_SET_PARAMETER = 180,
                    /**
*Set a relay to a condition.
*			 1	Relay number
*			 2	Setting (1=on, 0=off, others possible depending on system hardware)
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_SET_RELAY = 181,
                    /**
*Cycle a relay on and off for a desired number of cyles with a desired period.
*			 1	Relay number
*			 2	Cycle count
*			 3	Cycle time (seconds, decimal)
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_REPEAT_RELAY = 182,
                    /**
*Set a servo to a desired PWM value.
*			 1	Servo number
*			 2	PWM (microseconds, 1000 to 2000 typical)
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_SET_SERVO = 183,
                    /**
*Cycle a between its nominal setting and a desired PWM for a desired number of cycles with a desired period
*			 1	Servo number
*			 2	PWM (microseconds, 1000 to 2000 typical)
*			 3	Cycle count
*			 4	Cycle time (seconds)
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_REPEAT_SERVO = 184,
                    /**
*Terminate flight immediately
*			 1	Flight termination activated if 	>	0.5
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_FLIGHTTERMINATION = 185,
                    /**
*Change altitude set point.
*			 1	Altitude in meters
*			 2	Mav frame of new altitude (see MAV_FRAME)
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_CHANGE_ALTITUDE = 186,
                    /**
*Mission command to perform a landing. This is used as a marker in a mission to tell the autopilot where
*			 a sequence of mission items that represents a landing starts. It may also be sent via a COMMAND_LONG
*			 to trigger a landing, in which case the nearest (geographically) landing sequence in the mission will
*			 be used. The Latitude/Longitude is optional, and may be set to 0 if not needed. If specified then it
*			 will be used to help find the closest landing sequence
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Latitude
*			 6	Longitude
*			 7	Empty */
                    MAV_CMD_DO_LAND_START = 189,
                    /**
*Mission command to perform a landing from a rally point.
*			 1	Break altitude (meters)
*			 2	Landing speed (m/s)
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_RALLY_LAND = 190,
                    /**
*Mission command to safely abort an autonmous landing.
*			 1	Altitude (meters)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_GO_AROUND = 191,
                    /**
*Reposition the vehicle to a specific WGS84 global position.
*			 1	Ground speed, less than 0 (-1) for default
*			 2	Bitmask of option flags, see the MAV_DO_REPOSITION_FLAGS enum.
*			 3	Reserved
*			 4	Yaw heading, NaN for unchanged. For planes indicates loiter direction (0: clockwise, 1: counter clockwise)
*			 5	Latitude (deg * 1E7)
*			 6	Longitude (deg * 1E7)
*			 7	Altitude (meters) */
                    MAV_CMD_DO_REPOSITION = 192,
                    /**
*If in a GPS controlled position mode, hold the current position or continue.
*			 1	0: Pause current mission or reposition command, hold current position. 1: Continue mission. A VTOL capable vehicle should enter hover mode (multicopter and VTOL planes). A plane should loiter with the default loiter radius.
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Reserved
*			 6	Reserved
*			 7	Reserved */
                    MAV_CMD_DO_PAUSE_CONTINUE = 193,
                    /**
*Set moving direction to forward or reverse.
*			 1	Direction (0=Forward, 1=Reverse)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_SET_REVERSE = 194,
                    /**
*Control onboard camera system.
*			 1	Camera ID (-1 for all)
*			 2	Transmission: 0: disabled, 1: enabled compressed, 2: enabled raw
*			 3	Transmission mode: 0: video stream, 	>	0: single images every n seconds (decimal)
*			 4	Recording: 0: disabled, 1: enabled compressed, 2: enabled raw
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_CONTROL_VIDEO = 200,
                    /**
*Sets the region of interest (ROI) for a sensor set or the vehicle itself. This can then be used by the
*			 vehicles control system to control the vehicle attitude and the attitude of various sensors such as cameras
*			 1	Region of intereset mode. (see MAV_ROI enum)
*			 2	Waypoint index/ target ID. (see MAV_ROI enum)
*			 3	ROI index (allows a vehicle to manage multiple ROI's)
*			 4	Empty
*			 5	MAV_ROI_WPNEXT: pitch offset from next waypoint, MAV_ROI_LOCATION: latitude
*			 6	MAV_ROI_WPNEXT: roll offset from next waypoint, MAV_ROI_LOCATION: longitude
*			 7	MAV_ROI_WPNEXT: yaw offset from next waypoint, MAV_ROI_LOCATION: altitude */
                    MAV_CMD_DO_SET_ROI = 201,
                    /**
*Mission command to configure an on-board camera controller system.
*			 1	Modes: P, TV, AV, M, Etc
*			 2	Shutter speed: Divisor number for one second
*			 3	Aperture: F stop number
*			 4	ISO number e.g. 80, 100, 200, Etc
*			 5	Exposure type enumerator
*			 6	Command Identity
*			 7	Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off) */
                    MAV_CMD_DO_DIGICAM_CONFIGURE = 202,
                    /**
*Mission command to control an on-board camera controller system.
*			 1	Session control e.g. show/hide lens
*			 2	Zoom's absolute position
*			 3	Zooming step value to offset zoom from the current position
*			 4	Focus Locking, Unlocking or Re-locking
*			 5	Shooting Command
*			 6	Command Identity
*			 7	Test shot identifier. If set to 1, image will only be captured, but not counted towards internal frame count. */
                    MAV_CMD_DO_DIGICAM_CONTROL = 203,
                    /**
*Mission command to configure a camera or antenna mount
*			 1	Mount operation mode (see MAV_MOUNT_MODE enum)
*			 2	stabilize roll? (1 = yes, 0 = no)
*			 3	stabilize pitch? (1 = yes, 0 = no)
*			 4	stabilize yaw? (1 = yes, 0 = no)
*			 5	roll input (0 = angle, 1 = angular rate)
*			 6	pitch input (0 = angle, 1 = angular rate)
*			 7	yaw input (0 = angle, 1 = angular rate) */
                    MAV_CMD_DO_MOUNT_CONFIGURE = 204,
                    /**
*Mission command to control a camera or antenna mount
*			 1	pitch depending on mount mode (degrees or degrees/second depending on pitch input).
*			 2	roll depending on mount mode (degrees or degrees/second depending on roll input).
*			 3	yaw depending on mount mode (degrees or degrees/second depending on yaw input).
*			 4	alt in meters depending on mount mode.
*			 5	latitude in degrees * 1E7, set if appropriate mount mode.
*			 6	longitude in degrees * 1E7, set if appropriate mount mode.
*			 7	MAV_MOUNT_MODE enum value */
                    MAV_CMD_DO_MOUNT_CONTROL = 205,
                    /**
*Mission command to set camera trigger distance for this flight. The camera is trigerred each time this
*			 distance is exceeded. This command can also be used to set the shutter integration time for the camera
*			 1	Camera trigger distance (meters). 0 to stop triggering.
*			 2	Camera shutter integration time (milliseconds). -1 or 0 to ignore
*			 3	Trigger camera once immediately. (0 = no trigger, 1 = trigger)
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_SET_CAM_TRIGG_DIST = 206,
                    /**
*Mission command to enable the geofence
*			 1	enable? (0=disable, 1=enable, 2=disable_floor_only)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_FENCE_ENABLE = 207,
                    /**
*Mission command to trigger a parachute
*			 1	action (0=disable, 1=enable, 2=release, for some systems see PARACHUTE_ACTION enum, not in general message set.)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_PARACHUTE = 208,
                    /**
*Mission command to perform motor test
*			 1	motor sequence number (a number from 1 to max number of motors on the vehicle)
*			 2	throttle type (0=throttle percentage, 1=PWM, 2=pilot throttle channel pass-through. See MOTOR_TEST_THROTTLE_TYPE enum)
*			 3	throttle
*			 4	timeout (in seconds)
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_MOTOR_TEST = 209,
                    /**
*Change to/from inverted flight
*			 1	inverted (0=normal, 1=inverted)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_INVERTED_FLIGHT = 210,
                    /**
*Mission command to operate EPM gripper
*			 1	gripper number (a number from 1 to max number of grippers on the vehicle)
*			 2	gripper action (0=release, 1=grab. See GRIPPER_ACTIONS enum)
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_GRIPPER = 211,
                    /**
*Enable/disable autotune
*			 1	enable (1: enable, 0:disable)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_AUTOTUNE_ENABLE = 212,
                    /**
*Sets a desired vehicle turn angle and speed change
*			 1	yaw angle to adjust steering by in centidegress
*			 2	speed - normalized to 0 .. 1
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_NAV_SET_YAW_SPEED = 213,
                    /**
*Mission command to set camera trigger interval for this flight. If triggering is enabled, the camera is
*			 triggered each time this interval expires. This command can also be used to set the shutter integration
*			 time for the camera
*			 1	Camera trigger cycle time (milliseconds). -1 or 0 to ignore.
*			 2	Camera shutter integration time (milliseconds). Should be less than trigger cycle time. -1 or 0 to ignore.
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL = 214,
                    /**
*Mission command to control a camera or antenna mount, using a quaternion as reference.
*			 1	q1 - quaternion param #1, w (1 in null-rotation)
*			 2	q2 - quaternion param #2, x (0 in null-rotation)
*			 3	q3 - quaternion param #3, y (0 in null-rotation)
*			 4	q4 - quaternion param #4, z (0 in null-rotation)
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_MOUNT_CONTROL_QUAT = 220,
                    /**
*set id of master controller
*			 1	System ID
*			 2	Component ID
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_GUIDED_MASTER = 221,
                    /**
*set limits for external control
*			 1	timeout - maximum time (in seconds) that external controller will be allowed to control vehicle. 0 means no timeout
*			 2	absolute altitude min (in meters, AMSL) - if vehicle moves below this alt, the command will be aborted and the mission will continue.  0 means no lower altitude limit
*			 3	absolute altitude max (in meters)- if vehicle moves above this alt, the command will be aborted and the mission will continue.  0 means no upper altitude limit
*			 4	horizontal move limit (in meters, AMSL) - if vehicle moves more than this distance from it's location at the moment the command was executed, the command will be aborted and the mission will continue. 0 means no horizontal altitude limit
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_GUIDED_LIMITS = 222,
                    /**
*Control vehicle engine. This is interpreted by the vehicles engine controller to change the target engine
*			 state. It is intended for vehicles with internal combustion engine
*			 1	0: Stop engine, 1:Start Engine
*			 2	0: Warm start, 1:Cold start. Controls use of choke where applicable
*			 3	Height delay (meters). This is for commanding engine start only after the vehicle has gained the specified height. Used in VTOL vehicles during takeoff to start engine after the aircraft is off the ground. Zero for no delay.
*			 4	Empty
*			 5	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_ENGINE_CONTROL = 223,
                    /**
*NOP - This command is only used to mark the upper limit of the DO commands in the enumeration
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_LAST = 240,
                    /**
*Trigger calibration. This command will be only accepted if in pre-flight mode. Except for Temperature
*			 Calibration, only one sensor should be set in a single message and all others should be zero
*			 1	1: gyro calibration, 3: gyro temperature calibration
*			 2	1: magnetometer calibration
*			 3	1: ground pressure calibration
*			 4	1: radio RC calibration, 2: RC trim calibration
*			 5	1: accelerometer calibration, 2: board level calibration, 3: accelerometer temperature calibration
*			 6	1: APM: compass/motor interference calibration (PX4: airspeed calibration, deprecated), 2: airspeed calibration
*			 7	1: ESC calibration, 3: barometer temperature calibration */
                    MAV_CMD_PREFLIGHT_CALIBRATION = 241,
                    /**
*Set sensor offsets. This command will be only accepted if in pre-flight mode.
*			 1	Sensor to adjust the offsets for: 0: gyros, 1: accelerometer, 2: magnetometer, 3: barometer, 4: optical flow, 5: second magnetometer, 6: third magnetometer
*			 2	X axis offset (or generic dimension 1), in the sensor's raw units
*			 3	Y axis offset (or generic dimension 2), in the sensor's raw units
*			 4	Z axis offset (or generic dimension 3), in the sensor's raw units
*			 5	Generic dimension 4, in the sensor's raw units
*			 6	Generic dimension 5, in the sensor's raw units
*			 7	Generic dimension 6, in the sensor's raw units */
                    MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS = 242,
                    /**
*Trigger UAVCAN config. This command will be only accepted if in pre-flight mode.
*			 1	1: Trigger actuator ID assignment and direction mapping.
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Reserved
*			 6	Reserved
*			 7	Reserved */
                    MAV_CMD_PREFLIGHT_UAVCAN = 243,
                    /**
*Request storage of different parameter values and logs. This command will be only accepted if in pre-flight
*			 mode
*			 1	Parameter storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults
*			 2	Mission storage: 0: READ FROM FLASH/EEPROM, 1: WRITE CURRENT TO FLASH/EEPROM, 2: Reset to defaults
*			 3	Onboard logging: 0: Ignore, 1: Start default rate logging, -1: Stop logging, 	>	1: start logging with rate of param 3 in Hz (e.g. set to 1000 for 1000 Hz logging)
*			 4	Reserved
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_PREFLIGHT_STORAGE = 245,
                    /**
*Request the reboot or shutdown of system components.
*			 1	0: Do nothing for autopilot, 1: Reboot autopilot, 2: Shutdown autopilot, 3: Reboot autopilot and keep it in the bootloader until upgraded.
*			 2	0: Do nothing for onboard computer, 1: Reboot onboard computer, 2: Shutdown onboard computer, 3: Reboot onboard computer and keep it in the bootloader until upgraded.
*			 3	WIP: 0: Do nothing for camera, 1: Reboot onboard camera, 2: Shutdown onboard camera, 3: Reboot onboard camera and keep it in the bootloader until upgraded
*			 4	WIP: 0: Do nothing for mount (e.g. gimbal), 1: Reboot mount, 2: Shutdown mount, 3: Reboot mount and keep it in the bootloader until upgraded
*			 5	Reserved, send 0
*			 6	Reserved, send 0
*			 7	WIP: ID (e.g. camera ID -1 for all IDs) */
                    MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN = 246,
                    /**
*Hold / continue the current action
*			 1	MAV_GOTO_DO_HOLD: hold MAV_GOTO_DO_CONTINUE: continue with next item in mission plan
*			 2	MAV_GOTO_HOLD_AT_CURRENT_POSITION: Hold at current position MAV_GOTO_HOLD_AT_SPECIFIED_POSITION: hold at specified position
*			 3	MAV_FRAME coordinate frame of hold point
*			 4	Desired yaw angle in degrees
*			 5	Latitude / X position
*			 6	Longitude / Y position
*			 7	Altitude / Z position */
                    MAV_CMD_OVERRIDE_GOTO = 252,
                    /**
*start running a mission
*			 1	first_item: the first mission item to run
*			 2	last_item:  the last mission item to run (after this item is run, the mission ends) */
                    MAV_CMD_MISSION_START = 300,
                    /**
*Arms / Disarms a component
*			 1	1 to arm, 0 to disarm */
                    MAV_CMD_COMPONENT_ARM_DISARM = 400,
                    /**
*Request the home position from the vehicle.
*			 1	Reserved
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Reserved
*			 6	Reserved
*			 7	Reserved */
                    MAV_CMD_GET_HOME_POSITION = 410,
                    /**
*Starts receiver pairing
*			 1	0:Spektrum
*			 2	0:Spektrum DSM2, 1:Spektrum DSMX */
                    MAV_CMD_START_RX_PAIR = 500,
                    /**
*Request the interval between messages for a particular MAVLink message ID
*			 1	The MAVLink message ID */
                    MAV_CMD_GET_MESSAGE_INTERVAL = 510,
                    /**
*Request the interval between messages for a particular MAVLink message ID. This interface replaces REQUEST_DATA_STREA
*			 1	The MAVLink message ID
*			 2	The interval between two messages, in microseconds. Set to -1 to disable and 0 to request default rate. */
                    MAV_CMD_SET_MESSAGE_INTERVAL = 511,
                    /**
*Request MAVLink protocol version compatibility
*			 1	1: Request supported protocol versions by all nodes on the network
*			 2	Reserved (all remaining params) */
                    MAV_CMD_REQUEST_PROTOCOL_VERSION = 519,
                    /**
*Request autopilot capabilities
*			 1	1: Request autopilot version
*			 2	Reserved (all remaining params) */
                    MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES = 520,
                    /**
*WIP: Request camera information (CAMERA_INFORMATION).
*			 1	0: No action 1: Request camera capabilities
*			 2	Reserved (all remaining params) */
                    MAV_CMD_REQUEST_CAMERA_INFORMATION = 521,
                    /**
*WIP: Request camera settings (CAMERA_SETTINGS).
*			 1	0: No Action 1: Request camera settings
*			 2	Reserved (all remaining params) */
                    MAV_CMD_REQUEST_CAMERA_SETTINGS = 522,
                    /**
*WIP: Request storage information (STORAGE_INFORMATION). Use the command's target_component to target a
*			 specific component's storage
*			 1	Storage ID (0 for all, 1 for first, 2 for second, etc.)
*			 2	0: No Action 1: Request storage information
*			 3	Reserved (all remaining params) */
                    MAV_CMD_REQUEST_STORAGE_INFORMATION = 525,
                    /**
*WIP: Format a storage medium. Once format is complete, a STORAGE_INFORMATION message is sent. Use the
*			 command's target_component to target a specific component's storage
*			 1	Storage ID (1 for first, 2 for second, etc.)
*			 2	0: No action 1: Format storage
*			 3	Reserved (all remaining params) */
                    MAV_CMD_STORAGE_FORMAT = 526,
                    /**
*WIP: Request camera capture status (CAMERA_CAPTURE_STATUS)
*			 1	0: No Action 1: Request camera capture status
*			 2	Reserved (all remaining params) */
                    MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS = 527,
                    /**
*WIP: Request flight information (FLIGHT_INFORMATION)
*			 1	1: Request flight information
*			 2	Reserved (all remaining params) */
                    MAV_CMD_REQUEST_FLIGHT_INFORMATION = 528,
                    /**
*WIP: Reset all camera settings to Factory Default
*			 1	0: No Action 1: Reset all settings
*			 2	Reserved (all remaining params) */
                    MAV_CMD_RESET_CAMERA_SETTINGS = 529,
                    /**
*Set camera running mode. Use NAN for reserved values.
*			 1	Reserved (Set to 0)
*			 2	Camera mode (see CAMERA_MODE enum)
*			 3	Reserved (all remaining params) */
                    MAV_CMD_SET_CAMERA_MODE = 530,
                    /**
*Start image capture sequence. Sends CAMERA_IMAGE_CAPTURED after each capture. Use NAN for reserved values
*			 1	Reserved (Set to 0)
*			 2	Duration between two consecutive pictures (in seconds)
*			 3	Number of images to capture total - 0 for unlimited capture
*			 4	Reserved (all remaining params) */
                    MAV_CMD_IMAGE_START_CAPTURE = 2000,
                    /**
*Stop image capture sequence Use NAN for reserved values.
*			 1	Reserved (Set to 0)
*			 2	Reserved (all remaining params) */
                    MAV_CMD_IMAGE_STOP_CAPTURE = 2001,
                    /**
*WIP: Re-request a CAMERA_IMAGE_CAPTURE packet. Use NAN for reserved values.
*			 1	Sequence number for missing CAMERA_IMAGE_CAPTURE packet
*			 2	Reserved (all remaining params) */
                    MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE = 2002,
                    /**
*Enable or disable on-board camera triggering system.
*			 1	Trigger enable/disable (0 for disable, 1 for start), -1 to ignore
*			 2	1 to reset the trigger sequence, -1 or 0 to ignore
*			 3	1 to pause triggering, but without switching the camera off or retracting it. -1 to ignore */
                    MAV_CMD_DO_TRIGGER_CONTROL = 2003,
                    /**
*Starts video capture (recording). Use NAN for reserved values.
*			 1	Reserved (Set to 0)
*			 2	Frequency CAMERA_CAPTURE_STATUS messages should be sent while recording (0 for no messages, otherwise frequency in Hz)
*			 3	Reserved (all remaining params) */
                    MAV_CMD_VIDEO_START_CAPTURE = 2500,
                    /**
*Stop the current video capture (recording). Use NAN for reserved values.
*			 1	Reserved (Set to 0)
*			 2	Reserved (all remaining params) */
                    MAV_CMD_VIDEO_STOP_CAPTURE = 2501,
                    /**
*WIP: Start video streaming
*			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
*			 2	Reserved */
                    MAV_CMD_VIDEO_START_STREAMING = 2502,
                    /**
*WIP: Stop the current video streaming
*			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
*			 2	Reserved */
                    MAV_CMD_VIDEO_STOP_STREAMING = 2503,
                    /**
*WIP: Request video stream information (VIDEO_STREAM_INFORMATION)
*			 1	Camera ID (0 for all cameras, 1 for first, 2 for second, etc.)
*			 2	0: No Action 1: Request video stream information
*			 3	Reserved (all remaining params) */
                    MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION = 2504,
                    /**
*Request to start streaming logging data over MAVLink (see also LOGGING_DATA message)
*			 1	Format: 0: ULog
*			 2	Reserved (set to 0)
*			 3	Reserved (set to 0)
*			 4	Reserved (set to 0)
*			 5	Reserved (set to 0)
*			 6	Reserved (set to 0)
*			 7	Reserved (set to 0) */
                    MAV_CMD_LOGGING_START = 2510,
                    /**
*Request to stop streaming log data over MAVLink
*			 1	Reserved (set to 0)
*			 2	Reserved (set to 0)
*			 3	Reserved (set to 0)
*			 4	Reserved (set to 0)
*			 5	Reserved (set to 0)
*			 6	Reserved (set to 0)
*			 7	Reserved (set to 0) */
                    MAV_CMD_LOGGING_STOP = 2511,
                    /**
*1	Landing gear ID (default: 0, -1 for all)
*			 2	Landing gear position (Down: 0, Up: 1, NAN for no change)
*			 3	Reserved, set to NAN
*			 4	Reserved, set to NAN
*			 5	Reserved, set to NAN
*			 6	Reserved, set to NAN
*			 7	Reserved, set to NAN */
                    MAV_CMD_AIRFRAME_CONFIGURATION = 2520,
                    /**
*Create a panorama at the current position
*			 1	Viewing angle horizontal of the panorama (in degrees, +- 0.5 the total angle)
*			 2	Viewing angle vertical of panorama (in degrees)
*			 3	Speed of the horizontal rotation (in degrees per second)
*			 4	Speed of the vertical rotation (in degrees per second) */
                    MAV_CMD_PANORAMA_CREATE = 2800,
                    /**
*Request VTOL transition
*			 1	The target VTOL state, as defined by ENUM MAV_VTOL_STATE. Only MAV_VTOL_STATE_MC and MAV_VTOL_STATE_FW can be used. */
                    MAV_CMD_DO_VTOL_TRANSITION = 3000,
                    /**
*Request authorization to arm the vehicle to a external entity, the arm authorizer is resposible to request all data that is needs from the vehicle before authorize or deny the request. If approved the progress of command_ack message should be set with period of time that this authorization is valid in seconds or in case it was denied it should be set with one of the reasons in ARM_AUTH_DENIED_REASON.
*			 <p>
*			 1	Vehicle system id, this way ground station can request arm authorization on behalf of any vehicle */
                    MAV_CMD_ARM_AUTHORIZATION_REQUEST = 3001,
                    /**
*This command sets the submode to standard guided when vehicle is in guided mode. The vehicle holds position and altitude and the user can input the desired velocites along all three axes. */
                    MAV_CMD_SET_GUIDED_SUBMODE_STANDARD = 4000,
                    /**
*This command sets submode circle when vehicle is in guided mode. Vehicle flies along a circle facing the center of the circle. The user can input the velocity along the circle and change the radius. If no input is given the vehicle will hold position.
*			 <p>
*			 1	Radius of desired circle in CIRCLE_MODE
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Unscaled target latitude of center of circle in CIRCLE_MODE
*			 6	Unscaled target longitude of center of circle in CIRCLE_MODE */
                    MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE = 4001,
                    /**
*WIP: Delay mission state machine until gate has been reached.
*			 1	Geometry: 0: orthogonal to path between previous and next waypoint.
*			 2	Altitude: 0: ignore altitude
*			 3	Empty
*			 4	Empty
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
                    MAV_CMD_CONDITION_GATE = 4501,
                    /**
*Fence return point. There can only be one fence return point.
*			 <p>
*			 1	Reserved
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
                    MAV_CMD_NAV_FENCE_RETURN_POINT = 5000,
                    /**
*Fence vertex for an inclusion polygon (the polygon must not be self-intersecting). The vehicle must stay within this area. Minimum of 3 vertices required.
*			 <p>
*			 1	Polygon vertex count
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Reserved */
                    MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION = 5001,
                    /**
*Fence vertex for an exclusion polygon (the polygon must not be self-intersecting). The vehicle must stay outside this area. Minimum of 3 vertices required.
*			 <p>
*			 1	Polygon vertex count
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Reserved */
                    MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION = 5002,
                    /**
*Circular fence area. The vehicle must stay inside this area.
*			 <p>
*			 1	radius in meters
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Reserved */
                    MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION = 5003,
                    /**
*Circular fence area. The vehicle must stay outside this area.
*			 <p>
*			 1	radius in meters
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Reserved */
                    MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION = 5004,
                    /**
*Rally point. You can have multiple rally points defined.
*			 <p>
*			 1	Reserved
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Latitude
*			 6	Longitude
*			 7	Altitude */
                    MAV_CMD_NAV_RALLY_POINT = 5100,
                    /**
*Commands the vehicle to respond with a sequence of messages UAVCAN_NODE_INFO, one message per every UAVCAN
*			 node that is online. Note that some of the response messages can be lost, which the receiver can detect
*			 easily by checking whether every received UAVCAN_NODE_STATUS has a matching message UAVCAN_NODE_INFO
*			 received earlier; if not, this command should be sent again in order to request re-transmission of the
*			 node information messages
*			 1	Reserved (set to 0)
*			 2	Reserved (set to 0)
*			 3	Reserved (set to 0)
*			 4	Reserved (set to 0)
*			 5	Reserved (set to 0)
*			 6	Reserved (set to 0)
*			 7	Reserved (set to 0) */
                    MAV_CMD_UAVCAN_GET_NODE_INFO = 5200,
                    /**
*Deploy payload on a Lat / Lon / Alt position. This includes the navigation to reach the required release
*			 position and velocity
*			 1	Operation mode. 0: prepare single payload deploy (overwriting previous requests), but do not execute it. 1: execute payload deploy immediately (rejecting further deploy commands during execution, but allowing abort). 2: add payload deploy to existing deployment list.
*			 2	Desired approach vector in degrees compass heading (0..360). A negative value indicates the system can define the approach vector at will.
*			 3	Desired ground speed at release time. This can be overriden by the airframe in case it needs to meet minimum airspeed. A negative value indicates the system can define the ground speed at will.
*			 4	Minimum altitude clearance to the release position in meters. A negative value indicates the system can define the clearance at will.
*			 5	Latitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT
*			 6	Longitude unscaled for MISSION_ITEM or in 1e7 degrees for MISSION_ITEM_INT
*			 7	Altitude, in meters AMSL */
                    MAV_CMD_PAYLOAD_PREPARE_DEPLOY = 30001,
                    /**
*Control the payload deployment.
*			 1	Operation mode. 0: Abort deployment, continue normal mission. 1: switch to payload deploment mode. 100: delete first payload deployment request. 101: delete all payload deployment requests.
*			 2	Reserved
*			 3	Reserved
*			 4	Reserved
*			 5	Reserved
*			 6	Reserved
*			 7	Reserved */
                    MAV_CMD_PAYLOAD_CONTROL_DEPLOY = 30002,
                    /**
*User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
                    MAV_CMD_WAYPOINT_USER_1 = 31000,
                    /**
*User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
                    MAV_CMD_WAYPOINT_USER_2 = 31001,
                    /**
*User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
                    MAV_CMD_WAYPOINT_USER_3 = 31002,
                    /**
*User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
                    MAV_CMD_WAYPOINT_USER_4 = 31003,
                    /**
*User defined waypoint item. Ground Station will show the Vehicle as flying through this item.
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
                    MAV_CMD_WAYPOINT_USER_5 = 31004,
                    /**
*User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
*			 ROI item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
                    MAV_CMD_SPATIAL_USER_1 = 31005,
                    /**
*User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
*			 ROI item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
                    MAV_CMD_SPATIAL_USER_2 = 31006,
                    /**
*User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
*			 ROI item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
                    MAV_CMD_SPATIAL_USER_3 = 31007,
                    /**
*User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
*			 ROI item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
                    MAV_CMD_SPATIAL_USER_4 = 31008,
                    /**
*User defined spatial item. Ground Station will not show the Vehicle as flying through this item. Example:
*			 ROI item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	Latitude unscaled
*			 6	Longitude unscaled
*			 7	Altitude, in meters AMSL */
                    MAV_CMD_SPATIAL_USER_5 = 31009,
                    /**
*User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
*			 item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	User defined
*			 6	User defined
*			 7	User defined */
                    MAV_CMD_USER_1 = 31010,
                    /**
*User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
*			 item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	User defined
*			 6	User defined
*			 7	User defined */
                    MAV_CMD_USER_2 = 31011,
                    /**
*User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
*			 item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	User defined
*			 6	User defined
*			 7	User defined */
                    MAV_CMD_USER_3 = 31012,
                    /**
*User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
*			 item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	User defined
*			 6	User defined
*			 7	User defined */
                    MAV_CMD_USER_4 = 31013,
                    /**
*User defined command. Ground Station will not show the Vehicle as flying through this item. Example: MAV_CMD_DO_SET_PARAMETER
*			 item
*			 1	User defined
*			 2	User defined
*			 3	User defined
*			 4	User defined
*			 5	User defined
*			 6	User defined
*			 7	User defined */
                    MAV_CMD_USER_5 = 31014,
                    /**
*A system wide power-off event has been initiated.
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_POWER_OFF_INITIATED = 42000,
                    /**
*FLY button has been clicked.
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_SOLO_BTN_FLY_CLICK = 42001,
                    /**
*FLY button has been held for 1.5 seconds.
*			 1	Takeoff altitude
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_SOLO_BTN_FLY_HOLD = 42002,
                    /**
*PAUSE button has been clicked.
*			 1	1 if Solo is in a shot mode, 0 otherwise
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_SOLO_BTN_PAUSE_CLICK = 42003,
                    /**
*Initiate a magnetometer calibration
*			 1	uint8_t bitmask of magnetometers (0 means all)
*			 2	Automatically retry on failure (0=no retry, 1=retry).
*			 3	Save without user input (0=require input, 1=autosave).
*			 4	Delay (seconds)
*			 5	Autoreboot (0=user reboot, 1=autoreboot)
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_START_MAG_CAL = 42424,
                    /**
*Initiate a magnetometer calibration
*			 1	uint8_t bitmask of magnetometers (0 means all)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_ACCEPT_MAG_CAL = 42425,
                    /**
*Cancel a running magnetometer calibration
*			 1	uint8_t bitmask of magnetometers (0 means all)
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_CANCEL_MAG_CAL = 42426,
                    /**
*Command autopilot to get into factory test/diagnostic mode
*			 1	0 means get out of test mode, 1 means get into test mode
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_SET_FACTORY_TEST_MODE = 42427,
                    /**
*Reply with the version banner
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_DO_SEND_BANNER = 42428,
                    /**
*Used when doing accelerometer calibration. When sent to the GCS tells it what position to put the vehicle
*			 in. When sent to the vehicle says what position the vehicle is in
*			 1	Position, one of the ACCELCAL_VEHICLE_POS enum values
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_ACCELCAL_VEHICLE_POS = 42429,
                    /**
*Causes the gimbal to reset and boot as if it was just powered on
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_GIMBAL_RESET = 42501,
                    /**
*Reports progress and success or failure of gimbal axis calibration procedure
*			 1	Gimbal axis we're reporting calibration progress for
*			 2	Current calibration progress for this axis, 0x64=100%
*			 3	Status of the calibration
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS = 42502,
                    /**
*Starts commutation calibration on the gimbal
*			 1	Empty
*			 2	Empty
*			 3	Empty
*			 4	Empty
*			 5	Empty
*			 6	Empty
*			 7	Empty */
                    MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION = 42503,
                    /**
*Erases gimbal application and parameters
*			 1	Magic number
*			 2	Magic number
*			 3	Magic number
*			 4	Magic number
*			 5	Magic number
*			 6	Magic number
*			 7	Magic number */
                    MAV_CMD_GIMBAL_FULL_RESET = 42505,
                }

                impl MAV_CMD {
                    pub fn from_bits(src: i32) -> Option<MAV_CMD> {
                        match src
                        {
                            0 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_WAYPOINT);
                            }
                            1 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_LOITER_UNLIM);
                            }
                            2 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_LOITER_TURNS);
                            }
                            3 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_LOITER_TIME);
                            }
                            4 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_RETURN_TO_LAUNCH);
                            }
                            5 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_LAND);
                            }
                            6 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_TAKEOFF);
                            }
                            7 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_LAND_LOCAL);
                            }
                            8 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_TAKEOFF_LOCAL);
                            }
                            9 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_FOLLOW);
                            }
                            10 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT);
                            }
                            11 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_LOITER_TO_ALT);
                            }
                            12 => {
                                return Some(MAV_CMD::MAV_CMD_DO_FOLLOW);
                            }
                            13 => {
                                return Some(MAV_CMD::MAV_CMD_DO_FOLLOW_REPOSITION);
                            }
                            14 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_ROI);
                            }
                            15 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_PATHPLANNING);
                            }
                            16 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_SPLINE_WAYPOINT);
                            }
                            17 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_ALTITUDE_WAIT);
                            }
                            18 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_VTOL_TAKEOFF);
                            }
                            19 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_VTOL_LAND);
                            }
                            20 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_GUIDED_ENABLE);
                            }
                            21 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_DELAY);
                            }
                            22 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_PAYLOAD_PLACE);
                            }
                            23 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_LAST);
                            }
                            24 => {
                                return Some(MAV_CMD::MAV_CMD_CONDITION_DELAY);
                            }
                            25 => {
                                return Some(MAV_CMD::MAV_CMD_CONDITION_CHANGE_ALT);
                            }
                            26 => {
                                return Some(MAV_CMD::MAV_CMD_CONDITION_DISTANCE);
                            }
                            27 => {
                                return Some(MAV_CMD::MAV_CMD_CONDITION_YAW);
                            }
                            28 => {
                                return Some(MAV_CMD::MAV_CMD_CONDITION_LAST);
                            }
                            29 => {
                                return Some(MAV_CMD::MAV_CMD_DO_SET_MODE);
                            }
                            30 => {
                                return Some(MAV_CMD::MAV_CMD_DO_JUMP);
                            }
                            31 => {
                                return Some(MAV_CMD::MAV_CMD_DO_CHANGE_SPEED);
                            }
                            32 => {
                                return Some(MAV_CMD::MAV_CMD_DO_SET_HOME);
                            }
                            33 => {
                                return Some(MAV_CMD::MAV_CMD_DO_SET_PARAMETER);
                            }
                            34 => {
                                return Some(MAV_CMD::MAV_CMD_DO_SET_RELAY);
                            }
                            35 => {
                                return Some(MAV_CMD::MAV_CMD_DO_REPEAT_RELAY);
                            }
                            36 => {
                                return Some(MAV_CMD::MAV_CMD_DO_SET_SERVO);
                            }
                            37 => {
                                return Some(MAV_CMD::MAV_CMD_DO_REPEAT_SERVO);
                            }
                            38 => {
                                return Some(MAV_CMD::MAV_CMD_DO_FLIGHTTERMINATION);
                            }
                            39 => {
                                return Some(MAV_CMD::MAV_CMD_DO_CHANGE_ALTITUDE);
                            }
                            40 => {
                                return Some(MAV_CMD::MAV_CMD_DO_LAND_START);
                            }
                            41 => {
                                return Some(MAV_CMD::MAV_CMD_DO_RALLY_LAND);
                            }
                            42 => {
                                return Some(MAV_CMD::MAV_CMD_DO_GO_AROUND);
                            }
                            43 => {
                                return Some(MAV_CMD::MAV_CMD_DO_REPOSITION);
                            }
                            44 => {
                                return Some(MAV_CMD::MAV_CMD_DO_PAUSE_CONTINUE);
                            }
                            45 => {
                                return Some(MAV_CMD::MAV_CMD_DO_SET_REVERSE);
                            }
                            46 => {
                                return Some(MAV_CMD::MAV_CMD_DO_CONTROL_VIDEO);
                            }
                            47 => {
                                return Some(MAV_CMD::MAV_CMD_DO_SET_ROI);
                            }
                            48 => {
                                return Some(MAV_CMD::MAV_CMD_DO_DIGICAM_CONFIGURE);
                            }
                            49 => {
                                return Some(MAV_CMD::MAV_CMD_DO_DIGICAM_CONTROL);
                            }
                            50 => {
                                return Some(MAV_CMD::MAV_CMD_DO_MOUNT_CONFIGURE);
                            }
                            51 => {
                                return Some(MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL);
                            }
                            52 => {
                                return Some(MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_DIST);
                            }
                            53 => {
                                return Some(MAV_CMD::MAV_CMD_DO_FENCE_ENABLE);
                            }
                            54 => {
                                return Some(MAV_CMD::MAV_CMD_DO_PARACHUTE);
                            }
                            55 => {
                                return Some(MAV_CMD::MAV_CMD_DO_MOTOR_TEST);
                            }
                            56 => {
                                return Some(MAV_CMD::MAV_CMD_DO_INVERTED_FLIGHT);
                            }
                            57 => {
                                return Some(MAV_CMD::MAV_CMD_DO_GRIPPER);
                            }
                            58 => {
                                return Some(MAV_CMD::MAV_CMD_DO_AUTOTUNE_ENABLE);
                            }
                            59 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_SET_YAW_SPEED);
                            }
                            60 => {
                                return Some(MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL);
                            }
                            61 => {
                                return Some(MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL_QUAT);
                            }
                            62 => {
                                return Some(MAV_CMD::MAV_CMD_DO_GUIDED_MASTER);
                            }
                            63 => {
                                return Some(MAV_CMD::MAV_CMD_DO_GUIDED_LIMITS);
                            }
                            64 => {
                                return Some(MAV_CMD::MAV_CMD_DO_ENGINE_CONTROL);
                            }
                            65 => {
                                return Some(MAV_CMD::MAV_CMD_DO_LAST);
                            }
                            66 => {
                                return Some(MAV_CMD::MAV_CMD_PREFLIGHT_CALIBRATION);
                            }
                            67 => {
                                return Some(MAV_CMD::MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS);
                            }
                            68 => {
                                return Some(MAV_CMD::MAV_CMD_PREFLIGHT_UAVCAN);
                            }
                            69 => {
                                return Some(MAV_CMD::MAV_CMD_PREFLIGHT_STORAGE);
                            }
                            70 => {
                                return Some(MAV_CMD::MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN);
                            }
                            71 => {
                                return Some(MAV_CMD::MAV_CMD_OVERRIDE_GOTO);
                            }
                            72 => {
                                return Some(MAV_CMD::MAV_CMD_MISSION_START);
                            }
                            73 => {
                                return Some(MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM);
                            }
                            74 => {
                                return Some(MAV_CMD::MAV_CMD_GET_HOME_POSITION);
                            }
                            75 => {
                                return Some(MAV_CMD::MAV_CMD_START_RX_PAIR);
                            }
                            76 => {
                                return Some(MAV_CMD::MAV_CMD_GET_MESSAGE_INTERVAL);
                            }
                            77 => {
                                return Some(MAV_CMD::MAV_CMD_SET_MESSAGE_INTERVAL);
                            }
                            78 => {
                                return Some(MAV_CMD::MAV_CMD_REQUEST_PROTOCOL_VERSION);
                            }
                            79 => {
                                return Some(MAV_CMD::MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES);
                            }
                            80 => {
                                return Some(MAV_CMD::MAV_CMD_REQUEST_CAMERA_INFORMATION);
                            }
                            81 => {
                                return Some(MAV_CMD::MAV_CMD_REQUEST_CAMERA_SETTINGS);
                            }
                            82 => {
                                return Some(MAV_CMD::MAV_CMD_REQUEST_STORAGE_INFORMATION);
                            }
                            83 => {
                                return Some(MAV_CMD::MAV_CMD_STORAGE_FORMAT);
                            }
                            84 => {
                                return Some(MAV_CMD::MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS);
                            }
                            85 => {
                                return Some(MAV_CMD::MAV_CMD_REQUEST_FLIGHT_INFORMATION);
                            }
                            86 => {
                                return Some(MAV_CMD::MAV_CMD_RESET_CAMERA_SETTINGS);
                            }
                            87 => {
                                return Some(MAV_CMD::MAV_CMD_SET_CAMERA_MODE);
                            }
                            88 => {
                                return Some(MAV_CMD::MAV_CMD_IMAGE_START_CAPTURE);
                            }
                            89 => {
                                return Some(MAV_CMD::MAV_CMD_IMAGE_STOP_CAPTURE);
                            }
                            90 => {
                                return Some(MAV_CMD::MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE);
                            }
                            91 => {
                                return Some(MAV_CMD::MAV_CMD_DO_TRIGGER_CONTROL);
                            }
                            92 => {
                                return Some(MAV_CMD::MAV_CMD_VIDEO_START_CAPTURE);
                            }
                            93 => {
                                return Some(MAV_CMD::MAV_CMD_VIDEO_STOP_CAPTURE);
                            }
                            94 => {
                                return Some(MAV_CMD::MAV_CMD_VIDEO_START_STREAMING);
                            }
                            95 => {
                                return Some(MAV_CMD::MAV_CMD_VIDEO_STOP_STREAMING);
                            }
                            96 => {
                                return Some(MAV_CMD::MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION);
                            }
                            97 => {
                                return Some(MAV_CMD::MAV_CMD_LOGGING_START);
                            }
                            98 => {
                                return Some(MAV_CMD::MAV_CMD_LOGGING_STOP);
                            }
                            99 => {
                                return Some(MAV_CMD::MAV_CMD_AIRFRAME_CONFIGURATION);
                            }
                            100 => {
                                return Some(MAV_CMD::MAV_CMD_PANORAMA_CREATE);
                            }
                            101 => {
                                return Some(MAV_CMD::MAV_CMD_DO_VTOL_TRANSITION);
                            }
                            102 => {
                                return Some(MAV_CMD::MAV_CMD_ARM_AUTHORIZATION_REQUEST);
                            }
                            103 => {
                                return Some(MAV_CMD::MAV_CMD_SET_GUIDED_SUBMODE_STANDARD);
                            }
                            104 => {
                                return Some(MAV_CMD::MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE);
                            }
                            105 => {
                                return Some(MAV_CMD::MAV_CMD_CONDITION_GATE);
                            }
                            106 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_FENCE_RETURN_POINT);
                            }
                            107 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION);
                            }
                            108 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION);
                            }
                            109 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION);
                            }
                            110 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION);
                            }
                            111 => {
                                return Some(MAV_CMD::MAV_CMD_NAV_RALLY_POINT);
                            }
                            112 => {
                                return Some(MAV_CMD::MAV_CMD_UAVCAN_GET_NODE_INFO);
                            }
                            113 => {
                                return Some(MAV_CMD::MAV_CMD_PAYLOAD_PREPARE_DEPLOY);
                            }
                            114 => {
                                return Some(MAV_CMD::MAV_CMD_PAYLOAD_CONTROL_DEPLOY);
                            }
                            115 => {
                                return Some(MAV_CMD::MAV_CMD_WAYPOINT_USER_1);
                            }
                            116 => {
                                return Some(MAV_CMD::MAV_CMD_WAYPOINT_USER_2);
                            }
                            117 => {
                                return Some(MAV_CMD::MAV_CMD_WAYPOINT_USER_3);
                            }
                            118 => {
                                return Some(MAV_CMD::MAV_CMD_WAYPOINT_USER_4);
                            }
                            119 => {
                                return Some(MAV_CMD::MAV_CMD_WAYPOINT_USER_5);
                            }
                            120 => {
                                return Some(MAV_CMD::MAV_CMD_SPATIAL_USER_1);
                            }
                            121 => {
                                return Some(MAV_CMD::MAV_CMD_SPATIAL_USER_2);
                            }
                            122 => {
                                return Some(MAV_CMD::MAV_CMD_SPATIAL_USER_3);
                            }
                            123 => {
                                return Some(MAV_CMD::MAV_CMD_SPATIAL_USER_4);
                            }
                            124 => {
                                return Some(MAV_CMD::MAV_CMD_SPATIAL_USER_5);
                            }
                            125 => {
                                return Some(MAV_CMD::MAV_CMD_USER_1);
                            }
                            126 => {
                                return Some(MAV_CMD::MAV_CMD_USER_2);
                            }
                            127 => {
                                return Some(MAV_CMD::MAV_CMD_USER_3);
                            }
                            128 => {
                                return Some(MAV_CMD::MAV_CMD_USER_4);
                            }
                            129 => {
                                return Some(MAV_CMD::MAV_CMD_USER_5);
                            }
                            130 => {
                                return Some(MAV_CMD::MAV_CMD_POWER_OFF_INITIATED);
                            }
                            131 => {
                                return Some(MAV_CMD::MAV_CMD_SOLO_BTN_FLY_CLICK);
                            }
                            132 => {
                                return Some(MAV_CMD::MAV_CMD_SOLO_BTN_FLY_HOLD);
                            }
                            133 => {
                                return Some(MAV_CMD::MAV_CMD_SOLO_BTN_PAUSE_CLICK);
                            }
                            134 => {
                                return Some(MAV_CMD::MAV_CMD_DO_START_MAG_CAL);
                            }
                            135 => {
                                return Some(MAV_CMD::MAV_CMD_DO_ACCEPT_MAG_CAL);
                            }
                            136 => {
                                return Some(MAV_CMD::MAV_CMD_DO_CANCEL_MAG_CAL);
                            }
                            137 => {
                                return Some(MAV_CMD::MAV_CMD_SET_FACTORY_TEST_MODE);
                            }
                            138 => {
                                return Some(MAV_CMD::MAV_CMD_DO_SEND_BANNER);
                            }
                            139 => {
                                return Some(MAV_CMD::MAV_CMD_ACCELCAL_VEHICLE_POS);
                            }
                            140 => {
                                return Some(MAV_CMD::MAV_CMD_GIMBAL_RESET);
                            }
                            141 => {
                                return Some(MAV_CMD::MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS);
                            }
                            142 => {
                                return Some(MAV_CMD::MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION);
                            }
                            143 => {
                                return Some(MAV_CMD::MAV_CMD_GIMBAL_FULL_RESET);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            MAV_CMD::MAV_CMD_NAV_WAYPOINT => {
                                return 0;
                            }
                            MAV_CMD::MAV_CMD_NAV_LOITER_UNLIM => {
                                return 1;
                            }
                            MAV_CMD::MAV_CMD_NAV_LOITER_TURNS => {
                                return 2;
                            }
                            MAV_CMD::MAV_CMD_NAV_LOITER_TIME => {
                                return 3;
                            }
                            MAV_CMD::MAV_CMD_NAV_RETURN_TO_LAUNCH => {
                                return 4;
                            }
                            MAV_CMD::MAV_CMD_NAV_LAND => {
                                return 5;
                            }
                            MAV_CMD::MAV_CMD_NAV_TAKEOFF => {
                                return 6;
                            }
                            MAV_CMD::MAV_CMD_NAV_LAND_LOCAL => {
                                return 7;
                            }
                            MAV_CMD::MAV_CMD_NAV_TAKEOFF_LOCAL => {
                                return 8;
                            }
                            MAV_CMD::MAV_CMD_NAV_FOLLOW => {
                                return 9;
                            }
                            MAV_CMD::MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT => {
                                return 10;
                            }
                            MAV_CMD::MAV_CMD_NAV_LOITER_TO_ALT => {
                                return 11;
                            }
                            MAV_CMD::MAV_CMD_DO_FOLLOW => {
                                return 12;
                            }
                            MAV_CMD::MAV_CMD_DO_FOLLOW_REPOSITION => {
                                return 13;
                            }
                            MAV_CMD::MAV_CMD_NAV_ROI => {
                                return 14;
                            }
                            MAV_CMD::MAV_CMD_NAV_PATHPLANNING => {
                                return 15;
                            }
                            MAV_CMD::MAV_CMD_NAV_SPLINE_WAYPOINT => {
                                return 16;
                            }
                            MAV_CMD::MAV_CMD_NAV_ALTITUDE_WAIT => {
                                return 17;
                            }
                            MAV_CMD::MAV_CMD_NAV_VTOL_TAKEOFF => {
                                return 18;
                            }
                            MAV_CMD::MAV_CMD_NAV_VTOL_LAND => {
                                return 19;
                            }
                            MAV_CMD::MAV_CMD_NAV_GUIDED_ENABLE => {
                                return 20;
                            }
                            MAV_CMD::MAV_CMD_NAV_DELAY => {
                                return 21;
                            }
                            MAV_CMD::MAV_CMD_NAV_PAYLOAD_PLACE => {
                                return 22;
                            }
                            MAV_CMD::MAV_CMD_NAV_LAST => {
                                return 23;
                            }
                            MAV_CMD::MAV_CMD_CONDITION_DELAY => {
                                return 24;
                            }
                            MAV_CMD::MAV_CMD_CONDITION_CHANGE_ALT => {
                                return 25;
                            }
                            MAV_CMD::MAV_CMD_CONDITION_DISTANCE => {
                                return 26;
                            }
                            MAV_CMD::MAV_CMD_CONDITION_YAW => {
                                return 27;
                            }
                            MAV_CMD::MAV_CMD_CONDITION_LAST => {
                                return 28;
                            }
                            MAV_CMD::MAV_CMD_DO_SET_MODE => {
                                return 29;
                            }
                            MAV_CMD::MAV_CMD_DO_JUMP => {
                                return 30;
                            }
                            MAV_CMD::MAV_CMD_DO_CHANGE_SPEED => {
                                return 31;
                            }
                            MAV_CMD::MAV_CMD_DO_SET_HOME => {
                                return 32;
                            }
                            MAV_CMD::MAV_CMD_DO_SET_PARAMETER => {
                                return 33;
                            }
                            MAV_CMD::MAV_CMD_DO_SET_RELAY => {
                                return 34;
                            }
                            MAV_CMD::MAV_CMD_DO_REPEAT_RELAY => {
                                return 35;
                            }
                            MAV_CMD::MAV_CMD_DO_SET_SERVO => {
                                return 36;
                            }
                            MAV_CMD::MAV_CMD_DO_REPEAT_SERVO => {
                                return 37;
                            }
                            MAV_CMD::MAV_CMD_DO_FLIGHTTERMINATION => {
                                return 38;
                            }
                            MAV_CMD::MAV_CMD_DO_CHANGE_ALTITUDE => {
                                return 39;
                            }
                            MAV_CMD::MAV_CMD_DO_LAND_START => {
                                return 40;
                            }
                            MAV_CMD::MAV_CMD_DO_RALLY_LAND => {
                                return 41;
                            }
                            MAV_CMD::MAV_CMD_DO_GO_AROUND => {
                                return 42;
                            }
                            MAV_CMD::MAV_CMD_DO_REPOSITION => {
                                return 43;
                            }
                            MAV_CMD::MAV_CMD_DO_PAUSE_CONTINUE => {
                                return 44;
                            }
                            MAV_CMD::MAV_CMD_DO_SET_REVERSE => {
                                return 45;
                            }
                            MAV_CMD::MAV_CMD_DO_CONTROL_VIDEO => {
                                return 46;
                            }
                            MAV_CMD::MAV_CMD_DO_SET_ROI => {
                                return 47;
                            }
                            MAV_CMD::MAV_CMD_DO_DIGICAM_CONFIGURE => {
                                return 48;
                            }
                            MAV_CMD::MAV_CMD_DO_DIGICAM_CONTROL => {
                                return 49;
                            }
                            MAV_CMD::MAV_CMD_DO_MOUNT_CONFIGURE => {
                                return 50;
                            }
                            MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL => {
                                return 51;
                            }
                            MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_DIST => {
                                return 52;
                            }
                            MAV_CMD::MAV_CMD_DO_FENCE_ENABLE => {
                                return 53;
                            }
                            MAV_CMD::MAV_CMD_DO_PARACHUTE => {
                                return 54;
                            }
                            MAV_CMD::MAV_CMD_DO_MOTOR_TEST => {
                                return 55;
                            }
                            MAV_CMD::MAV_CMD_DO_INVERTED_FLIGHT => {
                                return 56;
                            }
                            MAV_CMD::MAV_CMD_DO_GRIPPER => {
                                return 57;
                            }
                            MAV_CMD::MAV_CMD_DO_AUTOTUNE_ENABLE => {
                                return 58;
                            }
                            MAV_CMD::MAV_CMD_NAV_SET_YAW_SPEED => {
                                return 59;
                            }
                            MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL => {
                                return 60;
                            }
                            MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL_QUAT => {
                                return 61;
                            }
                            MAV_CMD::MAV_CMD_DO_GUIDED_MASTER => {
                                return 62;
                            }
                            MAV_CMD::MAV_CMD_DO_GUIDED_LIMITS => {
                                return 63;
                            }
                            MAV_CMD::MAV_CMD_DO_ENGINE_CONTROL => {
                                return 64;
                            }
                            MAV_CMD::MAV_CMD_DO_LAST => {
                                return 65;
                            }
                            MAV_CMD::MAV_CMD_PREFLIGHT_CALIBRATION => {
                                return 66;
                            }
                            MAV_CMD::MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS => {
                                return 67;
                            }
                            MAV_CMD::MAV_CMD_PREFLIGHT_UAVCAN => {
                                return 68;
                            }
                            MAV_CMD::MAV_CMD_PREFLIGHT_STORAGE => {
                                return 69;
                            }
                            MAV_CMD::MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN => {
                                return 70;
                            }
                            MAV_CMD::MAV_CMD_OVERRIDE_GOTO => {
                                return 71;
                            }
                            MAV_CMD::MAV_CMD_MISSION_START => {
                                return 72;
                            }
                            MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM => {
                                return 73;
                            }
                            MAV_CMD::MAV_CMD_GET_HOME_POSITION => {
                                return 74;
                            }
                            MAV_CMD::MAV_CMD_START_RX_PAIR => {
                                return 75;
                            }
                            MAV_CMD::MAV_CMD_GET_MESSAGE_INTERVAL => {
                                return 76;
                            }
                            MAV_CMD::MAV_CMD_SET_MESSAGE_INTERVAL => {
                                return 77;
                            }
                            MAV_CMD::MAV_CMD_REQUEST_PROTOCOL_VERSION => {
                                return 78;
                            }
                            MAV_CMD::MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES => {
                                return 79;
                            }
                            MAV_CMD::MAV_CMD_REQUEST_CAMERA_INFORMATION => {
                                return 80;
                            }
                            MAV_CMD::MAV_CMD_REQUEST_CAMERA_SETTINGS => {
                                return 81;
                            }
                            MAV_CMD::MAV_CMD_REQUEST_STORAGE_INFORMATION => {
                                return 82;
                            }
                            MAV_CMD::MAV_CMD_STORAGE_FORMAT => {
                                return 83;
                            }
                            MAV_CMD::MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS => {
                                return 84;
                            }
                            MAV_CMD::MAV_CMD_REQUEST_FLIGHT_INFORMATION => {
                                return 85;
                            }
                            MAV_CMD::MAV_CMD_RESET_CAMERA_SETTINGS => {
                                return 86;
                            }
                            MAV_CMD::MAV_CMD_SET_CAMERA_MODE => {
                                return 87;
                            }
                            MAV_CMD::MAV_CMD_IMAGE_START_CAPTURE => {
                                return 88;
                            }
                            MAV_CMD::MAV_CMD_IMAGE_STOP_CAPTURE => {
                                return 89;
                            }
                            MAV_CMD::MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE => {
                                return 90;
                            }
                            MAV_CMD::MAV_CMD_DO_TRIGGER_CONTROL => {
                                return 91;
                            }
                            MAV_CMD::MAV_CMD_VIDEO_START_CAPTURE => {
                                return 92;
                            }
                            MAV_CMD::MAV_CMD_VIDEO_STOP_CAPTURE => {
                                return 93;
                            }
                            MAV_CMD::MAV_CMD_VIDEO_START_STREAMING => {
                                return 94;
                            }
                            MAV_CMD::MAV_CMD_VIDEO_STOP_STREAMING => {
                                return 95;
                            }
                            MAV_CMD::MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION => {
                                return 96;
                            }
                            MAV_CMD::MAV_CMD_LOGGING_START => {
                                return 97;
                            }
                            MAV_CMD::MAV_CMD_LOGGING_STOP => {
                                return 98;
                            }
                            MAV_CMD::MAV_CMD_AIRFRAME_CONFIGURATION => {
                                return 99;
                            }
                            MAV_CMD::MAV_CMD_PANORAMA_CREATE => {
                                return 100;
                            }
                            MAV_CMD::MAV_CMD_DO_VTOL_TRANSITION => {
                                return 101;
                            }
                            MAV_CMD::MAV_CMD_ARM_AUTHORIZATION_REQUEST => {
                                return 102;
                            }
                            MAV_CMD::MAV_CMD_SET_GUIDED_SUBMODE_STANDARD => {
                                return 103;
                            }
                            MAV_CMD::MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE => {
                                return 104;
                            }
                            MAV_CMD::MAV_CMD_CONDITION_GATE => {
                                return 105;
                            }
                            MAV_CMD::MAV_CMD_NAV_FENCE_RETURN_POINT => {
                                return 106;
                            }
                            MAV_CMD::MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION => {
                                return 107;
                            }
                            MAV_CMD::MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION => {
                                return 108;
                            }
                            MAV_CMD::MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION => {
                                return 109;
                            }
                            MAV_CMD::MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION => {
                                return 110;
                            }
                            MAV_CMD::MAV_CMD_NAV_RALLY_POINT => {
                                return 111;
                            }
                            MAV_CMD::MAV_CMD_UAVCAN_GET_NODE_INFO => {
                                return 112;
                            }
                            MAV_CMD::MAV_CMD_PAYLOAD_PREPARE_DEPLOY => {
                                return 113;
                            }
                            MAV_CMD::MAV_CMD_PAYLOAD_CONTROL_DEPLOY => {
                                return 114;
                            }
                            MAV_CMD::MAV_CMD_WAYPOINT_USER_1 => {
                                return 115;
                            }
                            MAV_CMD::MAV_CMD_WAYPOINT_USER_2 => {
                                return 116;
                            }
                            MAV_CMD::MAV_CMD_WAYPOINT_USER_3 => {
                                return 117;
                            }
                            MAV_CMD::MAV_CMD_WAYPOINT_USER_4 => {
                                return 118;
                            }
                            MAV_CMD::MAV_CMD_WAYPOINT_USER_5 => {
                                return 119;
                            }
                            MAV_CMD::MAV_CMD_SPATIAL_USER_1 => {
                                return 120;
                            }
                            MAV_CMD::MAV_CMD_SPATIAL_USER_2 => {
                                return 121;
                            }
                            MAV_CMD::MAV_CMD_SPATIAL_USER_3 => {
                                return 122;
                            }
                            MAV_CMD::MAV_CMD_SPATIAL_USER_4 => {
                                return 123;
                            }
                            MAV_CMD::MAV_CMD_SPATIAL_USER_5 => {
                                return 124;
                            }
                            MAV_CMD::MAV_CMD_USER_1 => {
                                return 125;
                            }
                            MAV_CMD::MAV_CMD_USER_2 => {
                                return 126;
                            }
                            MAV_CMD::MAV_CMD_USER_3 => {
                                return 127;
                            }
                            MAV_CMD::MAV_CMD_USER_4 => {
                                return 128;
                            }
                            MAV_CMD::MAV_CMD_USER_5 => {
                                return 129;
                            }
                            MAV_CMD::MAV_CMD_POWER_OFF_INITIATED => {
                                return 130;
                            }
                            MAV_CMD::MAV_CMD_SOLO_BTN_FLY_CLICK => {
                                return 131;
                            }
                            MAV_CMD::MAV_CMD_SOLO_BTN_FLY_HOLD => {
                                return 132;
                            }
                            MAV_CMD::MAV_CMD_SOLO_BTN_PAUSE_CLICK => {
                                return 133;
                            }
                            MAV_CMD::MAV_CMD_DO_START_MAG_CAL => {
                                return 134;
                            }
                            MAV_CMD::MAV_CMD_DO_ACCEPT_MAG_CAL => {
                                return 135;
                            }
                            MAV_CMD::MAV_CMD_DO_CANCEL_MAG_CAL => {
                                return 136;
                            }
                            MAV_CMD::MAV_CMD_SET_FACTORY_TEST_MODE => {
                                return 137;
                            }
                            MAV_CMD::MAV_CMD_DO_SEND_BANNER => {
                                return 138;
                            }
                            MAV_CMD::MAV_CMD_ACCELCAL_VEHICLE_POS => {
                                return 139;
                            }
                            MAV_CMD::MAV_CMD_GIMBAL_RESET => {
                                return 140;
                            }
                            MAV_CMD::MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS => {
                                return 141;
                            }
                            MAV_CMD::MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION => {
                                return 142;
                            }
                            MAV_CMD::MAV_CMD_GIMBAL_FULL_RESET => {
                                return 143;
                            }
                        }
                    }
                }

                /**
*Camera Modes. */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum CAMERA_MODE {
                    CAMERA_MODE_IMAGE = 0,
                    //Camera is in image/photo capture mode.
                    CAMERA_MODE_VIDEO = 1,
                    //Camera is in video capture mode.
                    CAMERA_MODE_IMAGE_SURVEY = 2,//Camera is in image survey capture mode. It allows for camera controller to do specific settings for surveys
                }

                impl CAMERA_MODE {
                    pub fn from_bits(src: i8) -> Option<CAMERA_MODE> {
                        match src
                        {
                            0 => Some(CAMERA_MODE::CAMERA_MODE_IMAGE),
                            1 => Some(CAMERA_MODE::CAMERA_MODE_VIDEO),
                            2 => Some(CAMERA_MODE::CAMERA_MODE_IMAGE_SURVEY),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Source of information about this collision. */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_COLLISION_SRC {
                    MAV_COLLISION_SRC_ADSB = 0,
                    //ID field references ADSB_VEHICLE packets
                    MAV_COLLISION_SRC_MAVLINK_GPS_GLOBAL_INT = 1,//ID field references MAVLink SRC ID
                }

                impl MAV_COLLISION_SRC {
                    pub fn from_bits(src: i8) -> Option<MAV_COLLISION_SRC> {
                        match src
                        {
                            0 => Some(MAV_COLLISION_SRC::MAV_COLLISION_SRC_ADSB),
                            1 => Some(MAV_COLLISION_SRC::MAV_COLLISION_SRC_MAVLINK_GPS_GLOBAL_INT),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Possible remote log data block statuses */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_REMOTE_LOG_DATA_BLOCK_STATUSES {
                    MAV_REMOTE_LOG_DATA_BLOCK_NACK = 0,
                    //This block has NOT been received
                    MAV_REMOTE_LOG_DATA_BLOCK_ACK = 1,//This block has been received
                }

                impl MAV_REMOTE_LOG_DATA_BLOCK_STATUSES {
                    pub fn from_bits(src: i8) -> Option<MAV_REMOTE_LOG_DATA_BLOCK_STATUSES> {
                        match src
                        {
                            0 => Some(MAV_REMOTE_LOG_DATA_BLOCK_STATUSES::MAV_REMOTE_LOG_DATA_BLOCK_NACK),
                            1 => Some(MAV_REMOTE_LOG_DATA_BLOCK_STATUSES::MAV_REMOTE_LOG_DATA_BLOCK_ACK),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Status flags for ADS-B transponder dynamic output */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum UAVIONIX_ADSB_RF_HEALTH {
                    UAVIONIX_ADSB_RF_HEALTH_INITIALIZING = 0,
                    UAVIONIX_ADSB_RF_HEALTH_OK = 1,
                    UAVIONIX_ADSB_RF_HEALTH_FAIL_TX = 2,
                    UAVIONIX_ADSB_RF_HEALTH_FAIL_RX = 16,
                }

                impl UAVIONIX_ADSB_RF_HEALTH {
                    pub fn from_bits(src: i32) -> Option<UAVIONIX_ADSB_RF_HEALTH> {
                        match src
                        {
                            0 => {
                                return Some(UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_INITIALIZING);
                            }
                            1 => {
                                return Some(UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_OK);
                            }
                            2 => {
                                return Some(UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_FAIL_TX);
                            }
                            3 => {
                                return Some(UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_FAIL_RX);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_INITIALIZING => {
                                return 0;
                            }
                            UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_OK => {
                                return 1;
                            }
                            UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_FAIL_TX => {
                                return 2;
                            }
                            UAVIONIX_ADSB_RF_HEALTH::UAVIONIX_ADSB_RF_HEALTH_FAIL_RX => {
                                return 3;
                            }
                        }
                    }
                }

                /**
*result from a mavlink command */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_RESULT {
                    MAV_RESULT_ACCEPTED = 0,
                    //Command ACCEPTED and EXECUTED
                    MAV_RESULT_TEMPORARILY_REJECTED = 1,
                    //Command TEMPORARY REJECTED/DENIED
                    MAV_RESULT_DENIED = 2,
                    //Command PERMANENTLY DENIED
                    MAV_RESULT_UNSUPPORTED = 3,
                    //Command UNKNOWN/UNSUPPORTED
                    MAV_RESULT_FAILED = 4,
                    //Command executed, but failed
                    MAV_RESULT_IN_PROGRESS = 5,//WIP: Command being executed
                }

                impl MAV_RESULT {
                    pub fn from_bits(src: i8) -> Option<MAV_RESULT> {
                        match src
                        {
                            0 => Some(MAV_RESULT::MAV_RESULT_ACCEPTED),
                            1 => Some(MAV_RESULT::MAV_RESULT_TEMPORARILY_REJECTED),
                            2 => Some(MAV_RESULT::MAV_RESULT_DENIED),
                            3 => Some(MAV_RESULT::MAV_RESULT_UNSUPPORTED),
                            4 => Some(MAV_RESULT::MAV_RESULT_FAILED),
                            5 => Some(MAV_RESULT::MAV_RESULT_IN_PROGRESS),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Special ACK block numbers control activation of dataflash log streaming */
                #[derive(PartialEq, Debug)]
                #[repr(u32)]
                pub enum MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS {
                    MAV_REMOTE_LOG_DATA_BLOCK_STOP = 2147483645,
                    //UAV to stop sending DataFlash blocks
                    MAV_REMOTE_LOG_DATA_BLOCK_START = 2147483646,//UAV to start sending DataFlash blocks
                }

                impl MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS {
                    pub fn from_bits(src: u32) -> Option<MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS> {
                        match src
                        {
                            2147483645 => Some(MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS::MAV_REMOTE_LOG_DATA_BLOCK_STOP),
                            2147483646 => Some(MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS::MAV_REMOTE_LOG_DATA_BLOCK_START),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> u32 {
                        self as u32
                    }
                }

                /**
*Status for ADS-B transponder dynamic input */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX {
                    UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_0 = 0,
                    UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_1 = 1,
                    UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_2D = 2,
                    UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_3D = 3,
                    UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_DGPS = 4,
                    UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_RTK = 5,
                }

                impl UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX {
                    pub fn from_bits(src: i8) -> Option<UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX> {
                        match src
                        {
                            0 => Some(UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX::UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_0),
                            1 => Some(UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX::UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_1),
                            2 => Some(UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX::UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_2D),
                            3 => Some(UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX::UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_3D),
                            4 => Some(UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX::UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_DGPS),
                            5 => Some(UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX::UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_RTK),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum GOPRO_COMMAND {
                    GOPRO_COMMAND_POWER = 0,
                    //(Get/Set)
                    GOPRO_COMMAND_CAPTURE_MODE = 1,
                    //(Get/Set)
                    GOPRO_COMMAND_SHUTTER = 2,
                    //(___/Set)
                    GOPRO_COMMAND_BATTERY = 3,
                    //(Get/___)
                    GOPRO_COMMAND_MODEL = 4,
                    //(Get/___)
                    GOPRO_COMMAND_VIDEO_SETTINGS = 5,
                    //(Get/Set)
                    GOPRO_COMMAND_LOW_LIGHT = 6,
                    //(Get/Set)
                    GOPRO_COMMAND_PHOTO_RESOLUTION = 7,
                    //(Get/Set)
                    GOPRO_COMMAND_PHOTO_BURST_RATE = 8,
                    //(Get/Set)
                    GOPRO_COMMAND_PROTUNE = 9,
                    //(Get/Set)
                    GOPRO_COMMAND_PROTUNE_WHITE_BALANCE = 10,
                    //(Get/Set) Hero 3+ Only
                    GOPRO_COMMAND_PROTUNE_COLOUR = 11,
                    //(Get/Set) Hero 3+ Only
                    GOPRO_COMMAND_PROTUNE_GAIN = 12,
                    //(Get/Set) Hero 3+ Only
                    GOPRO_COMMAND_PROTUNE_SHARPNESS = 13,
                    //(Get/Set) Hero 3+ Only
                    GOPRO_COMMAND_PROTUNE_EXPOSURE = 14,
                    //(Get/Set) Hero 3+ Only
                    GOPRO_COMMAND_TIME = 15,
                    //(Get/Set)
                    GOPRO_COMMAND_CHARGING = 16,//(Get/Set)
                }

                impl GOPRO_COMMAND {
                    pub fn from_bits(src: i8) -> Option<GOPRO_COMMAND> {
                        match src
                        {
                            0 => Some(GOPRO_COMMAND::GOPRO_COMMAND_POWER),
                            1 => Some(GOPRO_COMMAND::GOPRO_COMMAND_CAPTURE_MODE),
                            2 => Some(GOPRO_COMMAND::GOPRO_COMMAND_SHUTTER),
                            3 => Some(GOPRO_COMMAND::GOPRO_COMMAND_BATTERY),
                            4 => Some(GOPRO_COMMAND::GOPRO_COMMAND_MODEL),
                            5 => Some(GOPRO_COMMAND::GOPRO_COMMAND_VIDEO_SETTINGS),
                            6 => Some(GOPRO_COMMAND::GOPRO_COMMAND_LOW_LIGHT),
                            7 => Some(GOPRO_COMMAND::GOPRO_COMMAND_PHOTO_RESOLUTION),
                            8 => Some(GOPRO_COMMAND::GOPRO_COMMAND_PHOTO_BURST_RATE),
                            9 => Some(GOPRO_COMMAND::GOPRO_COMMAND_PROTUNE),
                            10 => Some(GOPRO_COMMAND::GOPRO_COMMAND_PROTUNE_WHITE_BALANCE),
                            11 => Some(GOPRO_COMMAND::GOPRO_COMMAND_PROTUNE_COLOUR),
                            12 => Some(GOPRO_COMMAND::GOPRO_COMMAND_PROTUNE_GAIN),
                            13 => Some(GOPRO_COMMAND::GOPRO_COMMAND_PROTUNE_SHARPNESS),
                            14 => Some(GOPRO_COMMAND::GOPRO_COMMAND_PROTUNE_EXPOSURE),
                            15 => Some(GOPRO_COMMAND::GOPRO_COMMAND_TIME),
                            16 => Some(GOPRO_COMMAND::GOPRO_COMMAND_CHARGING),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum GOPRO_REQUEST_STATUS {
                    GOPRO_REQUEST_SUCCESS = 0,
                    //The write message with ID indicated succeeded
                    GOPRO_REQUEST_FAILED = 1,//The write message with ID indicated failed
                }

                impl GOPRO_REQUEST_STATUS {
                    pub fn from_bits(src: i8) -> Option<GOPRO_REQUEST_STATUS> {
                        match src
                        {
                            0 => Some(GOPRO_REQUEST_STATUS::GOPRO_REQUEST_SUCCESS),
                            1 => Some(GOPRO_REQUEST_STATUS::GOPRO_REQUEST_FAILED),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Definitions for aircraft size */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE {
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_NO_DATA = 0,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L15M_W23M = 1,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25M_W28P5M = 2,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25_34M = 3,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_33M = 4,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_38M = 5,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_39P5M = 6,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_45M = 7,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_45M = 8,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_52M = 9,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_59P5M = 10,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_67M = 11,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W72P5M = 12,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W80M = 13,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W80M = 14,
                    UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W90M = 15,
                }

                impl UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE {
                    pub fn from_bits(src: i8) -> Option<UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE> {
                        match src
                        {
                            0 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_NO_DATA),
                            1 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L15M_W23M),
                            2 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25M_W28P5M),
                            3 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25_34M),
                            4 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_33M),
                            5 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_38M),
                            6 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_39P5M),
                            7 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_45M),
                            8 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_45M),
                            9 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_52M),
                            10 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_59P5M),
                            11 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_67M),
                            12 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W72P5M),
                            13 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W80M),
                            14 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W80M),
                            15 => Some(UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE::UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W90M),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_STATE {
                    UNINIT = 0,
                    //Uninitialized system, state is unknown.
                    ACTIVE = 1,
                    //System is active and might be already airborne. Motors are engaged.
                    BOOT = 2,
                    //System is booting up.
                    CALIBRATING = 3,
                    //System is calibrating and not flight-ready.
                    CRITICAL = 4,
                    //System is in a non-normal flight mode. It can however still navigate.
                    /**
*System is in a non-normal flight mode. It lost control over parts or over the whole airframe. It is in
*			 mayday and going down */
                    EMERGENCY = 5,
                    FLIGHT_TERMINATION = 6,
                    //System is terminating itself.
                    POWEROFF = 7,
                    //System just initialized its power-down sequence, will shut down now.
                    STANDBY = 8,//System is grounded and on standby. It can be launched any time.
                }

                impl MAV_STATE {
                    pub fn from_bits(src: i8) -> Option<MAV_STATE> {
                        match src
                        {
                            0 => Some(MAV_STATE::UNINIT),
                            1 => Some(MAV_STATE::ACTIVE),
                            2 => Some(MAV_STATE::BOOT),
                            3 => Some(MAV_STATE::CALIBRATING),
                            4 => Some(MAV_STATE::CRITICAL),
                            5 => Some(MAV_STATE::EMERGENCY),
                            6 => Some(MAV_STATE::FLIGHT_TERMINATION),
                            7 => Some(MAV_STATE::POWEROFF),
                            8 => Some(MAV_STATE::STANDBY),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*SERIAL_CONTROL flags (bitmask) */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum SERIAL_CONTROL_FLAG {
                    SERIAL_CONTROL_FLAG_REPLY = 1,
                    //Set if this is a reply
                    SERIAL_CONTROL_FLAG_RESPOND = 2,
                    //Set if the sender wants the receiver to send a response as another SERIAL_CONTROL message
                    /**
*Set if access to the serial port should be removed from whatever driver is currently using it, giving
*			 exclusive access to the SERIAL_CONTROL protocol. The port can be handed back by sending a request without
*			 this flag se */
                    SERIAL_CONTROL_FLAG_EXCLUSIVE = 4,
                    SERIAL_CONTROL_FLAG_BLOCKING = 8,
                    //Block on writes to the serial port
                    SERIAL_CONTROL_FLAG_MULTI = 16,//Send multiple replies until port is drained
                }

                impl SERIAL_CONTROL_FLAG {
                    pub fn from_bits(src: i32) -> Option<SERIAL_CONTROL_FLAG> {
                        match src
                        {
                            0 => {
                                return Some(SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_REPLY);
                            }
                            1 => {
                                return Some(SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_RESPOND);
                            }
                            2 => {
                                return Some(SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_EXCLUSIVE);
                            }
                            3 => {
                                return Some(SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_BLOCKING);
                            }
                            4 => {
                                return Some(SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_MULTI);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_REPLY => {
                                return 0;
                            }
                            SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_RESPOND => {
                                return 1;
                            }
                            SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_EXCLUSIVE => {
                                return 2;
                            }
                            SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_BLOCKING => {
                                return 3;
                            }
                            SERIAL_CONTROL_FLAG::SERIAL_CONTROL_FLAG_MULTI => {
                                return 4;
                            }
                        }
                    }
                }

                /**
*Camera capability flags (Bitmap). */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum CAMERA_CAP_FLAGS {
                    CAMERA_CAP_FLAGS_CAPTURE_VIDEO = 1,
                    //Camera is able to record video.
                    CAMERA_CAP_FLAGS_CAPTURE_IMAGE = 2,
                    //Camera is able to capture images.
                    CAMERA_CAP_FLAGS_HAS_MODES = 4,
                    //Camera has separate Video and Image/Photo modes (MAV_CMD_SET_CAMERA_MODE)
                    CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE = 8,
                    //Camera can capture images while in video mode
                    CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE = 16,
                    //Camera can capture videos while in Photo/Image mode
                    CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE = 32,//Camera has image survey mode (MAV_CMD_SET_CAMERA_MODE)
                }

                impl CAMERA_CAP_FLAGS {
                    pub fn from_bits(src: i32) -> Option<CAMERA_CAP_FLAGS> {
                        match src
                        {
                            0 => {
                                return Some(CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAPTURE_VIDEO);
                            }
                            1 => {
                                return Some(CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAPTURE_IMAGE);
                            }
                            2 => {
                                return Some(CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_HAS_MODES);
                            }
                            3 => {
                                return Some(CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE);
                            }
                            4 => {
                                return Some(CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE);
                            }
                            5 => {
                                return Some(CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAPTURE_VIDEO => {
                                return 0;
                            }
                            CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAPTURE_IMAGE => {
                                return 1;
                            }
                            CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_HAS_MODES => {
                                return 2;
                            }
                            CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE => {
                                return 3;
                            }
                            CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE => {
                                return 4;
                            }
                            CAMERA_CAP_FLAGS::CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE => {
                                return 5;
                            }
                        }
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum GOPRO_HEARTBEAT_FLAGS {
                    GOPRO_FLAG_RECORDING = 1//GoPro is currently recording
                }

                impl GOPRO_HEARTBEAT_FLAGS {
                    pub fn from_bits(src: i8) -> Option<GOPRO_HEARTBEAT_FLAGS> {
                        match src
                        {
                            1 => Some(GOPRO_HEARTBEAT_FLAGS::GOPRO_FLAG_RECORDING),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Bitmask of (optional) autopilot capabilities (64 bit). If a bit is set, the autopilot supports this capability */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum MAV_PROTOCOL_CAPABILITY {
                    MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT = 1,
                    //Autopilot supports MISSION float message type.
                    MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT = 2,
                    //Autopilot supports the new param float message type.
                    MAV_PROTOCOL_CAPABILITY_MISSION_INT = 4,
                    //Autopilot supports MISSION_INT scaled integer message type.
                    MAV_PROTOCOL_CAPABILITY_COMMAND_INT = 8,
                    //Autopilot supports COMMAND_INT scaled integer message type.
                    MAV_PROTOCOL_CAPABILITY_PARAM_UNION = 16,
                    //Autopilot supports the new param union message type.
                    MAV_PROTOCOL_CAPABILITY_FTP = 32,
                    //Autopilot supports the new FILE_TRANSFER_PROTOCOL message type.
                    MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET = 64,
                    //Autopilot supports commanding attitude offboard.
                    MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED = 128,
                    //Autopilot supports commanding position and velocity targets in local NED frame.
                    MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT = 256,
                    //Autopilot supports commanding position and velocity targets in global scaled integers.
                    MAV_PROTOCOL_CAPABILITY_TERRAIN = 512,
                    //Autopilot supports terrain protocol / data handling.
                    MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET = 1024,
                    //Autopilot supports direct actuator control.
                    MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION = 2048,
                    //Autopilot supports the flight termination command.
                    MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION = 4096,
                    //Autopilot supports onboard compass calibration.
                    MAV_PROTOCOL_CAPABILITY_MAVLINK2 = 8192,
                    //Autopilot supports mavlink version 2.
                    MAV_PROTOCOL_CAPABILITY_MISSION_FENCE = 16384,
                    //Autopilot supports mission fence protocol.
                    MAV_PROTOCOL_CAPABILITY_MISSION_RALLY = 32768,
                    //Autopilot supports mission rally point protocol.
                    MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION = 65536,//Autopilot supports the flight information protocol.
                }

                impl MAV_PROTOCOL_CAPABILITY {
                    pub fn from_bits(src: i32) -> Option<MAV_PROTOCOL_CAPABILITY> {
                        match src
                        {
                            0 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT);
                            }
                            1 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT);
                            }
                            2 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_INT);
                            }
                            3 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_COMMAND_INT);
                            }
                            4 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_PARAM_UNION);
                            }
                            5 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FTP);
                            }
                            6 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET);
                            }
                            7 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED);
                            }
                            8 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT);
                            }
                            9 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_TERRAIN);
                            }
                            10 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET);
                            }
                            11 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION);
                            }
                            12 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION);
                            }
                            13 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MAVLINK2);
                            }
                            14 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_FENCE);
                            }
                            15 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_RALLY);
                            }
                            16 => {
                                return Some(MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT => {
                                return 0;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT => {
                                return 1;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_INT => {
                                return 2;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_COMMAND_INT => {
                                return 3;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_PARAM_UNION => {
                                return 4;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FTP => {
                                return 5;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET => {
                                return 6;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED => {
                                return 7;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT => {
                                return 8;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_TERRAIN => {
                                return 9;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET => {
                                return 10;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION => {
                                return 11;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION => {
                                return 12;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MAVLINK2 => {
                                return 13;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_FENCE => {
                                return 14;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_MISSION_RALLY => {
                                return 15;
                            }
                            MAV_PROTOCOL_CAPABILITY::MAV_PROTOCOL_CAPABILITY_FLIGHT_INFORMATION => {
                                return 16;
                            }
                        }
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum GOPRO_HEARTBEAT_STATUS {
                    GOPRO_HEARTBEAT_STATUS_DISCONNECTED = 0,
                    //No GoPro connected
                    GOPRO_HEARTBEAT_STATUS_INCOMPATIBLE = 1,
                    //The detected GoPro is not HeroBus compatible
                    GOPRO_HEARTBEAT_STATUS_CONNECTED = 2,
                    //A HeroBus compatible GoPro is connected
                    GOPRO_HEARTBEAT_STATUS_ERROR = 3,//An unrecoverable error was encountered with the connected GoPro, it may require a power cycle
                }

                impl GOPRO_HEARTBEAT_STATUS {
                    pub fn from_bits(src: i8) -> Option<GOPRO_HEARTBEAT_STATUS> {
                        match src
                        {
                            0 => Some(GOPRO_HEARTBEAT_STATUS::GOPRO_HEARTBEAT_STATUS_DISCONNECTED),
                            1 => Some(GOPRO_HEARTBEAT_STATUS::GOPRO_HEARTBEAT_STATUS_INCOMPATIBLE),
                            2 => Some(GOPRO_HEARTBEAT_STATUS::GOPRO_HEARTBEAT_STATUS_CONNECTED),
                            3 => Some(GOPRO_HEARTBEAT_STATUS::GOPRO_HEARTBEAT_STATUS_ERROR),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAG_CAL_STATUS {
                    MAG_CAL_NOT_STARTED = 0,
                    MAG_CAL_WAITING_TO_START = 1,
                    MAG_CAL_RUNNING_STEP_ONE = 2,
                    MAG_CAL_RUNNING_STEP_TWO = 3,
                    MAG_CAL_SUCCESS = 4,
                    MAG_CAL_FAILED = 5,
                }

                impl MAG_CAL_STATUS {
                    pub fn from_bits(src: i8) -> Option<MAG_CAL_STATUS> {
                        match src
                        {
                            0 => Some(MAG_CAL_STATUS::MAG_CAL_NOT_STARTED),
                            1 => Some(MAG_CAL_STATUS::MAG_CAL_WAITING_TO_START),
                            2 => Some(MAG_CAL_STATUS::MAG_CAL_RUNNING_STEP_ONE),
                            3 => Some(MAG_CAL_STATUS::MAG_CAL_RUNNING_STEP_TWO),
                            4 => Some(MAG_CAL_STATUS::MAG_CAL_SUCCESS),
                            5 => Some(MAG_CAL_STATUS::MAG_CAL_FAILED),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum CAMERA_STATUS_TYPES {
                    CAMERA_STATUS_TYPE_HEARTBEAT = 0,
                    //Camera heartbeat, announce camera component ID at 1hz
                    CAMERA_STATUS_TYPE_TRIGGER = 1,
                    //Camera image triggered
                    CAMERA_STATUS_TYPE_DISCONNECT = 2,
                    //Camera connection lost
                    CAMERA_STATUS_TYPE_ERROR = 3,
                    //Camera unknown error
                    CAMERA_STATUS_TYPE_LOWBATT = 4,
                    //Camera battery low. Parameter p1 shows reported voltage
                    CAMERA_STATUS_TYPE_LOWSTORE = 5,
                    //Camera storage low. Parameter p1 shows reported shots remaining
                    CAMERA_STATUS_TYPE_LOWSTOREV = 6,//Camera storage low. Parameter p1 shows reported video minutes remaining
                }

                impl CAMERA_STATUS_TYPES {
                    pub fn from_bits(src: i8) -> Option<CAMERA_STATUS_TYPES> {
                        match src
                        {
                            0 => Some(CAMERA_STATUS_TYPES::CAMERA_STATUS_TYPE_HEARTBEAT),
                            1 => Some(CAMERA_STATUS_TYPES::CAMERA_STATUS_TYPE_TRIGGER),
                            2 => Some(CAMERA_STATUS_TYPES::CAMERA_STATUS_TYPE_DISCONNECT),
                            3 => Some(CAMERA_STATUS_TYPES::CAMERA_STATUS_TYPE_ERROR),
                            4 => Some(CAMERA_STATUS_TYPES::CAMERA_STATUS_TYPE_LOWBATT),
                            5 => Some(CAMERA_STATUS_TYPES::CAMERA_STATUS_TYPE_LOWSTORE),
                            6 => Some(CAMERA_STATUS_TYPES::CAMERA_STATUS_TYPE_LOWSTOREV),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*SERIAL_CONTROL device types */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum SERIAL_CONTROL_DEV {
                    SERIAL_CONTROL_DEV_TELEM1 = 0,
                    //First telemetry port
                    SERIAL_CONTROL_DEV_TELEM2 = 1,
                    //Second telemetry port
                    SERIAL_CONTROL_DEV_GPS1 = 2,
                    //First GPS port
                    SERIAL_CONTROL_DEV_GPS2 = 3,
                    //Second GPS port
                    SERIAL_CONTROL_DEV_SHELL = 10,//system shell
                }

                impl SERIAL_CONTROL_DEV {
                    pub fn from_bits(src: i32) -> Option<SERIAL_CONTROL_DEV> {
                        match src
                        {
                            0 => {
                                return Some(SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_TELEM1);
                            }
                            1 => {
                                return Some(SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_TELEM2);
                            }
                            2 => {
                                return Some(SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_GPS1);
                            }
                            3 => {
                                return Some(SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_GPS2);
                            }
                            4 => {
                                return Some(SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_SHELL);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_TELEM1 => {
                                return 0;
                            }
                            SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_TELEM2 => {
                                return 1;
                            }
                            SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_GPS1 => {
                                return 2;
                            }
                            SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_GPS2 => {
                                return 3;
                            }
                            SERIAL_CONTROL_DEV::SERIAL_CONTROL_DEV_SHELL => {
                                return 4;
                            }
                        }
                    }
                }

                /**
*result in a mavlink mission ack */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_MISSION_RESULT {
                    MAV_MISSION_ACCEPTED = 0,
                    //mission accepted OK
                    MAV_MISSION_ERROR = 1,
                    //generic error / not accepting mission commands at all right now
                    MAV_MISSION_UNSUPPORTED_FRAME = 2,
                    //coordinate frame is not supported
                    MAV_MISSION_UNSUPPORTED = 3,
                    //command is not supported
                    MAV_MISSION_NO_SPACE = 4,
                    //mission item exceeds storage space
                    MAV_MISSION_INVALID = 5,
                    //one of the parameters has an invalid value
                    MAV_MISSION_INVALID_PARAM1 = 6,
                    //param1 has an invalid value
                    MAV_MISSION_INVALID_PARAM2 = 7,
                    //param2 has an invalid value
                    MAV_MISSION_INVALID_PARAM3 = 8,
                    //param3 has an invalid value
                    MAV_MISSION_INVALID_PARAM4 = 9,
                    //param4 has an invalid value
                    MAV_MISSION_INVALID_PARAM5_X = 10,
                    //x/param5 has an invalid value
                    MAV_MISSION_INVALID_PARAM6_Y = 11,
                    //y/param6 has an invalid value
                    MAV_MISSION_INVALID_PARAM7 = 12,
                    //param7 has an invalid value
                    MAV_MISSION_INVALID_SEQUENCE = 13,
                    //received waypoint out of sequence
                    MAV_MISSION_DENIED = 14,//not accepting any mission commands from this communication partner
                }

                impl MAV_MISSION_RESULT {
                    pub fn from_bits(src: i8) -> Option<MAV_MISSION_RESULT> {
                        match src
                        {
                            0 => Some(MAV_MISSION_RESULT::MAV_MISSION_ACCEPTED),
                            1 => Some(MAV_MISSION_RESULT::MAV_MISSION_ERROR),
                            2 => Some(MAV_MISSION_RESULT::MAV_MISSION_UNSUPPORTED_FRAME),
                            3 => Some(MAV_MISSION_RESULT::MAV_MISSION_UNSUPPORTED),
                            4 => Some(MAV_MISSION_RESULT::MAV_MISSION_NO_SPACE),
                            5 => Some(MAV_MISSION_RESULT::MAV_MISSION_INVALID),
                            6 => Some(MAV_MISSION_RESULT::MAV_MISSION_INVALID_PARAM1),
                            7 => Some(MAV_MISSION_RESULT::MAV_MISSION_INVALID_PARAM2),
                            8 => Some(MAV_MISSION_RESULT::MAV_MISSION_INVALID_PARAM3),
                            9 => Some(MAV_MISSION_RESULT::MAV_MISSION_INVALID_PARAM4),
                            10 => Some(MAV_MISSION_RESULT::MAV_MISSION_INVALID_PARAM5_X),
                            11 => Some(MAV_MISSION_RESULT::MAV_MISSION_INVALID_PARAM6_Y),
                            12 => Some(MAV_MISSION_RESULT::MAV_MISSION_INVALID_PARAM7),
                            13 => Some(MAV_MISSION_RESULT::MAV_MISSION_INVALID_SEQUENCE),
                            14 => Some(MAV_MISSION_RESULT::MAV_MISSION_DENIED),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Power supply status flags (bitmask) */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum MAV_POWER_STATUS {
                    MAV_POWER_STATUS_BRICK_VALID = 1,
                    //main brick power supply valid
                    MAV_POWER_STATUS_SERVO_VALID = 2,
                    //main servo power supply valid for FMU
                    MAV_POWER_STATUS_USB_CONNECTED = 4,
                    //USB power is connected
                    MAV_POWER_STATUS_PERIPH_OVERCURRENT = 8,
                    //peripheral supply is in over-current state
                    MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT = 16,
                    //hi-power peripheral supply is in over-current state
                    MAV_POWER_STATUS_CHANGED = 32,//Power status has changed since boot
                }

                impl MAV_POWER_STATUS {
                    pub fn from_bits(src: i32) -> Option<MAV_POWER_STATUS> {
                        match src
                        {
                            0 => {
                                return Some(MAV_POWER_STATUS::MAV_POWER_STATUS_BRICK_VALID);
                            }
                            1 => {
                                return Some(MAV_POWER_STATUS::MAV_POWER_STATUS_SERVO_VALID);
                            }
                            2 => {
                                return Some(MAV_POWER_STATUS::MAV_POWER_STATUS_USB_CONNECTED);
                            }
                            3 => {
                                return Some(MAV_POWER_STATUS::MAV_POWER_STATUS_PERIPH_OVERCURRENT);
                            }
                            4 => {
                                return Some(MAV_POWER_STATUS::MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT);
                            }
                            5 => {
                                return Some(MAV_POWER_STATUS::MAV_POWER_STATUS_CHANGED);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            MAV_POWER_STATUS::MAV_POWER_STATUS_BRICK_VALID => {
                                return 0;
                            }
                            MAV_POWER_STATUS::MAV_POWER_STATUS_SERVO_VALID => {
                                return 1;
                            }
                            MAV_POWER_STATUS::MAV_POWER_STATUS_USB_CONNECTED => {
                                return 2;
                            }
                            MAV_POWER_STATUS::MAV_POWER_STATUS_PERIPH_OVERCURRENT => {
                                return 3;
                            }
                            MAV_POWER_STATUS::MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT => {
                                return 4;
                            }
                            MAV_POWER_STATUS::MAV_POWER_STATUS_CHANGED => {
                                return 5;
                            }
                        }
                    }
                }

                /**
*Generalized UAVCAN node mode */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum UAVCAN_NODE_MODE {
                    UAVCAN_NODE_MODE_OPERATIONAL = 0,
                    //The node is performing its primary functions.
                    UAVCAN_NODE_MODE_INITIALIZATION = 1,
                    //The node is initializing; this mode is entered immediately after startup.
                    UAVCAN_NODE_MODE_MAINTENANCE = 2,
                    //The node is under maintenance.
                    UAVCAN_NODE_MODE_SOFTWARE_UPDATE = 3,
                    //The node is in the process of updating its software.
                    UAVCAN_NODE_MODE_OFFLINE = 7,//The node is no longer available online.
                }

                impl UAVCAN_NODE_MODE {
                    pub fn from_bits(src: i32) -> Option<UAVCAN_NODE_MODE> {
                        match src
                        {
                            0 => {
                                return Some(UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_OPERATIONAL);
                            }
                            1 => {
                                return Some(UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_INITIALIZATION);
                            }
                            2 => {
                                return Some(UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_MAINTENANCE);
                            }
                            3 => {
                                return Some(UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_SOFTWARE_UPDATE);
                            }
                            4 => {
                                return Some(UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_OFFLINE);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_OPERATIONAL => {
                                return 0;
                            }
                            UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_INITIALIZATION => {
                                return 1;
                            }
                            UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_MAINTENANCE => {
                                return 2;
                            }
                            UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_SOFTWARE_UPDATE => {
                                return 3;
                            }
                            UAVCAN_NODE_MODE::UAVCAN_NODE_MODE_OFFLINE => {
                                return 4;
                            }
                        }
                    }
                }

                /**
*These flags indicate status such as data validity of each data source. Set = data valid */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum ADSB_FLAGS {
                    ADSB_FLAGS_VALID_COORDS = 1,
                    ADSB_FLAGS_VALID_ALTITUDE = 2,
                    ADSB_FLAGS_VALID_HEADING = 4,
                    ADSB_FLAGS_VALID_VELOCITY = 8,
                    ADSB_FLAGS_VALID_CALLSIGN = 16,
                    ADSB_FLAGS_VALID_SQUAWK = 32,
                    ADSB_FLAGS_SIMULATED = 64,
                }

                impl ADSB_FLAGS {
                    pub fn from_bits(src: i32) -> Option<ADSB_FLAGS> {
                        match src
                        {
                            0 => {
                                return Some(ADSB_FLAGS::ADSB_FLAGS_VALID_COORDS);
                            }
                            1 => {
                                return Some(ADSB_FLAGS::ADSB_FLAGS_VALID_ALTITUDE);
                            }
                            2 => {
                                return Some(ADSB_FLAGS::ADSB_FLAGS_VALID_HEADING);
                            }
                            3 => {
                                return Some(ADSB_FLAGS::ADSB_FLAGS_VALID_VELOCITY);
                            }
                            4 => {
                                return Some(ADSB_FLAGS::ADSB_FLAGS_VALID_CALLSIGN);
                            }
                            5 => {
                                return Some(ADSB_FLAGS::ADSB_FLAGS_VALID_SQUAWK);
                            }
                            6 => {
                                return Some(ADSB_FLAGS::ADSB_FLAGS_SIMULATED);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            ADSB_FLAGS::ADSB_FLAGS_VALID_COORDS => {
                                return 0;
                            }
                            ADSB_FLAGS::ADSB_FLAGS_VALID_ALTITUDE => {
                                return 1;
                            }
                            ADSB_FLAGS::ADSB_FLAGS_VALID_HEADING => {
                                return 2;
                            }
                            ADSB_FLAGS::ADSB_FLAGS_VALID_VELOCITY => {
                                return 3;
                            }
                            ADSB_FLAGS::ADSB_FLAGS_VALID_CALLSIGN => {
                                return 4;
                            }
                            ADSB_FLAGS::ADSB_FLAGS_VALID_SQUAWK => {
                                return 5;
                            }
                            ADSB_FLAGS::ADSB_FLAGS_SIMULATED => {
                                return 6;
                            }
                        }
                    }
                }

                /**
*Result from a PARAM_EXT_SET message. */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum PARAM_ACK {
                    PARAM_ACK_ACCEPTED = 0,
                    //Parameter value ACCEPTED and SET
                    PARAM_ACK_VALUE_UNSUPPORTED = 1,
                    //Parameter value UNKNOWN/UNSUPPORTED
                    PARAM_ACK_FAILED = 2,
                    //Parameter failed to set
                    /**
*Parameter value received but not yet validated or set. A subsequent PARAM_EXT_ACK will follow once operation
*			 is completed with the actual result. These are for parameters that may take longer to set. Instead of
*			 waiting for an ACK and potentially timing out, you will immediately receive this response to let you
*			 know it was received */
                    PARAM_ACK_IN_PROGRESS = 3,
                }

                impl PARAM_ACK {
                    pub fn from_bits(src: i8) -> Option<PARAM_ACK> {
                        match src
                        {
                            0 => Some(PARAM_ACK::PARAM_ACK_ACCEPTED),
                            1 => Some(PARAM_ACK::PARAM_ACK_VALUE_UNSUPPORTED),
                            2 => Some(PARAM_ACK::PARAM_ACK_FAILED),
                            3 => Some(PARAM_ACK::PARAM_ACK_IN_PROGRESS),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Enumeration of possible mount operation modes */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_MOUNT_MODE {
                    MAV_MOUNT_MODE_RETRACT = 0,
                    //Load and keep safe position (Roll,Pitch,Yaw) from permant memory and stop stabilization
                    MAV_MOUNT_MODE_NEUTRAL = 1,
                    //Load and keep neutral position (Roll,Pitch,Yaw) from permanent memory.
                    MAV_MOUNT_MODE_MAVLINK_TARGETING = 2,
                    //Load neutral position and start MAVLink Roll,Pitch,Yaw control with stabilization
                    MAV_MOUNT_MODE_RC_TARGETING = 3,
                    //Load neutral position and start RC Roll,Pitch,Yaw control with stabilization
                    MAV_MOUNT_MODE_GPS_POINT = 4,//Load neutral position and start to point to Lat,Lon,Alt
                }

                impl MAV_MOUNT_MODE {
                    pub fn from_bits(src: i8) -> Option<MAV_MOUNT_MODE> {
                        match src
                        {
                            0 => Some(MAV_MOUNT_MODE::MAV_MOUNT_MODE_RETRACT),
                            1 => Some(MAV_MOUNT_MODE::MAV_MOUNT_MODE_NEUTRAL),
                            2 => Some(MAV_MOUNT_MODE::MAV_MOUNT_MODE_MAVLINK_TARGETING),
                            3 => Some(MAV_MOUNT_MODE::MAV_MOUNT_MODE_RC_TARGETING),
                            4 => Some(MAV_MOUNT_MODE::MAV_MOUNT_MODE_GPS_POINT),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Enumeration of sensor orientation, according to its rotations */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_SENSOR_ORIENTATION {
                    NONE = 0,
                    //Roll: 0, Pitch: 0, Yaw: 0
                    YAW_45 = 1,
                    //Roll: 0, Pitch: 0, Yaw: 45
                    YAW_90 = 2,
                    //Roll: 0, Pitch: 0, Yaw: 90
                    YAW_135 = 3,
                    //Roll: 0, Pitch: 0, Yaw: 135
                    YAW_180 = 4,
                    //Roll: 0, Pitch: 0, Yaw: 180
                    YAW_225 = 5,
                    //Roll: 0, Pitch: 0, Yaw: 225
                    YAW_270 = 6,
                    //Roll: 0, Pitch: 0, Yaw: 270
                    YAW_315 = 7,
                    //Roll: 0, Pitch: 0, Yaw: 315
                    ROLL_180 = 8,
                    //Roll: 180, Pitch: 0, Yaw: 0
                    ROLL_180_YAW_45 = 9,
                    //Roll: 180, Pitch: 0, Yaw: 45
                    ROLL_180_YAW_90 = 10,
                    //Roll: 180, Pitch: 0, Yaw: 90
                    ROLL_180_YAW_135 = 11,
                    //Roll: 180, Pitch: 0, Yaw: 135
                    PITCH_180 = 12,
                    //Roll: 0, Pitch: 180, Yaw: 0
                    ROLL_180_YAW_225 = 13,
                    //Roll: 180, Pitch: 0, Yaw: 225
                    ROLL_180_YAW_270 = 14,
                    //Roll: 180, Pitch: 0, Yaw: 270
                    ROLL_180_YAW_315 = 15,
                    //Roll: 180, Pitch: 0, Yaw: 315
                    ROLL_90 = 16,
                    //Roll: 90, Pitch: 0, Yaw: 0
                    ROLL_90_YAW_45 = 17,
                    //Roll: 90, Pitch: 0, Yaw: 45
                    ROLL_90_YAW_90 = 18,
                    //Roll: 90, Pitch: 0, Yaw: 90
                    ROLL_90_YAW_135 = 19,
                    //Roll: 90, Pitch: 0, Yaw: 135
                    ROLL_270 = 20,
                    //Roll: 270, Pitch: 0, Yaw: 0
                    ROLL_270_YAW_45 = 21,
                    //Roll: 270, Pitch: 0, Yaw: 45
                    ROLL_270_YAW_90 = 22,
                    //Roll: 270, Pitch: 0, Yaw: 90
                    ROLL_270_YAW_135 = 23,
                    //Roll: 270, Pitch: 0, Yaw: 135
                    PITCH_90 = 24,
                    //Roll: 0, Pitch: 90, Yaw: 0
                    PITCH_270 = 25,
                    //Roll: 0, Pitch: 270, Yaw: 0
                    PITCH_180_YAW_90 = 26,
                    //Roll: 0, Pitch: 180, Yaw: 90
                    PITCH_180_YAW_270 = 27,
                    //Roll: 0, Pitch: 180, Yaw: 270
                    ROLL_90_PITCH_90 = 28,
                    //Roll: 90, Pitch: 90, Yaw: 0
                    ROLL_180_PITCH_90 = 29,
                    //Roll: 180, Pitch: 90, Yaw: 0
                    ROLL_270_PITCH_90 = 30,
                    //Roll: 270, Pitch: 90, Yaw: 0
                    ROLL_90_PITCH_180 = 31,
                    //Roll: 90, Pitch: 180, Yaw: 0
                    ROLL_270_PITCH_180 = 32,
                    //Roll: 270, Pitch: 180, Yaw: 0
                    ROLL_90_PITCH_270 = 33,
                    //Roll: 90, Pitch: 270, Yaw: 0
                    ROLL_180_PITCH_270 = 34,
                    //Roll: 180, Pitch: 270, Yaw: 0
                    ROLL_270_PITCH_270 = 35,
                    //Roll: 270, Pitch: 270, Yaw: 0
                    ROLL_90_PITCH_180_YAW_90 = 36,
                    //Roll: 90, Pitch: 180, Yaw: 90
                    ROLL_90_YAW_270 = 37,
                    //Roll: 90, Pitch: 0, Yaw: 270
                    ROLL_315_PITCH_315_YAW_315 = 38,//Roll: 315, Pitch: 315, Yaw: 315
                }

                impl MAV_SENSOR_ORIENTATION {
                    pub fn from_bits(src: i8) -> Option<MAV_SENSOR_ORIENTATION> {
                        match src
                        {
                            0 => Some(MAV_SENSOR_ORIENTATION::NONE),
                            1 => Some(MAV_SENSOR_ORIENTATION::YAW_45),
                            2 => Some(MAV_SENSOR_ORIENTATION::YAW_90),
                            3 => Some(MAV_SENSOR_ORIENTATION::YAW_135),
                            4 => Some(MAV_SENSOR_ORIENTATION::YAW_180),
                            5 => Some(MAV_SENSOR_ORIENTATION::YAW_225),
                            6 => Some(MAV_SENSOR_ORIENTATION::YAW_270),
                            7 => Some(MAV_SENSOR_ORIENTATION::YAW_315),
                            8 => Some(MAV_SENSOR_ORIENTATION::ROLL_180),
                            9 => Some(MAV_SENSOR_ORIENTATION::ROLL_180_YAW_45),
                            10 => Some(MAV_SENSOR_ORIENTATION::ROLL_180_YAW_90),
                            11 => Some(MAV_SENSOR_ORIENTATION::ROLL_180_YAW_135),
                            12 => Some(MAV_SENSOR_ORIENTATION::PITCH_180),
                            13 => Some(MAV_SENSOR_ORIENTATION::ROLL_180_YAW_225),
                            14 => Some(MAV_SENSOR_ORIENTATION::ROLL_180_YAW_270),
                            15 => Some(MAV_SENSOR_ORIENTATION::ROLL_180_YAW_315),
                            16 => Some(MAV_SENSOR_ORIENTATION::ROLL_90),
                            17 => Some(MAV_SENSOR_ORIENTATION::ROLL_90_YAW_45),
                            18 => Some(MAV_SENSOR_ORIENTATION::ROLL_90_YAW_90),
                            19 => Some(MAV_SENSOR_ORIENTATION::ROLL_90_YAW_135),
                            20 => Some(MAV_SENSOR_ORIENTATION::ROLL_270),
                            21 => Some(MAV_SENSOR_ORIENTATION::ROLL_270_YAW_45),
                            22 => Some(MAV_SENSOR_ORIENTATION::ROLL_270_YAW_90),
                            23 => Some(MAV_SENSOR_ORIENTATION::ROLL_270_YAW_135),
                            24 => Some(MAV_SENSOR_ORIENTATION::PITCH_90),
                            25 => Some(MAV_SENSOR_ORIENTATION::PITCH_270),
                            26 => Some(MAV_SENSOR_ORIENTATION::PITCH_180_YAW_90),
                            27 => Some(MAV_SENSOR_ORIENTATION::PITCH_180_YAW_270),
                            28 => Some(MAV_SENSOR_ORIENTATION::ROLL_90_PITCH_90),
                            29 => Some(MAV_SENSOR_ORIENTATION::ROLL_180_PITCH_90),
                            30 => Some(MAV_SENSOR_ORIENTATION::ROLL_270_PITCH_90),
                            31 => Some(MAV_SENSOR_ORIENTATION::ROLL_90_PITCH_180),
                            32 => Some(MAV_SENSOR_ORIENTATION::ROLL_270_PITCH_180),
                            33 => Some(MAV_SENSOR_ORIENTATION::ROLL_90_PITCH_270),
                            34 => Some(MAV_SENSOR_ORIENTATION::ROLL_180_PITCH_270),
                            35 => Some(MAV_SENSOR_ORIENTATION::ROLL_270_PITCH_270),
                            36 => Some(MAV_SENSOR_ORIENTATION::ROLL_90_PITCH_180_YAW_90),
                            37 => Some(MAV_SENSOR_ORIENTATION::ROLL_90_YAW_270),
                            38 => Some(MAV_SENSOR_ORIENTATION::ROLL_315_PITCH_315_YAW_315),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*State flags for ADS-B transponder dynamic report */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum UAVIONIX_ADSB_OUT_DYNAMIC_STATE {
                    UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE = 1,
                    UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED = 2,
                    UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED = 4,
                    UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND = 8,
                    UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT = 16,
                }

                impl UAVIONIX_ADSB_OUT_DYNAMIC_STATE {
                    pub fn from_bits(src: i32) -> Option<UAVIONIX_ADSB_OUT_DYNAMIC_STATE> {
                        match src
                        {
                            0 => {
                                return Some(UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE);
                            }
                            1 => {
                                return Some(UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED);
                            }
                            2 => {
                                return Some(UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED);
                            }
                            3 => {
                                return Some(UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND);
                            }
                            4 => {
                                return Some(UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE => {
                                return 0;
                            }
                            UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED => {
                                return 1;
                            }
                            UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED => {
                                return 2;
                            }
                            UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND => {
                                return 3;
                            }
                            UAVIONIX_ADSB_OUT_DYNAMIC_STATE::UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT => {
                                return 4;
                            }
                        }
                    }
                }

                /**
*Possible actions an aircraft can take to avoid a collision. */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_COLLISION_ACTION {
                    MAV_COLLISION_ACTION_NONE = 0,
                    //Ignore any potential collisions
                    MAV_COLLISION_ACTION_REPORT = 1,
                    //Report potential collision
                    MAV_COLLISION_ACTION_ASCEND_OR_DESCEND = 2,
                    //Ascend or Descend to avoid threat
                    MAV_COLLISION_ACTION_MOVE_HORIZONTALLY = 3,
                    //Move horizontally to avoid threat
                    MAV_COLLISION_ACTION_MOVE_PERPENDICULAR = 4,
                    //Aircraft to move perpendicular to the collision's velocity vector
                    MAV_COLLISION_ACTION_RTL = 5,
                    //Aircraft to fly directly back to its launch point
                    MAV_COLLISION_ACTION_HOVER = 6,//Aircraft to stop in place
                }

                impl MAV_COLLISION_ACTION {
                    pub fn from_bits(src: i8) -> Option<MAV_COLLISION_ACTION> {
                        match src
                        {
                            0 => Some(MAV_COLLISION_ACTION::MAV_COLLISION_ACTION_NONE),
                            1 => Some(MAV_COLLISION_ACTION::MAV_COLLISION_ACTION_REPORT),
                            2 => Some(MAV_COLLISION_ACTION::MAV_COLLISION_ACTION_ASCEND_OR_DESCEND),
                            3 => Some(MAV_COLLISION_ACTION::MAV_COLLISION_ACTION_MOVE_HORIZONTALLY),
                            4 => Some(MAV_COLLISION_ACTION::MAV_COLLISION_ACTION_MOVE_PERPENDICULAR),
                            5 => Some(MAV_COLLISION_ACTION::MAV_COLLISION_ACTION_RTL),
                            6 => Some(MAV_COLLISION_ACTION::MAV_COLLISION_ACTION_HOVER),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Aircraft-rated danger from this threat. */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_COLLISION_THREAT_LEVEL {
                    MAV_COLLISION_THREAT_LEVEL_NONE = 0,
                    //Not a threat
                    MAV_COLLISION_THREAT_LEVEL_LOW = 1,
                    //Craft is mildly concerned about this threat
                    MAV_COLLISION_THREAT_LEVEL_HIGH = 2,//Craft is panicing, and may take actions to avoid threat
                }

                impl MAV_COLLISION_THREAT_LEVEL {
                    pub fn from_bits(src: i8) -> Option<MAV_COLLISION_THREAT_LEVEL> {
                        match src
                        {
                            0 => Some(MAV_COLLISION_THREAT_LEVEL::MAV_COLLISION_THREAT_LEVEL_NONE),
                            1 => Some(MAV_COLLISION_THREAT_LEVEL::MAV_COLLISION_THREAT_LEVEL_LOW),
                            2 => Some(MAV_COLLISION_THREAT_LEVEL::MAV_COLLISION_THREAT_LEVEL_HIGH),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum LIMITS_STATE {
                    LIMITS_INIT = 0,
                    //pre-initialization
                    LIMITS_DISABLED = 1,
                    //disabled
                    LIMITS_ENABLED = 2,
                    //checking limits
                    LIMITS_TRIGGERED = 3,
                    //a limit has been breached
                    LIMITS_RECOVERING = 4,
                    //taking action eg. RTL
                    LIMITS_RECOVERED = 5,//we're no longer in breach of a limit
                }

                impl LIMITS_STATE {
                    pub fn from_bits(src: i8) -> Option<LIMITS_STATE> {
                        match src
                        {
                            0 => Some(LIMITS_STATE::LIMITS_INIT),
                            1 => Some(LIMITS_STATE::LIMITS_DISABLED),
                            2 => Some(LIMITS_STATE::LIMITS_ENABLED),
                            3 => Some(LIMITS_STATE::LIMITS_TRIGGERED),
                            4 => Some(LIMITS_STATE::LIMITS_RECOVERING),
                            5 => Some(LIMITS_STATE::LIMITS_RECOVERED),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Transceiver RF control flags for ADS-B transponder dynamic reports */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum UAVIONIX_ADSB_OUT_RF_SELECT {
                    UAVIONIX_ADSB_OUT_RF_SELECT_STANDBY = 0,
                    UAVIONIX_ADSB_OUT_RF_SELECT_RX_ENABLED = 1,
                    UAVIONIX_ADSB_OUT_RF_SELECT_TX_ENABLED = 2,
                }

                impl UAVIONIX_ADSB_OUT_RF_SELECT {
                    pub fn from_bits(src: i8) -> Option<UAVIONIX_ADSB_OUT_RF_SELECT> {
                        match src
                        {
                            0 => Some(UAVIONIX_ADSB_OUT_RF_SELECT::UAVIONIX_ADSB_OUT_RF_SELECT_STANDBY),
                            1 => Some(UAVIONIX_ADSB_OUT_RF_SELECT::UAVIONIX_ADSB_OUT_RF_SELECT_RX_ENABLED),
                            2 => Some(UAVIONIX_ADSB_OUT_RF_SELECT::UAVIONIX_ADSB_OUT_RF_SELECT_TX_ENABLED),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Enumeration of battery types */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_BATTERY_TYPE {
                    UNKNOWN = 0,
                    //Not specified.
                    LIPO = 1,
                    //Lithium polymer battery
                    LIFE = 2,
                    //Lithium-iron-phosphate battery
                    LION = 3,
                    //Lithium-ION battery
                    NIMH = 4,//Nickel metal hydride battery
                }

                impl MAV_BATTERY_TYPE {
                    pub fn from_bits(src: i8) -> Option<MAV_BATTERY_TYPE> {
                        match src
                        {
                            0 => Some(MAV_BATTERY_TYPE::UNKNOWN),
                            1 => Some(MAV_BATTERY_TYPE::LIPO),
                            2 => Some(MAV_BATTERY_TYPE::LIFE),
                            3 => Some(MAV_BATTERY_TYPE::LION),
                            4 => Some(MAV_BATTERY_TYPE::NIMH),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*Flags in EKF_STATUS message */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum EKF_STATUS_FLAGS {
                    EKF_ATTITUDE = 1,
                    //set if EKF's attitude estimate is good
                    EKF_VELOCITY_HORIZ = 2,
                    //set if EKF's horizontal velocity estimate is good
                    EKF_VELOCITY_VERT = 4,
                    //set if EKF's vertical velocity estimate is good
                    EKF_POS_HORIZ_REL = 8,
                    //set if EKF's horizontal position (relative) estimate is good
                    EKF_POS_HORIZ_ABS = 16,
                    //set if EKF's horizontal position (absolute) estimate is good
                    EKF_POS_VERT_ABS = 32,
                    //set if EKF's vertical position (absolute) estimate is good
                    EKF_POS_VERT_AGL = 64,
                    //set if EKF's vertical position (above ground) estimate is good
                    EKF_CONST_POS_MODE = 128,
                    //EKF is in constant position mode and does not know it's absolute or relative position
                    EKF_PRED_POS_HORIZ_REL = 256,
                    //set if EKF's predicted horizontal position (relative) estimate is good
                    EKF_PRED_POS_HORIZ_ABS = 512,//set if EKF's predicted horizontal position (absolute) estimate is good
                }

                impl EKF_STATUS_FLAGS {
                    pub fn from_bits(src: i32) -> Option<EKF_STATUS_FLAGS> {
                        match src
                        {
                            0 => {
                                return Some(EKF_STATUS_FLAGS::EKF_ATTITUDE);
                            }
                            1 => {
                                return Some(EKF_STATUS_FLAGS::EKF_VELOCITY_HORIZ);
                            }
                            2 => {
                                return Some(EKF_STATUS_FLAGS::EKF_VELOCITY_VERT);
                            }
                            3 => {
                                return Some(EKF_STATUS_FLAGS::EKF_POS_HORIZ_REL);
                            }
                            4 => {
                                return Some(EKF_STATUS_FLAGS::EKF_POS_HORIZ_ABS);
                            }
                            5 => {
                                return Some(EKF_STATUS_FLAGS::EKF_POS_VERT_ABS);
                            }
                            6 => {
                                return Some(EKF_STATUS_FLAGS::EKF_POS_VERT_AGL);
                            }
                            7 => {
                                return Some(EKF_STATUS_FLAGS::EKF_CONST_POS_MODE);
                            }
                            8 => {
                                return Some(EKF_STATUS_FLAGS::EKF_PRED_POS_HORIZ_REL);
                            }
                            9 => {
                                return Some(EKF_STATUS_FLAGS::EKF_PRED_POS_HORIZ_ABS);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            EKF_STATUS_FLAGS::EKF_ATTITUDE => {
                                return 0;
                            }
                            EKF_STATUS_FLAGS::EKF_VELOCITY_HORIZ => {
                                return 1;
                            }
                            EKF_STATUS_FLAGS::EKF_VELOCITY_VERT => {
                                return 2;
                            }
                            EKF_STATUS_FLAGS::EKF_POS_HORIZ_REL => {
                                return 3;
                            }
                            EKF_STATUS_FLAGS::EKF_POS_HORIZ_ABS => {
                                return 4;
                            }
                            EKF_STATUS_FLAGS::EKF_POS_VERT_ABS => {
                                return 5;
                            }
                            EKF_STATUS_FLAGS::EKF_POS_VERT_AGL => {
                                return 6;
                            }
                            EKF_STATUS_FLAGS::EKF_CONST_POS_MODE => {
                                return 7;
                            }
                            EKF_STATUS_FLAGS::EKF_PRED_POS_HORIZ_REL => {
                                return 8;
                            }
                            EKF_STATUS_FLAGS::EKF_PRED_POS_HORIZ_ABS => {
                                return 9;
                            }
                        }
                    }
                }

                /**
*These encode the sensors whose status is sent as part of the SYS_STATUS message. */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum MAV_SYS_STATUS_SENSOR {
                    MAV_SYS_STATUS_SENSOR_3D_GYRO = 1,
                    //0x01 3D gyro
                    MAV_SYS_STATUS_SENSOR_3D_ACCEL = 2,
                    //0x02 3D accelerometer
                    MAV_SYS_STATUS_SENSOR_3D_MAG = 4,
                    //0x04 3D magnetometer
                    MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE = 8,
                    //0x08 absolute pressure
                    MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE = 16,
                    //0x10 differential pressure
                    MAV_SYS_STATUS_SENSOR_GPS = 32,
                    //0x20 GPS
                    MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW = 64,
                    //0x40 optical flow
                    MAV_SYS_STATUS_SENSOR_VISION_POSITION = 128,
                    //0x80 computer vision position
                    MAV_SYS_STATUS_SENSOR_LASER_POSITION = 256,
                    //0x100 laser based position
                    MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH = 512,
                    //0x200 external ground truth (Vicon or Leica)
                    MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL = 1024,
                    //0x400 3D angular rate control
                    MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION = 2048,
                    //0x800 attitude stabilization
                    MAV_SYS_STATUS_SENSOR_YAW_POSITION = 4096,
                    //0x1000 yaw position
                    MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL = 8192,
                    //0x2000 z/altitude control
                    MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL = 16384,
                    //0x4000 x/y position control
                    MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS = 32768,
                    //0x8000 motor outputs / control
                    MAV_SYS_STATUS_SENSOR_RC_RECEIVER = 65536,
                    //0x10000 rc receiver
                    MAV_SYS_STATUS_SENSOR_3D_GYRO2 = 131072,
                    //0x20000 2nd 3D gyro
                    MAV_SYS_STATUS_SENSOR_3D_ACCEL2 = 262144,
                    //0x40000 2nd 3D accelerometer
                    MAV_SYS_STATUS_SENSOR_3D_MAG2 = 524288,
                    //0x80000 2nd 3D magnetometer
                    MAV_SYS_STATUS_GEOFENCE = 1048576,
                    //0x100000 geofence
                    MAV_SYS_STATUS_AHRS = 2097152,
                    //0x200000 AHRS subsystem health
                    MAV_SYS_STATUS_TERRAIN = 4194304,
                    //0x400000 Terrain subsystem health
                    MAV_SYS_STATUS_REVERSE_MOTOR = 8388608,
                    //0x800000 Motors are reversed
                    MAV_SYS_STATUS_LOGGING = 16777216,
                    //0x1000000 Logging
                    MAV_SYS_STATUS_SENSOR_BATTERY = 33554432,//0x2000000 Battery
                }

                impl MAV_SYS_STATUS_SENSOR {
                    pub fn from_bits(src: i32) -> Option<MAV_SYS_STATUS_SENSOR> {
                        match src
                        {
                            0 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_GYRO);
                            }
                            1 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_ACCEL);
                            }
                            2 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_MAG);
                            }
                            3 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE);
                            }
                            4 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE);
                            }
                            5 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_GPS);
                            }
                            6 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW);
                            }
                            7 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_VISION_POSITION);
                            }
                            8 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_LASER_POSITION);
                            }
                            9 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH);
                            }
                            10 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL);
                            }
                            11 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION);
                            }
                            12 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_YAW_POSITION);
                            }
                            13 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL);
                            }
                            14 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL);
                            }
                            15 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS);
                            }
                            16 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_RC_RECEIVER);
                            }
                            17 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_GYRO2);
                            }
                            18 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_ACCEL2);
                            }
                            19 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_MAG2);
                            }
                            20 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_GEOFENCE);
                            }
                            21 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_AHRS);
                            }
                            22 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_TERRAIN);
                            }
                            23 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_REVERSE_MOTOR);
                            }
                            24 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_LOGGING);
                            }
                            25 => {
                                return Some(MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_BATTERY);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_GYRO => {
                                return 0;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_ACCEL => {
                                return 1;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_MAG => {
                                return 2;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE => {
                                return 3;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE => {
                                return 4;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_GPS => {
                                return 5;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW => {
                                return 6;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_VISION_POSITION => {
                                return 7;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_LASER_POSITION => {
                                return 8;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH => {
                                return 9;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL => {
                                return 10;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION => {
                                return 11;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_YAW_POSITION => {
                                return 12;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL => {
                                return 13;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL => {
                                return 14;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS => {
                                return 15;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_RC_RECEIVER => {
                                return 16;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_GYRO2 => {
                                return 17;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_ACCEL2 => {
                                return 18;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_3D_MAG2 => {
                                return 19;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_GEOFENCE => {
                                return 20;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_AHRS => {
                                return 21;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_TERRAIN => {
                                return 22;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_REVERSE_MOTOR => {
                                return 23;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_LOGGING => {
                                return 24;
                            }
                            MAV_SYS_STATUS_SENSOR::MAV_SYS_STATUS_SENSOR_BATTERY => {
                                return 25;
                            }
                        }
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum MAV_FRAME {
                    /**
*Global coordinate frame, WGS84 coordinate system. First value / x: latitude, second value / y: longitude,
*					 third value / z: positive altitude over mean sea level (MSL */
                    MAV_FRAME_GLOBAL = 0,
                    MAV_FRAME_LOCAL_NED = 1,
                    //Local coordinate frame, Z-up (x: north, y: east, z: down).
                    MAV_FRAME_MISSION = 2,
                    //NOT a coordinate frame, indicates a mission command.
                    /**
*Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home
*			 position. First value / x: latitude, second value / y: longitude, third value / z: positive altitude
*			 with 0 being at the altitude of the home location */
                    MAV_FRAME_GLOBAL_RELATIVE_ALT = 3,
                    MAV_FRAME_LOCAL_ENU = 4,
                    //Local coordinate frame, Z-down (x: east, y: north, z: up)
                    /**
*Global coordinate frame, WGS84 coordinate system. First value / x: latitude in degrees*1.0e-7, second
*			 value / y: longitude in degrees*1.0e-7, third value / z: positive altitude over mean sea level (MSL */
                    MAV_FRAME_GLOBAL_INT = 5,
                    /**
*Global coordinate frame, WGS84 coordinate system, relative altitude over ground with respect to the home
*			 position. First value / x: latitude in degrees*10e-7, second value / y: longitude in degrees*10e-7, third
*			 value / z: positive altitude with 0 being at the altitude of the home location */
                    MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = 6,
                    /**
*Offset to the current local frame. Anything expressed in this frame should be added to the current local
*			 frame position */
                    MAV_FRAME_LOCAL_OFFSET_NED = 7,
                    /**
*Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to
*			 command 2 m/s^2 acceleration to the right */
                    MAV_FRAME_BODY_NED = 8,
                    /**
*Offset in body NED frame. This makes sense if adding setpoints to the current flight path, to avoid an
*			 obstacle - e.g. useful to command 2 m/s^2 acceleration to the east */
                    MAV_FRAME_BODY_OFFSET_NED = 9,
                    /**
*Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude
*			 over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees, second value
*			 / y: longitude in degrees, third value / z: positive altitude in meters with 0 being at ground level
*			 in terrain model */
                    MAV_FRAME_GLOBAL_TERRAIN_ALT = 10,
                    /**
*Global coordinate frame with above terrain level altitude. WGS84 coordinate system, relative altitude
*			 over terrain with respect to the waypoint coordinate. First value / x: latitude in degrees*10e-7, second
*			 value / y: longitude in degrees*10e-7, third value / z: positive altitude in meters with 0 being at ground
*			 level in terrain model */
                    MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = 11,
                }

                impl MAV_FRAME {
                    pub fn from_bits(src: i8) -> Option<MAV_FRAME> {
                        match src
                        {
                            0 => Some(MAV_FRAME::MAV_FRAME_GLOBAL),
                            1 => Some(MAV_FRAME::MAV_FRAME_LOCAL_NED),
                            2 => Some(MAV_FRAME::MAV_FRAME_MISSION),
                            3 => Some(MAV_FRAME::MAV_FRAME_GLOBAL_RELATIVE_ALT),
                            4 => Some(MAV_FRAME::MAV_FRAME_LOCAL_ENU),
                            5 => Some(MAV_FRAME::MAV_FRAME_GLOBAL_INT),
                            6 => Some(MAV_FRAME::MAV_FRAME_GLOBAL_RELATIVE_ALT_INT),
                            7 => Some(MAV_FRAME::MAV_FRAME_LOCAL_OFFSET_NED),
                            8 => Some(MAV_FRAME::MAV_FRAME_BODY_NED),
                            9 => Some(MAV_FRAME::MAV_FRAME_BODY_OFFSET_NED),
                            10 => Some(MAV_FRAME::MAV_FRAME_GLOBAL_TERRAIN_ALT),
                            11 => Some(MAV_FRAME::MAV_FRAME_GLOBAL_TERRAIN_ALT_INT),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*ADSB classification for the type of vehicle emitting the transponder signal */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum ADSB_EMITTER_TYPE {
                    ADSB_EMITTER_TYPE_NO_INFO = 0,
                    ADSB_EMITTER_TYPE_LIGHT = 1,
                    ADSB_EMITTER_TYPE_SMALL = 2,
                    ADSB_EMITTER_TYPE_LARGE = 3,
                    ADSB_EMITTER_TYPE_HIGH_VORTEX_LARGE = 4,
                    ADSB_EMITTER_TYPE_HEAVY = 5,
                    ADSB_EMITTER_TYPE_HIGHLY_MANUV = 6,
                    ADSB_EMITTER_TYPE_ROTOCRAFT = 7,
                    ADSB_EMITTER_TYPE_UNASSIGNED = 8,
                    ADSB_EMITTER_TYPE_GLIDER = 9,
                    ADSB_EMITTER_TYPE_LIGHTER_AIR = 10,
                    ADSB_EMITTER_TYPE_PARACHUTE = 11,
                    ADSB_EMITTER_TYPE_ULTRA_LIGHT = 12,
                    ADSB_EMITTER_TYPE_UNASSIGNED2 = 13,
                    ADSB_EMITTER_TYPE_UAV = 14,
                    ADSB_EMITTER_TYPE_SPACE = 15,
                    ADSB_EMITTER_TYPE_UNASSGINED3 = 16,
                    ADSB_EMITTER_TYPE_EMERGENCY_SURFACE = 17,
                    ADSB_EMITTER_TYPE_SERVICE_SURFACE = 18,
                    ADSB_EMITTER_TYPE_POINT_OBSTACLE = 19,
                }

                impl ADSB_EMITTER_TYPE {
                    pub fn from_bits(src: i8) -> Option<ADSB_EMITTER_TYPE> {
                        match src
                        {
                            0 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_NO_INFO),
                            1 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_LIGHT),
                            2 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_SMALL),
                            3 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_LARGE),
                            4 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_HIGH_VORTEX_LARGE),
                            5 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_HEAVY),
                            6 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_HIGHLY_MANUV),
                            7 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_ROTOCRAFT),
                            8 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_UNASSIGNED),
                            9 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_GLIDER),
                            10 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_LIGHTER_AIR),
                            11 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_PARACHUTE),
                            12 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_ULTRA_LIGHT),
                            13 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_UNASSIGNED2),
                            14 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_UAV),
                            15 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_SPACE),
                            16 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_UNASSGINED3),
                            17 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_EMERGENCY_SURFACE),
                            18 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_SERVICE_SURFACE),
                            19 => Some(ADSB_EMITTER_TYPE::ADSB_EMITTER_TYPE_POINT_OBSTACLE),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*GPS lataral offset encoding */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT {
                    NO_DATA = 0,
                    LEFT_2M = 1,
                    LEFT_4M = 2,
                    LEFT_6M = 3,
                    RIGHT_0M = 4,
                    RIGHT_2M = 5,
                    RIGHT_4M = 6,
                    RIGHT_6M = 7,
                }

                impl UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT {
                    pub fn from_bits(src: i8) -> Option<UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT> {
                        match src
                        {
                            0 => Some(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT::NO_DATA),
                            1 => Some(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT::LEFT_2M),
                            2 => Some(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT::LEFT_4M),
                            3 => Some(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT::LEFT_6M),
                            4 => Some(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT::RIGHT_0M),
                            5 => Some(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT::RIGHT_2M),
                            6 => Some(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT::RIGHT_4M),
                            7 => Some(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT::RIGHT_6M),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*GPS longitudinal offset encoding */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON {
                    UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_NO_DATA = 0,
                    UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_APPLIED_BY_SENSOR = 1,
                }

                impl UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON {
                    pub fn from_bits(src: i8) -> Option<UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON> {
                        match src
                        {
                            0 => Some(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON::UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_NO_DATA),
                            1 => Some(UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON::UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_APPLIED_BY_SENSOR),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum GPS_INPUT_IGNORE_FLAGS {
                    GPS_INPUT_IGNORE_FLAG_ALT = 1,
                    //ignore altitude field
                    GPS_INPUT_IGNORE_FLAG_HDOP = 2,
                    //ignore hdop field
                    GPS_INPUT_IGNORE_FLAG_VDOP = 4,
                    //ignore vdop field
                    GPS_INPUT_IGNORE_FLAG_VEL_HORIZ = 8,
                    //ignore horizontal velocity field (vn and ve)
                    GPS_INPUT_IGNORE_FLAG_VEL_VERT = 16,
                    //ignore vertical velocity field (vd)
                    GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY = 32,
                    //ignore speed accuracy field
                    GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY = 64,
                    //ignore horizontal accuracy field
                    GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY = 128,//ignore vertical accuracy field
                }

                impl GPS_INPUT_IGNORE_FLAGS {
                    pub fn from_bits(src: i32) -> Option<GPS_INPUT_IGNORE_FLAGS> {
                        match src
                        {
                            0 => {
                                return Some(GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_ALT);
                            }
                            1 => {
                                return Some(GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_HDOP);
                            }
                            2 => {
                                return Some(GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VDOP);
                            }
                            3 => {
                                return Some(GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VEL_HORIZ);
                            }
                            4 => {
                                return Some(GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VEL_VERT);
                            }
                            5 => {
                                return Some(GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY);
                            }
                            6 => {
                                return Some(GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY);
                            }
                            7 => {
                                return Some(GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_ALT => {
                                return 0;
                            }
                            GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_HDOP => {
                                return 1;
                            }
                            GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VDOP => {
                                return 2;
                            }
                            GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VEL_HORIZ => {
                                return 3;
                            }
                            GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VEL_VERT => {
                                return 4;
                            }
                            GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY => {
                                return 5;
                            }
                            GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY => {
                                return 6;
                            }
                            GPS_INPUT_IGNORE_FLAGS::GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY => {
                                return 7;
                            }
                        }
                    }
                }

                /**
*Flags in RALLY_POINT message */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum RALLY_FLAGS {
                    FAVORABLE_WIND = 1,
                    //Flag set when requiring favorable winds for landing.
                    /**
*Flag set when plane is to immediately descend to break altitude and land without GCS intervention. Flag
*			 not set when plane is to loiter at Rally point until commanded to land */
                    LAND_IMMEDIATELY = 2,
                }

                impl RALLY_FLAGS {
                    pub fn from_bits(src: i8) -> Option<RALLY_FLAGS> {
                        match src
                        {
                            1 => Some(RALLY_FLAGS::FAVORABLE_WIND),
                            2 => Some(RALLY_FLAGS::LAND_IMMEDIATELY),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }


                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum FENCE_BREACH {
                    FENCE_BREACH_NONE = 0,
                    //No last fence breach
                    FENCE_BREACH_MINALT = 1,
                    //Breached minimum altitude
                    FENCE_BREACH_MAXALT = 2,
                    //Breached maximum altitude
                    FENCE_BREACH_BOUNDARY = 3,//Breached fence boundary
                }

                impl FENCE_BREACH {
                    pub fn from_bits(src: i8) -> Option<FENCE_BREACH> {
                        match src
                        {
                            0 => Some(FENCE_BREACH::FENCE_BREACH_NONE),
                            1 => Some(FENCE_BREACH::FENCE_BREACH_MINALT),
                            2 => Some(FENCE_BREACH::FENCE_BREACH_MAXALT),
                            3 => Some(FENCE_BREACH::FENCE_BREACH_BOUNDARY),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }

                /**
*These flags encode the MAV mode. */
                #[derive(PartialEq, Debug)]
                #[repr(i32)]
                pub enum MAV_MODE_FLAG {
                    MAV_MODE_FLAG_CUSTOM_MODE_ENABLED = 1,
                    //0b00000001 Reserved for future use.
                    /**
*0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should
*			 not be used for stable implementations */
                    MAV_MODE_FLAG_TEST_ENABLED = 2,
                    /**
*0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not,
*			 depends on the actual implementation */
                    MAV_MODE_FLAG_AUTO_ENABLED = 4,
                    MAV_MODE_FLAG_GUIDED_ENABLED = 8,
                    //0b00001000 guided mode enabled, system flies waypoints / mission items.
                    /**
*0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further
*			 control inputs to move around */
                    MAV_MODE_FLAG_STABILIZE_ENABLED = 16,
                    /**
*0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software
*			 is full operational */
                    MAV_MODE_FLAG_HIL_ENABLED = 32,
                    MAV_MODE_FLAG_MANUAL_INPUT_ENABLED = 64,
                    //0b01000000 remote control input is enabled.
                    /**
*0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. Additional
*					 note: this flag is to be ignore when sent in the command MAV_CMD_DO_SET_MODE and MAV_CMD_COMPONENT_ARM_DISARM
*					 shall be used instead. The flag can still be used to report the armed state */
                    MAV_MODE_FLAG_SAFETY_ARMED = 128,
                }

                impl MAV_MODE_FLAG {
                    pub fn from_bits(src: i32) -> Option<MAV_MODE_FLAG> {
                        match src
                        {
                            0 => {
                                return Some(MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED);
                            }
                            1 => {
                                return Some(MAV_MODE_FLAG::MAV_MODE_FLAG_TEST_ENABLED);
                            }
                            2 => {
                                return Some(MAV_MODE_FLAG::MAV_MODE_FLAG_AUTO_ENABLED);
                            }
                            3 => {
                                return Some(MAV_MODE_FLAG::MAV_MODE_FLAG_GUIDED_ENABLED);
                            }
                            4 => {
                                return Some(MAV_MODE_FLAG::MAV_MODE_FLAG_STABILIZE_ENABLED);
                            }
                            5 => {
                                return Some(MAV_MODE_FLAG::MAV_MODE_FLAG_HIL_ENABLED);
                            }
                            6 => {
                                return Some(MAV_MODE_FLAG::MAV_MODE_FLAG_MANUAL_INPUT_ENABLED);
                            }
                            7 => {
                                return Some(MAV_MODE_FLAG::MAV_MODE_FLAG_SAFETY_ARMED);
                            }

                            _ => None,
                        }
                    }

                    pub fn bits(self) -> i32 {
                        match self
                        {
                            MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED => {
                                return 0;
                            }
                            MAV_MODE_FLAG::MAV_MODE_FLAG_TEST_ENABLED => {
                                return 1;
                            }
                            MAV_MODE_FLAG::MAV_MODE_FLAG_AUTO_ENABLED => {
                                return 2;
                            }
                            MAV_MODE_FLAG::MAV_MODE_FLAG_GUIDED_ENABLED => {
                                return 3;
                            }
                            MAV_MODE_FLAG::MAV_MODE_FLAG_STABILIZE_ENABLED => {
                                return 4;
                            }
                            MAV_MODE_FLAG::MAV_MODE_FLAG_HIL_ENABLED => {
                                return 5;
                            }
                            MAV_MODE_FLAG::MAV_MODE_FLAG_MANUAL_INPUT_ENABLED => {
                                return 6;
                            }
                            MAV_MODE_FLAG::MAV_MODE_FLAG_SAFETY_ARMED => {
                                return 7;
                            }
                        }
                    }
                }

                /**
*Bus types for device operations */
                #[derive(PartialEq, Debug)]
                #[repr(i8)]
                pub enum DEVICE_OP_BUSTYPE {
                    DEVICE_OP_BUSTYPE_I2C = 0,
                    //I2C Device operation
                    DEVICE_OP_BUSTYPE_SPI = 1,//SPI Device operation
                }

                impl DEVICE_OP_BUSTYPE {
                    pub fn from_bits(src: i8) -> Option<DEVICE_OP_BUSTYPE> {
                        match src
                        {
                            0 => Some(DEVICE_OP_BUSTYPE::DEVICE_OP_BUSTYPE_I2C),
                            1 => Some(DEVICE_OP_BUSTYPE::DEVICE_OP_BUSTYPE_SPI),
                            _ => None,
                        }
                    }
                    pub fn bits(self) -> i8 {
                        self as i8
                    }
                }
            }

            pub mod CommunicationChannel {
                use crate::com::company::demo::GroundControl as packs;
                use crate::sys;
                use std::mem::transmute;


                pub trait IReceiver {
                    /**
							* Getting reference to customer receiver by reference to sys::Receiver inside it. Mostly used self_by_field_ptr! macros
							**/
                    unsafe fn into_self<'a>(receiver: *mut sys::Receiver) -> &'a mut Self;
                    /**
							* Get internal sys::Receiver from Customer receiver
							**/
                    fn get_receiver(&mut self) -> &mut sys::Receiver;
                    /**
							* Received packs handler functions
							**/
                    fn on_RESOURCE_REQUEST(&mut self, pack: *mut sys::Pack);
                    fn on_ATTITUDE_TARGET(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_COUNT(&mut self, pack: *mut sys::Pack);
                    fn on_ADSB_VEHICLE(&mut self, pack: *mut sys::Pack);
                    fn on_MESSAGE_INTERVAL(&mut self, pack: *mut sys::Pack);
                    fn on_ESTIMATOR_STATUS(&mut self, pack: *mut sys::Pack);
                    fn on_TIMESYNC(&mut self, pack: *mut sys::Pack);
                    fn on_GLOBAL_POSITION_INT_COV(&mut self, pack: *mut sys::Pack);
                    fn on_BUTTON_CHANGE(&mut self, pack: *mut sys::Pack);
                    fn on_SAFETY_SET_ALLOWED_AREA(&mut self, pack: *mut sys::Pack);
                    fn on_STORAGE_INFORMATION(&mut self, pack: *mut sys::Pack);
                    fn on_COLLISION(&mut self, pack: *mut sys::Pack);
                    fn on_ALTITUDE(&mut self, pack: *mut sys::Pack);
                    fn on_HIL_STATE_QUATERNION(&mut self, pack: *mut sys::Pack);
                    fn on_CAMERA_INFORMATION(&mut self, pack: *mut sys::Pack);
                    fn on_GPS_STATUS(&mut self, pack: *mut sys::Pack);
                    fn on_PARAM_SET(&mut self, pack: *mut sys::Pack);
                    fn on_TERRAIN_DATA(&mut self, pack: *mut sys::Pack);
                    fn on_RC_CHANNELS_OVERRIDE(&mut self, pack: *mut sys::Pack);
                    fn on_SCALED_IMU(&mut self, pack: *mut sys::Pack);
                    fn on_DEBUG(&mut self, pack: *mut sys::Pack);
                    fn on_CAMERA_IMAGE_CAPTURED(&mut self, pack: *mut sys::Pack);
                    fn on_LOG_ENTRY(&mut self, pack: *mut sys::Pack);
                    fn on_ACTUATOR_CONTROL_TARGET(&mut self, pack: *mut sys::Pack);
                    fn on_HIGH_LATENCY(&mut self, pack: *mut sys::Pack);
                    fn on_PARAM_REQUEST_READ(&mut self, pack: *mut sys::Pack);
                    fn on_SET_ATTITUDE_TARGET(&mut self, pack: *mut sys::Pack);
                    fn on_FOLLOW_TARGET(&mut self, pack: *mut sys::Pack);
                    fn on_HIL_STATE(&mut self, pack: *mut sys::Pack);
                    fn on_HOME_POSITION(&mut self, pack: *mut sys::Pack);
                    fn on_GPS2_RAW(&mut self, pack: *mut sys::Pack);
                    fn on_MEMORY_VECT(&mut self, pack: *mut sys::Pack);
                    fn on_REQUEST_DATA_STREAM(&mut self, pack: *mut sys::Pack);
                    fn on_HIL_CONTROLS(&mut self, pack: *mut sys::Pack);
                    fn on_HIL_SENSOR(&mut self, pack: *mut sys::Pack);
                    fn on_SETUP_SIGNING(&mut self, pack: *mut sys::Pack);
                    fn on_GPS_RTK(&mut self, pack: *mut sys::Pack);
                    fn on_PARAM_REQUEST_LIST(&mut self, pack: *mut sys::Pack);
                    fn on_LANDING_TARGET(&mut self, pack: *mut sys::Pack);
                    fn on_SET_ACTUATOR_CONTROL_TARGET(&mut self, pack: *mut sys::Pack);
                    fn on_CONTROL_SYSTEM_STATE(&mut self, pack: *mut sys::Pack);
                    fn on_SET_POSITION_TARGET_GLOBAL_INT(&mut self, pack: *mut sys::Pack);
                    fn on_VIBRATION(&mut self, pack: *mut sys::Pack);
                    fn on_PING33(&mut self, pack: *mut sys::Pack);
                    fn on_VFR_HUD(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_SET_CURRENT(&mut self, pack: *mut sys::Pack);
                    fn on_HIL_GPS(&mut self, pack: *mut sys::Pack);
                    fn on_NAV_CONTROLLER_OUTPUT(&mut self, pack: *mut sys::Pack);
                    fn on_AUTH_KEY(&mut self, pack: *mut sys::Pack);
                    fn on_LOCAL_POSITION_NED_COV(&mut self, pack: *mut sys::Pack);
                    fn on_ATT_POS_MOCAP(&mut self, pack: *mut sys::Pack);
                    fn on_STATUSTEXT(&mut self, pack: *mut sys::Pack);
                    fn on_PING(&mut self, pack: *mut sys::Pack);
                    fn on_CAMERA_CAPTURE_STATUS(&mut self, pack: *mut sys::Pack);
                    fn on_GLOBAL_POSITION_INT(&mut self, pack: *mut sys::Pack);
                    fn on_ENCAPSULATED_DATA(&mut self, pack: *mut sys::Pack);
                    fn on_GPS_INPUT(&mut self, pack: *mut sys::Pack);
                    fn on_COMMAND_LONG(&mut self, pack: *mut sys::Pack);
                    fn on_LOG_REQUEST_DATA(&mut self, pack: *mut sys::Pack);
                    fn on_GPS_RAW_INT(&mut self, pack: *mut sys::Pack);
                    fn on_RC_CHANNELS_SCALED(&mut self, pack: *mut sys::Pack);
                    fn on_CAMERA_SETTINGS(&mut self, pack: *mut sys::Pack);
                    fn on_RAW_PRESSURE(&mut self, pack: *mut sys::Pack);
                    fn on_NAMED_VALUE_FLOAT(&mut self, pack: *mut sys::Pack);
                    fn on_ATTITUDE(&mut self, pack: *mut sys::Pack);
                    fn on_TERRAIN_REQUEST(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_WRITE_PARTIAL_LIST(&mut self, pack: *mut sys::Pack);
                    fn on_LOG_ERASE(&mut self, pack: *mut sys::Pack);
                    fn on_MANUAL_SETPOINT(&mut self, pack: *mut sys::Pack);
                    fn on_SAFETY_ALLOWED_AREA(&mut self, pack: *mut sys::Pack);
                    fn on_OPTICAL_FLOW_RAD(&mut self, pack: *mut sys::Pack);
                    fn on_LOG_DATA(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_CLEAR_ALL(&mut self, pack: *mut sys::Pack);
                    fn on_VICON_POSITION_ESTIMATE(&mut self, pack: *mut sys::Pack);
                    fn on_GPS2_RTK(&mut self, pack: *mut sys::Pack);
                    fn on_LOG_REQUEST_LIST(&mut self, pack: *mut sys::Pack);
                    fn on_SCALED_PRESSURE(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_REQUEST_INT(&mut self, pack: *mut sys::Pack);
                    fn on_V2_EXTENSION(&mut self, pack: *mut sys::Pack);
                    fn on_HEARTBEAT(&mut self, pack: *mut sys::Pack);
                    fn on_PARAM_MAP_RC(&mut self, pack: *mut sys::Pack);
                    fn on_POWER_STATUS(&mut self, pack: *mut sys::Pack);
                    fn on_TERRAIN_CHECK(&mut self, pack: *mut sys::Pack);
                    fn on_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(&mut self, pack: *mut sys::Pack);
                    fn on_COMMAND_ACK(&mut self, pack: *mut sys::Pack);
                    fn on_DATA_STREAM(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_REQUEST(&mut self, pack: *mut sys::Pack);
                    fn on_TERRAIN_REPORT(&mut self, pack: *mut sys::Pack);
                    fn on_SET_HOME_POSITION(&mut self, pack: *mut sys::Pack);
                    fn on_SwitchModeCommand(&mut self);
                    fn on_HIL_RC_INPUTS_RAW(&mut self, pack: *mut sys::Pack);
                    fn on_SCALED_IMU3(&mut self, pack: *mut sys::Pack);
                    fn on_SET_MODE(&mut self, pack: *mut sys::Pack);
                    fn on_POSITION_TARGET_GLOBAL_INT(&mut self, pack: *mut sys::Pack);
                    fn on_FLIGHT_INFORMATION(&mut self, pack: *mut sys::Pack);
                    fn on_SIM_STATE(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_ITEM_REACHED(&mut self, pack: *mut sys::Pack);
                    fn on_RC_CHANNELS_RAW(&mut self, pack: *mut sys::Pack);
                    fn on_SERVO_OUTPUT_RAW(&mut self, pack: *mut sys::Pack);
                    fn on_VISION_SPEED_ESTIMATE(&mut self, pack: *mut sys::Pack);
                    fn on_DEBUG_VECT(&mut self, pack: *mut sys::Pack);
                    fn on_LOG_REQUEST_END(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_ACK(&mut self, pack: *mut sys::Pack);
                    fn on_CHANGE_OPERATOR_CONTROL_ACK(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_CURRENT(&mut self, pack: *mut sys::Pack);
                    fn on_SYSTEM_TIME(&mut self, pack: *mut sys::Pack);
                    fn on_CAMERA_TRIGGER(&mut self, pack: *mut sys::Pack);
                    fn on_VISION_POSITION_ESTIMATE(&mut self, pack: *mut sys::Pack);
                    fn on_MANUAL_CONTROL(&mut self, pack: *mut sys::Pack);
                    fn on_RC_CHANNELS(&mut self, pack: *mut sys::Pack);
                    fn on_PARAM_VALUE(&mut self, pack: *mut sys::Pack);
                    fn on_BATTERY_STATUS(&mut self, pack: *mut sys::Pack);
                    fn on_SET_POSITION_TARGET_LOCAL_NED(&mut self, pack: *mut sys::Pack);
                    fn on_SERIAL_CONTROL(&mut self, pack: *mut sys::Pack);
                    fn on_SET_GPS_GLOBAL_ORIGIN(&mut self, pack: *mut sys::Pack);
                    fn on_AUTOPILOT_VERSION(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_REQUEST_LIST(&mut self, pack: *mut sys::Pack);
                    fn on_PLAY_TUNE(&mut self, pack: *mut sys::Pack);
                    fn on_SCALED_PRESSURE3(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_REQUEST_PARTIAL_LIST(&mut self, pack: *mut sys::Pack);
                    fn on_LOCAL_POSITION_NED(&mut self, pack: *mut sys::Pack);
                    fn on_DATA_TRANSMISSION_HANDSHAKE(&mut self, pack: *mut sys::Pack);
                    fn on_GPS_GLOBAL_ORIGIN(&mut self, pack: *mut sys::Pack);
                    fn on_SCALED_IMU2(&mut self, pack: *mut sys::Pack);
                    fn on_ATTITUDE_QUATERNION(&mut self, pack: *mut sys::Pack);
                    fn on_HIL_ACTUATOR_CONTROLS(&mut self, pack: *mut sys::Pack);
                    fn on_POSITION_TARGET_LOCAL_NED(&mut self, pack: *mut sys::Pack);
                    fn on_DISTANCE_SENSOR(&mut self, pack: *mut sys::Pack);
                    fn on_HIL_OPTICAL_FLOW(&mut self, pack: *mut sys::Pack);
                    fn on_SCALED_PRESSURE2(&mut self, pack: *mut sys::Pack);
                    fn on_WIND_COV(&mut self, pack: *mut sys::Pack);
                    fn on_CHANGE_OPERATOR_CONTROL(&mut self, pack: *mut sys::Pack);
                    fn on_SYS_STATUS(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_ITEM(&mut self, pack: *mut sys::Pack);
                    fn on_RAW_IMU(&mut self, pack: *mut sys::Pack);
                    fn on_COMMAND_INT(&mut self, pack: *mut sys::Pack);
                    fn on_OPTICAL_FLOW(&mut self, pack: *mut sys::Pack);
                    fn on_MISSION_ITEM_INT(&mut self, pack: *mut sys::Pack);
                    fn on_HIGHRES_IMU(&mut self, pack: *mut sys::Pack);
                    fn on_EXTENDED_SYS_STATE(&mut self, pack: *mut sys::Pack);
                    fn on_GPS_INJECT_DATA(&mut self, pack: *mut sys::Pack);
                    fn on_ATTITUDE_QUATERNION_COV(&mut self, pack: *mut sys::Pack);
                    fn on_NAMED_VALUE_INT(&mut self, pack: *mut sys::Pack);
                    fn on_RADIO_STATUS(&mut self, pack: *mut sys::Pack);
                    fn on_GPS_RTCM_DATA(&mut self, pack: *mut sys::Pack);
                    fn on_GLOBAL_VISION_POSITION_ESTIMATE(&mut self, pack: *mut sys::Pack);
                    fn on_FILE_TRANSFER_PROTOCOL(&mut self, pack: *mut sys::Pack);

                    /**
							* Translate received byte(s) into pack(s)
							**/
                    #[inline(always)]
                    fn bytes_into_packs(&mut self, src: &[u8]) -> Result<usize, ::std::io::Error> {
                        unsafe { sys::receive(src.as_ptr(), src.len(), self.get_receiver()); }
                        Ok(src.len() as usize)
                    }
                    /**
						    *Convenient  sys::Receiver constructor
						    **/
                    fn new() -> sys::Receiver { sys::Receiver::new(Self::dispatch) }
                    /**
							*Received packs to packs handler functions dispatcher
							**/
                    unsafe extern fn dispatch(receiver: *mut sys::Receiver, id: usize, pack: *mut sys::Pack) -> *const sys::Meta {
                        let self_ = Self::into_self(receiver);
                        match id {
                            92 =>
                                {
                                    if pack.is_null() { return packs::TERRAIN_REQUEST::meta_; }
                                    Self::on_TERRAIN_REQUEST(self_, pack);
                                }
                            13 =>
                                {
                                    if pack.is_null() { return packs::OPTICAL_FLOW::meta_; }
                                    Self::on_OPTICAL_FLOW(self_, pack);
                                }
                            85 =>
                                {
                                    if pack.is_null() { return packs::MISSION_ACK::meta_; }
                                    Self::on_MISSION_ACK(self_, pack);
                                }
                            203 =>
                                {
                                    if pack.is_null() { return packs::PLAY_TUNE::meta_; }
                                    Self::on_PLAY_TUNE(self_, pack);
                                }
                            158 =>
                                {
                                    if pack.is_null() { return packs::LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET::meta_; }
                                    Self::on_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(self_, pack);
                                }
                            45 =>
                                {
                                    if pack.is_null() { return packs::COLLISION::meta_; }
                                    Self::on_COLLISION(self_, pack);
                                }
                            132 =>
                                {
                                    if pack.is_null() { return packs::SYS_STATUS::meta_; }
                                    Self::on_SYS_STATUS(self_, pack);
                                }
                            209 =>
                                {
                                    if pack.is_null() { return packs::SET_POSITION_TARGET_LOCAL_NED::meta_; }
                                    Self::on_SET_POSITION_TARGET_LOCAL_NED(self_, pack);
                                }
                            139 =>
                                {
                                    if pack.is_null() { return packs::PING33::meta_; }
                                    Self::on_PING33(self_, pack);
                                }
                            31 =>
                                {
                                    if pack.is_null() { return packs::DATA_STREAM::meta_; }
                                    Self::on_DATA_STREAM(self_, pack);
                                }
                            110 =>
                                {
                                    if pack.is_null() { return packs::GLOBAL_VISION_POSITION_ESTIMATE::meta_; }
                                    Self::on_GLOBAL_VISION_POSITION_ESTIMATE(self_, pack);
                                }
                            103 =>
                                {
                                    if pack.is_null() { return packs::VIBRATION::meta_; }
                                    Self::on_VIBRATION(self_, pack);
                                }
                            148 =>
                                {
                                    if pack.is_null() { return packs::RC_CHANNELS_RAW::meta_; }
                                    Self::on_RC_CHANNELS_RAW(self_, pack);
                                }
                            27 =>
                                {
                                    if pack.is_null() { return packs::FILE_TRANSFER_PROTOCOL::meta_; }
                                    Self::on_FILE_TRANSFER_PROTOCOL(self_, pack);
                                }
                            178 =>
                                {
                                    if pack.is_null() { return packs::SCALED_IMU2::meta_; }
                                    Self::on_SCALED_IMU2(self_, pack);
                                }
                            82 =>
                                {
                                    if pack.is_null() { return packs::HIL_CONTROLS::meta_; }
                                    Self::on_HIL_CONTROLS(self_, pack);
                                }
                            50 =>
                                {
                                    if pack.is_null() { return packs::MISSION_COUNT::meta_; }
                                    Self::on_MISSION_COUNT(self_, pack);
                                }
                            136 =>
                                {
                                    if pack.is_null() { return packs::PARAM_VALUE::meta_; }
                                    Self::on_PARAM_VALUE(self_, pack);
                                }
                            55 =>
                                {
                                    if pack.is_null() { return packs::RC_CHANNELS_OVERRIDE::meta_; }
                                    Self::on_RC_CHANNELS_OVERRIDE(self_, pack);
                                }
                            106 =>
                                {
                                    if pack.is_null() { return packs::ATTITUDE_TARGET::meta_; }
                                    Self::on_ATTITUDE_TARGET(self_, pack);
                                }
                            205 =>
                                {
                                    if pack.is_null() { return packs::SETUP_SIGNING::meta_; }
                                    Self::on_SETUP_SIGNING(self_, pack);
                                }
                            21 =>
                                {
                                    if pack.is_null() { return packs::NAMED_VALUE_INT::meta_; }
                                    Self::on_NAMED_VALUE_INT(self_, pack);
                                }
                            202 =>
                                {
                                    if pack.is_null() { return packs::OPTICAL_FLOW_RAD::meta_; }
                                    Self::on_OPTICAL_FLOW_RAD(self_, pack);
                                }
                            213 =>
                                {
                                    if pack.is_null() { return packs::GPS2_RAW::meta_; }
                                    Self::on_GPS2_RAW(self_, pack);
                                }
                            9 =>
                                {
                                    if pack.is_null() { return packs::SYSTEM_TIME::meta_; }
                                    Self::on_SYSTEM_TIME(self_, pack);
                                }
                            181 =>
                                {
                                    if pack.is_null() { return packs::CAMERA_SETTINGS::meta_; }
                                    Self::on_CAMERA_SETTINGS(self_, pack);
                                }
                            87 =>
                                {
                                    if pack.is_null() { return packs::HIGH_LATENCY::meta_; }
                                    Self::on_HIGH_LATENCY(self_, pack);
                                }
                            179 =>
                                {
                                    if pack.is_null() { return packs::SAFETY_ALLOWED_AREA::meta_; }
                                    Self::on_SAFETY_ALLOWED_AREA(self_, pack);
                                }
                            129 =>
                                {
                                    if pack.is_null() { return packs::POSITION_TARGET_LOCAL_NED::meta_; }
                                    Self::on_POSITION_TARGET_LOCAL_NED(self_, pack);
                                }
                            149 =>
                                {
                                    if pack.is_null() { return packs::DATA_TRANSMISSION_HANDSHAKE::meta_; }
                                    Self::on_DATA_TRANSMISSION_HANDSHAKE(self_, pack);
                                }
                            212 =>
                                {
                                    if pack.is_null() { return packs::MISSION_SET_CURRENT::meta_; }
                                    Self::on_MISSION_SET_CURRENT(self_, pack);
                                }
                            48 =>
                                {
                                    if pack.is_null() { return packs::GPS_STATUS::meta_; }
                                    Self::on_GPS_STATUS(self_, pack);
                                }
                            34 =>
                                {
                                    if pack.is_null() { return packs::ALTITUDE::meta_; }
                                    Self::on_ALTITUDE(self_, pack);
                                }
                            111 =>
                                {
                                    if pack.is_null() { return packs::BATTERY_STATUS::meta_; }
                                    Self::on_BATTERY_STATUS(self_, pack);
                                }
                            78 =>
                                {
                                    if pack.is_null() { return packs::ADSB_VEHICLE::meta_; }
                                    Self::on_ADSB_VEHICLE(self_, pack);
                                }
                            52 =>
                                {
                                    if pack.is_null() { return packs::GPS_INJECT_DATA::meta_; }
                                    Self::on_GPS_INJECT_DATA(self_, pack);
                                }
                            163 =>
                                {
                                    if pack.is_null() { return packs::RAW_IMU::meta_; }
                                    Self::on_RAW_IMU(self_, pack);
                                }
                            16 =>
                                {
                                    if pack.is_null() { return packs::VISION_POSITION_ESTIMATE::meta_; }
                                    Self::on_VISION_POSITION_ESTIMATE(self_, pack);
                                }
                            116 =>
                                {
                                    if pack.is_null() { return packs::HIL_OPTICAL_FLOW::meta_; }
                                    Self::on_HIL_OPTICAL_FLOW(self_, pack);
                                }
                            77 =>
                                {
                                    if pack.is_null() { return packs::SET_HOME_POSITION::meta_; }
                                    Self::on_SET_HOME_POSITION(self_, pack);
                                }
                            176 =>
                                {
                                    if pack.is_null() { return packs::EXTENDED_SYS_STATE::meta_; }
                                    Self::on_EXTENDED_SYS_STATE(self_, pack);
                                }
                            157 =>
                                {
                                    if pack.is_null() { return packs::CAMERA_INFORMATION::meta_; }
                                    Self::on_CAMERA_INFORMATION(self_, pack);
                                }
                            37 =>
                                {
                                    if pack.is_null() { return packs::LOG_REQUEST_LIST::meta_; }
                                    Self::on_LOG_REQUEST_LIST(self_, pack);
                                }
                            102 =>
                                {
                                    if pack.is_null() { return packs::LOG_REQUEST_END::meta_; }
                                    Self::on_LOG_REQUEST_END(self_, pack);
                                }
                            71 =>
                                {
                                    if pack.is_null() { return packs::ATTITUDE_QUATERNION::meta_; }
                                    Self::on_ATTITUDE_QUATERNION(self_, pack);
                                }
                            146 =>
                                {
                                    if pack.is_null() { return packs::BUTTON_CHANGE::meta_; }
                                    Self::on_BUTTON_CHANGE(self_, pack);
                                }
                            151 =>
                                {
                                    if pack.is_null() { return packs::SCALED_PRESSURE2::meta_; }
                                    Self::on_SCALED_PRESSURE2(self_, pack);
                                }
                            94 =>
                                {
                                    if pack.is_null() { return packs::SET_ACTUATOR_CONTROL_TARGET::meta_; }
                                    Self::on_SET_ACTUATOR_CONTROL_TARGET(self_, pack);
                                }
                            95 =>
                                {
                                    if pack.is_null() { return packs::AUTH_KEY::meta_; }
                                    Self::on_AUTH_KEY(self_, pack);
                                }
                            131 =>
                                {
                                    if pack.is_null() { return packs::LOCAL_POSITION_NED::meta_; }
                                    Self::on_LOCAL_POSITION_NED(self_, pack);
                                }
                            134 =>
                                {
                                    if pack.is_null() { return packs::ATTITUDE::meta_; }
                                    Self::on_ATTITUDE(self_, pack);
                                }
                            3 =>
                                {
                                    if pack.is_null() { return packs::ACTUATOR_CONTROL_TARGET::meta_; }
                                    Self::on_ACTUATOR_CONTROL_TARGET(self_, pack);
                                }
                            210 =>
                                {
                                    if pack.is_null() { return packs::HOME_POSITION::meta_; }
                                    Self::on_HOME_POSITION(self_, pack);
                                }
                            152 =>
                                {
                                    if pack.is_null() { return packs::TERRAIN_CHECK::meta_; }
                                    Self::on_TERRAIN_CHECK(self_, pack);
                                }
                            219 =>
                                {
                                    if pack.is_null() { return packs::MANUAL_SETPOINT::meta_; }
                                    Self::on_MANUAL_SETPOINT(self_, pack);
                                }
                            91 =>
                                {
                                    if pack.is_null() { return packs::GPS2_RTK::meta_; }
                                    Self::on_GPS2_RTK(self_, pack);
                                }
                            180 =>
                                {
                                    if pack.is_null() { return packs::LOCAL_POSITION_NED_COV::meta_; }
                                    Self::on_LOCAL_POSITION_NED_COV(self_, pack);
                                }
                            4 =>
                                {
                                    if pack.is_null() { return packs::LOG_ERASE::meta_; }
                                    Self::on_LOG_ERASE(self_, pack);
                                }
                            46 =>
                                {
                                    if pack.is_null() { return packs::TIMESYNC::meta_; }
                                    Self::on_TIMESYNC(self_, pack);
                                }
                            156 =>
                                {
                                    if pack.is_null() { return packs::POWER_STATUS::meta_; }
                                    Self::on_POWER_STATUS(self_, pack);
                                }
                            200 =>
                                {
                                    if pack.is_null() { return packs::ATT_POS_MOCAP::meta_; }
                                    Self::on_ATT_POS_MOCAP(self_, pack);
                                }
                            207 =>
                                {
                                    if pack.is_null() { return packs::CONTROL_SYSTEM_STATE::meta_; }
                                    Self::on_CONTROL_SYSTEM_STATE(self_, pack);
                                }
                            122 =>
                                {
                                    if pack.is_null() { return packs::PING::meta_; }
                                    Self::on_PING(self_, pack);
                                }
                            81 =>
                                {
                                    if pack.is_null() { return packs::MISSION_ITEM_REACHED::meta_; }
                                    Self::on_MISSION_ITEM_REACHED(self_, pack);
                                }
                            123 =>
                                {
                                    if pack.is_null() { return packs::PARAM_SET::meta_; }
                                    Self::on_PARAM_SET(self_, pack);
                                }
                            73 =>
                                {
                                    if pack.is_null() { return packs::GPS_INPUT::meta_; }
                                    Self::on_GPS_INPUT(self_, pack);
                                }
                            188 =>
                                {
                                    if pack.is_null() { return packs::MISSION_REQUEST_INT::meta_; }
                                    Self::on_MISSION_REQUEST_INT(self_, pack);
                                }
                            215 =>
                                {
                                    if pack.is_null() { return packs::FLIGHT_INFORMATION::meta_; }
                                    Self::on_FLIGHT_INFORMATION(self_, pack);
                                }
                            24 =>
                                {
                                    if pack.is_null() { return packs::SAFETY_SET_ALLOWED_AREA::meta_; }
                                    Self::on_SAFETY_SET_ALLOWED_AREA(self_, pack);
                                }
                            53 =>
                                {
                                    if pack.is_null() { return packs::SET_GPS_GLOBAL_ORIGIN::meta_; }
                                    Self::on_SET_GPS_GLOBAL_ORIGIN(self_, pack);
                                }
                            58 =>
                                {
                                    if pack.is_null() { return packs::STORAGE_INFORMATION::meta_; }
                                    Self::on_STORAGE_INFORMATION(self_, pack);
                                }
                            98 =>
                                {
                                    if pack.is_null() { return packs::REQUEST_DATA_STREAM::meta_; }
                                    Self::on_REQUEST_DATA_STREAM(self_, pack);
                                }
                            67 =>
                                {
                                    if pack.is_null() { return packs::RESOURCE_REQUEST::meta_; }
                                    Self::on_RESOURCE_REQUEST(self_, pack);
                                }
                            61 =>
                                {
                                    if pack.is_null() { return packs::DISTANCE_SENSOR::meta_; }
                                    Self::on_DISTANCE_SENSOR(self_, pack);
                                }
                            10 =>
                                {
                                    if pack.is_null() { return packs::CAMERA_IMAGE_CAPTURED::meta_; }
                                    Self::on_CAMERA_IMAGE_CAPTURED(self_, pack);
                                }
                            88 =>
                                {
                                    if pack.is_null() { return packs::GPS_RTCM_DATA::meta_; }
                                    Self::on_GPS_RTCM_DATA(self_, pack);
                                }
                            196 =>
                                {
                                    if pack.is_null() { return packs::HIL_STATE_QUATERNION::meta_; }
                                    Self::on_HIL_STATE_QUATERNION(self_, pack);
                                }
                            29 =>
                                {
                                    if pack.is_null() { return packs::PARAM_MAP_RC::meta_; }
                                    Self::on_PARAM_MAP_RC(self_, pack);
                                }
                            62 =>
                                {
                                    if pack.is_null() { return packs::CHANGE_OPERATOR_CONTROL_ACK::meta_; }
                                    Self::on_CHANGE_OPERATOR_CONTROL_ACK(self_, pack);
                                }
                            47 =>
                                {
                                    if pack.is_null() { return packs::PARAM_REQUEST_LIST::meta_; }
                                    Self::on_PARAM_REQUEST_LIST(self_, pack);
                                }
                            39 =>
                                {
                                    if pack.is_null() { return packs::FOLLOW_TARGET::meta_; }
                                    Self::on_FOLLOW_TARGET(self_, pack);
                                }
                            184 =>
                                {
                                    if pack.is_null() { return packs::HIL_RC_INPUTS_RAW::meta_; }
                                    Self::on_HIL_RC_INPUTS_RAW(self_, pack);
                                }
                            125 =>
                                {
                                    if pack.is_null() { return packs::HEARTBEAT::meta_; }
                                    Self::on_HEARTBEAT(self_, pack);
                                }
                            23 =>
                                {
                                    if pack.is_null() { return packs::RC_CHANNELS::meta_; }
                                    Self::on_RC_CHANNELS(self_, pack);
                                }
                            172 =>
                                {
                                    if pack.is_null() { return packs::LANDING_TARGET::meta_; }
                                    Self::on_LANDING_TARGET(self_, pack);
                                }
                            218 =>
                                {
                                    if pack.is_null() { return packs::SET_POSITION_TARGET_GLOBAL_INT::meta_; }
                                    Self::on_SET_POSITION_TARGET_GLOBAL_INT(self_, pack);
                                }
                            170 =>
                                {
                                    if pack.is_null() { return packs::ENCAPSULATED_DATA::meta_; }
                                    Self::on_ENCAPSULATED_DATA(self_, pack);
                                }
                            191 =>
                                {
                                    if pack.is_null() { return packs::CAMERA_TRIGGER::meta_; }
                                    Self::on_CAMERA_TRIGGER(self_, pack);
                                }
                            187 =>
                                {
                                    if pack.is_null() { return packs::DEBUG_VECT::meta_; }
                                    Self::on_DEBUG_VECT(self_, pack);
                                }
                            101 =>
                                {
                                    if pack.is_null() { return packs::COMMAND_LONG::meta_; }
                                    Self::on_COMMAND_LONG(self_, pack);
                                }
                            30 =>
                                {
                                    if pack.is_null() { return packs::MEMORY_VECT::meta_; }
                                    Self::on_MEMORY_VECT(self_, pack);
                                }
                            162 =>
                                {
                                    if pack.is_null() { return packs::GLOBAL_POSITION_INT::meta_; }
                                    Self::on_GLOBAL_POSITION_INT(self_, pack);
                                }
                            107 =>
                                {
                                    if pack.is_null() { return packs::RADIO_STATUS::meta_; }
                                    Self::on_RADIO_STATUS(self_, pack);
                                }
                            54 =>
                                {
                                    if pack.is_null() { return packs::MANUAL_CONTROL::meta_; }
                                    Self::on_MANUAL_CONTROL(self_, pack);
                                }
                            145 =>
                                {
                                    if pack.is_null() { return packs::MISSION_WRITE_PARTIAL_LIST::meta_; }
                                    Self::on_MISSION_WRITE_PARTIAL_LIST(self_, pack);
                                }
                            135 =>
                                {
                                    if pack.is_null() { return packs::VICON_POSITION_ESTIMATE::meta_; }
                                    Self::on_VICON_POSITION_ESTIMATE(self_, pack);
                                }
                            147 =>
                                {
                                    if pack.is_null() { return packs::MISSION_REQUEST::meta_; }
                                    Self::on_MISSION_REQUEST(self_, pack);
                                }
                            169 =>
                                {
                                    if pack.is_null() { return packs::HIL_SENSOR::meta_; }
                                    Self::on_HIL_SENSOR(self_, pack);
                                }
                            79 =>
                                {
                                    if pack.is_null() { return packs::SERVO_OUTPUT_RAW::meta_; }
                                    Self::on_SERVO_OUTPUT_RAW(self_, pack);
                                }
                            206 =>
                                {
                                    if pack.is_null() { return packs::MISSION_REQUEST_PARTIAL_LIST::meta_; }
                                    Self::on_MISSION_REQUEST_PARTIAL_LIST(self_, pack);
                                }
                            126 =>
                                {
                                    if pack.is_null() { return packs::DEBUG::meta_; }
                                    Self::on_DEBUG(self_, pack);
                                }
                            38 =>
                                {
                                    if pack.is_null() { return packs::ESTIMATOR_STATUS::meta_; }
                                    Self::on_ESTIMATOR_STATUS(self_, pack);
                                }
                            189 =>
                                {
                                    if pack.is_null() { return packs::MISSION_CURRENT::meta_; }
                                    Self::on_MISSION_CURRENT(self_, pack);
                                }
                            168 =>
                                {
                                    if pack.is_null() { return packs::HIL_GPS::meta_; }
                                    Self::on_HIL_GPS(self_, pack);
                                }
                            161 =>
                                {
                                    if pack.is_null() { return packs::LOG_ENTRY::meta_; }
                                    Self::on_LOG_ENTRY(self_, pack);
                                }
                            15 =>
                                {
                                    if pack.is_null() { return packs::VFR_HUD::meta_; }
                                    Self::on_VFR_HUD(self_, pack);
                                }
                            182 =>
                                {
                                    if pack.is_null() { return packs::ATTITUDE_QUATERNION_COV::meta_; }
                                    Self::on_ATTITUDE_QUATERNION_COV(self_, pack);
                                }
                            56 =>
                                {
                                    if pack.is_null() { return packs::GPS_RAW_INT::meta_; }
                                    Self::on_GPS_RAW_INT(self_, pack);
                                }
                            193 =>
                                {
                                    if pack.is_null() { return packs::MISSION_CLEAR_ALL::meta_; }
                                    Self::on_MISSION_CLEAR_ALL(self_, pack);
                                }
                            8 =>
                                {
                                    if pack.is_null() { return packs::NAMED_VALUE_FLOAT::meta_; }
                                    Self::on_NAMED_VALUE_FLOAT(self_, pack);
                                }
                            108 =>
                                {
                                    if pack.is_null() { return packs::SIM_STATE::meta_; }
                                    Self::on_SIM_STATE(self_, pack);
                                }
                            60 =>
                                {
                                    if pack.is_null() { return packs::AUTOPILOT_VERSION::meta_; }
                                    Self::on_AUTOPILOT_VERSION(self_, pack);
                                }
                            167 =>
                                {
                                    if pack.is_null() { return packs::COMMAND_INT::meta_; }
                                    Self::on_COMMAND_INT(self_, pack);
                                }
                            89 =>
                                {
                                    if pack.is_null() { return packs::GPS_RTK::meta_; }
                                    Self::on_GPS_RTK(self_, pack);
                                }
                            160 =>
                                {
                                    if pack.is_null() { return packs::WIND_COV::meta_; }
                                    Self::on_WIND_COV(self_, pack);
                                }
                            201 =>
                                {
                                    if pack.is_null() { return packs::NAV_CONTROLLER_OUTPUT::meta_; }
                                    Self::on_NAV_CONTROLLER_OUTPUT(self_, pack);
                                }
                            216 =>
                                {
                                    if pack.is_null() { return packs::CAMERA_CAPTURE_STATUS::meta_; }
                                    Self::on_CAMERA_CAPTURE_STATUS(self_, pack);
                                }
                            28 =>
                                {
                                    if pack.is_null() { return packs::SwitchModeCommand::meta_; }
                                    Self::on_SwitchModeCommand(self_);
                                }
                            59 =>
                                {
                                    if pack.is_null() { return packs::MISSION_ITEM_INT::meta_; }
                                    Self::on_MISSION_ITEM_INT(self_, pack);
                                }
                            195 =>
                                {
                                    if pack.is_null() { return packs::SCALED_IMU::meta_; }
                                    Self::on_SCALED_IMU(self_, pack);
                                }
                            130 =>
                                {
                                    if pack.is_null() { return packs::SCALED_PRESSURE3::meta_; }
                                    Self::on_SCALED_PRESSURE3(self_, pack);
                                }
                            18 =>
                                {
                                    if pack.is_null() { return packs::SCALED_PRESSURE::meta_; }
                                    Self::on_SCALED_PRESSURE(self_, pack);
                                }
                            7 =>
                                {
                                    if pack.is_null() { return packs::SET_MODE::meta_; }
                                    Self::on_SET_MODE(self_, pack);
                                }
                            124 =>
                                {
                                    if pack.is_null() { return packs::STATUSTEXT::meta_; }
                                    Self::on_STATUSTEXT(self_, pack);
                                }
                            72 =>
                                {
                                    if pack.is_null() { return packs::LOG_REQUEST_DATA::meta_; }
                                    Self::on_LOG_REQUEST_DATA(self_, pack);
                                }
                            173 =>
                                {
                                    if pack.is_null() { return packs::TERRAIN_DATA::meta_; }
                                    Self::on_TERRAIN_DATA(self_, pack);
                                }
                            199 =>
                                {
                                    if pack.is_null() { return packs::HIL_ACTUATOR_CONTROLS::meta_; }
                                    Self::on_HIL_ACTUATOR_CONTROLS(self_, pack);
                                }
                            204 =>
                                {
                                    if pack.is_null() { return packs::LOG_DATA::meta_; }
                                    Self::on_LOG_DATA(self_, pack);
                                }
                            6 =>
                                {
                                    if pack.is_null() { return packs::GLOBAL_POSITION_INT_COV::meta_; }
                                    Self::on_GLOBAL_POSITION_INT_COV(self_, pack);
                                }
                            121 =>
                                {
                                    if pack.is_null() { return packs::COMMAND_ACK::meta_; }
                                    Self::on_COMMAND_ACK(self_, pack);
                                }
                            35 =>
                                {
                                    if pack.is_null() { return packs::MISSION_ITEM::meta_; }
                                    Self::on_MISSION_ITEM(self_, pack);
                                }
                            86 =>
                                {
                                    if pack.is_null() { return packs::TERRAIN_REPORT::meta_; }
                                    Self::on_TERRAIN_REPORT(self_, pack);
                                }
                            133 =>
                                {
                                    if pack.is_null() { return packs::POSITION_TARGET_GLOBAL_INT::meta_; }
                                    Self::on_POSITION_TARGET_GLOBAL_INT(self_, pack);
                                }
                            166 =>
                                {
                                    if pack.is_null() { return packs::PARAM_REQUEST_READ::meta_; }
                                    Self::on_PARAM_REQUEST_READ(self_, pack);
                                }
                            185 =>
                                {
                                    if pack.is_null() { return packs::GPS_GLOBAL_ORIGIN::meta_; }
                                    Self::on_GPS_GLOBAL_ORIGIN(self_, pack);
                                }
                            74 =>
                                {
                                    if pack.is_null() { return packs::SET_ATTITUDE_TARGET::meta_; }
                                    Self::on_SET_ATTITUDE_TARGET(self_, pack);
                                }
                            42 =>
                                {
                                    if pack.is_null() { return packs::VISION_SPEED_ESTIMATE::meta_; }
                                    Self::on_VISION_SPEED_ESTIMATE(self_, pack);
                                }
                            120 =>
                                {
                                    if pack.is_null() { return packs::RC_CHANNELS_SCALED::meta_; }
                                    Self::on_RC_CHANNELS_SCALED(self_, pack);
                                }
                            99 =>
                                {
                                    if pack.is_null() { return packs::SERIAL_CONTROL::meta_; }
                                    Self::on_SERIAL_CONTROL(self_, pack);
                                }
                            25 =>
                                {
                                    if pack.is_null() { return packs::MISSION_REQUEST_LIST::meta_; }
                                    Self::on_MISSION_REQUEST_LIST(self_, pack);
                                }
                            140 =>
                                {
                                    if pack.is_null() { return packs::HIL_STATE::meta_; }
                                    Self::on_HIL_STATE(self_, pack);
                                }
                            154 =>
                                {
                                    if pack.is_null() { return packs::CHANGE_OPERATOR_CONTROL::meta_; }
                                    Self::on_CHANGE_OPERATOR_CONTROL(self_, pack);
                                }
                            2 =>
                                {
                                    if pack.is_null() { return packs::SCALED_IMU3::meta_; }
                                    Self::on_SCALED_IMU3(self_, pack);
                                }
                            174 =>
                                {
                                    if pack.is_null() { return packs::V2_EXTENSION::meta_; }
                                    Self::on_V2_EXTENSION(self_, pack);
                                }
                            41 =>
                                {
                                    if pack.is_null() { return packs::MESSAGE_INTERVAL::meta_; }
                                    Self::on_MESSAGE_INTERVAL(self_, pack);
                                }
                            137 =>
                                {
                                    if pack.is_null() { return packs::HIGHRES_IMU::meta_; }
                                    Self::on_HIGHRES_IMU(self_, pack);
                                }
                            19 =>
                                {
                                    if pack.is_null() { return packs::RAW_PRESSURE::meta_; }
                                    Self::on_RAW_PRESSURE(self_, pack);
                                }

                            _ => { panic!("unknown ID") }
                        }

                        ::std::ptr::null_mut()
                    }
                }


                pub trait ITransmitter {
                    /**
								*Function that fetch next pack from sending queue to send it
								**/
                    unsafe extern fn dequeue(dst: *mut sys::Transmitter) -> *const sys::Pack;
                    /**
			                    *Add pack to the sending queue
			                    **/
                    fn queue(&mut self, pack: *mut sys::Pack) -> Result<(), *mut sys::Pack>;
                    /**
			                    *  Get reference to transmitter by customer transmitter
			                    **/
                    fn get_transmitter(&mut self) -> &mut sys::Transmitter;
                    #[inline(always)]
                    fn send_SwitchModeCommand(&mut self) -> bool { self.queue(sys::Pack::new(packs::SwitchModeCommand::meta_)).is_ok() }


                    fn send<SRC: ITransmittable::Pack>(&mut self, src: SRC) -> Result<(), *mut sys::Pack> { self.queue(src.pack()) }

                    /**
			                    *Request to translate packs in sending queue into provided bytes buffer
			                    **/
                    #[inline(always)]
                    fn packs_into_bytes(&mut self, dst: &mut [u8]) -> Result<usize, ::std::io::Error> { unsafe { Ok(sys::transmit(self.get_transmitter(), dst.as_mut_ptr(), dst.len()) as usize) } }

                    fn new() -> sys::Transmitter { sys::Transmitter::new(Self::dequeue) }
                }


                pub mod ITransmittable {
                    use crate::com::company::demo::GroundControl as packs;
                    use crate::sys;

                    /**
*Setup a MAVLink2 signing key. If called with secret_key of all zero and zero initial_timestamp will disable
*				 signin */

                    pub fn SETUP_SIGNING() -> packs::SETUP_SIGNING::Pack_ {
                        packs::SETUP_SIGNING::Pack_(sys::Pack::new(packs::SETUP_SIGNING::meta_))
                    }

                    /**
*Send raw controller memory. The use of this message is discouraged for normal packets, but a quite efficient
*				 way for testing new messages and getting experimental debug output */

                    pub fn MEMORY_VECT() -> packs::MEMORY_VECT::Pack_ {
                        packs::MEMORY_VECT::Pack_(sys::Pack::new(packs::MEMORY_VECT::meta_))
                    }

                    /**
*Reply to LOG_REQUEST_LIST */

                    pub fn LOG_ENTRY() -> packs::LOG_ENTRY::Pack_ {
                        packs::LOG_ENTRY::Pack_(sys::Pack::new(packs::LOG_ENTRY::meta_))
                    }

                    pub fn VICON_POSITION_ESTIMATE() -> packs::VICON_POSITION_ESTIMATE::Pack_ {
                        packs::VICON_POSITION_ESTIMATE::Pack_(sys::Pack::new(packs::VICON_POSITION_ESTIMATE::meta_))
                    }

                    /**
*Adaptive Controller tuning information */

                    pub fn ADAP_TUNING<'a>(curs: &'a mut sys::Cursors) -> packs::ADAP_TUNING::Data_<'a> {
                        packs::ADAP_TUNING::Data_::<'a>(curs.wrap(sys::Pack::new(packs::ADAP_TUNING::meta_)))
                    }

                    /**
*WIP: Settings of a camera, can be requested using MAV_CMD_REQUEST_CAMERA_SETTINGS. */

                    pub fn CAMERA_SETTINGS<'a>(curs: &'a mut sys::Cursors) -> packs::CAMERA_SETTINGS::Data_<'a> {
                        packs::CAMERA_SETTINGS::Data_::<'a>(curs.wrap(sys::Pack::new(packs::CAMERA_SETTINGS::meta_)))
                    }

                    /**
*RPM sensor output */

                    pub fn RPM() -> packs::RPM::Pack_ {
                        packs::RPM::Pack_(sys::Pack::new(packs::RPM::meta_))
                    }

                    /**
*Terrain data sent from GCS. The lat/lon and grid_spacing must be the same as a lat/lon from a TERRAIN_REQUES */

                    pub fn TERRAIN_DATA() -> packs::TERRAIN_DATA::Pack_ {
                        packs::TERRAIN_DATA::Pack_(sys::Pack::new(packs::TERRAIN_DATA::meta_))
                    }

                    /**
*Sent from simulation to autopilot, avoids in contrast to HIL_STATE singularities. This packet is useful
*				 for high throughput applications such as hardware in the loop simulations */

                    pub fn HIL_STATE_QUATERNION() -> packs::HIL_STATE_QUATERNION::Pack_ {
                        packs::HIL_STATE_QUATERNION::Pack_(sys::Pack::new(packs::HIL_STATE_QUATERNION::meta_))
                    }

                    /**
*Message to configure a camera mount, directional antenna, etc. */

                    pub fn MOUNT_CONFIGURE<'a>(curs: &'a mut sys::Cursors) -> packs::MOUNT_CONFIGURE::Data_<'a> {
                        packs::MOUNT_CONFIGURE::Data_::<'a>(curs.wrap(sys::Pack::new(packs::MOUNT_CONFIGURE::meta_)))
                    }

                    /**
*Status text message. These messages are printed in yellow in the COMM console of QGroundControl. WARNING:
*				 They consume quite some bandwidth, so use only for important status and error messages. If implemented
*				 wisely, these messages are buffered on the MCU and sent only at a limited rate (e.g. 10 Hz) */

                    pub fn STATUSTEXT<'a>(curs: &'a mut sys::Cursors) -> packs::STATUSTEXT::Data_<'a> {
                        packs::STATUSTEXT::Data_::<'a>(curs.wrap(sys::Pack::new(packs::STATUSTEXT::meta_)))
                    }

                    /**
*Vibration levels and accelerometer clipping */

                    pub fn VIBRATION() -> packs::VIBRATION::Pack_ {
                        packs::VIBRATION::Pack_(sys::Pack::new(packs::VIBRATION::meta_))
                    }

                    /**
*This interface replaces DATA_STREAM */

                    pub fn MESSAGE_INTERVAL() -> packs::MESSAGE_INTERVAL::Pack_ {
                        packs::MESSAGE_INTERVAL::Pack_(sys::Pack::new(packs::MESSAGE_INTERVAL::meta_))
                    }

                    /**
*RTCM message for injecting into the onboard GPS (used for DGPS) */

                    pub fn GPS_RTCM_DATA() -> packs::GPS_RTCM_DATA::Pack_ {
                        packs::GPS_RTCM_DATA::Pack_(sys::Pack::new(packs::GPS_RTCM_DATA::meta_))
                    }

                    /**
*Motion capture attitude and position */

                    pub fn ATT_POS_MOCAP() -> packs::ATT_POS_MOCAP::Pack_ {
                        packs::ATT_POS_MOCAP::Pack_(sys::Pack::new(packs::ATT_POS_MOCAP::meta_))
                    }

                    /**
*Request to read the value of a parameter with the either the param_id string id or param_index. */

                    pub fn PARAM_EXT_REQUEST_READ<'a>(curs: &'a mut sys::Cursors) -> packs::PARAM_EXT_REQUEST_READ::Data_<'a> {
                        packs::PARAM_EXT_REQUEST_READ::Data_::<'a>(curs.wrap(sys::Pack::new(packs::PARAM_EXT_REQUEST_READ::meta_)))
                    }

                    /**
*The location and information of an ADSB vehicle */

                    pub fn ADSB_VEHICLE<'a>(curs: &'a mut sys::Cursors) -> packs::ADSB_VEHICLE::Data_<'a> {
                        packs::ADSB_VEHICLE::Data_::<'a>(curs.wrap(sys::Pack::new(packs::ADSB_VEHICLE::meta_)))
                    }

                    /**
*The RAW IMU readings for 3rd 9DOF sensor setup. This message should contain the scaled values to the described
*				 unit */

                    pub fn SCALED_IMU3() -> packs::SCALED_IMU3::Pack_ {
                        packs::SCALED_IMU3::Pack_(sys::Pack::new(packs::SCALED_IMU3::meta_))
                    }

                    /**
*Airspeed auto-calibration */

                    pub fn AIRSPEED_AUTOCAL() -> packs::AIRSPEED_AUTOCAL::Pack_ {
                        packs::AIRSPEED_AUTOCAL::Pack_(sys::Pack::new(packs::AIRSPEED_AUTOCAL::meta_))
                    }

                    /**
*Information about a captured image */

                    pub fn CAMERA_IMAGE_CAPTURED<'a>(curs: &'a mut sys::Cursors) -> packs::CAMERA_IMAGE_CAPTURED::Data_<'a> {
                        packs::CAMERA_IMAGE_CAPTURED::Data_::<'a>(curs.wrap(sys::Pack::new(packs::CAMERA_IMAGE_CAPTURED::meta_)))
                    }

                    pub fn ENCAPSULATED_DATA() -> packs::ENCAPSULATED_DATA::Pack_ {
                        packs::ENCAPSULATED_DATA::Pack_(sys::Pack::new(packs::ENCAPSULATED_DATA::meta_))
                    }

                    /**
*The position the system will return to and land on. The position is set automatically by the system during
*				 the takeoff in case it was not explicitely set by the operator before or after. The global and local
*				 positions encode the position in the respective coordinate frames, while the q parameter encodes the
*				 orientation of the surface. Under normal conditions it describes the heading and terrain slope, which
*				 can be used by the aircraft to adjust the approach. The approach 3D vector describes the point to which
*				 the system should fly in normal flight mode and then perform a landing sequence along the vector */

                    pub fn SET_HOME_POSITION<'a>(curs: &'a mut sys::Cursors) -> packs::SET_HOME_POSITION::Data_<'a> {
                        packs::SET_HOME_POSITION::Data_::<'a>(curs.wrap(sys::Pack::new(packs::SET_HOME_POSITION::meta_)))
                    }

                    pub fn VISION_SPEED_ESTIMATE() -> packs::VISION_SPEED_ESTIMATE::Pack_ {
                        packs::VISION_SPEED_ESTIMATE::Pack_(sys::Pack::new(packs::VISION_SPEED_ESTIMATE::meta_))
                    }

                    pub fn MOUNT_ORIENTATION() -> packs::MOUNT_ORIENTATION::Pack_ {
                        packs::MOUNT_ORIENTATION::Pack_(sys::Pack::new(packs::MOUNT_ORIENTATION::meta_))
                    }

                    /**
*File transfer message */

                    pub fn FILE_TRANSFER_PROTOCOL() -> packs::FILE_TRANSFER_PROTOCOL::Pack_ {
                        packs::FILE_TRANSFER_PROTOCOL::Pack_(sys::Pack::new(packs::FILE_TRANSFER_PROTOCOL::meta_))
                    }

                    /**
*Set the vehicle attitude and body angular rates. */

                    pub fn SET_ACTUATOR_CONTROL_TARGET() -> packs::SET_ACTUATOR_CONTROL_TARGET::Pack_ {
                        packs::SET_ACTUATOR_CONTROL_TARGET::Pack_(sys::Pack::new(packs::SET_ACTUATOR_CONTROL_TARGET::meta_))
                    }

                    /**
*RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */

                    pub fn GPS2_RTK() -> packs::GPS2_RTK::Pack_ {
                        packs::GPS2_RTK::Pack_(sys::Pack::new(packs::GPS2_RTK::meta_))
                    }

                    /**
*Status of third AHRS filter if available. This is for ANU research group (Ali and Sean) */

                    pub fn AHRS3() -> packs::AHRS3::Pack_ {
                        packs::AHRS3::Pack_(sys::Pack::new(packs::AHRS3::meta_))
                    }

                    /**
*Send a key-value pair as integer. The use of this message is discouraged for normal packets, but a quite
*				 efficient way for testing new messages and getting experimental debug output */

                    pub fn NAMED_VALUE_INT<'a>(curs: &'a mut sys::Cursors) -> packs::NAMED_VALUE_INT::Data_<'a> {
                        packs::NAMED_VALUE_INT::Data_::<'a>(curs.wrap(sys::Pack::new(packs::NAMED_VALUE_INT::meta_)))
                    }

                    /**
*current motion information from a designated system */

                    pub fn FOLLOW_TARGET() -> packs::FOLLOW_TARGET::Pack_ {
                        packs::FOLLOW_TARGET::Pack_(sys::Pack::new(packs::FOLLOW_TARGET::meta_))
                    }

                    /**
*The current system altitude. */

                    pub fn ALTITUDE() -> packs::ALTITUDE::Pack_ {
                        packs::ALTITUDE::Pack_(sys::Pack::new(packs::ALTITUDE::meta_))
                    }

                    /**
*Request for terrain data and terrain status */

                    pub fn TERRAIN_REQUEST() -> packs::TERRAIN_REQUEST::Pack_ {
                        packs::TERRAIN_REQUEST::Pack_(sys::Pack::new(packs::TERRAIN_REQUEST::meta_))
                    }

                    /**
*Camera Capture Feedback */

                    pub fn CAMERA_FEEDBACK<'a>(curs: &'a mut sys::Cursors) -> packs::CAMERA_FEEDBACK::Data_<'a> {
                        packs::CAMERA_FEEDBACK::Data_::<'a>(curs.wrap(sys::Pack::new(packs::CAMERA_FEEDBACK::meta_)))
                    }

                    /**
*Stop log transfer and resume normal logging */

                    pub fn LOG_REQUEST_END() -> packs::LOG_REQUEST_END::Pack_ {
                        packs::LOG_REQUEST_END::Pack_(sys::Pack::new(packs::LOG_REQUEST_END::meta_))
                    }

                    /**
*Status of simulation environment, if used */

                    pub fn SIM_STATE() -> packs::SIM_STATE::Pack_ {
                        packs::SIM_STATE::Pack_(sys::Pack::new(packs::SIM_STATE::meta_))
                    }

                    /**
*Status generated by radio and injected into MAVLink stream. */

                    pub fn RADIO_STATUS() -> packs::RADIO_STATUS::Pack_ {
                        packs::RADIO_STATUS::Pack_(sys::Pack::new(packs::RADIO_STATUS::meta_))
                    }

                    /**
*Reports progress of compass calibration. */

                    pub fn MAG_CAL_PROGRESS<'a>(curs: &'a mut sys::Cursors) -> packs::MAG_CAL_PROGRESS::Data_<'a> {
                        packs::MAG_CAL_PROGRESS::Data_::<'a>(curs.wrap(sys::Pack::new(packs::MAG_CAL_PROGRESS::meta_)))
                    }

                    pub fn DISTANCE_SENSOR<'a>(curs: &'a mut sys::Cursors) -> packs::DISTANCE_SENSOR::Data_<'a> {
                        packs::DISTANCE_SENSOR::Data_::<'a>(curs.wrap(sys::Pack::new(packs::DISTANCE_SENSOR::meta_)))
                    }

                    /**
*RTK GPS data. Gives information on the relative baseline calculation the GPS is reporting */

                    pub fn GPS_RTK() -> packs::GPS_RTK::Pack_ {
                        packs::GPS_RTK::Pack_(sys::Pack::new(packs::GPS_RTK::meta_))
                    }

                    /**
*Barometer readings for 3rd barometer */

                    pub fn SCALED_PRESSURE3() -> packs::SCALED_PRESSURE3::Pack_ {
                        packs::SCALED_PRESSURE3::Pack_(sys::Pack::new(packs::SCALED_PRESSURE3::meta_))
                    }

                    /**
*Status of DCM attitude estimator */

                    pub fn AHRS() -> packs::AHRS::Pack_ {
                        packs::AHRS::Pack_(sys::Pack::new(packs::AHRS::meta_))
                    }

                    /**
*Static data to configure the ADS-B transponder (send within 10 sec of a POR and every 10 sec thereafter */

                    pub fn UAVIONIX_ADSB_OUT_CFG<'a>(curs: &'a mut sys::Cursors) -> packs::UAVIONIX_ADSB_OUT_CFG::Data_<'a> {
                        packs::UAVIONIX_ADSB_OUT_CFG::Data_::<'a>(curs.wrap(sys::Pack::new(packs::UAVIONIX_ADSB_OUT_CFG::meta_)))
                    }

                    /**
*Erase all logs */

                    pub fn LOG_ERASE() -> packs::LOG_ERASE::Pack_ {
                        packs::LOG_ERASE::Pack_(sys::Pack::new(packs::LOG_ERASE::meta_))
                    }

                    pub fn WIND_COV() -> packs::WIND_COV::Pack_ {
                        packs::WIND_COV::Pack_(sys::Pack::new(packs::WIND_COV::meta_))
                    }

                    /**
*Control message for rate gimbal */

                    pub fn GIMBAL_CONTROL() -> packs::GIMBAL_CONTROL::Pack_ {
                        packs::GIMBAL_CONTROL::Pack_(sys::Pack::new(packs::GIMBAL_CONTROL::meta_))
                    }

                    /**
*The IMU readings in SI units in NED body frame */

                    pub fn HIGHRES_IMU() -> packs::HIGHRES_IMU::Pack_ {
                        packs::HIGHRES_IMU::Pack_(sys::Pack::new(packs::HIGHRES_IMU::meta_))
                    }

                    /**
*Message implementing parts of the V2 payload specs in V1 frames for transitional support. */

                    pub fn V2_EXTENSION() -> packs::V2_EXTENSION::Pack_ {
                        packs::V2_EXTENSION::Pack_(sys::Pack::new(packs::V2_EXTENSION::meta_))
                    }

                    /**
*Status generated by radio */

                    pub fn RADIO() -> packs::RADIO::Pack_ {
                        packs::RADIO::Pack_(sys::Pack::new(packs::RADIO::meta_))
                    }

                    /**
*Send a block of log data to remote location */

                    pub fn REMOTE_LOG_DATA_BLOCK<'a>(curs: &'a mut sys::Cursors) -> packs::REMOTE_LOG_DATA_BLOCK::Data_<'a> {
                        packs::REMOTE_LOG_DATA_BLOCK::Data_::<'a>(curs.wrap(sys::Pack::new(packs::REMOTE_LOG_DATA_BLOCK::meta_)))
                    }

                    /**
*Offsets and calibrations values for hardware sensors. This makes it easier to debug the calibration process */

                    pub fn SENSOR_OFFSETS() -> packs::SENSOR_OFFSETS::Pack_ {
                        packs::SENSOR_OFFSETS::Pack_(sys::Pack::new(packs::SENSOR_OFFSETS::meta_))
                    }

                    /**
*Reply to LOG_REQUEST_DATA */

                    pub fn LOG_DATA() -> packs::LOG_DATA::Pack_ {
                        packs::LOG_DATA::Pack_(sys::Pack::new(packs::LOG_DATA::meta_))
                    }

                    /**
*Dynamic data used to generate ADS-B out transponder data (send at 5Hz) */

                    pub fn UAVIONIX_ADSB_OUT_DYNAMIC<'a>(curs: &'a mut sys::Cursors) -> packs::UAVIONIX_ADSB_OUT_DYNAMIC::Data_<'a> {
                        packs::UAVIONIX_ADSB_OUT_DYNAMIC::Data_::<'a>(curs.wrap(sys::Pack::new(packs::UAVIONIX_ADSB_OUT_DYNAMIC::meta_)))
                    }

                    /**
*Simulated optical flow from a flow sensor (e.g. PX4FLOW or optical mouse sensor) */

                    pub fn HIL_OPTICAL_FLOW() -> packs::HIL_OPTICAL_FLOW::Pack_ {
                        packs::HIL_OPTICAL_FLOW::Pack_(sys::Pack::new(packs::HIL_OPTICAL_FLOW::meta_))
                    }

                    pub fn DATA_TRANSMISSION_HANDSHAKE() -> packs::DATA_TRANSMISSION_HANDSHAKE::Pack_ {
                        packs::DATA_TRANSMISSION_HANDSHAKE::Pack_(sys::Pack::new(packs::DATA_TRANSMISSION_HANDSHAKE::meta_))
                    }

                    /**
*Data packet, size 32 */

                    pub fn DATA32() -> packs::DATA32::Pack_ {
                        packs::DATA32::Pack_(sys::Pack::new(packs::DATA32::meta_))
                    }

                    /**
*GCS */

                    pub fn FENCE_POINT() -> packs::FENCE_POINT::Pack_ {
                        packs::FENCE_POINT::Pack_(sys::Pack::new(packs::FENCE_POINT::meta_))
                    }

                    /**
*Heartbeat from a HeroBus attached GoPro */

                    pub fn GOPRO_HEARTBEAT<'a>(curs: &'a mut sys::Cursors) -> packs::GOPRO_HEARTBEAT::Data_<'a> {
                        packs::GOPRO_HEARTBEAT::Data_::<'a>(curs.wrap(sys::Pack::new(packs::GOPRO_HEARTBEAT::meta_)))
                    }

                    /**
*Battery information */

                    pub fn BATTERY_STATUS<'a>(curs: &'a mut sys::Cursors) -> packs::BATTERY_STATUS::Data_<'a> {
                        packs::BATTERY_STATUS::Data_::<'a>(curs.wrap(sys::Pack::new(packs::BATTERY_STATUS::meta_)))
                    }

                    /**
*Status of simulation environment, if used */

                    pub fn SIMSTATE() -> packs::SIMSTATE::Pack_ {
                        packs::SIMSTATE::Pack_(sys::Pack::new(packs::SIMSTATE::meta_))
                    }

                    /**
*Set a parameter value. In order to deal with message loss (and retransmission of PARAM_EXT_SET), when
*				 setting a parameter value and the new value is the same as the current value, you will immediately get
*				 a PARAM_ACK_ACCEPTED response. If the current state is PARAM_ACK_IN_PROGRESS, you will accordingly receive
*				 a PARAM_ACK_IN_PROGRESS in response */

                    pub fn PARAM_EXT_SET<'a>(curs: &'a mut sys::Cursors) -> packs::PARAM_EXT_SET::Data_<'a> {
                        packs::PARAM_EXT_SET::Data_::<'a>(curs.wrap(sys::Pack::new(packs::PARAM_EXT_SET::meta_)))
                    }

                    /**
*WIP: Information about a storage medium. */

                    pub fn STORAGE_INFORMATION() -> packs::STORAGE_INFORMATION::Pack_ {
                        packs::STORAGE_INFORMATION::Pack_(sys::Pack::new(packs::STORAGE_INFORMATION::meta_))
                    }

                    /**
*Read registers reply */

                    pub fn DEVICE_OP_READ_REPLY() -> packs::DEVICE_OP_READ_REPLY::Pack_ {
                        packs::DEVICE_OP_READ_REPLY::Pack_(sys::Pack::new(packs::DEVICE_OP_READ_REPLY::meta_))
                    }

                    /**
*Request to set a GOPRO_COMMAND with a desired */

                    pub fn GOPRO_SET_REQUEST<'a>(curs: &'a mut sys::Cursors) -> packs::GOPRO_SET_REQUEST::Data_<'a> {
                        packs::GOPRO_SET_REQUEST::Data_::<'a>(curs.wrap(sys::Pack::new(packs::GOPRO_SET_REQUEST::meta_)))
                    }

                    /**
*The smoothed, monotonic system state used to feed the control loops of the system. */

                    pub fn CONTROL_SYSTEM_STATE() -> packs::CONTROL_SYSTEM_STATE::Pack_ {
                        packs::CONTROL_SYSTEM_STATE::Pack_(sys::Pack::new(packs::CONTROL_SYSTEM_STATE::meta_))
                    }

                    /**
*Write registers for a device */

                    pub fn DEVICE_OP_WRITE<'a>(curs: &'a mut sys::Cursors) -> packs::DEVICE_OP_WRITE::Data_<'a> {
                        packs::DEVICE_OP_WRITE::Data_::<'a>(curs.wrap(sys::Pack::new(packs::DEVICE_OP_WRITE::meta_)))
                    }

                    /**
*Wind estimation */

                    pub fn WIND() -> packs::WIND::Pack_ {
                        packs::WIND::Pack_(sys::Pack::new(packs::WIND::meta_))
                    }

                    /**
*Response from a GOPRO_COMMAND get request */

                    pub fn GOPRO_GET_RESPONSE<'a>(curs: &'a mut sys::Cursors) -> packs::GOPRO_GET_RESPONSE::Data_<'a> {
                        packs::GOPRO_GET_RESPONSE::Data_::<'a>(curs.wrap(sys::Pack::new(packs::GOPRO_GET_RESPONSE::meta_)))
                    }

                    /**
*WIP: Version and capability of protocol version. This message is the response to REQUEST_PROTOCOL_VERSION
*				 and is used as part of the handshaking to establish which MAVLink version should be used on the network.
*				 Every node should respond to REQUEST_PROTOCOL_VERSION to enable the handshaking. Library implementers
*				 should consider adding this into the default decoding state machine to allow the protocol core to respond
*				 directly */

                    pub fn PROTOCOL_VERSION() -> packs::PROTOCOL_VERSION::Pack_ {
                        packs::PROTOCOL_VERSION::Pack_(sys::Pack::new(packs::PROTOCOL_VERSION::meta_))
                    }

                    /**
*GPS sensor input message.  This is a raw sensor value sent by the GPS. This is NOT the global position
*				 estimate of the sytem */

                    pub fn GPS_INPUT<'a>(curs: &'a mut sys::Cursors) -> packs::GPS_INPUT::Data_<'a> {
                        packs::GPS_INPUT::Data_::<'a>(curs.wrap(sys::Pack::new(packs::GPS_INPUT::meta_)))
                    }

                    /**
*Status of key hardware */

                    pub fn HWSTATUS() -> packs::HWSTATUS::Pack_ {
                        packs::HWSTATUS::Pack_(sys::Pack::new(packs::HWSTATUS::meta_))
                    }

                    /**
*Data packet, size 96 */

                    pub fn DATA96() -> packs::DATA96::Pack_ {
                        packs::DATA96::Pack_(sys::Pack::new(packs::DATA96::meta_))
                    }

                    /**
*Request a current fence point from MAV */

                    pub fn FENCE_FETCH_POINT() -> packs::FENCE_FETCH_POINT::Pack_ {
                        packs::FENCE_FETCH_POINT::Pack_(sys::Pack::new(packs::FENCE_FETCH_POINT::meta_))
                    }

                    /**
*Transceiver heartbeat with health report (updated every 10s) */

                    pub fn UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT<'a>(curs: &'a mut sys::Cursors) -> packs::UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT::Data_<'a> {
                        packs::UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT::Data_::<'a>(curs.wrap(sys::Pack::new(packs::UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT::meta_)))
                    }

                    /**
*Optical flow from an angular rate flow sensor (e.g. PX4FLOW or mouse sensor) */

                    pub fn OPTICAL_FLOW_RAD() -> packs::OPTICAL_FLOW_RAD::Pack_ {
                        packs::OPTICAL_FLOW_RAD::Pack_(sys::Pack::new(packs::OPTICAL_FLOW_RAD::meta_))
                    }

                    /**
*WIP: Message that sets video stream settings */

                    pub fn SET_VIDEO_STREAM_SETTINGS<'a>(curs: &'a mut sys::Cursors) -> packs::SET_VIDEO_STREAM_SETTINGS::Data_<'a> {
                        packs::SET_VIDEO_STREAM_SETTINGS::Data_::<'a>(curs.wrap(sys::Pack::new(packs::SET_VIDEO_STREAM_SETTINGS::meta_)))
                    }

                    /**
*The IMU readings in SI units in NED body frame */

                    pub fn HIL_SENSOR() -> packs::HIL_SENSOR::Pack_ {
                        packs::HIL_SENSOR::Pack_(sys::Pack::new(packs::HIL_SENSOR::meta_))
                    }

                    /**
*Version and capability of autopilot software */

                    pub fn AUTOPILOT_VERSION<'a>(curs: &'a mut sys::Cursors) -> packs::AUTOPILOT_VERSION::Data_<'a> {
                        packs::AUTOPILOT_VERSION::Data_::<'a>(curs.wrap(sys::Pack::new(packs::AUTOPILOT_VERSION::meta_)))
                    }

                    /**
*The global position, as returned by the Global Positioning System (GPS). This is
*				 NOT the global position estimate of the sytem, but rather a RAW sensor value. See message GLOBAL_POSITION for the global position estimate. Coordinate frame is right-handed, Z-axis up (GPS frame). */

                    pub fn HIL_GPS() -> packs::HIL_GPS::Pack_ {
                        packs::HIL_GPS::Pack_(sys::Pack::new(packs::HIL_GPS::meta_))
                    }

                    /**
*Reports results of completed compass calibration. Sent until MAG_CAL_ACK received. */

                    pub fn MAG_CAL_REPORT<'a>(curs: &'a mut sys::Cursors) -> packs::MAG_CAL_REPORT::Data_<'a> {
                        packs::MAG_CAL_REPORT::Data_::<'a>(curs.wrap(sys::Pack::new(packs::MAG_CAL_REPORT::meta_)))
                    }

                    /**
*Response from a TERRAIN_CHECK request */

                    pub fn TERRAIN_REPORT() -> packs::TERRAIN_REPORT::Pack_ {
                        packs::TERRAIN_REPORT::Pack_(sys::Pack::new(packs::TERRAIN_REPORT::meta_))
                    }

                    /**
*3 axis gimbal mesuraments */

                    pub fn GIMBAL_REPORT() -> packs::GIMBAL_REPORT::Pack_ {
                        packs::GIMBAL_REPORT::Pack_(sys::Pack::new(packs::GIMBAL_REPORT::meta_))
                    }

                    /**
*Configure AP SSID and Password. */

                    pub fn WIFI_CONFIG_AP<'a>(curs: &'a mut sys::Cursors) -> packs::WIFI_CONFIG_AP::Data_<'a> {
                        packs::WIFI_CONFIG_AP::Data_::<'a>(curs.wrap(sys::Pack::new(packs::WIFI_CONFIG_AP::meta_)))
                    }

                    /**
*Control vehicle LEDs */

                    pub fn LED_CONTROL() -> packs::LED_CONTROL::Pack_ {
                        packs::LED_CONTROL::Pack_(sys::Pack::new(packs::LED_CONTROL::meta_))
                    }

                    /**
*100 Hz gimbal torque command telemetry */

                    pub fn GIMBAL_TORQUE_CMD_REPORT() -> packs::GIMBAL_TORQUE_CMD_REPORT::Pack_ {
                        packs::GIMBAL_TORQUE_CMD_REPORT::Pack_(sys::Pack::new(packs::GIMBAL_TORQUE_CMD_REPORT::meta_))
                    }

                    pub fn DEBUG_VECT<'a>(curs: &'a mut sys::Cursors) -> packs::DEBUG_VECT::Data_<'a> {
                        packs::DEBUG_VECT::Data_::<'a>(curs.wrap(sys::Pack::new(packs::DEBUG_VECT::meta_)))
                    }

                    /**
*Message appropriate for high latency connections like Iridium */

                    pub fn HIGH_LATENCY<'a>(curs: &'a mut sys::Cursors) -> packs::HIGH_LATENCY::Data_<'a> {
                        packs::HIGH_LATENCY::Data_::<'a>(curs.wrap(sys::Pack::new(packs::HIGH_LATENCY::meta_)))
                    }

                    /**
*Data packet, size 16 */

                    pub fn DATA16() -> packs::DATA16::Pack_ {
                        packs::DATA16::Pack_(sys::Pack::new(packs::DATA16::meta_))
                    }

                    /**
*Estimator status message including flags, innovation test ratios and estimated accuracies. The flags message
*				 is an integer bitmask containing information on which EKF outputs are valid. See the ESTIMATOR_STATUS_FLAGS
*				 enum definition for further information. The innovaton test ratios show the magnitude of the sensor innovation
*				 divided by the innovation check threshold. Under normal operation the innovaton test ratios should be
*				 below 0.5 with occasional values up to 1.0. Values greater than 1.0 should be rare under normal operation
*				 and indicate that a measurement has been rejected by the filter. The user should be notified if an innovation
*				 test ratio greater than 1.0 is recorded. Notifications for values in the range between 0.5 and 1.0 should
*				 be optional and controllable by the user */

                    pub fn ESTIMATOR_STATUS<'a>(curs: &'a mut sys::Cursors) -> packs::ESTIMATOR_STATUS::Data_<'a> {
                        packs::ESTIMATOR_STATUS::Data_::<'a>(curs.wrap(sys::Pack::new(packs::ESTIMATOR_STATUS::meta_)))
                    }

                    /**
*Emit the value of a parameter. The inclusion of param_count and param_index in the message allows the
*				 recipient to keep track of received parameters and allows them to re-request missing parameters after
*				 a loss or timeout */

                    pub fn PARAM_EXT_VALUE<'a>(curs: &'a mut sys::Cursors) -> packs::PARAM_EXT_VALUE::Data_<'a> {
                        packs::PARAM_EXT_VALUE::Data_::<'a>(curs.wrap(sys::Pack::new(packs::PARAM_EXT_VALUE::meta_)))
                    }

                    /**
*Camera Event */

                    pub fn CAMERA_STATUS<'a>(curs: &'a mut sys::Cursors) -> packs::CAMERA_STATUS::Data_<'a> {
                        packs::CAMERA_STATUS::Data_::<'a>(curs.wrap(sys::Pack::new(packs::CAMERA_STATUS::meta_)))
                    }

                    /**
*GCS */

                    pub fn RALLY_POINT<'a>(curs: &'a mut sys::Cursors) -> packs::RALLY_POINT::Data_<'a> {
                        packs::RALLY_POINT::Data_::<'a>(curs.wrap(sys::Pack::new(packs::RALLY_POINT::meta_)))
                    }

                    /**
*Request a GOPRO_COMMAND response from the GoPro */

                    pub fn GOPRO_GET_REQUEST<'a>(curs: &'a mut sys::Cursors) -> packs::GOPRO_GET_REQUEST::Data_<'a> {
                        packs::GOPRO_GET_REQUEST::Data_::<'a>(curs.wrap(sys::Pack::new(packs::GOPRO_GET_REQUEST::meta_)))
                    }

                    /**
*EKF Status message including flags and variances */

                    pub fn EKF_STATUS_REPORT<'a>(curs: &'a mut sys::Cursors) -> packs::EKF_STATUS_REPORT::Data_<'a> {
                        packs::EKF_STATUS_REPORT::Data_::<'a>(curs.wrap(sys::Pack::new(packs::EKF_STATUS_REPORT::meta_)))
                    }

                    /**
*Request the autopilot version from the system/component. */

                    pub fn AUTOPILOT_VERSION_REQUEST() -> packs::AUTOPILOT_VERSION_REQUEST::Pack_ {
                        packs::AUTOPILOT_VERSION_REQUEST::Pack_(sys::Pack::new(packs::AUTOPILOT_VERSION_REQUEST::meta_))
                    }

                    /**
*Write registers reply */

                    pub fn DEVICE_OP_WRITE_REPLY() -> packs::DEVICE_OP_WRITE_REPLY::Pack_ {
                        packs::DEVICE_OP_WRITE_REPLY::Pack_(sys::Pack::new(packs::DEVICE_OP_WRITE_REPLY::meta_))
                    }

                    /**
*The location of a landing area captured from a downward facing camera */

                    pub fn LANDING_TARGET<'a>(curs: &'a mut sys::Cursors) -> packs::LANDING_TARGET::Data_<'a> {
                        packs::LANDING_TARGET::Data_::<'a>(curs.wrap(sys::Pack::new(packs::LANDING_TARGET::meta_)))
                    }

                    /**
*Barometer readings for 2nd barometer */

                    pub fn SCALED_PRESSURE2() -> packs::SCALED_PRESSURE2::Pack_ {
                        packs::SCALED_PRESSURE2::Pack_(sys::Pack::new(packs::SCALED_PRESSURE2::meta_))
                    }

                    /**
*Time synchronization message. */

                    pub fn TIMESYNC() -> packs::TIMESYNC::Pack_ {
                        packs::TIMESYNC::Pack_(sys::Pack::new(packs::TIMESYNC::meta_))
                    }

                    /**
*Report button state change */

                    pub fn BUTTON_CHANGE() -> packs::BUTTON_CHANGE::Pack_ {
                        packs::BUTTON_CHANGE::Pack_(sys::Pack::new(packs::BUTTON_CHANGE::meta_))
                    }

                    /**
*Data packet, size 64 */

                    pub fn DATA64() -> packs::DATA64::Pack_ {
                        packs::DATA64::Pack_(sys::Pack::new(packs::DATA64::meta_))
                    }

                    /**
*data for injecting into the onboard GPS (used for DGPS) */

                    pub fn GPS_INJECT_DATA() -> packs::GPS_INJECT_DATA::Pack_ {
                        packs::GPS_INJECT_DATA::Pack_(sys::Pack::new(packs::GPS_INJECT_DATA::meta_))
                    }

                    /**
*Send Status of each log block that autopilot board might have sent */

                    pub fn REMOTE_LOG_BLOCK_STATUS<'a>(curs: &'a mut sys::Cursors) -> packs::REMOTE_LOG_BLOCK_STATUS::Data_<'a> {
                        packs::REMOTE_LOG_BLOCK_STATUS::Data_::<'a>(curs.wrap(sys::Pack::new(packs::REMOTE_LOG_BLOCK_STATUS::meta_)))
                    }

                    /**
*The RAW IMU readings for secondary 9DOF sensor setup. This message should contain the scaled values to
*				 the described unit */

                    pub fn SCALED_IMU2() -> packs::SCALED_IMU2::Pack_ {
                        packs::SCALED_IMU2::Pack_(sys::Pack::new(packs::SCALED_IMU2::meta_))
                    }

                    /**
*Request a chunk of a log */

                    pub fn LOG_REQUEST_DATA() -> packs::LOG_REQUEST_DATA::Pack_ {
                        packs::LOG_REQUEST_DATA::Pack_(sys::Pack::new(packs::LOG_REQUEST_DATA::meta_))
                    }

                    /**
*Status of AP_Limits. Sent in extended status stream when AP_Limits is enabled */

                    pub fn LIMITS_STATUS<'a>(curs: &'a mut sys::Cursors) -> packs::LIMITS_STATUS::Data_<'a> {
                        packs::LIMITS_STATUS::Data_::<'a>(curs.wrap(sys::Pack::new(packs::LIMITS_STATUS::meta_)))
                    }

                    /**
*Message to control a camera mount, directional antenna, etc. */

                    pub fn MOUNT_CONTROL() -> packs::MOUNT_CONTROL::Pack_ {
                        packs::MOUNT_CONTROL::Pack_(sys::Pack::new(packs::MOUNT_CONTROL::meta_))
                    }

                    /**
*state of APM memory */

                    pub fn MEMINFO<'a>(curs: &'a mut sys::Cursors) -> packs::MEMINFO::Data_<'a> {
                        packs::MEMINFO::Data_::<'a>(curs.wrap(sys::Pack::new(packs::MEMINFO::meta_)))
                    }

                    /**
*Obstacle distances in front of the sensor, starting from the left in increment degrees to the right */

                    pub fn OBSTACLE_DISTANCE<'a>(curs: &'a mut sys::Cursors) -> packs::OBSTACLE_DISTANCE::Data_<'a> {
                        packs::OBSTACLE_DISTANCE::Data_::<'a>(curs.wrap(sys::Pack::new(packs::OBSTACLE_DISTANCE::meta_)))
                    }

                    /**
*Power supply status */

                    pub fn POWER_STATUS<'a>(curs: &'a mut sys::Cursors) -> packs::POWER_STATUS::Data_<'a> {
                        packs::POWER_STATUS::Data_::<'a>(curs.wrap(sys::Pack::new(packs::POWER_STATUS::meta_)))
                    }

                    /**
*PID tuning information */

                    pub fn PID_TUNING<'a>(curs: &'a mut sys::Cursors) -> packs::PID_TUNING::Data_<'a> {
                        packs::PID_TUNING::Data_::<'a>(curs.wrap(sys::Pack::new(packs::PID_TUNING::meta_)))
                    }

                    /**
*Control on-board Camera Control System to take shots. */

                    pub fn DIGICAM_CONTROL() -> packs::DIGICAM_CONTROL::Pack_ {
                        packs::DIGICAM_CONTROL::Pack_(sys::Pack::new(packs::DIGICAM_CONTROL::meta_))
                    }

                    /**
*Request that the vehicle report terrain height at the given location. Used by GCS to check if vehicle
*				 has all terrain data needed for a mission */

                    pub fn TERRAIN_CHECK() -> packs::TERRAIN_CHECK::Pack_ {
                        packs::TERRAIN_CHECK::Pack_(sys::Pack::new(packs::TERRAIN_CHECK::meta_))
                    }

                    /**
*An ack for a LOGGING_DATA_ACKED message */

                    pub fn LOGGING_ACK() -> packs::LOGGING_ACK::Pack_ {
                        packs::LOGGING_ACK::Pack_(sys::Pack::new(packs::LOGGING_ACK::meta_))
                    }

                    /**
*Information about a potential collision */

                    pub fn COLLISION<'a>(curs: &'a mut sys::Cursors) -> packs::COLLISION::Data_<'a> {
                        packs::COLLISION::Data_::<'a>(curs.wrap(sys::Pack::new(packs::COLLISION::meta_)))
                    }

                    /**
*A message containing logged data which requires a LOGGING_ACK to be sent back */

                    pub fn LOGGING_DATA_ACKED() -> packs::LOGGING_DATA_ACKED::Pack_ {
                        packs::LOGGING_DATA_ACKED::Pack_(sys::Pack::new(packs::LOGGING_DATA_ACKED::meta_))
                    }

                    /**
*The autopilot is requesting a resource (file, binary, other type of data) */

                    pub fn RESOURCE_REQUEST() -> packs::RESOURCE_REQUEST::Pack_ {
                        packs::RESOURCE_REQUEST::Pack_(sys::Pack::new(packs::RESOURCE_REQUEST::meta_))
                    }

                    /**
*Status of geo-fencing. Sent in extended status stream when fencing enabled */

                    pub fn FENCE_STATUS<'a>(curs: &'a mut sys::Cursors) -> packs::FENCE_STATUS::Data_<'a> {
                        packs::FENCE_STATUS::Data_::<'a>(curs.wrap(sys::Pack::new(packs::FENCE_STATUS::meta_)))
                    }

                    /**
*Status of compassmot calibration */

                    pub fn COMPASSMOT_STATUS() -> packs::COMPASSMOT_STATUS::Pack_ {
                        packs::COMPASSMOT_STATUS::Pack_(sys::Pack::new(packs::COMPASSMOT_STATUS::meta_))
                    }

                    /**
*Read registers for a device */

                    pub fn DEVICE_OP_READ<'a>(curs: &'a mut sys::Cursors) -> packs::DEVICE_OP_READ::Data_<'a> {
                        packs::DEVICE_OP_READ::Data_::<'a>(curs.wrap(sys::Pack::new(packs::DEVICE_OP_READ::meta_)))
                    }

                    /**
*Message with some status from APM to GCS about camera or antenna mount */

                    pub fn MOUNT_STATUS() -> packs::MOUNT_STATUS::Pack_ {
                        packs::MOUNT_STATUS::Pack_(sys::Pack::new(packs::MOUNT_STATUS::meta_))
                    }

                    /**
*General information describing a particular UAVCAN node. Please refer to the definition of the UAVCAN
*				 service "uavcan.protocol.GetNodeInfo" for the background information. This message should be emitted
*				 by the system whenever a new node appears online, or an existing node reboots. Additionally, it can be
*				 emitted upon request from the other end of the MAVLink channel (see MAV_CMD_UAVCAN_GET_NODE_INFO). It
*				 is also not prohibited to emit this message unconditionally at a low frequency. The UAVCAN specification
*				 is available at http:uavcan.org */

                    pub fn UAVCAN_NODE_INFO<'a>(curs: &'a mut sys::Cursors) -> packs::UAVCAN_NODE_INFO::Data_<'a> {
                        packs::UAVCAN_NODE_INFO::Data_::<'a>(curs.wrap(sys::Pack::new(packs::UAVCAN_NODE_INFO::meta_)))
                    }

                    /**
*Provides state for additional features */

                    pub fn EXTENDED_SYS_STATE<'a>(curs: &'a mut sys::Cursors) -> packs::EXTENDED_SYS_STATE::Data_<'a> {
                        packs::EXTENDED_SYS_STATE::Data_::<'a>(curs.wrap(sys::Pack::new(packs::EXTENDED_SYS_STATE::meta_)))
                    }

                    /**
*Request a list of available logs. On some systems calling this may stop on-board logging until LOG_REQUEST_END
*				 is called */

                    pub fn LOG_REQUEST_LIST() -> packs::LOG_REQUEST_LIST::Pack_ {
                        packs::LOG_REQUEST_LIST::Pack_(sys::Pack::new(packs::LOG_REQUEST_LIST::meta_))
                    }

                    /**
*WIP: Information about a camera */

                    pub fn CAMERA_INFORMATION<'a>(curs: &'a mut sys::Cursors) -> packs::CAMERA_INFORMATION::Data_<'a> {
                        packs::CAMERA_INFORMATION::Data_::<'a>(curs.wrap(sys::Pack::new(packs::CAMERA_INFORMATION::meta_)))
                    }

                    /**
*Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the magnetometer offsets */

                    pub fn SET_MAG_OFFSETS() -> packs::SET_MAG_OFFSETS::Pack_ {
                        packs::SET_MAG_OFFSETS::Pack_(sys::Pack::new(packs::SET_MAG_OFFSETS::meta_))
                    }

                    /**
*Set the vehicle attitude and body angular rates. */

                    pub fn ACTUATOR_CONTROL_TARGET() -> packs::ACTUATOR_CONTROL_TARGET::Pack_ {
                        packs::ACTUATOR_CONTROL_TARGET::Pack_(sys::Pack::new(packs::ACTUATOR_CONTROL_TARGET::meta_))
                    }

                    /**
*Response from a GOPRO_COMMAND set request */

                    pub fn GOPRO_SET_RESPONSE<'a>(curs: &'a mut sys::Cursors) -> packs::GOPRO_SET_RESPONSE::Data_<'a> {
                        packs::GOPRO_SET_RESPONSE::Data_::<'a>(curs.wrap(sys::Pack::new(packs::GOPRO_SET_RESPONSE::meta_)))
                    }

                    /**
*Response from a PARAM_EXT_SET message. */

                    pub fn PARAM_EXT_ACK<'a>(curs: &'a mut sys::Cursors) -> packs::PARAM_EXT_ACK::Data_<'a> {
                        packs::PARAM_EXT_ACK::Data_::<'a>(curs.wrap(sys::Pack::new(packs::PARAM_EXT_ACK::meta_)))
                    }

                    /**
*2nd Battery status */

                    pub fn BATTERY2() -> packs::BATTERY2::Pack_ {
                        packs::BATTERY2::Pack_(sys::Pack::new(packs::BATTERY2::meta_))
                    }

                    /**
*Send a key-value pair as float. The use of this message is discouraged for normal packets, but a quite
*				 efficient way for testing new messages and getting experimental debug output */

                    pub fn NAMED_VALUE_FLOAT<'a>(curs: &'a mut sys::Cursors) -> packs::NAMED_VALUE_FLOAT::Data_<'a> {
                        packs::NAMED_VALUE_FLOAT::Data_::<'a>(curs.wrap(sys::Pack::new(packs::NAMED_VALUE_FLOAT::meta_)))
                    }

                    /**
*Camera-IMU triggering and synchronisation message. */

                    pub fn CAMERA_TRIGGER() -> packs::CAMERA_TRIGGER::Pack_ {
                        packs::CAMERA_TRIGGER::Pack_(sys::Pack::new(packs::CAMERA_TRIGGER::meta_))
                    }

                    /**
*Rangefinder reporting */

                    pub fn RANGEFINDER() -> packs::RANGEFINDER::Pack_ {
                        packs::RANGEFINDER::Pack_(sys::Pack::new(packs::RANGEFINDER::meta_))
                    }

                    /**
*WIP: Information about flight since last arming */

                    pub fn FLIGHT_INFORMATION() -> packs::FLIGHT_INFORMATION::Pack_ {
                        packs::FLIGHT_INFORMATION::Pack_(sys::Pack::new(packs::FLIGHT_INFORMATION::meta_))
                    }

                    /**
*Request a current rally point from MAV. MAV should respond with a RALLY_POINT message. MAV should not
*				 respond if the request is invalid */

                    pub fn RALLY_FETCH_POINT() -> packs::RALLY_FETCH_POINT::Pack_ {
                        packs::RALLY_FETCH_POINT::Pack_(sys::Pack::new(packs::RALLY_FETCH_POINT::meta_))
                    }

                    pub fn PING33<'a>(curs: &'a mut sys::Cursors) -> packs::PING33::Data_<'a> {
                        packs::PING33::Data_::<'a>(curs.wrap(sys::Pack::new(packs::PING33::meta_)))
                    }

                    /**
*Send a debug value. The index is used to discriminate between values. These values show up in the plot
*				 of QGroundControl as DEBUG N */

                    pub fn DEBUG() -> packs::DEBUG::Pack_ {
                        packs::DEBUG::Pack_(sys::Pack::new(packs::DEBUG::meta_))
                    }

                    /**
*Control vehicle tone generation (buzzer) */

                    pub fn PLAY_TUNE<'a>(curs: &'a mut sys::Cursors) -> packs::PLAY_TUNE::Data_<'a> {
                        packs::PLAY_TUNE::Data_::<'a>(curs.wrap(sys::Pack::new(packs::PLAY_TUNE::meta_)))
                    }

                    /**
*Request all parameters of this component. After this request, all parameters are emitted. */

                    pub fn PARAM_EXT_REQUEST_LIST() -> packs::PARAM_EXT_REQUEST_LIST::Pack_ {
                        packs::PARAM_EXT_REQUEST_LIST::Pack_(sys::Pack::new(packs::PARAM_EXT_REQUEST_LIST::meta_))
                    }

                    /**
*A message containing logged data (see also MAV_CMD_LOGGING_START) */

                    pub fn LOGGING_DATA() -> packs::LOGGING_DATA::Pack_ {
                        packs::LOGGING_DATA::Pack_(sys::Pack::new(packs::LOGGING_DATA::meta_))
                    }

                    /**
*Configure on-board Camera Control System. */

                    pub fn DIGICAM_CONFIGURE() -> packs::DIGICAM_CONFIGURE::Pack_ {
                        packs::DIGICAM_CONFIGURE::Pack_(sys::Pack::new(packs::DIGICAM_CONFIGURE::meta_))
                    }

                    /**
*General status information of an UAVCAN node. Please refer to the definition of the UAVCAN message "uavcan.protocol.NodeStatus"
*				 for the background information. The UAVCAN specification is available at http:uavcan.org */

                    pub fn UAVCAN_NODE_STATUS<'a>(curs: &'a mut sys::Cursors) -> packs::UAVCAN_NODE_STATUS::Data_<'a> {
                        packs::UAVCAN_NODE_STATUS::Data_::<'a>(curs.wrap(sys::Pack::new(packs::UAVCAN_NODE_STATUS::meta_)))
                    }

                    /**
*camera vision based attitude and position deltas */

                    pub fn VISION_POSITION_DELTA() -> packs::VISION_POSITION_DELTA::Pack_ {
                        packs::VISION_POSITION_DELTA::Pack_(sys::Pack::new(packs::VISION_POSITION_DELTA::meta_))
                    }

                    /**
*WIP: Information about video stream */

                    pub fn VIDEO_STREAM_INFORMATION<'a>(curs: &'a mut sys::Cursors) -> packs::VIDEO_STREAM_INFORMATION::Data_<'a> {
                        packs::VIDEO_STREAM_INFORMATION::Data_::<'a>(curs.wrap(sys::Pack::new(packs::VIDEO_STREAM_INFORMATION::meta_)))
                    }

                    /**
*WIP: Information about the status of a capture */

                    pub fn CAMERA_CAPTURE_STATUS() -> packs::CAMERA_CAPTURE_STATUS::Pack_ {
                        packs::CAMERA_CAPTURE_STATUS::Pack_(sys::Pack::new(packs::CAMERA_CAPTURE_STATUS::meta_))
                    }

                    /**
*raw ADC output */

                    pub fn AP_ADC() -> packs::AP_ADC::Pack_ {
                        packs::AP_ADC::Pack_(sys::Pack::new(packs::AP_ADC::meta_))
                    }

                    /**
*Status of secondary AHRS filter if available */

                    pub fn AHRS2() -> packs::AHRS2::Pack_ {
                        packs::AHRS2::Pack_(sys::Pack::new(packs::AHRS2::meta_))
                    }

                    /**
*Control a serial port. This can be used for raw access to an onboard serial peripheral such as a GPS or
*				 telemetry radio. It is designed to make it possible to update the devices firmware via MAVLink messages
*				 or change the devices settings. A message with zero bytes can be used to change just the baudrate */

                    pub fn SERIAL_CONTROL<'a>(curs: &'a mut sys::Cursors) -> packs::SERIAL_CONTROL::Data_<'a> {
                        packs::SERIAL_CONTROL::Data_::<'a>(curs.wrap(sys::Pack::new(packs::SERIAL_CONTROL::meta_)))
                    }

                    /**
*Second GPS data. Coordinate frame is right-handed, Z-axis up (GPS frame). */

                    pub fn GPS2_RAW<'a>(curs: &'a mut sys::Cursors) -> packs::GPS2_RAW::Data_<'a> {
                        packs::GPS2_RAW::Data_::<'a>(curs.wrap(sys::Pack::new(packs::GPS2_RAW::meta_)))
                    }

                    /**
*This message can be requested by sending the MAV_CMD_GET_HOME_POSITION command. The position the system
*				 will return to and land on. The position is set automatically by the system during the takeoff in case
*				 it was not explicitely set by the operator before or after. The position the system will return to and
*				 land on. The global and local positions encode the position in the respective coordinate frames, while
*				 the q parameter encodes the orientation of the surface. Under normal conditions it describes the heading
*				 and terrain slope, which can be used by the aircraft to adjust the approach. The approach 3D vector describes
*				 the point to which the system should fly in normal flight mode and then perform a landing sequence along
*				 the vector */

                    pub fn HOME_POSITION<'a>(curs: &'a mut sys::Cursors) -> packs::HOME_POSITION::Data_<'a> {
                        packs::HOME_POSITION::Data_::<'a>(curs.wrap(sys::Pack::new(packs::HOME_POSITION::meta_)))
                    }


                    pub trait Pack {
                        fn pack(self) -> *mut sys::Pack;
                    }
                }
            }
        }
    }
}

						